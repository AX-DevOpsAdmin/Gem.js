{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 01d71854d7c5fc411df0","webpack:///./billysFile/code/javascript/nodejs/modules/blocks.js/blocks.js","webpack:///./billysFile/code/javascript/nodejs/modules/blocks.js/src/Style.js","webpack:///./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/Button.js","webpack:///./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/CheckBox.js","webpack:///./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/Label.js","webpack:///./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/Radio.js","webpack:///./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/Select.js","webpack:///./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/Table.js","webpack:///./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/TableCell.js","webpack:///./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/TableHeader.js","webpack:///./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/TableRow.js","webpack:///./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/TextArea.js","webpack:///./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/TextField.js","webpack:///./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/Text.js","webpack:///./billysFile/code/javascript/nodejs/modules/blocks.js/src/utils.js","webpack:///./billysFile/code/javascript/nodejs/modules/blocks.js/src/domUtils.js","webpack:///./billysFile/code/javascript/nodejs/modules/blocks.js/external/jss.js","webpack:///(webpack)/~/node-libs-browser/~/events/events.js","webpack:///./billysFile/code/javascript/nodejs/modules/blocks.js/~/proto/proto.js","webpack:///./billysFile/code/javascript/nodejs/modules/blocks.js/~/observe/observe.js","webpack:///./billysFile/code/javascript/nodejs/modules/blocks.js/~/trimArguments/trimArguments.js","webpack:///./billysFile/code/javascript/nodejs/modules/blocks.js/~/hashmap/hashmap.js","webpack:///(webpack)/~/node-libs-browser/~/path-browserify/index.js","webpack:///./billysFile/code/javascript/nodejs/modules/blocks.js/~/observe/utils.js","webpack:///(webpack)/~/node-libs-browser/~/process/browser.js","webpack:///./billysFile/code/javascript/nodejs/modules/blocks.js/src/BlockBase.js","webpack:///./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/Block.js"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,wC;;;;;;;ACtCA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAgB,qBAAqB;AACrC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,4BAA2B;AAC3B;AACA,MAAK;AACL;;;;;;;;ACvDA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,cAAa;AACb;AACA;;AAEA,cAAa;AACb;AACA;;AAEA,cAAa,mCAAmC;AAChD;AACA;AACA;AACA;;AAEA;;AAEA,cAAa,kCAAkC;AAC/C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,cAAa;AACb;;AAEA,cAAa;AACb;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,2CAA0C;;AAE1C;AACA;AACA;AACA,kBAAiB;AACjB,qDAAoD;AACpD,qEAAoE,aAAa;AACjF;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,yCAAwC;AACxC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sBAAqB;AACrB;AACA;AACA;;AAEA,2DAA0D;AAC1D;AACA;;AAEA,kBAAiB,OAAO;;AAExB;AACA;AACA;AACA;;AAEA;AACA;AACA,sBAAqB;AACrB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,uGAAsG;AACtG,yBAAwB,4BAA4B;AACpD,cAAa;;AAEb,yBAAwB,kCAAkC;AAC1D;AACA,6BAA4B,qCAAqC,OAAO;AACxE,mCAAkC,wCAAwC;AAC1E;AACA;AACA;AACA,0BAAyB,OAAO;AAChC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB,wDAAuD;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA,6BAA4B,0BAA0B;AACtD;AACA;AACA;;AAEA;AACA;AACA,qCAAoC;AACpC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,6BAA4B,gCAAgC;AAC5D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,sDAAqD;AACrD,6BAA4B,gCAAgC;AAC5D;AACA,iCAAgC,0BAA0B;AAC1D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA,gDAA+C;AAC/C;AACA;AACA,0BAAyB,sCAAsC;AAC/D,kHAAiH;AACjH;AACA;AACA,8BAA6B,cAAc;AAC3C;AACA;AACA,8BAA6B;;AAE7B,0BAAyB;AACzB;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,4BAA2B;AAC3B,wBAAuB;AACvB,gBAAe;AACf,eAAc;;AAEd;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;AAGD;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qCAAoC;AACpC,iBAAgB,eAAe;AAC/B;AACA;AACA,qBAAoB,oBAAoB;AACxC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,gBAAgB;AACxC;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA,qBAAoB;AACpB,UAAS;AACT;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;;AAEb;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;;AAEb,kDAAiD,iBAAiB;;AAElE,qBAAoB;AACpB,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;;AAEb;AACA;AACA,6DAA4D,gBAAgB;AAC5E;;AAEA;AACA;AACA;;AAEA;AACA;AACA,cAAa;AACb;AACA;AACA,cAAa;;AAEb,qBAAoB;AACpB,UAAS;AACT;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA,cAAa;;AAEb;AACA;AACA,6DAA4D,gBAAgB;AAC5E;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,cAAa;;AAEb,qBAAoB;AACpB,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA,UAAS;AACT,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA,UAAS,kCAAkC;AAC3C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,aAAY;AACZ;;;AAGA,sEAAqE,QAAQ,WAAW,sBAAsB,SAAS;AACvH;AACA;AACA;AACA;AACA;AACA;;AAEA,sCAAqC;AACrC;AACA;AACA;AACA;;AAEA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,UAAS;AACT,iHAAgH;AAChH;AACA;;AAEA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA,iBAAgB,uBAAuB;AACvC;AACA,iDAAgD;AAChD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,mBAAkB;AAClB;AACA,EAAC;;AAED,kCAAiC;;AAEjC,uI;;;;;;;AC/vBA;AACA;;AAEA;;AAEA;;AAEA;AACA;;;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,MAAK;;AAEL,EAAC;;;;;;;AClCD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,EAAC;;;;;;;ACnCD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qCAAoC;AACpC;;AAEA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA,EAAC;;;;;;;ACjDD;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAI;;AAEJ;AACA;AACA;AACA,IAAG;AACH;AACA,EAAC;;;;;;;ACrCD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,gBAAe,iBAAiB;AAChC;AACA;AACA;AACA;AACA;AACA,KAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,wBAAuB,mBAAmB;AAC1C,IAAG;AACH;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,0BAAyB,sBAAsB;AAC/C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA,sBAAqB,sBAAsB;AAC3C;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,qCAAoC,YAAY;AAChD;AACA,UAAS;AACT;AACA,0BAAyB,sBAAsB;AAC/C;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA,qCAAoC,YAAY;AAChD;AACA;AACA;AACA,EAAC;;;;;;;AC3HD;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;;;;;;AC3CD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;;;;;;AC1BD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;;;ACjBD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,gBAAe,kBAAkB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;;;;;;;ACpDD;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG,E;AACH;AACA;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA,EAAC;;;;;;;AC1BD;AACA;;AAEA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;AACA;AACA,IAAG;AACH;;;AAGA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,EAAC;;;;;;;ACxDD;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA,kCAAiC;AACjC;AACA;AACA,UAAS;;AAET;AACA,kCAAiC;AACjC;AACA;AACA,UAAS;AACT;;AAEA;;AAEA;AACA;AACA;AACA,UAAS;AACT,sEAAqE;AACrE;AACA,MAAK;AACL,EAAC;;;;;;;ACpDD;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;AChDA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAoB,qDAAqD;AACzE;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,E;;;;;;ACjJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAqC;;AAErC;AACA;AACA;AACA,wBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,wBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,4CAA2C,EAAE;AAC7C,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT,0BAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA,wBAAuB,kBAAkB;AACzC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA,4BAA2B,wBAAwB;AACnD;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,kBAAkB;AAC7C;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4BAA2B,kBAAkB;AAC7C;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,EAAC;;AAED,2EAA0E,oB;;;;;;ACjS1E;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAmB,SAAS;AAC5B;AACA;AACA;AACA,IAAG;AACH;AACA;AACA,gBAAe,SAAS;AACxB;;AAEA;AACA;AACA,gBAAe,SAAS;AACxB;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,IAAG;AACH,qBAAoB,SAAS;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,IAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC5SA;AACA;;AAEA,mGAAkG,iBAAiB;AACnH;AACA;;AAEA;AACA;AACA;;AAEA,MAAK,OAAO;AACZ;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA,gDAA+C;AAC/C;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,oCAAmC;AACnC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,2BAA0B;;AAE1B;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oEAAmE;AACnE;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,MAAK;AACL;AACA;AACA,E;;;;;;ACtHA;AACA;AACA;;;AAGA;AACA;AACA,aAAY;AACZ,aAAY;AACZ,aAAY;AACZ;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,iEAAgE;AAChE;;AAEA;AACA;AACA,6CAA4C;AAC5C;;;AAGA;AACA;AACA;AACA;AACA,sDAAqD;AACrD;;AAEA;AACA;AACA,+CAA8C;AAC9C;;AAEA;AACA,yCAAwC,OAAO;AAC/C;AACA;;AAEA;AACA;AACA;AACA;AACA,kCAAiC,IAAI;AACrC,mCAAkC;AAClC,wCAAuC;AACvC;AACA,kDAAiD;AACjD,kDAAiD;AACjD;AACA;AACA,yCAAwC,gBAAgB;AACxD;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL,EAAC;;;AAGD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAgB,yBAAyB;AACzC;AACA;;AAEA,aAAY;AACZ;;AAEA;AACA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,sCAAqC,yIAAyI;AAC9K,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iEAAgE,iBAAiB,OAAO;AACxF;AACA;;AAEA;AACA;AACA,sDAAqD,iBAAiB,gBAAgB;AACtF;;AAEA,EAAC;;AAED;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;AACA;AACA,UAAS;AACT;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAiB;AACjB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sBAAqB;AACrB;AACA;AACA;AACA;AACA,sBAAqB;;AAErB;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,2CAA0C;;AAE1C;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA,kBAAiB;AACjB;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yBAAwB,YAAY;AACpC,qCAAoC,wBAAwB;AAC5D;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAgB,4BAA4B;AAC5C;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,0DAAyD;AACzD;AACA;AACA,cAAa;AACb;AACA;;AAEA,iDAAgD,WAAW,mBAAmB;AAC9E;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA,6FAA4F;AAC5F;AACA;AACA,cAAa;AACb;AACA;;AAEA,oDAAmD,WAAW,mBAAmB;AACjF;AACA;AACA,UAAS;AACT;AACA;AACA,cAAa;AACb;AACA;AACA;;AAEA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,iBAAgB,qBAAqB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,MAAK;AACL;AACA;;AAEA,aAAY;AACZ,E;;;;;;AC/ZA;AACA;AACA;AACA;AACA;;AAEA;AACA,6BAA4B,MAAM;AAClC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,E;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAE;AACF;AACA;AACA,GAAE;AACF;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;AACA,6BAA4B;AAC5B,oCAAmC;AACnC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,uCAAsC,gBAAgB,EAAE;AACxD;AACA,IAAG;;AAEH;AACA;AACA,kCAAiC,oBAAoB,EAAE;AACvD;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAoB,gBAAgB;AACpC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,eAAc;AACd;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,kBAAiB,iBAAiB;AAClC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sCAAqC,iBAAiB;AACtD;AACA;;AAEA;;AAEA,EAAC;;;;;;;ACzLD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iCAAgC,QAAQ;AACxC;AACA;AACA;AACA,MAAK;AACL;AACA;AACA,MAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAU,MAAM;AAChB;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,8BAA6B,IAAI;AACjC;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,qCAAoC,8BAA8B;AAClE;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,WAAU,oBAAoB;AAC9B;AACA;;AAEA;AACA,WAAU,UAAU;AACpB;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,kBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA,gCAA+B,sBAAsB;AACrD;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA,oBAAmB,eAAe;AAClC;AACA;AACA;AACA;;AAEA;AACA;AACA,mCAAkC;AAClC;AACA;AACA;AACA;AACA;;;;;;;;AC/NA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;;;;;;AC1CA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,8BAA6B;AAC7B;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;;AAET,sCAAqC,mBAAmB;;AAExD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;;AAET;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,EAAC;;AAED;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,4BAA2B;AAC3B;AACA;AACA;;;;;;;ACrFA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,2BAA0B;;AAE1B;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;;AAGA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA;AACA,MAAK;;;AAGL;;;AAGA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,gCAA+B;;AAE/B;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA,UAAS;AACT;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;;AAEA;;AAEA,cAAa;AACb;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA;AACA;AACA,MAAK;;AAEL;AACA;AACA;AACA;AACA;AACA,gBAAe,yBAAyB;AACxC;AACA;AACA;;AAEA;AACA;AACA,gBAAe,8BAA8B;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb,UAAS;AACT;;AAEA;AACA;AACA,gBAAe,sBAAsB;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,gBAAe,oBAAoB;AACnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,+BAA8B,8BAA8B;AAC5D;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAa;AACb;AACA;AACA,UAAS,OAAO;AAChB;AACA;;AAEA,sBAAqB,eAAe;AACpC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;;AAEA;AACA,8BAA6B;AAC7B;AACA,sDAAqD;AACrD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA,qBAAoB,mBAAmB;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,cAAa,OAAO;AACpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,I;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;;AAGA,0CAAyC,8BAA8B;AACvE,mBAAkB;AAClB,2BAA0B;;AAE1B,aAAY;AACZ,uBAAsB;AACtB,+BAA8B;AAC9B;AACA,EAAC;;AAED;;;AAGA;AACA;AACA;AACA,iBAAgB,qBAAqB;AACrC;AACA,2BAA0B;AAC1B;AACA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA;;AAEA;AACA,2BAA0B;AAC1B;AACA;AACA,cAAa;AACb;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,kBAAiB;AACjB;AACA;AACA,cAAa;AACb;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iDAAgD;;AAEhD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAS;AACT;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC/cA;AACA;;AAEA;;AAEA;;AAEA;;;AAGA;;AAEA;AACA;AACA;AACA,UAAS;AACT;AACA,UAAS;AACT;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA,IAAG;AACH;AACA,EAAC","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"blocks\"] = factory();\n\telse\n\t\troot[\"blocks\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 01d71854d7c5fc411df0\n **/","exports.BlockBase = require('./src/BlockBase')\r\nexports.Style = require('./src/Style')\r\n\r\nexports.Block = require(\"./src/Components/Block\")\r\nexports.Button = require(\"./src/Components/Button\")\r\nexports.CheckBox = require(\"./src/Components/CheckBox\")\r\nexports.Label = require(\"./src/Components/Label\")\r\nexports.Radio = require(\"./src/Components/Radio\")\r\nexports.Select = require(\"./src/Components/Select\")\r\nexports.Table = require(\"./src/Components/Table\")\r\nexports.TableCell = require(\"./src/Components/TableCell\")\r\nexports.TableHeader = require(\"./src/Components/TableHeader\")\r\nexports.TableRow = require(\"./src/Components/TableRow\")\r\nexports.TextArea = require(\"./src/Components/TextArea\")\r\nexports.TextField = require(\"./src/Components/TextField\")\r\nexports.Text = require(\"./src/Components/Text\")\r\n\r\nvar domUtils = require('./src/domUtils')\r\n\r\n// todo:\r\n//exports.List = require('./src/Components/List')\r\n//exports.Image = require('./src/Components/Image')\r\n//exports.Canvas = require('./src/Components/Canvas')\r\n\r\n\r\n// appends components to the body\r\nexports.attach = function(components) {\r\n    if(!(components instanceof Array)) {\r\n        components = [components]\r\n    }\r\n    if(document.body === null) throw new Error(\"Your document does not have a body.\")\r\n\r\n    for(var n=0; n<components.length; n++) {\r\n        document.body.appendChild(components[n].domNode)\r\n    }\r\n}\r\n// removes components from the body\r\nexports.detach = function(components) {\r\n    if(!(components instanceof Array)) {\r\n        components = [components]\r\n    }\r\n\r\n    for(var n=0; n<components.length; n++) {\r\n        document.body.removeChild(components[n].domNode)\r\n    }\r\n}\r\n\r\n// creates a body tag (only call this if document.body is null)\r\nexports.createBody = function(callback) {\r\n    var dom = document.implementation.createDocument('http://www.w3.org/1999/xhtml', 'html', null);\r\n    var body = dom.createElement(\"body\")\r\n    dom.firstChild.appendChild(body)\r\n    setTimeout(function() {  // set timeout is needed because the body tag is only added after javascript goes back to the scheduler\r\n        callback()\r\n    },0)\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/blocks.js/blocks.js\n ** module id = 0\n ** module chunks = 0\n **/","var jss = require(\"../external/jss\")\nvar proto = require('proto')\nvar HashMap = require('hashmap') // .HashMap // weirdly, it looks like this is being treated like an AMD module\n\nvar utils = require(\"./utils\")\n\nvar baseClassName = '_ComponentStyle_' // the base name for generated class names\nvar nextClassNumber = 0\n\n// creates a style object\n\nvar Style = module.exports = proto(function() {\n\n    this.defaultClassName = '_default_'     // the name of the default class (used to prevent style inheritance)\n\n    // styleDefinition is an object where key-value pairs can be any of the following:\n    // <ComponentName>: the value can either be a Style object or a nested styleDefinition object\n    // $setup: the value is a function to be run on a component when the style is applied to it\n    // $kill: the value is a function to be run on a component when a style is removed from it\n    // '$': the value describes css styles inside the component - it should be an object with the following form:\n        // cssStyle: the value should be a valid css value for that style attribute\n        // classname: the value should be an object containing an object of the same form as the '$' value\n    this.init = function(styleDefinition, privateOptions) {\n        if(privateOptions === undefined) privateOptions = {}\n        if(privateOptions.inLabel===undefined) inLabel = false\n\n        this.className = baseClassName+nextClassNumber\n        nextClassNumber++\n\n        this.componentStyleMap = {}\n        this.labelStyleMap = {}\n\n        var labelStyles = {}\n        var pseudoClassStyles = {}\n        var cssProperties = {}\n        for(var key in styleDefinition) {\n            var value = styleDefinition[key]\n\n            if(key === '$setup') {\n                if(!(value instanceof Function)) throw new Error(\"$setup key must be a function ('setup' can't be used as a label)\")\n                this.setup = value\n\n            } else if(key === '$kill') {\n                if(!(value instanceof Function)) throw new Error(\"$kill key must be a function ('kill' can't be used as a label)\")\n                this.kill = value\n\n            } else if(key === '$state') {\n                if(!(value instanceof Function)) throw new Error(\"$state key must be a function ('$state' can't be used as a label)\")\n                this.stateHandler = value\n\n            } else if(key.indexOf('$$') === 0) { // pseudo-class style\n                var pseudoClass = mapCamelCase(key.substr(2))\n                if(pseudoClass === '') {\n                    throw new Error(\"Empty pseudo-class name not valid (style key '$$')\")\n                }\n\n                utils.merge(pseudoClassStyles, flattenPseudoClassStyles(pseudoClass, value))\n\n            } else if(key.indexOf('$') === 0) {   // label style\n                if(privateOptions.inLabel)\n                    throw new Error(\"Can't create nested label style \"+key+\" because components can only have one label\")\n\n                var label = key.substr(1)\n                if(label === '') {\n                    throw new Error(\"Empty label name not valid (style key '$')\")\n                }\n\n                labelStyles[label] = value\n\n            } else if(isStyleObject(value)) {\n                this.componentStyleMap[key] = value\n\n            } else if(value instanceof Object) {\n                this.componentStyleMap[key] = Style(value)  // turn the object description into a full fledged style object\n            } else {\n                var cssStyle = key\n                var cssStyleName = mapCamelCase(cssStyle)\n                cssProperties[cssStyleName] = cssValue(cssStyleName, value)\n            }\n        }\n\n        jss.set('.'+this.className, cssProperties) // create the css class\n\n        if(module.exports.isDev) {\n            this.styleDefinitions = {}\n            this.styleDefinitions['.'+this.className] = cssProperties\n        }\n\n        // create label styles\n        if(Object.keys(labelStyles).length > 0) {\n            var baseStyle = utils.merge({}, cssProperties, this.componentStyleMap)\n\n            for(var label in labelStyles) {\n                if(isStyleObject(labelStyles[label])) {\n                    this.labelStyleMap[label] = labelStyles[label]\n                } else {\n                    var mergedStyle = utils.merge({}, baseStyle, labelStyles[label])\n                    this.labelStyleMap[label] = Style(mergedStyle, {inLabel:true})\n                }\n            }\n        }\n\n        // create pseudoclass styles\n        if(Object.keys(pseudoClassStyles).length > 0) {\n\n            // create a two-level map where the top-level keys are emulatable psuedo classes, and non-emulatable pseudo classes are at the second level\n            // the classes will also be sorted and deduped\n            var tieredPseudoClasses = {} // the two-level map\n            for(var key in pseudoClassStyles) {\n                var value = pseudoClassStyles[key]\n\n                // split key into pseudoclass list\n                var pseudoClassList = key.split(\":\")\n                var emulatablePseudoClasses = []\n                var nonEmulatablePseudoClasses = []\n                for(var n in pseudoClassList) {\n                    var pseudoClass = pseudoClassList[n]\n                    var pseudoClassParts = getPseudoClassParts(pseudoClass)\n                    if(pseudoClassParts.class in emulatedPseudoClasses) {\n                        emulatablePseudoClasses.push(pseudoClass)\n                    } else {\n                        nonEmulatablePseudoClasses.push(pseudoClass)\n                    }\n                }\n\n                if(emulatablePseudoClasses.length === 0) { // if none of the pseudoclasses can be emulated using javascript\n                    validatePurePseudoClassStyles(key, value)                        // then validate the value and\n                    createPseudoClassRules(this, key, '.'+this.className+\":\"+key, value)   // create pseudoClassRules\n\n                } else { // if some of the pseudoclasses can be emulated using javascript\n\n                    emulatablePseudoClasses.sort()\n                    var emulatablePseudoClassKey = emulatablePseudoClasses.join(':')\n                    if(tieredPseudoClasses[emulatablePseudoClassKey] === undefined)\n                        tieredPseudoClasses[emulatablePseudoClassKey] = {}\n\n                    if(nonEmulatablePseudoClasses.length === 0) {\n                        utils.merge(tieredPseudoClasses[emulatablePseudoClassKey], value)\n                    } else {\n                        nonEmulatablePseudoClasses.sort()\n                        var nonEmulatablePsuedoClassKey = nonEmulatablePseudoClasses.join(':')\n\n                        var secondTier = {}\n                        secondTier['$$'+nonEmulatablePsuedoClassKey] = value\n\n                        utils.merge(tieredPseudoClasses[emulatablePseudoClassKey], secondTier)\n                    }\n                }\n            }\n\n            // make combinations of the emulatable pseudoclasses, so that they combine like the non-emulated ones do\n            // info about mathematical combination: https://en.wikipedia.org/wiki/Combination\n\n            var tieredPseudoClassesKeys = Object.keys(tieredPseudoClasses).reverse().map(function(v) {    // reverse first so that more specific pseudoclasses go first\n                return {key: v, parts: v.split(':')} // so it doesn't have to split every time\n            })\n\n            for(var n=0; n<tieredPseudoClassesKeys.length; n++) {\n                var keyA = tieredPseudoClassesKeys[n]\n                for(var k=2; k <= tieredPseudoClassesKeys.length; k++) { // k is the number of psuedoclasses to combine\n                    for(var j=n+1; j<tieredPseudoClassesKeys.length-(k-2); j++) {\n                        var result = combinePseudoclasses(tieredPseudoClasses, [keyA].concat(tieredPseudoClassesKeys.slice(j, k)))\n                        if(result.key in tieredPseudoClasses) {\n                            utils.merge(tieredPseudoClasses[result.key], result.value)\n                        } else { // new key\n                            tieredPseudoClasses[result.key] = result.value\n                        }\n                    }\n                }\n            }\n\n            // turn the emulatable pseudo classes into Style objects\n            // also build up the set of psuedoclasses that will be emulated\n            // also build up a map of pseudoclasses-to-emulate to the emulation functions for those pseudoclasses\n            var pseudoClasesToEmulate = []\n            var preSplitPseudoClasses = [] // a list where each element looks like: [pseudoClassList, styleObject]  (this is primarily for performance - so we don't have to split the key every time we check for state changes)\n            var pseudoClassesToEmulationInfo = {}\n            for(var key in tieredPseudoClasses) {\n                if(isStyleObject(tieredPseudoClasses[key])) {\n                    tieredPseudoClasses[key] = tieredPseudoClasses[key]\n                } else {\n                    var newStyle = Style(utils.merge({}, cssProperties, tieredPseudoClasses[key])) // pseudoClassStyles merged with parent css styles\n\n                    // merge in componentStyleMap and labelStyleMap\n                    for(var k in this.componentStyleMap) {\n                        if(newStyle.componentStyleMap[k] === undefined)\n                            newStyle.componentStyleMap[k] = this.componentStyleMap[k]\n                    }\n                    for(var k in this.labelStyleMap) {\n                        if(newStyle.labelStyleMap[k] === undefined)\n                            newStyle.labelStyleMap[k] = this.labelStyleMap[k]\n                    }\n\n                    tieredPseudoClasses[key] = newStyle\n                }\n\n\n                var pseudoClassList = key.split(\":\")\n                for(var n=0; n<pseudoClassList.length; n++) {\n                    var pseudoClass = pseudoClassList[n]\n                    if(pseudoClasesToEmulate.indexOf(pseudoClass) === -1) {\n                        pseudoClasesToEmulate.push(pseudoClass)\n\n                        var pseudoClassParts = getPseudoClassParts(pseudoClass)\n                        var fns = emulatedPseudoClasses[pseudoClassParts.class]\n                        var info = {fns: fns}\n                        if(fns.processParameter !== undefined) {\n                            info.parameter = fns.processParameter(pseudoClassParts.parameter)\n                        }\n                        pseudoClassesToEmulationInfo[pseudoClass] = info\n                    }\n                }\n\n                preSplitPseudoClasses.push([pseudoClassList, tieredPseudoClasses[key]])\n            }\n\n            // create functions that initialize and keep track of state\n            var initializeState = function(component) {\n                var state = {}\n                for(var n=0; n<pseudoClasesToEmulate.length; n++) {\n                    var pseudoClass = pseudoClasesToEmulate[n]\n                    var pseudoClassEmulationInfo = pseudoClassesToEmulationInfo[pseudoClass]\n                    state[pseudoClass] = pseudoClassEmulationInfo.fns.check(component, pseudoClassEmulationInfo.parameter)\n                }\n\n                return state\n            }\n\n            var that = this\n            var changeStyleIfNecessary = function(currentStyle, component, state) {\n                var longestMatchingLength = 0;\n                var mostSpecificMatchingStyle = that; // if nothing else matches, change back to the base style object\n                for(var n=0; n<preSplitPseudoClasses.length; n++) {\n                    var pseudoClassList = preSplitPseudoClasses[n][0]\n                    for(var j=0; j<pseudoClassList.length; j++) {\n                        if(!state[pseudoClassList[j]]) {\n                            break;\n                        }\n                    }\n\n                    if(j === pseudoClassList.length && j > longestMatchingLength) {\n                        longestMatchingLength = j\n                        mostSpecificMatchingStyle = preSplitPseudoClasses[n][1]\n                    }\n                }\n\n                if(mostSpecificMatchingStyle !== currentStyle) {\n                    component.style = mostSpecificMatchingStyle\n                }\n            }\n\n            // setup pseudoclass emulation with $setup and $kill handlers\n\n            var wrapSetupAndKill = function(style) {\n                var originalSetup = style.setup\n                style.setup = function(component) {\n                    var that = this\n\n                    this._styleSetupStates = {} // maps pseudoClass to setupState\n                    var state = initializeState(component)\n                    for(var pseudoClass in pseudoClassesToEmulationInfo) {\n                        ;(function(pseudoClass, emulationInfo){   // close over those variables (so they keep the value they had when the function was setup)\n                            that._styleSetupStates[pseudoClass] = emulationInfo.fns.setup(component, function() { // start\n                                state[pseudoClass] = true\n                                changeStyleIfNecessary(that, component, state)\n                            }, function() { // end\n                                state[pseudoClass] = false\n                                changeStyleIfNecessary(that, component, state)\n                            }, emulationInfo.parameter)\n\n                        })(pseudoClass, pseudoClassesToEmulationInfo[pseudoClass])\n                    }\n\n                    changeStyleIfNecessary(that, component, state)\n\n                    if(originalSetup !== undefined) {\n                        originalSetup.apply(this, arguments)\n                    }\n                }\n\n                var originalKill = style.kill\n                style.kill = function(component) {\n                    for(var pseudoClass in pseudoClassesToEmulationInfo) {\n                        var emulationInfo = pseudoClassesToEmulationInfo[pseudoClass]\n                        emulationInfo.fns.kill(component, this._styleSetupStates[pseudoClass])\n                    }\n\n                    if(originalKill !== undefined) {\n                        originalKill.apply(this, arguments)\n                    }\n                }\n            }\n\n            // wrap all the setup and kill functions\n\n            for(var key in tieredPseudoClasses) {\n                var style = tieredPseudoClasses[key]\n                wrapSetupAndKill(style)\n            }\n\n            wrapSetupAndKill(this)\n        }\n    }\n\n    // instance properties\n\n    this.className          // the css classname for this style\n    this.componentStyleMap; // maps a Component name to a Style object for that component\n    this.labelStyleMap;     // maps a label name to a Style object for that label\n    this.setup;             // run some javascript on any element this class is applied to\n    this.kill;              // a function to run on removal of the style (should reverse setup)\n\n    // gets the style object for a component (takes into account whether the component has a label\n    this.get = function(component) {\n        if(component.label !== undefined) {\n            var labelStyle = this.labelStyleMap[component.label]\n            if(labelStyle !==  undefined) {\n                return labelStyle\n            }\n        }\n        // else\n        return this\n    }\n})\n\n\n// private\n\n\n// keys is a list of objects where each object has the members:\n    // key - the original string key\n    // parts - the key split by \":\"\n// returns an object with the following members:\n    // key - the new combined key\n    // value - the new merged value\nvar combinePseudoclasses = function(pseudoclasses, keys) {\n    var resultKeyParts = keys[0].parts\n    var resultValue = utils.merge({}, pseudoclasses[keys[0].key]) // make a copy\n    for(var n=1; n<keys.length; n++) {\n        var key = keys[n]\n        // merge all psuedoclasses that don't already exist into the resultKey\n        for(var j=0; j<key.parts.length; j++) {\n            var part = key.parts[j]\n            if(resultKeyParts.indexOf(part) === -1) {\n                resultKeyParts.push(part)\n            }\n        }\n\n        // merge the value into resultValue\n        utils.merge(resultValue, pseudoclasses[key.key])\n    }\n\n    return {key: resultKeyParts.join(':'), value: resultValue}\n}\n\n// a map of pseudoclass names and how they are emulated with javascript\n// each pseudoclass sets up the following functions:\n    // check - a function that checks if that pseudoclass currently applies to the component when its called\n    // setup - calls a callback when the pseudoClass starts and stops applying\n        // should return an object that will be passed to the kill function (as its 'state' parameter)\n    // kill - cleans up anything set up in the 'setup' function\n    // processParameter - takes the pseudoclass parameter and returns some object representing it that will be used by the setup and check functions\nvar emulatedPseudoClasses = {\n    hover: {\n        check: function(component) {\n            var nodes = document.querySelectorAll( \":hover\" )\n            for(var n=0; n<nodes.length; n++) {\n                if(nodes[n] === component.domNode) {\n                    return true\n                }\n            }\n            return false\n        },\n        setup: function(component, startCallback, endCallback) {\n            component.domNode.addEventListener(\"mouseover\", startCallback)\n            component.domNode.addEventListener(\"mouseout\", endCallback)\n\n            return {start: startCallback, end: endCallback}\n        },\n        kill: function(component, state) {\n            component.domNode.removeEventListener(\"mouseover\", state.start)\n            component.domNode.removeEventListener(\"mouseout\", state.end)\n        }\n    },\n    checked: {\n        check: function(component) {\n            return component.val()\n        },\n        setup: function(component, startCallback, endCallback) {\n            var setupState = {}\n            component.on(\"change\", setupState.listener = function() {\n                if(component.val()) {\n                    startCallback()\n                } else {\n                    endCallback()\n                }\n            })\n\n            return setupState\n        },\n        kill: function(component, state) {\n            component.removeListener(\"change\", state.listener)\n        }\n    },\n    required: {\n        check: function(component) {\n            return component.attr('required') !== null\n        },\n        setup: function(component, startCallback, endCallback) {\n            var observer = new MutationObserver(function() {\n                if(component.attr('required') !== null) {\n                    startCallback()\n                } else {\n                    endCallback()\n                }\n            })\n\n            observer.observe(component.domNode, {attributes: true})\n\n            return {observer: observer}\n        },\n        kill: function(component, state) {\n            state.observer.disconnect()\n        }\n    },\n    'last-child': {\n        check: function(component) {\n            return nthLastChildCheck(component, '1')\n        },\n        setup: function(component, startCallback, endCallback) {\n            var observer = new MutationObserver(function() {\n                if(nthLastChildCheck(component, '1')) {\n                    startCallback()\n                } else {\n                    endCallback()\n                }\n            })\n\n            var setupObserver = function() {\n                // note that since this uses the component parent rather than domNode.parentNode, this won't work for components added to non-component nodes (and there's no good way to do it, because you would have to poll for parent changes)\n                observer.observe(component.parent.domNode, {childList: true})\n            }\n\n            if(component.parent !== undefined) {\n                setupObserver()\n            }\n\n            component.on('newParent', function() {\n                setupObserver()\n            })\n            component.on('parentRemoved', function() {\n                observer.disconnect()\n            })\n\n            return {observer: observer}\n        },\n        kill: function(component, state) {\n            state.observer.disconnect()\n        }\n    },\n    'nth-child': {\n        // todo: support full an+b parameters for nth-child https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-child\n        check: function(component, parameterCheck) {\n            return nthChildCheck(component, parameterCheck)\n        },\n        setup: function(component, startCallback, endCallback, parameterCheck) {\n\n            var checkAndCallCallbacks = function() {\n                if(nthChildCheck(component, parameterCheck)) {\n                    startCallback()\n                } else {\n                    endCallback()\n                }\n            }\n\n            var observer = new MutationObserver(function() {\n                checkAndCallCallbacks()\n            })\n\n            var setupObserver = function() {\n                // note that since this uses the component parent rather than domNode.parentNode, this won't work for components added to non-component nodes (and there's no good way to do it, because you would have to poll for parent changes)\n                observer.observe(component.parent.domNode, {childList: true})\n            }\n\n            if(component.parent !== undefined) {\n                setupObserver()\n            }\n\n            component.on('newParent', function() {\n                setupObserver()\n                checkAndCallCallbacks()\n            })\n            component.on('parentRemoved', function() {\n                observer.disconnect()\n                checkAndCallCallbacks()\n            })\n\n            return {observer: observer}\n        },\n        kill: function(component, state) {\n            state.observer.disconnect()\n        },\n        processParameter: function(parameter) {\n            return nthChildParameterFn(parameter)\n        }\n    },\n\n    // not's parameter is a statement consisting of pseudoclasses separated either by & or ,\n    // $$not(pseudoclass1&pseudoclass2,psuedoclass3) translates to the css :not(:pseudoclass1:pseudoclass2,:psuedoclass3)\n    /*not: {\n        check: function() {\n\n        },\n    }*/\n}\n\n// name is the name of the new pseudoclass\n// fns is an object with the members:\n    // check(component) - returns true if the pseudoclass applies to the component\n    // setup(component, startCallback, endCallback, parameter) - a function that should call startCallback when the pseudoclass starts applying, and endCallback when it stops applying\n        // parameter - the parameter passed to the pseudoclass (e.g. in :not(:first-child), \":first-child\" is the parameter)\n    // kill - a function that cleans up any event listeners or anything else set up in the 'setup' function\nmodule.exports.addPseudoClass = function(name, fns) {\n    if(emulatedPseudoClasses[name] !== undefined) throw new Error(\"The pseudoclass '\"+name+\"' is already defined.\")\n    // else\n    emulatedPseudoClasses[name] = fns\n}\n\n\nfunction nthChildCheck(component, testFn) {\n    if(component.domNode.parentNode === null)\n        return false\n\n    var children = component.domNode.parentNode.children                    // must be domNode.parentNode, because child nodes may not be Components\n    var index = Array.prototype.indexOf.call(children, component.domNode)\n    return testFn(index)\n}\n\nfunction nthLastChildCheck(component, parameter) {\n    if(component.domNode.parentNode === null)\n        return false\n\n    var children = component.domNode.parentNode.children                    // must be domNode.parentNode, because child nodes may not be Components\n    var index = children.length - parseInt(parameter)\n    return children[index] === component.domNode\n}\n\n// returns a function that takes an index and tell you if that index applies to the nthChildParameter\nvar nthChildParameter = /^(((-?\\d*)(([+-]\\d*)n?)?)|((-?\\d)*n?([+-]\\d*)?))$/\nfunction nthChildParameterFn(parameter) {\n    var parts = parameter.match(nthChildParameter)\n    if(parts === null)\n        throw new Error(\"nth-child parameter '\"+parameter+\"' isn't valid\")\n\n    if(parts[2] !== undefined) {\n        var constant = parts[3]\n        var variable = parts[5]\n    } else {\n        var constant = parts[8]\n        var variable = parts[7]\n    }\n\n    if(constant === undefined) constant = 0\n    else                       constant = parseInt(constant)\n    if(variable === undefined) variable = 0\n    else                       variable = parseInt(variable)\n\n    if(variable === 0) {\n        return function(index) {\n            return index+1 === constant\n        }\n    } else {\n        return function(index) {\n            return ((index+1-constant)/variable) % 1 === 0\n        }\n    }\n\n}\n\n// maps a style value to a css value\n// style values that are numbers are mapped to strings, usually with px postfix\nfunction cssValue(cssStyleName, value) {\n    // If a number was passed in, add 'px' to the (except for certain CSS properties) [also taken from jquery's code]\n    if(typeof(value) === \"number\" && cssNumber[cssStyleName] === undefined) {\n        return value+\"px\"\n    } else {\n        return value.toString()\n    }\n}\n\nfunction createPseudoClassRules(that, pseudoClass, selector, pseudoClassStyle) {\n\n    var pseudoClassCss = {}\n    for(var key in pseudoClassStyle) {\n        var value = pseudoClassStyle[key]\n\n        if(!(value instanceof Object)) {\n            var cssStyle = key\n            var cssStyleName = mapCamelCase(cssStyle)\n            pseudoClassCss[cssStyleName] = cssValue(cssStyleName, value)\n        } else {\n            throw new Error(\"All properties within the pseudoclasses '\"+pseudoClass+\"' must be css styles\")\n        }\n    }\n\n    // create immediate pseudo class style\n    jss.set(selector, pseudoClassCss) // create the css class with the pseudoClass\n\n    if(module.exports.isDev) {\n        that.styleDefinitions = {}\n        that.styleDefinitions[selector] = pseudoClassCss\n    }\n}\n\n// throws exceptions for various style configurations that are unsupported by pure pseudo classes (ones that can't be emulated usuing javascript)\nfunction validatePurePseudoClassStyles(pseudoClass, pseudoClassStyles) {\n    for(var key in pseudoClassStyles) {\n        var value = pseudoClassStyles[key]\n\n        if(isStyleObject(value)) {\n            throw new Error(\"Can't set the pseudoclasses '\"+pseudoClass+\"' to a Style object\")\n        } else if(key === '$setup') {\n            throw new Error(\"$setup can't be used within the pseudoclasses '\"+pseudoClass+\"'\")\n        } else if(key === '$kill') {\n            throw new Error(\"$kill can't be used within the pseudoclasses '\"+pseudoClass+\"'\")\n        } else if(key.indexOf('$') === 0) {   // label style\n            throw new Error(\"Component labels can't be used within the pseudoclasses '\"+pseudoClass+\"'\")\n        }\n    }\n}\n\n// e.g. pulls out 'nth-child' and '2+3n' from 'nth-child(2+3n)'\nvar pseudoClassRegex = /^([^(]*)(\\((.*)\\))?$/\nfunction getPseudoClassParts(fullPsuedoClass) {\n    var x = fullPsuedoClass.match(pseudoClassRegex)\n    if(x === null) throw new Error(\"Pseudoclass '\"+fullPsuedoClass+\"' is invalid\")\n    return {class: x[1], parameter: x[3]}\n}\n\n\n// takes in a list of pseudoClassRules and changes any nesting like {hover: {focus: {}}} into something like {hover: {}, \"hover:focus\": {}}\n// also does some validation\nfunction flattenPseudoClassStyles(pseudoClass, pseudoClassStyle) {\n    var nonPseudoClassStyles = {}\n    var subpseudoClasses = {}\n    for(var key in pseudoClassStyle) {\n        var value = pseudoClassStyle[key]\n\n        if(key.indexOf('$$') === 0) { // pseudo-class style\n            var subPseudoClass = key.substr(2)\n            if(subPseudoClass === '') {\n                throw new Error(\"Empty pseudo-class name not valid (style key '$$')\")\n            }\n\n            subpseudoClasses[subPseudoClass] = value\n        } else {\n            nonPseudoClassStyles[key] = value\n        }\n    }\n\n    // create flattened styles (with merged in styles from its parent pseudoclass\n    var flattenedStyles = {}\n    for(var subPseudoClass in subpseudoClasses) {\n        var value = subpseudoClasses[subPseudoClass]\n\n        if(isStyleObject(value)) {\n            flattenedStyles[pseudoClass+\":\"+subPseudoClass] =  value\n        } else {\n            utils.merge(flattenedStyles, flattenPseudoClassStyles(pseudoClass+\":\"+subPseudoClass, utils.merge({}, nonPseudoClassStyles, value)))\n        }\n    }\n\n    // write the top-level pseudoClass\n    flattenedStyles[pseudoClass] = nonPseudoClassStyles\n\n    return flattenedStyles\n}\n\n\n// taken from jquery's code\nvar cssNumber = {\n    \"column-count\": 1,\n    \"fill-opacity\": 1,\n    \"flex-grow\": 1,\n    \"flex-shrink\": 1,\n    \"font-weight\": 1,\n    \"line-height\": 1,\n    \"opacity\": 1,\n    \"order\": 1,\n    \"orphans\": 1,\n    \"widows\": 1,\n    \"z-index\": 1,\n    \"zoom\": 1\n}\n\nfunction isStyleObject(o) {\n    return o.componentStyleMap !== undefined && o.componentStyleMap !== undefined\n}\n\n\nvar asciiA = 'A'.charCodeAt(0), asciiZ = 'Z'.charCodeAt(0), difference = 'a'.charCodeAt(0) - asciiA\nfunction mapCamelCase(cssStyleName) {\n    for(var n=0; n<cssStyleName.length; n++) {\n        var ascii = cssStyleName.charCodeAt(n)\n        if(asciiA <= ascii && ascii <= asciiZ) { // found capital letter\n            cssStyleName = cssStyleName.slice(0, n) + '-'+String.fromCharCode(ascii+difference) + cssStyleName.slice(n+1)\n            n++ // increment a second time for the dash\n        }\n    }\n\n    return cssStyleName\n}\n\n// maps all the styles that are inherited by descendant nodes to their default values\n// source: http://stackoverflow.com/questions/5612302/which-css-styles-are-inherited\nvar defaultStyleValues = {\n    'azimuth': 'center',\n    'border-collapse': 'separate',\n    'border-spacing': '0',\n    'caption-side': 'top',\n    //'color': 'black',         // let this inherit\n    //'cursor': 'auto',         // let this one inherit - its weird otherwise\n    'direction': 'ltr',\n     display: 'inline-block', // changes the default display to inline-block\n    'elevation': '',\n    'empty-cells': 'show',\n    // 'font-family': '',       // let this inherit\n    // 'font-size': 'medium',   // let this inherit\n    //'font-style': 'normal',   // let this inherit\n    //'font-variant': 'normal', // let this inherit\n    //'font-weight': 'normal',  // let this inherit\n    'letter-spacing': 'normal',\n    'line-height': 'normal',\n    'list-style-image': 'none',\n    'list-style-position': 'outside',\n    'list-style-type': 'disc',\n    'orphans': '2',\n    'pitch-range': '',\n    'pitch': '',\n     position: 'relative', // changes the default positioning so that absolute is relative to its parent by default\n    'quotes': '',\n    'richness': '',\n    'speak-header': '',\n    'speak-numeral': '',\n    'speak-punctuation': '',\n    'speak': '',\n    'speak-rate': '',\n    'stress': '',\n    'text-align': 'left',\n    'text-indent': '0',\n    'text-transform': 'none',\n    'visibility': 'visible',\n    'voice-family': '',\n    'volume': '',\n    'white-space': 'normal',\n    'widows': '2',\n    'word-spacing': 'normal'\n}\n\njss.set('.'+Style.defaultClassName, defaultStyleValues) // creates default css class in order to prevent inheritance\n\njss.set('input', { // chrome and firefox user agent stylesheets mess with this otherwise\n    cursor: 'inherit'\n})\n\n/*private*/ module.exports.isDev; // should be set by Component\n\nvar computedStyles = module.exports.computedStyles = new HashMap() // stores a map from styleMap components, to the combined style map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/blocks.js/src/Style.js\n ** module id = 2\n ** module chunks = 0\n **/","var Block = require('../BlockBase')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\n    // static variables\n\n    this.name = 'Button'\n\tthis.emits = [\"click\"];\n\n\n    // instance properties\n\n\tthis.init = function(text) {\n        superclass.init.call(this, undefined, document.createElement(\"input\")) // superclass constructor\n\t\tvar that = this\n\n\t\tthis.attr('type','button');\n\t\tthis.attr('value',text);\n\t\t\n\t\tthis.domNode.addEventListener(\"click\",function(data) {\n\t\t\tthat.emit(\"click\",data);\n\t\t})\n\t}\n\n    Object.defineProperty(this, 'text', {\n        get: function() {\n            return this.attr('value')\n        },\n        set: function(text) {\n            this.attr('value', text)\n        }\n    })\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/Button.js\n ** module id = 4\n ** module chunks = 0\n **/","var Block = require('../BlockBase')\nvar proto = require('proto')\nvar Label = require(\"./Label\");\n\nmodule.exports = proto(Block, function(superclass) {\n\t// static variables\n    this.name = 'CheckBox'\n\n\t// instance methods\n\tthis.init = function(label) {\n\t\tif (label === undefined) label = \"\";\n        superclass.init.call(this, label, document.createElement(\"input\")) // superclass constructor\n\n\t\tvar that = this\n\n\t\tthis.attr('type','checkbox');\n\t\tthis.domNode.addEventListener(\"click\",function(e) {\n\t\t\tthat.emit(\"click\",e);\n\t\t});\n\t\t\n\t\tthis.domNode.addEventListener(\"change\",function() {\n\t\t\tthat.emit(\"change\",that.domNode.checked)\n\t\t})\n\t}\n\n    // if no parameters are passed, it returns whether or not the checkbox is checked\n    // if one parameter is passed, it sets the value of the checkbox to the passed value (true for checked)\n    this.check = this.val = function() {\n        if(arguments.length === 0) {\n            return this.domNode.checked\n        } else {\n            this.domNode.checked = arguments[0]\n            this.emit('change', arguments[0]) // the browser has no listenable event that is triggered on change of the 'checked' property\n        }\n    }\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/CheckBox.js\n ** module id = 5\n ** module chunks = 0\n **/","var Block = require('../BlockBase')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\t////////////////////////\n\t// static variables\n\t////////////////////////\n    this.name = 'Label'\n\n\t////////////////////////\n\t// instance methods\n\t////////////////////////\n\tthis.init = function(text,header) {\n        if (header === undefined) header = false;\n\n        superclass.init.call(this) // superclass constructor\n\t\tvar that = this\n\n\t\tvar style = \"\";\n\t\tif (header)\n            style = \"display: block;\";\n\t\tthis.attr('style', style)\n\n\t\tthis.domNode.textContent = text;\n\t\tthis.domNode.addEventListener(\"click\",function(e) {\n\t\t\tthat.emit(\"click\",e);\n\t\t});\n\t}\n\t\n\tthis.set = function(text) {\n\t\tthis.domNode.textContent = text;\n\t}\n\n\t// this is needed for stuff like html entities\n\tthis.setRaw = function(text) {\n\t\tthis.domNode.innerHTML = text;\n\t}\n\t\n\tthis.get = function() {\n\t\treturn this.domNode.textContent;\n\t}\n\n\tthis.width = function(width) {\n\t\tif (width === undefined) {\n\t\t\treturn parseInt(this.domNode.style.width.replace(\"px\",\"\"));\n\t\t} else {\n\t\t\tthis.domNode.style.width = width + \"px\";\n\t\t}\n\t}\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/Label.js\n ** module id = 6\n ** module chunks = 0\n **/","var proto = require('proto')\n\nvar Block = require('../BlockBase')\nvar domUtils = require('../domUtils')\nvar Label = require(\"./Label\")\n\n\nmodule.exports = proto(Block, function(superclass) {\n\t/////////////////////////\n\t// static variables\n\t/////////////////////////\n    this.name = 'Radio'\n\n\t//////////////////////////\n\t// instance methods\n\t//////////////////////////\n\tthis.init = function(groupName,options) {\n        superclass.init.call(this) // superclass constructor\n\t\tvar that = this\n\n\t\toptions.forEach(function(elem,index) {\n\t\t\tvar elem = document.createElement('input');\n\t\t\tdomUtils.setAttribute(elem,'type','radio');\n\t\t\tdomUtils.setAttribute(elem,'name',groupName);\n\t\t\tdomUtils.setAttribute(elem,'value',elem.value);\n\t\t\t\n\t\t\telem.addEventListener(\"click\",function(data) {\n\t\t\t\tthat.emit(\"change\",data);\n\t\t\t\tdata.value = elem.value;\n\t\t\t\tthat.emit(\"click\",data);\n\t\t\t});\n\t\t\t\n\t\t\tthat.domNode.appendChild(elem);\n\t\t\tthat.add(new Label(elem.text));\n\t\t\tthat.domNode.appendChild(document.createElement(\"br\"));\n\t\t});\n\t}\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/Radio.js\n ** module id = 7\n ** module chunks = 0\n **/","var Block = require('../BlockBase')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\t//////////////////////\n\t// static variables\n\t//////////////////////\n    this.name = 'Select';\n\t\n    this.Option = proto(Block, function(superclass) {\n\t\t//////////////////////\n\t\t// staic variables\n\t\t//////////////////////\n        this.name = 'Option'\n\n\t\t//////////////////////\n\t\t// instance methods\n\t\t//////////////////////\n        this.init = function(value, text) {\n            superclass.init.call(this, undefined, document.createElement(\"option\")) // superclass constructor\n\n            this.domNode.innerHTML = text\n            this.domNode.value = value\n        }\n\n        this.select = function(selected) {\n            this.domNode.selected = selected\n        }\n    })\n\n\t///////////////////////\n\t// instance methods\n\t///////////////////////\n\tthis.init = function(options,multiple,selectedValue) {\n        superclass.init.call(this, undefined, document.createElement(\"select\")) // superclass constructor\n\n\t\tvar that = this\n\t\tthis.multiple = multiple;\n\n\t\tvar elem = this.domNode;\n\t\tif (multiple) {\n\t\t\tthis.createAttribute(elem,'multiple','multiple');\n\t\t}\n\t\t\n\t\tfor (var i=0;i<options.length;i++) {\n\t\t\tvar val = undefined;\n\t\t\tvar text = undefined;\n\t\t\tif (typeof options[i] === \"string\") {\n\t\t\t\tval = options[i];\n\t\t\t\ttext = options[i];\n\t\t\t} else {\n\t\t\t\tval = options[i].value;\n\t\t\t\ttext = options[i].text;\n\t\t\t}\n\t\t\tvar selected = false;\n\t\t\tif (val === selectedValue) {\n\t\t\t\tselected = true;\n\t\t\t}\n\t\t\tthis.addOption(val,text,selected)\n\t\t}\n\t\t\n\t\telem.addEventListener(\"change\",function(e) {\n\t\t\tthat.emit(\"change\",{value:that.value()});\n\t\t});\n\t}\n\n    this.value = function() {\n\t\tif(!this.multiple) {\n            return this.domNode.value\n        } else {\n            var values = [];\n            if (this.domNode.length == 0) return values;\n            for (var i=0;i<this.domNode.length;i++) {\n                var option = this.domNode.options[i];\n                if (option.selected) {\n                    values.push(option.value);\n                    if (!this.multiple) break;\n                }\n            }\n            if (values.length === 0 && !this.multiple) {\n                values.push(this.domNode.options[0].value);\n            }\n            return values;\n        }\n    }\n\t\n\tthis.addOption = function(value,text,selected) {\n\t\tvar option = this.Option(value,text)\n        if (selected !== undefined) option.select(selected)\n\t\tthis.add(option)\n\t}\n\n    this.removeOption = function(value) {\n        for (var i=0;i<this.domNode.length;i++) {\n            var option = this.domNode.options[i];\n            if(option.value === value) {\n                this.remove(option)\n            }\n        }\n    }\n\t\n\tthis.set = this.setValue = function(value) {\n        if(!this.multiple) {\n            if(this.domNode.value !== value) {\n                this.domNode.value = value\n                this.emit(\"change\",{value:value});\n            }\n        } else {\n            var set = false;\n            for (var i=0;i<this.domNode.length;i++) {\n                var option = this.domNode.options[i];\n                if (option.value == value) {\n                    if (option.selected === false) set = true;\n                    option.selected = true\n                } else {\n                    option.selected = false;\n                }\n            }\n            if (set) {\n                this.emit(\"change\",{value:value});\n            }\n        }\n\t}\n})\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/Select.js\n ** module id = 8\n ** module chunks = 0\n **/","var Block = require('../BlockBase')\nvar proto = require('proto')\nvar TableHeader = require(\"./TableHeader\");\nvar TableRow = require(\"./TableRow\");\nvar TableCell = require(\"./TableCell\");\n\nmodule.exports = proto(Block, function(superclass) {\n\t//////////////////////\n\t// static variables\n\t//////////////////////\n\tthis.name = 'Table'\n\n    this.Row = TableRow\n\tthis.Header = TableHeader;\n    this.Cell = TableCell\n\n\t///////////////////////////\n\t// instance methods\n\t///////////////////////////\n\tthis.init = function() {\n\t\tsuperclass.init.call(this, undefined, document.createElement(\"table\")) // superclass constructor\n\t\tthis.attr(\"cellspacing\",0);\n\t}\n\t\n\tthis.addHeader = function(posDom) {\n\t\tvar row = new TableHeader();\n\t\tif (posDom === undefined) {\n\t\t\tthis.add(row);\n\t\t} else {\n\t\t\tthis.addBeforeNode(posDom,[row]);\n\t\t}\n\t\treturn row;\n\t}\n\n\tthis.addRow = function() {\n\t\tvar row = new TableRow();\n\t\tthis.add(row);\n\t\treturn row;\n\t}\n\t\n\tthis.rowCount = function() {\n\t\treturn this.domNode.childNodes.length;\n\t}\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/Table.js\n ** module id = 9\n ** module chunks = 0\n **/","var Block = require('../BlockBase')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\t/////////////////////////////\n\t// static variables\n\t/////////////////////////////\n\tthis.name = 'TableCell'\n\t\n\t//////////////////////\n\t// instance methods\n\t//////////////////////\n\tthis.init = function(data) {\n\t\tsuperclass.init.call(this, undefined, document.createElement(\"td\")) // superclass constructor\n\t\tif (data !== undefined) {\n\t\t\tthis.add(data);\n\t\t}\n\t}\n\n\tthis.columns = function(cols) {\n\t\tthis.attr('colspan',cols);\n\t}\n\t\n\tthis.removeSelf = function() {\n\t\tthis.parent.remove(this);\n\t}\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/TableCell.js\n ** module id = 10\n ** module chunks = 0\n **/","var Block = require('../BlockBase')\nvar proto = require('proto')\nvar TableRow = require(\"./TableRow\");\n\nmodule.exports = proto(TableRow, function(superclass) {\n\t///////////////////////\n\t// static variables\n\t///////////////////////\n\tthis.name = 'TableHeader'\n\t\n\t///////////////////////\n\t// instance methods\n\t///////////////////////\n\tthis.init = function() {\n\t\tsuperclass.init.call(this) // superclass constructor\n\t\tvar that = this\n\t}\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/TableHeader.js\n ** module id = 11\n ** module chunks = 0\n **/","var Block = require('../BlockBase')\nvar proto = require('proto')\nvar TableCell = require(\"./TableCell\");\n\nvar TableRow = module.exports = proto(Block, function(superclass) {\n\t///////////////////////////\n\t// static variables\n\t///////////////////////////\n\tthis.name = 'TableRow'\n\t\n\t/////////////////////////////\n\t// instance methods\n\t/////////////////////////////\n\tthis.init = function() {\n\t\tsuperclass.init.call(this,  undefined, document.createElement(\"tr\")) // superclass constructor\n\t}\n\t\n\tthis.addCell = function(data) {\n\t\tif (data === undefined) data = [];\n\t\tvar cell = new TableCell(data);\n\t\tthis.add(cell);\n\t\treturn cell;\n\t}\n\n\tthis.addCells = function(cellList) {\n\t\tvar cells = [];\n\t\tfor (var i=0;i<cellList.length;i++) {\n\t\t\tvar cell = cellList[i];\n\t\t\tif (cellList[i].name !== \"TableCell\") {\n\t\t\t\tcell = new TableCell(cell);\n\t\t\t}\n\t\t\tthis.add(cell);\n\t\t\tcells.push(cell);\n\t\t}\n\t\treturn cells;\n\t}\n\t\n\tthis.removeSelf = function() {\n\t\tthis.parent.remove(this);\n\t}\n\t\n\tthis.addAfter = function() {\n\t\tvar row = new TableRow();\n\t\tthis.parent.addAfter(this,[row]);\n\t\treturn row;\n\t}\n\t\n\tthis.addBefore = function() {\n\t\tvar row = new TableRow();\n\t\tthis.parent.addBefore(this,[row]);\n\t\treturn row;\n\t}\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/TableRow.js\n ** module id = 12\n ** module chunks = 0\n **/","var Block = require('../BlockBase')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\t////////////////////////\n\t// static variables\n\t////////////////////////\n    this.name = 'TextArea'\n\n\tthis.init = function() {\n        superclass.init.call(this, undefined, document.createElement(\"textarea\")) // superclass constructor\n\t\tvar that = this\n\n\t\tvar elem = this.domNode\n\t\telem.addEventListener(\"click\",function(e) {\n\t\t\tthat.emit(\"click\",e);\n\t\t});\t\n\t\telem.addEventListener(\"change\",function(e) {\n\t\t\tthat.emit(\"change\",e);\n\t\t});\n\t}\n\n\t//////////////////////\n\t// instance properties\n\t//////////////////////\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/TextArea.js\n ** module id = 13\n ** module chunks = 0\n **/","var Block = require('../BlockBase')\nvar proto = require('proto')\n\nvar domUtils = require(\"../domUtils\")\n\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static properties\n\n    this.name = 'TextField'\n\n\tthis.init = function(password) {\n        superclass.init.call(this, undefined, document.createElement(\"input\")) // superclass constructor\n\n\t\tvar that = this\n\n\t\tvar elem = this.elem = this.domNode\n        elem.className = 'field'\n\t\tdomUtils.setAttribute(elem,'type','text');\n        if(password)\n            domUtils.setAttribute(elem, 'type', 'password')\n\n\t\telem.addEventListener(\"click\",function(e) {\n\t\t\tthat.emit(\"click\",e);\n\t\t});\n\t\telem.addEventListener(\"change\",function(e) {\n\t\t\tthat.emit(\"change\",e);\n\t\t});\n        elem.addEventListener(\"keypress\",function(e) {\n\t\t\tthat.emit(\"keypress\",e);\n\t\t})\n        elem.addEventListener(\"keyup\",function(e) {\n\t\t\tthat.emit(\"keyup\",e);\n\t\t})\n\t}\n\n\n\t// instance properties\n\n    Object.defineProperty(this, 'val', {\n        get: function() {\n            return this.elem.value\n        }, set: function(v) {\n            this.elem.value = v\n        }\n    })\n\n    // obsolete - user the val property instead\n    this.value = function() {\n        return this.elem.value\n    }\n\n    this.focus = function() {\n        this.elem.focus()\n    }\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/TextField.js\n ** module id = 14\n ** module chunks = 0\n **/","var Block = require('../BlockBase')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\n    //static properties\n\n    this.name = 'Text'\n\n    this.init = function(/*[label,] text*/) {\n        if(arguments.length === 1) {\n            var text = arguments[0]\n        } else {\n            var label = arguments[0]\n            var text = arguments[1]\n        }\n\n        if (text === undefined) text = '';\n\n        superclass.init.call(this) // superclass constructor\n\n        var that = this\n\n        this.label = label\n        this.text = text\n        this.domNode.style[\"white-space\"] = \"pre\";\n        this.domNode.addEventListener(\"click\",function(e) {\n                that.emit(\"click\",e);\n        });\n\n        this.domNode.addEventListener(\"input\",function(data) {\n                var eventData = {newText:data.srcElement.textContent,oldText:that.oldText};\n                that.oldText = eventData.newText;\n                that.emit(\"input\",eventData);\n        });\n\n        this.domNode.addEventListener(\"blur\",function(data) {\n                var eventData = {newText:data.srcElement.textContent,oldText:that.lastFocus};\n                that.lastFocus = eventData.newText;\n                that.emit(\"blur\",eventData);\n        });\n    }\n\n    // instance properties\n\n    Object.defineProperty(this, 'text', {\n        get: function() {\n            return this.domNode.textContent\n        }, set: function(v) {\n            this.domNode.innerHTML = v.toString().replace(/</g, '&lt;').replace(/\\n/g, '<br>')\n        }\n    })\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/Text.js\n ** module id = 15\n ** module chunks = 0\n **/","// utilities needed by the configuration (excludes dependencies the configs don't need so the webpack bundle is lean)\r\n\r\nvar path = require('path')\r\n\r\n\r\n// Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1\r\n// any number of objects can be passed into the function and will be merged into the first argument in order\r\n// returns obj1 (now mutated)\r\nvar merge = exports.merge = function(obj1, obj2/*, moreObjects...*/){\r\n    return mergeInternal(arrayify(arguments), false)\r\n}\r\n\r\n// like merge, but traverses the whole object tree\r\n// the result is undefined for objects with circular references\r\nvar deepMerge = exports.deepMerge = function(obj1, obj2/*, moreObjects...*/) {\r\n    return mergeInternal(arrayify(arguments), true)\r\n}\r\n\r\n// returns a new object where properties of b are merged onto a (a's properties may be overwritten)\r\nexports.objectConjunction = function(a, b) {\r\n    var objectCopy = {}\r\n    merge(objectCopy, a)\r\n    merge(objectCopy, b)\r\n    return objectCopy\r\n}\r\n\r\nfunction mergeInternal(objects, deep) {\r\n    var obj1 = objects[0]\r\n    var obj2 = objects[1]\r\n\r\n    for(var key in obj2){\r\n       if(Object.hasOwnProperty.call(obj2, key)) {\r\n            if(deep && obj1[key] instanceof Object && obj2[key] instanceof Object) {\r\n                mergeInternal([obj1[key], obj2[key]], true)\r\n            } else {\r\n                obj1[key] = obj2[key]\r\n            }\r\n       }\r\n    }\r\n\r\n    if(objects.length > 2) {\r\n        var newObjects = [obj1].concat(objects.slice(2))\r\n        return mergeInternal(newObjects, deep)\r\n    } else {\r\n        return obj1\r\n    }\r\n}\r\n\r\nfunction arrayify(a) {\r\n    return Array.prototype.slice.call(a, 0)\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/blocks.js/src/utils.js\n ** module id = 16\n ** module chunks = 0\n **/","\r\n\r\n// creates a dom element optionally with a class and attributes\r\n var node = module.exports.node = function(type, className, options) {\r\n    var elem = document.createElement(type)\r\n\r\n    if(options !== undefined) {\r\n        if(options.attr !== undefined) {\r\n            for(var attribute in options.attr) {\r\n                createAttribute(elem, attribute, options.attr[attribute])\r\n            }\r\n        }\r\n        if(options.textContent !== undefined) {\r\n            elem.textContent = options.textContent\r\n        }\r\n    }\r\n\r\n    if(className !== undefined)\r\n        elem.className = className\r\n\r\n    return elem\r\n}\r\n\r\n// convenience function for creating a div\r\nmodule.exports.div = function(className, options) {\r\n    return node('div', className, options)\r\n}\r\n\r\n// adds an attribute to a domNode\r\nvar setAttribute = module.exports.setAttribute = function(/*[domNode,] type, value*/) {\r\n    if (arguments.length === 2) {\r\n        var domNode = this.domNode;\r\n        var type = arguments[0];\r\n        var value = arguments[1];\r\n    } else if (arguments.length === 3) {\r\n        var domNode = arguments[0];\r\n        var type = arguments[1];\r\n        var value = arguments[2];\r\n    } else {\r\n        throw new Error(\"This function expects arguments to be: [domNode,] type, value\");\r\n    }\r\n    var attr = document.createAttribute(type)\r\n    attr.value = value\r\n    domNode.setAttributeNode(attr)\r\n}\r\n\r\n\r\n// sets the selection\r\n//\r\n// works for contenteditable elements\r\nexports.setSelection = function(node, start, end) {\r\n    // memoize\r\n    if (window.getSelection && document.createRange) {\r\n        exports.setSelection = function(containerEl, start, end) {\r\n            var charIndex = 0, range = document.createRange();\r\n            range.setStart(containerEl, 0);\r\n            range.collapse(true);\r\n            var nodeStack = [containerEl], node, foundStart = false, stop = false;\r\n\r\n            while (!stop && (node = nodeStack.pop())) {\r\n                if (node.nodeType == 3) {\r\n                    var hiddenCharacters = findHiddenCharacters(node, node.length)\r\n                    var nextCharIndex = charIndex + node.length - hiddenCharacters;\r\n\r\n                    if (!foundStart && start >= charIndex && start <= nextCharIndex) {\r\n                        var nodeIndex = start-charIndex\r\n                        var hiddenCharactersBeforeStart = findHiddenCharacters(node, nodeIndex)\r\n                        range.setStart(node, nodeIndex + hiddenCharactersBeforeStart);\r\n                        foundStart = true;\r\n                    }\r\n                    if (foundStart && end >= charIndex && end <= nextCharIndex) {\r\n                        var nodeIndex = end-charIndex\r\n                        var hiddenCharactersBeforeEnd = findHiddenCharacters(node, nodeIndex)\r\n                        range.setEnd(node, nodeIndex + hiddenCharactersBeforeEnd);\r\n                        stop = true;\r\n                    }\r\n                    charIndex = nextCharIndex;\r\n                } else {\r\n                    var i = node.childNodes.length;\r\n                    while (i--) {\r\n                        nodeStack.push(node.childNodes[i]);\r\n                    }\r\n                }\r\n            }\r\n\r\n            var sel = window.getSelection();\r\n            sel.removeAllRanges();\r\n            sel.addRange(range);\r\n        }\r\n    } else if (document.selection) {\r\n        exports.setSelection = function(containerEl, start, end) {\r\n            var textRange = document.body.createTextRange();\r\n            textRange.moveToElementText(containerEl);\r\n            textRange.collapse(true);\r\n            textRange.moveEnd(\"character\", end);\r\n            textRange.moveStart(\"character\", start);\r\n            textRange.select();\r\n        };\r\n    }\r\n\r\n    var findHiddenCharacters = function(node, beforeCaretIndex) {\r\n        var hiddenCharacters = 0\r\n        var lastCharWasWhiteSpace=true\r\n        for(var n=0; n-hiddenCharacters<beforeCaretIndex &&n<node.length; n++) {\r\n            if([' ','\\n','\\t','\\r'].indexOf(node.textContent[n]) !== -1) {\r\n                if(lastCharWasWhiteSpace)\r\n                    hiddenCharacters++\r\n                else\r\n                    lastCharWasWhiteSpace = true\r\n            } else {\r\n                lastCharWasWhiteSpace = false\r\n            }\r\n        }\r\n\r\n        return hiddenCharacters\r\n    }\r\n\r\n    exports.setSelection(node, start, end)\r\n}\r\n\r\n// gets the character offsets of a selection within a particular dom node\r\nexports.getCaretOffset = function (node) {\r\n    // memoize\r\n    if(typeof window.getSelection != \"undefined\") {\r\n        exports.getCaretOffset = function (element) {\r\n            if (window.getSelection().type === \"None\" || window.getSelection().rangeCount === 0)\r\n                return 0;\r\n\r\n            var range = window.getSelection().getRangeAt(0);\r\n            var preCaretRange = range.cloneRange();\r\n            preCaretRange.selectNodeContents(element);\r\n            preCaretRange.setEnd(range.endContainer, range.endOffset);\r\n            return preCaretRange.toString().length;\r\n        }\r\n    } else if (typeof document.selection != \"undefined\" && document.selection.type != \"Control\") {\r\n        exports.getCaretOffset = function (element) {\r\n            var textRange = document.selection.createRange();\r\n            var preCaretTextRange = document.body.createTextRange();\r\n            preCaretTextRange.moveToElementText(element);\r\n            preCaretTextRange.setEndPoint(\"EndToEnd\", textRange);\r\n            return preCaretTextRange.text.length;\r\n        }\r\n    }\r\n\r\n    return exports.getCaretOffset(node);\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/blocks.js/src/domUtils.js\n ** module id = 17\n ** module chunks = 0\n **/","/*\r\n * JSS v0.6 - JavaScript Stylesheets\r\n * https://github.com/Box9/jss\r\n *\r\n * Copyright (c) 2011, David Tang\r\n * MIT Licensed (http://www.opensource.org/licenses/mit-license.php)\r\n */\r\nvar jss = (function() {\r\n    var adjSelAttrRegex = /((?:\\.|#)[^\\.\\s#]+)((?:\\.|#)[^\\.\\s#]+)/g;\r\n    var doubleColonPseudoElRegex = /(::)(before|after|first-line|first-letter|selection)/;\r\n    var singleColonPseudoElRegex = /([^:])(:)(before|after|first-line|first-letter|selection)/;\r\n    var singleColonForPseudoElements; // flag for older browsers\r\n\r\n    function getSelectorsAndRules(sheet) {\r\n        var rules = sheet.cssRules || sheet.rules || [];\r\n        var results = {};\r\n        for (var i = 0; i < rules.length; i++) {\r\n            // Older browsers and FF report pseudo element selectors in an outdated format\r\n            var selectorText = toDoubleColonPseudoElements(rules[i].selectorText);\r\n            if (!results[selectorText]) {\r\n                results[selectorText] = [];\r\n            }\r\n            results[selectorText].push({\r\n                sheet: sheet,\r\n                index: i,\r\n                style: rules[i].style\r\n            });\r\n        }\r\n        return results;\r\n    }\r\n\r\n    function getRules(sheet, selector) {\r\n        var rules = sheet.cssRules || sheet.rules || [];\r\n        var results = [];\r\n        // Browsers report selectors in lowercase\r\n        selector = selector.toLowerCase();\r\n        for (var i = 0; i < rules.length; i++) {\r\n            var selectorText = rules[i].selectorText;\r\n            // Note - certain rules (e.g. @rules) don't have selectorText\r\n            if (selectorText && (selectorText == selector || selectorText == swapAdjSelAttr(selector) || selectorText == swapPseudoElSyntax(selector))) {\r\n                results.push({\r\n                    sheet: sheet,\r\n                    index: i,\r\n                    style: rules[i].style\r\n                });\r\n            }\r\n        }\r\n        return results;\r\n    }\r\n\r\n    function addRule(sheet, selector) {\r\n        var rules = sheet.cssRules || sheet.rules || [];\r\n        var index = rules.length;\r\n        var pseudoElementRule = addPseudoElementRule(sheet, selector, rules, index);\r\n\r\n        if (!pseudoElementRule) {\r\n            addRuleToSheet(sheet, selector, index);\r\n        }\r\n\r\n        return {\r\n            sheet: sheet,\r\n            index: index,\r\n            style: rules[index].style\r\n        };\r\n    };\r\n\r\n    function addRuleToSheet(sheet, selector, index) {\r\n        if (sheet.insertRule) {\r\n            sheet.insertRule(selector + ' { }', index);\r\n        } else {\r\n            sheet.addRule(selector, null, index);\r\n        }\r\n    }\r\n\r\n    // Handles single colon syntax for older browsers and bugzilla.mozilla.org/show_bug.cgi?id=949651\r\n    function addPseudoElementRule(sheet, selector, rules, index) {\r\n        var doubleColonSelector;\r\n        var singleColonSelector;\r\n\r\n        if (doubleColonPseudoElRegex.exec(selector)) {\r\n            doubleColonSelector = selector;\r\n            singleColonSelector = toSingleColonPseudoElements(selector);\r\n        } else if (singleColonPseudoElRegex.exec(selector)) {\r\n            doubleColonSelector = toDoubleColonPseudoElements(selector);\r\n            singleColonSelector = selector;\r\n        } else {\r\n            return false; // Not dealing with a pseudo element\r\n        }\r\n\r\n        if (!singleColonForPseudoElements) {\r\n            // Assume modern browser and then check if successful\r\n            addRuleToSheet(sheet, doubleColonSelector, index);\r\n            if (rules.length <= index) {\r\n                singleColonForPseudoElements = true;\r\n            }\r\n        }\r\n        if (singleColonForPseudoElements) {\r\n            addRuleToSheet(sheet, singleColonSelector, index);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function toDoubleColonPseudoElements(selector) {\r\n        return selector.replace(singleColonPseudoElRegex, function (match, submatch1, submatch2, submatch3) {\r\n            return submatch1 + '::' + submatch3;\r\n        });\r\n    }\r\n\r\n    function toSingleColonPseudoElements(selector) {\r\n        return selector.replace(doubleColonPseudoElRegex, function(match, submatch1, submatch2) {\r\n            return ':' + submatch2;\r\n        })\r\n    }\r\n\r\n    function removeRule(rule) {\r\n        var sheet = rule.sheet;\r\n        if (sheet.deleteRule) {\r\n            sheet.deleteRule(rule.index);\r\n        } else if (sheet.removeRule) {\r\n            sheet.removeRule(rule.index);\r\n        }\r\n    }\r\n\r\n    function extend(dest, src) {\r\n        for (var key in src) {\r\n            if (!src.hasOwnProperty(key))\r\n                continue;\r\n            dest[key] = src[key];\r\n        }\r\n        return dest;\r\n    }\r\n\r\n    function aggregateStyles(rules) {\r\n        var aggregate = {};\r\n        for (var i = 0; i < rules.length; i++) {\r\n            extend(aggregate, declaredProperties(rules[i].style));\r\n        }\r\n        return aggregate;\r\n    }\r\n\r\n    function declaredProperties(style) {\r\n        var declared = {};\r\n        for (var i = 0; i < style.length; i++) {\r\n            declared[style[i]] = style[toCamelCase(style[i])];\r\n        }\r\n        return declared;\r\n    }\r\n\r\n    // IE9 stores rules with attributes (classes or ID's) adjacent in the opposite order as defined\r\n    // causing them to not be found, so this method swaps [#|.]sel1[#|.]sel2 to become [#|.]sel2[#|.]sel1\r\n    function swapAdjSelAttr(selector) {\r\n        var swap = '';\r\n        var lastIndex = 0;\r\n\r\n        while ((match = adjSelAttrRegex.exec(selector)) != null) {\r\n            if (match[0] === '')\r\n                break;\r\n            swap += selector.substring(lastIndex, match.index);\r\n            swap += selector.substr(match.index + match[1].length, match[2].length);\r\n            swap += selector.substr(match.index, match[1].length);\r\n            lastIndex = match.index + match[0].length;\r\n        }\r\n        swap += selector.substr(lastIndex);\r\n\r\n        return swap;\r\n    };\r\n\r\n    // FF and older browsers store rules with pseudo elements using single-colon syntax\r\n    function swapPseudoElSyntax(selector) {\r\n        if (doubleColonPseudoElRegex.exec(selector)) {\r\n            return toSingleColonPseudoElements(selector);\r\n        }\r\n        return selector;\r\n    }\r\n\r\n    function setStyleProperties(rule, properties) {\r\n        for (var key in properties) {\r\n            var value = properties[key];\r\n            var importantIndex = value.indexOf(' !important');\r\n\r\n            // Modern browsers seem to handle overrides fine, but IE9 doesn't\r\n            rule.style.removeProperty(key);\r\n            if (importantIndex > 0) {\r\n                rule.style.setProperty(key, value.substr(0, importantIndex), 'important');\r\n            } else {\r\n                rule.style.setProperty(key, value);\r\n            }\r\n        }\r\n    }\r\n\r\n    function toCamelCase(str) {\r\n        return str.replace(/-([a-z])/g, function (match, submatch) {\r\n            return submatch.toUpperCase();\r\n        });\r\n    }\r\n\r\n    function transformCamelCasedPropertyNames(oldProps) {\r\n        var newProps = {};\r\n        for (var key in oldProps) {\r\n            newProps[unCamelCase(key)] = oldProps[key];\r\n        }\r\n        return newProps;\r\n    }\r\n\r\n    function unCamelCase(str) {\r\n        return str.replace(/([A-Z])/g, function(match, submatch) {\r\n            return '-' + submatch.toLowerCase();\r\n        });\r\n    }\r\n\r\n    var Jss = function(doc) {\r\n        this.doc = doc;\r\n        this.head = this.doc.head || this.doc.getElementsByTagName('head')[0];\r\n        this.sheets = this.doc.styleSheets || [];\r\n    };\r\n\r\n    Jss.prototype = {\r\n        // Returns JSS rules (selector is optional)\r\n        get: function(selector) {\r\n            if (!this.defaultSheet) {\r\n                return {};\r\n            }\r\n            if (selector) {\r\n                return aggregateStyles(getRules(this.defaultSheet, selector));\r\n            }\r\n            var rules = getSelectorsAndRules(this.defaultSheet);\r\n            for (selector in rules) {\r\n                rules[selector] = aggregateStyles(rules[selector]);\r\n            }\r\n            return rules;\r\n        },\r\n        // Returns all rules (selector is required)\r\n        getAll: function(selector) {\r\n            var properties = {};\r\n            for (var i = 0; i < this.sheets.length; i++) {\r\n                extend(properties, aggregateStyles(getRules(this.sheets[i], selector)));\r\n            }\r\n            return properties;\r\n        },\r\n        // Adds JSS rules for the selector based on the given properties\r\n        set: function(selector, properties) {\r\n            if (!this.defaultSheet) {\r\n                this.defaultSheet = this._createSheet();\r\n            }\r\n            properties = transformCamelCasedPropertyNames(properties);\r\n            var rules = getRules(this.defaultSheet, selector);\r\n            if (!rules.length) {\r\n                rules = [addRule(this.defaultSheet, selector)];\r\n            }\r\n            for (var i = 0; i < rules.length; i++) {\r\n                setStyleProperties(rules[i], properties);\r\n            }\r\n        },\r\n        // Removes JSS rules (selector is optional)\r\n        remove: function(selector) {\r\n            if (!this.defaultSheet)\r\n                return;\r\n            if (!selector) {\r\n                this._removeSheet(this.defaultSheet);\r\n                delete this.defaultSheet;\r\n                return;\r\n            }\r\n            var rules = getRules(this.defaultSheet, selector);\r\n            for (var i = 0; i < rules.length; i++) {\r\n                removeRule(rules[i]);\r\n            }\r\n            return rules.length;\r\n        },\r\n        _createSheet: function() {\r\n            var styleNode = this.doc.createElement('style');\r\n            styleNode.type = 'text/css';\r\n            styleNode.rel = 'stylesheet';\r\n            this.head.appendChild(styleNode);\r\n            return styleNode.sheet;\r\n        },\r\n        _removeSheet: function(sheet) {\r\n            var node = sheet.ownerNode;\r\n            node.parentNode.removeChild(node);\r\n        }\r\n    };\r\n\r\n    var exports = new Jss(document);\r\n    exports.forDocument = function(doc) {\r\n        return new Jss(doc);\r\n    };\r\n    return exports;\r\n})();\r\n\r\ntypeof module !== 'undefined' && module.exports && (module.exports = jss); // CommonJS support\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/blocks.js/external/jss.js\n ** module id = 18\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/events/events.js\n ** module id = 19\n ** module chunks = 0\n **/","\"use strict\";\r\n/* Copyright (c) 2013 Billy Tetrud - Free to use for any purpose: MIT License*/\r\n\r\nvar prototypeName='prototype', undefined, protoUndefined='undefined', init='init', ownProperty=({}).hasOwnProperty; // minifiable variables\r\nfunction proto() {\r\n    var args = arguments // minifiable variables\r\n\r\n    if(args.length == 1) {\r\n        var parent = {}\r\n        var prototypeBuilder = args[0]\r\n\r\n    } else { // length == 2\r\n        var parent = args[0]\r\n        var prototypeBuilder = args[1]\r\n    }\r\n\r\n    // special handling for Error objects\r\n    var namePointer = {}\r\n    if([Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError].indexOf(parent) !== -1) {\r\n        parent = normalizeErrorObject(parent, namePointer)\r\n    }\r\n\r\n    // set up the parent into the prototype chain if a parent is passed\r\n    var parentIsFunction = typeof(parent) === \"function\"\r\n    if(parentIsFunction) {\r\n        prototypeBuilder[prototypeName] = parent[prototypeName]\r\n    } else {\r\n        prototypeBuilder[prototypeName] = parent\r\n    }\r\n\r\n    // the prototype that will be used to make instances\r\n    var prototype = new prototypeBuilder(parent)\r\n    prototype.constructor = ProtoObjectFactory;    // set the constructor property on the prototype\r\n    namePointer.name = prototype.name\r\n\r\n    // if there's no init, assume its inheriting a non-proto class, so default to applying the superclass's constructor.\r\n    if(!prototype[init] && parentIsFunction) {\r\n        prototype[init] = function() {\r\n            parent.apply(this, arguments)\r\n        }\r\n    }\r\n\r\n    // constructor for empty object which will be populated via the constructor\r\n    var F = function() {}\r\n        F[prototypeName] = prototype    // set the prototype for created instances\r\n\r\n    function ProtoObjectFactory() {     // result object factory\r\n        var x = new F()                 // empty object\r\n\r\n        if(prototype[init]) {\r\n            var result = prototype[init].apply(x, arguments)    // populate object via the constructor\r\n            if(result === proto[protoUndefined])\r\n                return undefined\r\n            else if(result !== undefined)\r\n                return result\r\n            else\r\n                return x\r\n        } else {\r\n            return x\r\n        }\r\n    }\r\n\r\n    // add all the prototype properties onto the static class as well (so you can access that class when you want to reference superclass properties)\r\n    for(var n in prototype) {\r\n        addProperty(ProtoObjectFactory, prototype, n)\r\n    }\r\n\r\n    // add properties from parent that don't exist in the static class object yet (to get thing in like\r\n    for(var n in parent) {\r\n        if(Object.hasOwnProperty.call(parent, n) && ProtoObjectFactory[n] === undefined) {\r\n            addProperty(ProtoObjectFactory, parent, n)\r\n        }\r\n    }\r\n\r\n    ProtoObjectFactory[prototypeName] = prototype  // set the prototype on the object factory\r\n\r\n    return ProtoObjectFactory;\r\n}\r\n\r\nproto[protoUndefined] = {} // a special marker for when you want to return undefined from a constructor\r\n\r\nmodule.exports = proto\r\n\r\nfunction normalizeErrorObject(ErrorObject, namePointer) {\r\n    function NormalizedError() {\r\n        var tmp = new ErrorObject(arguments[0])\r\n        tmp.name = namePointer.name\r\n\r\n        this.message = tmp.message\r\n        if(Object.defineProperty) {\r\n            /*this.stack = */Object.defineProperty(this, 'stack', { // getter for more optimizy goodness\r\n                get: function() {\r\n                    return tmp.stack\r\n                }\r\n            })\r\n        } else {\r\n            this.stack = tmp.stack\r\n        }\r\n\r\n        return this\r\n    }\r\n        var IntermediateInheritor = function() {}\r\n            IntermediateInheritor.prototype = ErrorObject.prototype\r\n        NormalizedError.prototype = new IntermediateInheritor()\r\n    return NormalizedError\r\n}\r\n\r\nfunction addProperty(factoryObject, prototype, property) {\r\n    try {\r\n        var info = Object.getOwnPropertyDescriptor(prototype, property)\r\n        if(info.get !== undefined || info.get !== undefined && Object.defineProperty !== undefined) {\r\n            Object.defineProperty(factoryObject, property, info)\r\n        } else {\r\n            factoryObject[property] = prototype[property]\r\n        }\r\n    } catch(e) {\r\n        // do nothing, if a property (like `name`) can't be set, just ignore it\r\n    }\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/blocks.js/~/proto/proto.js\n ** module id = 20\n ** module chunks = 0\n **/","var proto = require(\"proto\")\r\nvar EventEmitter = require(\"events\").EventEmitter\r\nvar utils = require(\"./utils\")\r\n\r\n\r\n// emits the event:\r\n    // change - the event data is an object of one of the following forms:\r\n        // {id:_, type: 'set', property: propertyList}\r\n        // {id:_, type: 'added', property: propertyList, index:_, count: numberOfElementsAdded}\r\n        // {id:_, type: 'removed', property: propertyList, index:_, values: removedValues}\r\nvar Observe = module.exports = proto(EventEmitter, function() {\r\n\r\n    // static members\r\n\r\n    this.init = function(obj) {\r\n        this.subject = obj\r\n\r\n        this.setMaxListeners(1000)\r\n    }\r\n\r\n    // instance members\r\n\r\n    // gets an element or member of the subject and returns another Observee\r\n    // changes to the returned Observee will be emitted by its parent as well\r\n    this.get = function(property) {\r\n        return ObserveeChild(this, parsePropertyList(property))\r\n    }\r\n\r\n    // sets a value on the subject\r\n    // property - either an array of members to select, or a string where properties to select are separated by dots\r\n    // value - the value to set\r\n    this.set = function(property, value) {\r\n        setInternal(this, parsePropertyList(property), value, {})\r\n    }\r\n\r\n    // pushes a value onto a list\r\n    this.push = function(/*value...*/) {\r\n        pushInternal(this, [], arguments, {})\r\n    }\r\n\r\n\r\n    // index is the index to remove/insert at\r\n    // countToRemove is the number to remove\r\n    // elementsToAdd is a list of elements to add\r\n    this.splice = function(/*index, countToRemove[, elementsToAdd]*/) {\r\n        return spliceInternal(this, [], arguments, {})\r\n    }\r\n\r\n    // use this instead of concat for mutation behavior\r\n    this.append = function(arrayToAppend) {\r\n        appendInternal(this, [], arguments, {})\r\n    }\r\n\r\n    this.id = function(id) {\r\n        return ObserveeChild(this, [], {id: id})\r\n        //return idFunction(this, [], id)\r\n    }\r\n\r\n    // For the returned object, any property added via set, push, splice, or append joins an internal observee together with this observee, so that\r\n    //      the internal observee and the containing observee will both send 'change' events appropriately\r\n    // collapse - (default: false) if true, any property added will be set to the subject of the value added (so that value won't be an observee anymore\r\n        // note: only use collapse:true if the observees you're unioning isn't actually an object that inherits from an observee - any instance methods on the observee that come from child classes won't be accessible anymore\r\n        // e.g. var x = observe({a:5})\r\n        //      var b = observe({})\r\n        //      x.subject.a === 5    ;; true\r\n        //      b.union(true).set('x', x)\r\n        //      b.subject.x.a === 5            ;; true\r\n        //      b.subject.x.subject.a === 5    ;; false\r\n    this.union = function(collapse) {\r\n        if(collapse === undefined) collapse = false\r\n        return ObserveeChild(this, [], {union: collapse})\r\n    }\r\n\r\n\r\n    /* pause and unpause may cause weird affects in certain cases (e.g. if you remove an element at index 4 and *then* add an element at index 2)\r\n    // pause sending events (for when you want to do a lot of things to an object)\r\n    this.pause = function() {\r\n        this.paused = true\r\n    }\r\n    this.unpause = function() {\r\n        this.paused = undefined\r\n        sendEvent(this)\r\n    }*/\r\n})\r\n\r\n\r\nfunction parsePropertyList(property) {\r\n    if(!(property instanceof Array)) {\r\n        property = property.toString().split('.')\r\n    }\r\n\r\n    return property\r\n}\r\n\r\nfunction getPropertyPointer(subject, propertyList) {\r\n    var current = subject\r\n    for(var n=0; n<propertyList.length-1; n++) {\r\n        current = current[propertyList[n]]\r\n    }\r\n\r\n    return {obj: current, key:propertyList[n]}\r\n}\r\n\r\nvar getPropertyValue = module.exports.getPropertyValue = function(subject, property) {\r\n    var pointer = getPropertyPointer(subject, property)\r\n    if(pointer.key !== undefined) {\r\n        return pointer.obj[pointer.key]\r\n    } else {\r\n        return pointer.obj\r\n    }\r\n}\r\n\r\n// private\r\n\r\n// options can have the properties:\r\n    // union - if true, any value set, pushed, appended, or spliced onto the observee is unioned\r\nvar ObserveeChild = proto(EventEmitter, function() {\r\n\r\n    this.init = function(parent, propertyList, options) {\r\n        if(options === undefined) this.options = {}\r\n        else                      this.options = options\r\n\r\n        if(parent._observeeParent !== undefined)\r\n            this._observeeParent = parent._observeeParent\r\n        else\r\n            this._observeeParent = parent\r\n\r\n        this.property = propertyList\r\n        this.subject = getPropertyValue(parent.subject, propertyList)\r\n\r\n        var that = this\r\n        parent.on('change', function(change) {\r\n            var answers = changeQuestions(that.property, change)\r\n\r\n            if(answers.isWithin ) {\r\n                that.emit('change', {type:change.type, property: change.property.slice(that.property.length), index:change.index, count:change.count, removed: change.removed})\r\n            } else if(answers.couldRelocate) {\r\n                if(change.type === 'removed') {\r\n                    var relevantIndex = that.property[change.property.length]\r\n                    var removedIndexesAreBeforeIndexOfObserveeChild = change.index + change.removed.length - 1 < relevantIndex\r\n\r\n                    if(removedIndexesAreBeforeIndexOfObserveeChild) {\r\n                        that.property[change.property.length] = relevantIndex - change.removed.length // change the propertyList to match the new index\r\n                    }\r\n                } else if(change.type === 'added') {\r\n                    var relevantIndex = that.property[change.property.length]\r\n                    if(change.index < relevantIndex) {\r\n                        that.property[change.property.length] = relevantIndex + change.count // change the propertyList to match the new index\r\n                    }\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    this.get = function(property) {\r\n        return this._observeeParent.get(this.property.concat(parsePropertyList(property)))\r\n    }\r\n\r\n    this.set = function(property, value) {\r\n        setInternal(this._observeeParent, this.property.concat(parsePropertyList(property)), value, this.options)\r\n    }\r\n\r\n    this.push = function(/*values...*/) {\r\n        pushInternal(this._observeeParent, this.property, arguments, this.options)\r\n    }\r\n\r\n    this.splice = function(index, countToRemove/*[, elementsToAdd....]*/) {\r\n        spliceInternal(this._observeeParent, this.property, arguments, this.options)\r\n    }\r\n\r\n    this.append = function(/*[property,] arrayToAppend*/) {\r\n        appendInternal(this._observeeParent, this.property, arguments, this.options)\r\n    }\r\n\r\n    this.id = function(id) {\r\n        return ObserveeChild(this, this.property, utils.merge({}, this.options, {id: id}))\r\n        //return idFunction(this._observeeParent, this.property, id)\r\n    }\r\n\r\n    this.union = function(collapse) {\r\n        if(collapse === undefined) collapse = false\r\n        return ObserveeChild(this, [], utils.merge({}, this.options, {union: collapse}))\r\n    }\r\n\r\n})\r\n\r\n     /*\r\nfunction idFunction(that, propertyList, id) {\r\n    var result = {\r\n        set: function(property, value) {\r\n            var fullPropertyList = propertyList.concat(parsePropertyList(property))\r\n            setInternal(that, fullPropertyList, value, id)\r\n        },\r\n        push: function() {\r\n            pushInternal(that, propertyList, arguments, id)\r\n        },\r\n        splice: function() {\r\n            spliceInternal(that, propertyList, arguments, id)\r\n        },\r\n        append: function() {\r\n            appendInternal(that, propertyList, arguments, id)\r\n        },\r\n        get: function() {\r\n\r\n        }\r\n    }\r\n}\r\n*/\r\n\r\n// that - the Observee object\r\nfunction setInternal(that, propertyList, value, options) {\r\n    var pointer = getPropertyPointer(that.subject, propertyList)\r\n\r\n    var internalObservee = value\r\n    if(options.union === true) {\r\n        value = value.subject\r\n    }\r\n\r\n    pointer.obj[pointer.key] = value\r\n\r\n    var event = {type: 'set', property: propertyList}\r\n    if(options.id !== undefined) event.id = options.id\r\n    that.emit('change',event)\r\n\r\n    if(options.union !== undefined)\r\n        unionizeEvents(that, internalObservee, propertyList, options.union)\r\n}\r\n\r\nfunction pushInternal(that, propertyList, args, options) {\r\n    var array = getPropertyValue(that.subject, propertyList)\r\n    var originalLength = array.length\r\n    array.push.apply(array, args)\r\n\r\n    var internalObservees = unionizeList(array, originalLength, args.length, options.union)\r\n\r\n    var event = {type: 'added', property: propertyList, index: originalLength, count: 1}\r\n    if(options.id !== undefined) event.id = options.id\r\n    that.emit('change', event)\r\n\r\n    unionizeListEvents(that, internalObservees, propertyList, options.union)\r\n}\r\n\r\nfunction spliceInternal(that, propertyList, args, options) {\r\n    var index = args[0]\r\n    var countToRemove = args[1]\r\n\r\n    var array = getPropertyValue(that.subject, propertyList)\r\n    var result = array.splice.apply(array, args)\r\n\r\n    if(countToRemove > 0) {\r\n        var event = {type: 'removed', property: propertyList, index: index, removed: result}\r\n        if(options.id !== undefined) event.id = options.id\r\n        that.emit('change', event)\r\n    }\r\n    if(args.length > 2) {\r\n        var event = {type: 'added', property: propertyList, index: index, count: args.length-2}\r\n\r\n        var internalObservees = unionizeList(array, index, event.count, options.union)\r\n\r\n        if(options.id !== undefined) event.id = options.id\r\n        that.emit('change', event)\r\n\r\n        unionizeListEvents(that, internalObservees, propertyList, options.union)\r\n    }\r\n\r\n    return result\r\n}\r\n\r\n// note: I'm not using splice to do this as an optimization (because otherwise the property list would have to be parsed twice and the value gotten twice) - maybe this optimization wasn't worth it but its already done\r\nfunction appendInternal(that, propertyList, args, options) {\r\n    var arrayToAppend = args[0]\r\n    if(arrayToAppend.length === 0) return; //nothing to do\r\n\r\n    var array = getPropertyValue(that.subject, propertyList)\r\n    var originalLength = array.length\r\n\r\n    var spliceArgs = [originalLength, 0]\r\n    spliceArgs = spliceArgs.concat(arrayToAppend)\r\n    var oldLength = array.length\r\n    array.splice.apply(array, spliceArgs)\r\n\r\n    var internalObservees = unionizeList(array, oldLength, array.length, options.union)\r\n\r\n    var event = {type: 'added', property: propertyList, index: originalLength, count: arrayToAppend.length}\r\n    if(options.id !== undefined) event.id = options.id\r\n    that.emit('change', event)\r\n\r\n    unionizeListEvents(that, internalObservees, propertyList, options.union)\r\n}\r\n\r\n// sets a slice of elements to their subjects and\r\n// returns the original observee objects along with their indexes\r\nfunction unionizeList(array, start, count, union) {\r\n    var internalObservees = [] // list of observees and their property path\r\n    if(union !== undefined) {\r\n        var afterEnd = start+count\r\n        for(var n=start; n<afterEnd; n++) {\r\n            internalObservees.push({obj: array[n], index: n})\r\n            if(union === true)\r\n                array[n] = array[n].subject\r\n        }\r\n    }\r\n\r\n    return internalObservees\r\n}\r\n\r\n// runs unionizeEvents for elements in a list\r\n// internalObservees should be the result from `unionizeList`\r\nfunction unionizeListEvents(that, internalObservees, propertyList, collapse) {\r\n    for(var n=0; n<internalObservees.length; n++) {\r\n        unionizeEvents(that, internalObservees[n].obj, propertyList.concat(internalObservees[n].index), collapse)\r\n    }\r\n}\r\n\r\n\r\n// sets up the union change events for an observee with one of its inner properties\r\n// parameters:\r\n    // that - the container observee\r\n    // innerObservee - the contained observee\r\n    // propertyList - the propertyList to unionize\r\n    // collapse - the union option (true for collapse)\r\nfunction unionizeEvents(that, innerObservee, propertyList, collapse) {\r\n    var propertyListDepth = propertyList.length\r\n\r\n    if(innerObservee.on === undefined || innerObservee.emit === undefined || innerObservee.removeListener === undefined || innerObservee.set === undefined) {\r\n        throw new Error(\"Attempting to union a value that isn't an observee\")\r\n    }\r\n\r\n    var innerChangeHandler, containerChangeHandler\r\n    var ignorableContainerEvents = [], ignorableInnerEvents = []\r\n    innerObservee.on('change', innerChangeHandler = function(change) {\r\n        if(ignorableInnerEvents.indexOf(change) === -1) {        // don't run this for events generated by the union event handlers\r\n            if(collapse) {\r\n                var property = propertyList.concat(change.property)\r\n            } else {\r\n                var property = propertyList.concat(['subject']).concat(change.property)\r\n            }\r\n\r\n            var containerChange = utils.merge({}, change, {property: property})\r\n            ignorableContainerEvents.push(containerChange)\r\n            that.emit('change', containerChange)\r\n        }\r\n    })\r\n    that.on('change', containerChangeHandler = function(change) {\r\n        var changedPropertyDepth = change.property.length\r\n\r\n        var answers = changeQuestions(propertyList, change)\r\n        var changeIsWithinInnerProperty = answers.isWithin\r\n        var changeCouldRelocateInnerProperty = answers.couldRelocate\r\n\r\n        if(changeIsWithinInnerProperty && ignorableContainerEvents.indexOf(change) === -1) {   // don't run this for events generated by the union event handlers\r\n            if(collapse) {\r\n                var property = change.property.slice(propertyListDepth)\r\n            } else {\r\n                var property = change.property.slice(propertyListDepth+1) // +1 for the 'subject'\r\n            }\r\n\r\n            var innerObserveeEvent = utils.merge({}, change, {property: property})\r\n            ignorableInnerEvents.push(innerObserveeEvent)\r\n            innerObservee.emit('change', innerObserveeEvent)\r\n        } else if(changeCouldRelocateInnerProperty) {\r\n            if(change.type === 'set' /*&& changedPropertyDepth <= propertyListDepth  - this part already done above*/) {\r\n                removeUnion()\r\n            } else if(change.type === 'removed') {\r\n                var relevantIndex = propertyList[change.property.length]\r\n                var removedIndexesContainsIndexOfInnerObservee = change.index <= relevantIndex && relevantIndex <= change.index + change.removed.length - 1\r\n                var removedIndexesAreBeforeIndexOfInnerObservee = change.index + change.removed.length - 1 < relevantIndex && relevantIndex\r\n\r\n                if(removedIndexesContainsIndexOfInnerObservee && changedPropertyDepth <= propertyListDepth+1) {\r\n                    removeUnion()\r\n                } else if(removedIndexesAreBeforeIndexOfInnerObservee) {\r\n                    propertyList[change.property.length] = relevantIndex - change.removed.length // change the propertyList to match the new index\r\n                }\r\n            } else if(change.type === 'added') {\r\n                var relevantIndex = propertyList[change.property.length]\r\n                if(change.index < relevantIndex) {\r\n                    propertyList[change.property.length] = relevantIndex + change.count // change the propertyList to match the new index\r\n                }\r\n            }\r\n        }\r\n    })\r\n\r\n    var removeUnion = function() {\r\n        innerObservee.removeListener('change', innerChangeHandler)\r\n        that.removeListener('change', containerChangeHandler)\r\n    }\r\n}\r\n\r\n\r\n// answers certain questions about a change compared to a property list\r\n// returns an object like: {\r\n    // isWithin: _,           // true if changeIsWithinInnerProperty\r\n    // couldRelocate: _       // true if changeCouldRelocateInnerProperty or if innerProperty might be removed\r\n// }\r\nfunction changeQuestions(propertyList, change) {\r\n    var propertyListDepth = propertyList.length\r\n\r\n    var changeIsWithinInnerProperty = true // assume true until proven otherwise\r\n    var changeCouldRelocateInnerProperty = true // assume true until prove otherwise\r\n    for(var n=0; n<propertyListDepth; n++) {\r\n        if(change.property[n] !== propertyList[n]) {\r\n            changeIsWithinInnerProperty = false\r\n            if(n<change.property.length) {\r\n                changeCouldRelocateInnerProperty = false\r\n            }\r\n        }\r\n    }\r\n\r\n    if(change.property.length <= propertyListDepth) {\r\n        changeIsWithinInnerProperty = false\r\n    } else {\r\n        changeCouldRelocateInnerProperty = false\r\n    }\r\n\r\n    return {couldRelocate: changeCouldRelocateInnerProperty, isWithin: changeIsWithinInnerProperty}\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/blocks.js/~/observe/observe.js\n ** module id = 21\n ** module chunks = 0\n **/","// resolves varargs variable into more usable form\n// args - should be a function arguments variable\n// returns a javascript Array object of arguments that doesn't count trailing undefined values in the length\nmodule.exports = function(theArguments) {\n    var args = Array.prototype.slice.call(theArguments, 0)\n\n    var count = 0;\n    for(var n=args.length-1; n>=0; n--) {\n        if(args[n] === undefined)\n            count++\n        else\n            break\n    }\n    args.splice(args.length-count, count)\n    return args\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/blocks.js/~/trimArguments/trimArguments.js\n ** module id = 22\n ** module chunks = 0\n **/","/**\r\n * HashMap - HashMap Class for JavaScript\r\n * @author Ariel Flesler <aflesler@gmail.com>\r\n * @version 2.0.0\r\n * Homepage: https://github.com/flesler/hashmap\r\n */\r\n\r\n(function (factory) {\r\n\tif (typeof define === 'function' && define.amd) {\r\n\t\t// AMD. Register as an anonymous module.\r\n\t\tdefine([], factory);\r\n\t} else if (typeof exports === 'object') {\r\n\t\t// Node js environment\r\n\t\texports.HashMap = factory();\r\n\t} else {\r\n\t\t// Browser globals (this is window)\r\n\t\tthis.HashMap = factory();\r\n\t}\r\n}(function () {\r\n\t\r\n\tfunction HashMap(other) {\r\n\t\tthis.clear();\r\n\t\tswitch (arguments.length) {\r\n\t\t\tcase 0: break;\r\n\t\t\tcase 1: this.copy(other); break;\r\n\t\t\tdefault: multi(this, arguments); break;\r\n\t\t}\r\n\t}\r\n\r\n\tvar proto = HashMap.prototype = {\r\n\t\tconstructor:HashMap,\r\n\r\n\t\tget:function(key) {\r\n\t\t\tvar data = this._data[this.hash(key)];\r\n\t\t\treturn data && data[1];\r\n\t\t},\r\n\t\t\r\n\t\tset:function(key, value) {\r\n\t\t\t// Store original key as well (for iteration)\r\n\t\t\tthis._data[this.hash(key)] = [key, value];\r\n\t\t},\r\n\r\n\t\tmulti:function() {\r\n\t\t\tmulti(this, arguments);\r\n\t\t},\r\n\r\n\t\tcopy:function(other) {\r\n\t\t\tfor (var key in other._data) {\r\n\t\t\t\tthis._data[key] = other._data[key];\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\thas:function(key) {\r\n\t\t\treturn this.hash(key) in this._data;\r\n\t\t},\r\n\t\t\r\n\t\tsearch:function(value) {\r\n\t\t\tfor (var key in this._data) {\r\n\t\t\t\tif (this._data[key][1] === value) {\r\n\t\t\t\t\treturn this._data[key][0];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\t\t},\r\n\t\t\r\n\t\tremove:function(key) {\r\n\t\t\tdelete this._data[this.hash(key)];\r\n\t\t},\r\n\r\n\t\ttype:function(key) {\r\n\t\t\tvar str = Object.prototype.toString.call(key);\r\n\t\t\tvar type = str.slice(8, -1).toLowerCase();\r\n\t\t\t// Some browsers yield DOMWindow for null and undefined, works fine on Node\r\n\t\t\tif (type === 'domwindow' && !key) {\r\n\t\t\t\treturn key + '';\r\n\t\t\t}\r\n\t\t\treturn type;\r\n\t\t},\r\n\r\n\t\tkeys:function() {\r\n\t\t\tvar keys = [];\r\n\t\t\tthis.forEach(function(value, key) { keys.push(key); });\r\n\t\t\treturn keys;\r\n\t\t},\r\n\r\n\t\tvalues:function() {\r\n\t\t\tvar values = [];\r\n\t\t\tthis.forEach(function(value) { values.push(value); });\r\n\t\t\treturn values;\r\n\t\t},\r\n\r\n\t\tcount:function() {\r\n\t\t\treturn this.keys().length;\r\n\t\t},\r\n\r\n\t\tclear:function() {\r\n\t\t\t// TODO: Would Object.create(null) make any difference\r\n\t\t\tthis._data = {};\r\n\t\t},\r\n\r\n\t\tclone:function() {\r\n\t\t\treturn new HashMap(this);\r\n\t\t},\r\n\r\n\t\thash:function(key) {\r\n\t\t\tswitch (this.type(key)) {\r\n\t\t\t\tcase 'undefined':\r\n\t\t\t\tcase 'null':\r\n\t\t\t\tcase 'boolean':\r\n\t\t\t\tcase 'number':\r\n\t\t\t\tcase 'regexp':\r\n\t\t\t\t\treturn key + '';\r\n\r\n\t\t\t\tcase 'date':\r\n\t\t\t\t\treturn ':' + key.getTime();\r\n\r\n\t\t\t\tcase 'string':\r\n\t\t\t\t\treturn '\"' + key;\r\n\r\n\t\t\t\tcase 'array':\r\n\t\t\t\t\tvar hashes = [];\r\n\t\t\t\t\tfor (var i = 0; i < key.length; i++)\r\n\t\t\t\t\t\thashes[i] = this.hash(key[i]);\r\n\t\t\t\t\treturn '[' + hashes.join('|');\r\n\r\n\t\t\t\tcase 'object':\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t// TODO: Don't use expandos when Object.defineProperty is not available?\r\n\t\t\t\t\tif (!key._hmuid_) {\r\n\t\t\t\t\t\tkey._hmuid_ = ++HashMap.uid;\r\n\t\t\t\t\t\thide(key, '_hmuid_');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn '{' + key._hmuid_;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tforEach:function(func) {\r\n\t\t\tfor (var key in this._data) {\r\n\t\t\t\tvar data = this._data[key];\r\n\t\t\t\tfunc.call(this, data[1], data[0]);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tHashMap.uid = 0;\r\n\r\n\t//- Automatically add chaining to some methods\r\n\r\n\tfor (var method in proto) {\r\n\t\t// Skip constructor, valueOf, toString and any other built-in method\r\n\t\tif (method === 'constructor' || !proto.hasOwnProperty(method)) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tvar fn = proto[method];\r\n\t\tif (fn.toString().indexOf('return ') === -1) {\r\n\t\t\tproto[method] = chain(fn);\r\n\t\t}\r\n\t}\r\n\r\n\t//- Utils\r\n\r\n\tfunction multi(map, args) {\r\n\t\tfor (var i = 0; i < args.length; i += 2) {\r\n\t\t\tmap.set(args[i], args[i+1])\r\n\t\t}\r\n\t}\r\n\r\n\tfunction chain(fn) {\r\n\t\treturn function() {\r\n\t\t\tfn.apply(this, arguments);\r\n\t\t\treturn this;\r\n\t\t};\r\n\t}\r\n\r\n\tfunction hide(obj, prop) {\r\n\t\t// Make non iterable if supported\r\n\t\tif (Object.defineProperty) {\r\n\t\t\tObject.defineProperty(obj, prop, {enumerable:false});\r\n\t\t}\r\n\t};\r\n\r\n\treturn HashMap;\r\n\r\n}));\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/blocks.js/~/hashmap/hashmap.js\n ** module id = 23\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/path-browserify/index.js\n ** module id = 24\n ** module chunks = 0\n **/","// utilities needed by the configuration (excludes dependencies the configs don't need so the webpack bundle is lean)\r\n\r\nvar path = require('path')\r\n\r\n\r\n// Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1\r\n// any number of objects can be passed into the function and will be merged into the first argument in order\r\n// returns obj1 (now mutated)\r\nvar merge = exports.merge = function(obj1, obj2/*, moreObjects...*/){\r\n    return mergeInternal(arrayify(arguments), false)\r\n}\r\n\r\n// like merge, but traverses the whole object tree\r\n// the result is undefined for objects with circular references\r\nvar deepMerge = exports.deepMerge = function(obj1, obj2/*, moreObjects...*/) {\r\n    return mergeInternal(arrayify(arguments), true)\r\n}\r\n\r\nfunction mergeInternal(objects, deep) {\r\n    var obj1 = objects[0]\r\n    var obj2 = objects[1]\r\n\r\n    for(var key in obj2){\r\n       if(Object.hasOwnProperty.call(obj2, key)) {\r\n            if(deep && obj1[key] instanceof Object && obj2[key] instanceof Object) {\r\n                mergeInternal([obj1[key], obj2[key]], true)\r\n            } else {\r\n                obj1[key] = obj2[key]\r\n            }\r\n       }\r\n    }\r\n\r\n    if(objects.length > 2) {\r\n        var newObjects = [obj1].concat(objects.slice(2))\r\n        return mergeInternal(newObjects, deep)\r\n    } else {\r\n        return obj1\r\n    }\r\n}\r\n\r\nfunction arrayify(a) {\r\n    return Array.prototype.slice.call(a, 0)\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/blocks.js/~/observe/utils.js\n ** module id = 25\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canMutationObserver = typeof window !== 'undefined'\n    && window.MutationObserver;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    var queue = [];\n\n    if (canMutationObserver) {\n        var hiddenDiv = document.createElement(\"div\");\n        var observer = new MutationObserver(function () {\n            var queueList = queue.slice();\n            queue.length = 0;\n            queueList.forEach(function (fn) {\n                fn();\n            });\n        });\n\n        observer.observe(hiddenDiv, { attributes: true });\n\n        return function nextTick(fn) {\n            if (!queue.length) {\n                hiddenDiv.setAttribute('yes', 'no');\n            }\n            queue.push(fn);\n        };\n    }\n\n    if (canPost) {\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** (webpack)/~/node-libs-browser/~/process/browser.js\n ** module id = 26\n ** module chunks = 0\n **/","var emitter = require('events').EventEmitter\nvar proto = require(\"proto\");\nvar trimArguments = require(\"trimArguments\")\nvar utils = require('./utils')\nvar domUtils = require('./domUtils')\nvar observe = require('observe')\n\nvar Style = require(\"./Style\")\nStyle.isDev = function() {return module.exports.dev}\n\nvar components = {};\n\n// events:\n    // newParent - emits this when a component gets a new parent\n    // parentRemoved - emits this when a component is detached from its parent\nvar Block = module.exports = proto(emitter,function(superclass) {\n\n    // static properties\n\n\t// this should not be static, but breaks if it's made into an instance variable\n    this.emits = [];\n\n\t\n    Object.defineProperty(this, 'label', {\n        get: function() {\n            return this._label\n        }, set: function(v) {\n            if(this._label === undefined) {\n                this._label = v\n\n                if(module.exports.dev) {\n                    this.attr('label', this.label)\n                }\n            } else {\n                throw new Error(\"A Block's label can only be set once (was already set to: \"+this._label+\")\")\n            }\n        }\n    })\n\t\n\n\t// instance properties\n\n\t\n\tthis.domNode;\n\n\n    // constructor\n\tthis.init = function() {\n        if(this.name === undefined) {\n            throw new Error(\"The 'name' property is required for Blocks\")\n        }\n\n        this.children = []\n\t\tthis.unbubbledEvents = []\n\t\tthis.bubbles = []\n        this.state = observe({})\n\n        if(module.exports.dev) {\n            this.attr('name', this.name)\n        }\n\n        this.parent = undefined;\n\t\t\n\t\tif (this.id !== undefined) {\n\t\t\tcomponents[this.id] = this;\n\t\t}\n\n        if(this.domNode === undefined) {\n            this.domNode = domUtils.div()\n        }\n\n        this.create.apply(this, arguments)\n\n        this.domNode.className = Style.defaultClassName\n\t}\n\n    // sub-constructor - called by the constructor\n    // parameters:\n        // label - (Optional) A label that can be used to style a component differently.\n                   // Intended to be some string describing what the component is being used for.\n                   // Note, tho, that labels are not dynamic - changing the label won't affect styling until a new style is applied to the component)\n        // domNode - (Optional) A domNode to be used as the container domNode instead of the default (a div)\n    this.create = function(/*[label,] domNode*/) {\n        if(arguments.length === 1) {\n            this.domNode = arguments[0]\n        } else if(arguments.length >= 2) {\n            this.label = arguments[0]\n            this.domNode = arguments[1]\n        }\n    }\n\n    // sets or gets an attribute on the components domNode\n    // parameter sets:\n    // if one argument is passed, the attribute's value is returned\n    // if there are two arguments passed, the attribute is set\n        // if 'value' is undefined, the attribute is removed\n    this.attr = function(attribute, value) {\n        if(arguments.length === 1) {\n            return this.domNode.getAttribute(attribute)\n        } else {\n            if(value !== undefined) {\n                domUtils.setAttribute(this.domNode, attribute, value)\n            } else {\n                this.domNode.removeAttribute(attribute)\n            }\n        }\n    }\n\n    this.focus = function() {\n        this.domNode.focus()\n    }\n    this.blur = function() {\n        this.domNode.blur()\n    }\n\n\n    Object.defineProperty(this, 'style', {\n        get: function() {\n            return this._style\n\n        // sets the style, replacing one if one already exists\n        }, set: function(styleObject) {\n            if(styleObject === undefined) {\n                var styleMap = this.getParentStyleMap()\n                if(styleMap !== undefined) {\n                    setCurrentStyle(this, styleMap[this.name])\n                } else {\n                    setCurrentStyle(this, undefined)\n                }\n\n                this.computedStyleMap = styleMap\n\n            } else {\n                setCurrentStyle(this, styleObject)\n                var specificStyle = styleObject.get(this)\n                if(this.getParentStyleMap() !== undefined) {\n                    this.computedStyleMap = styleMapConjunction(this.getParentStyleMap(), specificStyle.componentStyleMap)\n                } else {\n                    this.computedStyleMap = specificStyle.componentStyleMap\n                }\n            }\n\n            this._style = styleObject\n            propogateStyleSet(this.children, this.computedStyleMap) // propogate styles to children\n        }\n    })\n\n\tthis.bubble = function(component) {\n\t\tif (!isBlock(component)) {\n\t\t\tconsole.log(\"Cannot bubble events from an object that is not a Block\");\n\t\t\treturn;\n\t\t}\n\t\tfor (var i=0;i<component.emits.length;i++) {\n\t\t\tthis.emits.push(component.emits[i]);\n\t\t}\n\t\tthis.bubbles.push(component);\n\t\t\n\t\t// now run through all our unbubbled events and see if any of them handle this\n\t\tvar newUnbubbled = [];\n\t\tfor (var i=0;i<this.unbubbledEvents.length;i++) {\n\t\t\tvar success = this.attachBubbleEvent(this.unbubbledEvents[i].event,this.unbubbledEvents[i].callback);\n\t\t\tif (success !== true) {\n\t\t\t\tnewUnbubbled.push(this.unbubbledEvents[i]);\n\t\t\t}\n\t\t}\n\t\tthis.unbubbledEvents = newUnbubbled;\n\t}\n\n    this.bubbleEvents = function(component, events) {\n        var that = this\n        events.forEach(function(event) {\n            component.on(event, function(eventObject) {\n                that.emit(event, eventObject)\n            })\n        })\n    }\n\n\tthis.attachBubbleEvent = function(event,callback) {\n\t\tvar foundBubble = false;\n\t\tfor (var i=0;i<this.bubbles.length;i++) {\n\t\t\tif (this.bubbles[i].handlesEvent(event)) {\n\t\t\t\t// if the bubbled component does handle this event, then attach the callback handler\n\t\t\t\t// note this could mean the callback is attached to multiple components\n\t\t\t\tthis.bubbles[i].on(event,callback);\n\t\t\t\tfoundBubble = true;\n\t\t\t}\n\t\t}\n\t\treturn foundBubble;\n\t}\n\n\tthis.handlesEvent = function(event) {\n\t\tfor (var i=0;i<this.emits.length;i++) {\n\t\t\tif (this.emits[i] === event) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t}\n\n\tthis.on = function(event,callback) {\n\t\tvar foundBubble = this.attachBubbleEvent(event,callback);\n\t\tif (!foundBubble) {\n\t\t\tsuperclass.prototype.on.call(this,event,callback);\n\t\t\tthis.unbubbledEvents.push({event:event,callback:callback});\n\t\t}\n\t}\n\n    // adds elements to the components main domNode\n    // arguments can be one of the following:\n        // component, component, component, ...\n        // listOfBlocks\n    this.add = function() {\n        this.addAt.apply(this, [this.domNode.children.length].concat(trimArguments(arguments)))\n\t}\n\n    // adds nodes at a particular index\n    // arguments can be one of the following:\n        // component, component, component, ...\n        // listOfBlocks\n    this.addAt = function(index/*, nodes...*/) {\n        if(arguments.length === 2) {\n            if(arguments[1] instanceof Array) {\n                var nodes = arguments[1]\n            } else {\n                var nodes = [arguments[1]]\n            }\n        } else { // > 2\n            var nodes = trimArguments(arguments).slice(1)\n        }\n\n        for (var i=0;i<nodes.length;i++) {\n\t\t\tvar node = nodes[i];\n            this.children.splice(index+i, 0, node)\n\n            if(!isBlock(node)) {\n                throw new Error(\"node is not a Block\")\n            }\n\n            node.parent = undefined\n            node.emit('parentRemoved')\n\n            var beforeChild = this.children[1+i+index]\n            if(beforeChild === undefined) {\n                this.domNode.appendChild(node.domNode)\n            } else {\n                this.domNode.insertBefore(node.domNode, beforeChild.domNode)\n            }\n\n            node.parent = this;\n            node.emit('newParent')\n\n            // apply styles\n            //if(itsaBlock) { // its always a component now\n                var that = this\n                node.getParentStyleMap = function() {return that.computedStyleMap}\n                propogateStyleSet([node], this.computedStyleMap)\n            //}\n\t\t}\n    }\n\t\n\t// add a list of nodes before a particular node\n    // if beforeChild is undefined, this will append the given nodes\n    // arguments can be one of the following:\n        // component, component, component, ...\n        // listOfBlocks\n    this.addBefore = this.addBeforeNode = function(beforeChild) {\n        var nodes = trimArguments(arguments).slice(1)\n        if(beforeChild === undefined) {\n            this.add.apply(this, nodes)\n        } else {\n            var index = this.children.indexOf(beforeChild)\n            this.addAt.apply(this, [index].concat(nodes))\n        }\n    }\n\t\n\n    // arguments can be one of the following:\n        // object, object, object, ...\n        // listOfObjects\n    // where 'object' is either an:\n        // index - the numerical index to remove\n        // component - a component to remove\n    this.remove = function() {\n        if(arguments[0] instanceof Array) {\n            var removals = arguments[0]\n        } else {\n            var removals = arguments\n        }\n\n        for(var n=0; n<removals.length; n++) {\n            var r = removals[n]\n            var itsaBlock = isBlock(r)\n            if(itsaBlock) {\n                r.parent = undefined\n                var index = this.children.indexOf(r)\n                this.children.splice(index, 1)\n                this.domNode.removeChild(r.domNode)\n\n                r.emit('parentRemoved')\n\n            } else { // index\n                var c = this.children[r]\n                this.children[r].parent = undefined\n                this.children.splice(r, 1)\n                this.domNode.removeChild(this.domNode.childNodes[r])\n\n                c.emit('parentRemoved')\n            }\n        }\n    }\n\t\n\tthis.hide = function() {\n\t\tif (this.domNode !== undefined && this.domNode.style.display !== 'none' ) {\n            this.displayStyle = this.domNode.style.display\n            this.domNode.style.display = 'none'\n\t\t}\n\t}\n\t\n\tthis.show = function() {\n\t\tif (this.domNode !== undefined) {\n            this.domNode.style.display = this.displayStyle\n\t\t}\t\t\n\t}\n\n\tthis.hidden = function() {\n\t\treturn this.domNode.style.display === 'none';\n\t}\n\n    this.setSelection = function(start, end) {\n        domUtils.setSelection(this.domNode, start, end)\n    }\n    this.getCaretOffset = function() {\n        return domUtils.getCaretOffset(this.domNode)\n    }\n\n\n\t// private instance variables/functions\n\n\n    this.getParentStyleMap = function() {/*default returns undefined*/}  // should be set to a function that returns the computedStyleMap of the component containing this one (so Styles objects can be inherited)\n    this.children;     // a list of child components that are a part of a Block object (these are used so Styles can be propogated down to child components)\n    this.computedStyleMap;  // a map of style objects computed from the Styles set on a given component and its parent components\n\n\tthis.style;              // the object's explicit Style object (undefined if it inherits a style)\n    this.currentStyle;       // the object's current Style (inherited or explicit)\n    this.displayStyle='block';       // stores the display style for use when 'show' is called (default is 'block')\n    this._styleSetupStates   // place to put states for setup functions (used for css pseudoclass emulation)\n});\n\nmodule.exports.dev = false // set to true to enable dom element naming (so you can see boundaries of components when inspecting the dom)\n\n\n// propogates a style-set change to a set of components\n    // styleMap should be a *copy* of a Style's componentStyleMap property (because it will be modified)\nfunction propogateStyleSet(components, styleMap) {\n    for(var n=0; n<components.length; n++) {\n        var c = components[n]\n        //if(isBlock(c)) {   //\n            // object inherits style if its in the styleSet and if it doesn't have an explicitly set style\n            if(c.style === undefined) {\n                if(styleMap === undefined) {\n                    setCurrentStyle(c, undefined)\n                } else if(styleMap[c.name] !== undefined) {\n                    setCurrentStyle(c, styleMap[c.name])\n                }\n            }\n\n            // set the computed style set\n            var mainStyle; // the style directly given to a component, either its `style` property, or its inherited style\n            if(c.style !== undefined) {\n                mainStyle = c.style.get(c)\n            } else if(styleMap !== undefined) {\n                mainStyle = styleMap[c.name]\n                if(mainStyle !== undefined) {\n                    mainStyle = mainStyle.get(c) // get the specific style (taking into account any label)\n                }\n            }\n\n            if(mainStyle !== undefined) {\n                if(styleMap !== undefined) {\n                    c.computedStyleMap = styleMapConjunction(styleMap, mainStyle.componentStyleMap)\n                } else {\n                    c.computedStyleMap = mainStyle.componentStyleMap\n                }\n            } else {\n                c.computedStyleMap = styleMap\n            }\n\n            propogateStyleSet(c.children, c.computedStyleMap)\n        //}\n    }\n}\n\n// returns the conjunction of two style maps\n// gets it from the computedStyles cache if its already in there\nfunction styleMapConjunction(secondaryStyleMap, primaryStyleMap) {\n    var cachedStyleMap = Style.computedStyles.get()\n    if(cachedStyleMap === undefined) {\n        cachedStyleMap = utils.objectConjunction(secondaryStyleMap, primaryStyleMap)\n        Style.computedStyles.set([secondaryStyleMap, primaryStyleMap], cachedStyleMap)\n    }\n\n    return cachedStyleMap\n}\n\n// takes lables into account\nfunction setCurrentStyle(component, style) {\n    if(style === component.currentStyle) return; // do nothing\n\n    if(style !== undefined)\n        var specificStyle = style.get(component)\n    else\n        var specificStyle = style\n\n    setStyleClass(component, specificStyle)\n    applyStyleKillFunction(component)\n    component.currentStyle = specificStyle\n    applyStyleSetupFunction(component, specificStyle)\n    applyStateHandler(component, specificStyle)\n}\n\n// applies kill appropriately\nfunction applyStyleKillFunction(component) {\n    var currentStyle = component.currentStyle\n    if(currentStyle !== undefined && currentStyle.setup !== undefined) {\n        if(currentStyle.kill === undefined)\n            throw new Error('style has been unset but does not have a \"kill\" function to undo its \"setup\" function')\n\n        currentStyle.kill(component)\n    }\n}\n// applies setup appropriately\nfunction applyStyleSetupFunction(component, style) {\n    if(style !== undefined && style.setup !== undefined) {\n        style.setup(component) // call setup on the component\n    }\n}\n// initializes and sets up state-change handler\nfunction applyStateHandler(component, style) {\n    if(style !== undefined && style.stateHandler !== undefined) {\n        style.stateHandler(component.state, component.domNode.style)\n        component.state.on('change', function() {\n            style.stateHandler(component.state.subject, component.domNode.style)\n        })\n    }\n}\n\n// sets the style, replacing one if one already exists\nfunction setStyleClass(component, style) {\n    var currentStyle = component.currentStyle\n    if(currentStyle !== undefined) {\n        component.domNode.className = component.domNode.className.replace(new RegExp(\" ?\\\\b\"+currentStyle.className+\"\\\\b\"),'') // remove the previous css class\n    }\n    if(style !== undefined) {\n        component.domNode.className += ' '+style.className\n    }\n}\n\nfunction isBlock(c) {\n    return c.add !== undefined && c.children instanceof Array && c.domNode !== undefined\n}\nfunction isDomNode(node) {\n    return node.nodeName !== undefined\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/blocks.js/src/BlockBase.js\n ** module id = 27\n ** module chunks = 0\n **/","var Block = require('../BlockBase')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static properties\n\n    this.name = 'Block'\n\n\n\t// instance properties\n\n\tthis.init = function (/*[label,] content*/) {\n        if(arguments.length === 0) {\n            var content = []\n        } else if(arguments.length === 1) {\n            var content = arguments[0]\n        } else {\n            var label = arguments[0]\n            var content = arguments[1]\n        }\n\n\t\tvar that = this\n        superclass.init.call(this) // superclass constructor\n\n        this.label = label\n\n\t\tif(content !== undefined)\n            this.add(content)\n\n\t\tthis.domNode.addEventListener(\"click\",function(data) {\n\t\t\tthat.emit(\"click\",data);\n\t\t});\n\t}\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./billysFile/code/javascript/nodejs/modules/blocks.js/src/Components/Block.js\n ** module id = 28\n ** module chunks = 0\n **/"],"sourceRoot":"","file":"blocks.umd.js"}