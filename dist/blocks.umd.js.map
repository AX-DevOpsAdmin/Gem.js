{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///blocks.umd.js","webpack:///webpack/bootstrap 8d1ee4cfca7813806c4b","webpack:///./blocks.browser.js","webpack:///./~/Block.js","webpack:///./~/Style.js","webpack:///./~/Components/Canvas.js","webpack:///./~/Components/Container.js","webpack:///./~/Components/Button.js","webpack:///./~/Components/CheckBox.js","webpack:///./~/Components/Image.js","webpack:///./~/Components/List.js","webpack:///./~/Components/Radio.js","webpack:///./~/Components/Select.js","webpack:///./~/Components/Table.js","webpack:///./~/Components/TextArea.js","webpack:///./~/Components/TextField.js","webpack:///./~/Components/Text.js","webpack:///./external/jss.js","webpack:///./~/utils.js","webpack:///./~/blockStyleUtils.js","webpack:///./~/EventEmitterB.js","webpack:///./~/domUtils.js","webpack:///./~/Components/Item.js","webpack:///./~/Components/Option.js","webpack:///./~/Components/Header.js","webpack:///./~/Components/Row.js","webpack:///./~/Components/Cell.js","webpack:///../~/build-modules/~/webpack/~/node-libs-browser/~/events/events.js","webpack:///../~/proto/proto.js","webpack:///../~/hashmap/hashmap.js","webpack:///../~/trimArguments/trimArguments.js","webpack:///../~/observe/observe.js","webpack:///./~/Components/RowlikeGenerator.js","webpack:///../~/build-modules/~/webpack/~/node-libs-browser/~/path-browserify/index.js","webpack:///../~/observe/utils.js","webpack:///../~/build-modules/~/webpack/~/node-libs-browser/~/process/browser.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Block","Style","Canvas","Container","Button","CheckBox","Image","List","Radio","Select","Table","TextArea","TextField","Text","Object","defineProperty","get","dev","set","v","attach","apply","arguments","detach","createBody","isBlock","undefined","add","children","Array","domNode","EventEmitterB","proto","trimArguments","observe","utils","domUtils","blockStyleUtils","isDev","components","setOfBrowserEvents","arrayToMap","superclass","init","that","name","Error","defaultBlockStyle","defaultStyleMap","constructor","createDefaultBlockStyle","state","parent","div","build","attr","classList","className","push","defaultClassName","join","ifonHandlers","ifon","event","excludeDomEvents","addEventListener","emit","concat","prototype","slice","ifoff","removeEventListener","length","label","_label","addAt","index","nodes","normalizeAddAtArguments","i","node","splice","beforeChild","appendChild","insertBefore","getParentStyleMap","computedStyleMap","propogateStyleSet","addBefore","addBeforeNode","indexOf","remove","removals","normalizeRemoveArguments","sort","a","b","n","r","removeChild","childNodes","attribute","getAttribute","attributes","setAttribute","value","removeAttribute","style","display","setToVisible","_displayStyle","document","activeElement","setToInFocus","focus","blur","_style","styleObject","styleMap","setCurrentStyle","getStyleForComponent","specificStyle","styleMapConjunction","componentStyleMap","getSelectionRange","selection","setSelectionRange","currentStyle","_styleSetupStates","body","callback","dom","implementation","createDocument","createElement","documentElement","setTimeout","map","removal","parameterIndex","createTieredPseudoClasses","pseudoClassStyles","tieredPseudoClasses","key","pseudoClassList","split","emulatablePseudoClasses","nonEmulatablePseudoClasses","pseudoClass","pseudoClassParts","getPseudoClassParts","emulatedPseudoClasses","validatePurePseudoClassStyles","createPseudoClassRules","emulatablePseudoClassKey","merge","nonEmulatablePsuedoClassKey","secondTier","pseudoclassCombinations","tieredPseudoClassesKeys","keys","reverse","parts","keyA","k","j","result","combinePseudoclasses","nthChildCheck","component","testFn","parentNode","nthLastChildCheck","parameter","parseInt","nthChildParameterFn","match","nthChildParameter","constant","variable","cssValue","cssStyleName","cssNumber","toString","selector","pseudoClassStyle","pseudoClassCss","cssStyle","mapCamelCase","defaultJss","styleDefinitions","isStyleObject","fullPsuedoClass","x","pseudoClassRegex","class","flattenPseudoClassStyles","nonPseudoClassStyles","subpseudoClasses","subPseudoClass","substr","flattenedStyles","o","ascii","charCodeAt","asciiA","asciiZ","String","fromCharCode","difference","jssModule","HashMap","baseClassName","nextClassNumber","forDocument","defaultSheet","_createSheet","jss","styleDefinition","privateOptions","inLabel","labelStyleMap","labelStyles","cssProperties","Function","setup","kill","stateHandler","jssSheet","baseStyle","mergedStyle","pseudoClasesToEmulate","preSplitPseudoClasses","pseudoClassesToEmulationInfo","newStyle","fns","info","processParameter","initializeState","pseudoClassEmulationInfo","check","changeStyleIfNecessary","longestMatchingLength","mostSpecificMatchingStyle","wrapSetupAndKill","originalSetup","emulationInfo","originalKill","labelStyle","pseudoclasses","resultKeyParts","resultValue","part","hover","querySelectorAll","startCallback","endCallback","on","start","end","off","checked","selected","setupState","listener","removeListener","required","observer","MutationObserver","disconnect","last-child","setupObserver","childList","nth-child","parameterCheck","checkAndCallCallbacks","addPseudoClass","column-count","fill-opacity","flex-grow","flex-shrink","font-weight","line-height","opacity","order","orphans","widows","z-index","zoom","defaultStyleValues","azimuth","border-collapse","border-spacing","caption-side","direction","elevation","empty-cells","letter-spacing","list-style-image","list-style-position","list-style-type","pitch-range","pitch","position","quotes","richness","speak-header","speak-numeral","speak-punctuation","speak","speak-rate","stress","text-align","text-indent","text-transform","voice-family","volume","white-space","word-spacing","cursor","computedStyles","height","width","context","getContext","toImg","toDataURL","contentArgs","text","newValue","curValue","imageSource","src","Item","listInit","ordered","type","defaultStyle","listStyleType","item","selectSibling","button","buttons","group","values","buttonToSelect","setButtonInGroup","_selected","getRandomInt","min","max","Math","floor","random","EventEmitter","randomStart","RadioButton","val","originalSelected","radioGroup","preventDefault","keyCode","selectNext","selectPrevious","oldValue","booleanValue","previouslySelected","Option","options","option","newOption","nodesToAdd","forEach","anyWereSelected","removalIndexes","theSelectedWasRemoved","prepareForValueChange","optionValue","setSelectedQuiet","headerOrRegularRow","Prototype","args","row","Header","Row","Cell","borderSpacing","tableInit","header","password","whiteSpace","data","eventData","newText","srcElement","textContent","oldText","lastFocus","innerText","getSelectorsAndRules","sheet","rules","cssRules","results","selectorText","toDoubleColonPseudoElements","getRules","toLowerCase","swapAdjSelAttr","swapPseudoElSyntax","addRule","pseudoElementRule","addPseudoElementRule","addRuleToSheet","insertRule","doubleColonSelector","singleColonSelector","doubleColonPseudoElRegex","exec","toSingleColonPseudoElements","singleColonPseudoElRegex","singleColonForPseudoElements","replace","submatch1","submatch2","submatch3","removeRule","rule","deleteRule","extend","dest","hasOwnProperty","aggregateStyles","aggregate","declaredProperties","declared","toCamelCase","swap","lastIndex","adjSelAttrRegex","substring","setStyleProperties","properties","importantIndex","removeProperty","setProperty","str","submatch","toUpperCase","transformCamelCasedPropertyNames","oldProps","newProps","unCamelCase","Jss","doc","head","getElementsByTagName","sheets","styleSheets","getAll","_removeSheet","styleNode","rel","ownerNode","mergeInternal","objects","deep","obj1","obj2","newObjects","arrayify","deepMerge","objectConjunction","objectCopy","array","applyStyleSetupFunction","_styleSetupObject","applyStyleKillFunction","applyStateHandler","subject","setStyleClass","RegExp","trim","validateDefaultStyle","styleFromMap","mainStyle","block","secondaryStyleMap","primaryStyleMap","cachedStyleMap","defaultStyles","nextConstructor","defaultStyleSet","default","triggerIfHandlers","handlerListName","triggerIfHandlerList","normalHandlerToAllHandlerProperty","handlerList","addHandlerToList","removeFromHandlerList","removeCallbackFromList","allHandlerListName","list","ifoffHandlers","ifonAllHandlers","ifoffAllHandlers","eventName","_events","listeners","removeIfon","removeIfoff","proxy","emitter","except","handleIt","only","handler","addListener","triggerIfOn","triggerIfOff","removeAllListeners","triggerIfOffForEvents","iterateThroughLeafNodes","element","nodeStack","pop","nodeType","findHiddenCharacters","beforeCaretIndex","hiddenCharacters","lastCharWasWhiteSpace","elem","createAttribute","setAttributeNode","containerEl","nodeName","charIndex","range","createRange","setStart","collapse","foundStart","nextCharIndex","nodeIndex","hiddenCharactersBeforeStart","hiddenCharactersBeforeEnd","setEnd","sel","window","getSelection","removeAllRanges","addRange","isInputOrArea","rangeCount","getRangeAt","startsInElement","contains","startContainer","elementToIterateThrough","startFound","commonAncestorContainer","startContainerFound","visibleCharacterOffset","leaf","startOffset","endContainer","endOffset","selectionStart","selectionEnd","contents","RowlikeGenerator","colspan","cols","_maxListeners","isFunction","arg","isNumber","isObject","isUndefined","defaultMaxListeners","setMaxListeners","isNaN","TypeError","er","len","error","newListener","warned","console","trace","once","g","fired","ret","listenerCount","noop","prototypeBuilder","namePointer","EvalError","RangeError","ReferenceError","SyntaxError","URIError","normalizeErrorObject","parentIsFunction","prototypeName","F","constructorName","ProtoObjectFactory","protoUndefined","addProperty","ownProperty","ErrorObject","NormalizedError","tmp","message","stack","IntermediateInheritor","factoryObject","property","getOwnPropertyDescriptor","e","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","other","clear","copy","multi","chain","fn","hide","obj","prop","enumerable","_data","hash","has","search","count","clone","getTime","hashes","_hmuid_","uid","func","method","theArguments","parsePropertyList","getPropertyPointer","propertyList","current","setInternal","pointer","internalObservee","union","unionizeEvents","pushInternal","getPropertyValue","originalLength","internalObservees","unionizeList","unionizeListEvents","spliceInternal","countToRemove","removed","appendInternal","arrayToAppend","spliceArgs","oldLength","afterEnd","innerObservee","propertyListDepth","innerChangeHandler","containerChangeHandler","ignorableContainerEvents","ignorableInnerEvents","change","containerChange","changedPropertyDepth","answers","changeQuestions","changeIsWithinInnerProperty","isWithin","changeCouldRelocateInnerProperty","couldRelocate","innerObserveeEvent","removeUnion","relevantIndex","removedIndexesContainsIndexOfInnerObservee","removedIndexesAreBeforeIndexOfInnerObservee","ObserveeChild","append","_observeeParent","removedIndexesAreBeforeIndexOfObserveeChild","elementType","rowInit","cell","process","normalizeArray","allowAboveRoot","up","last","unshift","filter","xs","f","res","splitPathRe","splitPath","filename","resolve","resolvedPath","resolvedAbsolute","path","cwd","charAt","normalize","isAbsolute","trailingSlash","paths","relative","from","to","arr","fromParts","toParts","samePartsLength","outputParts","sep","delimiter","dirname","dir","basename","ext","extname","nextTick","canSetImmediate","setImmediate","canMutationObserver","canPost","postMessage","queue","hiddenDiv","queueList","ev","source","stopPropagation","shift","title","browser","env","argv","binding","chdir"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,OAAAH,GACA,gBAAAC,SACAA,QAAA,OAAAD,IAEAD,EAAA,OAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAP,WACAS,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,QAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDgBM,SAASL,EAAQD,EAASM,GEtDhCN,EAAAe,MAAAT,EAAA,GACAN,EAAAgB,MAAAV,EAAA,GAEAN,EAAAiB,OAAAX,EAAA,GACAN,EAAAkB,UAAAZ,EAAA,GACAN,EAAAmB,OAAAb,EAAA,GACAN,EAAAoB,SAAAd,EAAA,GACAN,EAAAqB,MAAAf,EAAA,GACAN,EAAAsB,KAAAhB,EAAA,GAEAN,EAAAuB,MAAAjB,EAAA,GACAN,EAAAwB,OAAAlB,EAAA,IACAN,EAAAyB,MAAAnB,EAAA,IACAN,EAAA0B,SAAApB,EAAA,IACAN,EAAA2B,UAAArB,EAAA,IACAN,EAAA4B,KAAAtB,EAAA,IAIAuB,OAAAC,eAAA9B,EAAA,OACA+B,IAAA,WACA,MAAA/B,GAAAe,MAAAiB,KACKC,IAAA,SAAAC,GACLlC,EAAAe,MAAAiB,IAAAE,KAIAlC,EAAAmC,OAAA,WACAnC,EAAAe,MAAAoB,OAAAC,MAAAhC,KAAAiC,YAEArC,EAAAsC,OAAA,WACAtC,EAAAe,MAAAuB,OAAAF,MAAAhC,KAAAiC,YAGArC,EAAAuC,WAAA,WACAvC,EAAAe,MAAAuB,OAAAF,MAAAhC,KAAAiC,aF6DM,SAASpC,EAAQD,EAASM,GGmVhC,QAAAkC,GAAA3B,GACA,MAAA4B,UAAA5B,EAAA6B,KAAA7B,EAAA8B,mBAAAC,QAAAH,SAAA5B,EAAAgC,QApbA,GAAAC,GAAAxC,EAAA,IACAyC,EAAAzC,EAAA,IACA0C,EAAA1C,EAAA,IACA2C,EAAA3C,EAAA,IAEA4C,EAAA5C,EAAA,IACA6C,EAAA7C,EAAA,IACA8C,EAAA9C,EAAA,IAEAU,EAAAV,EAAA,EACAU,GAAAqC,MAAA,WAA0B,MAAApD,GAAAD,QAAAgC,IAE1B,KAAAsB,MAEAC,EAAAL,EAAAM,YACA,sHACA,iHACA,sIACA,sIACA,mIACA,gIACA,6HACA,+HACA,kIACA,oIACA,sIACA,4HACA,mHAMAvD,GAAAD,QAAA+C,EAAAD,EAAA,SAAAW,GAKArD,KAAAsD,KAAA,WACA,GAAAC,GAAAvD,IAEA,IAAAqC,SAAArC,KAAAwD,KACA,SAAAC,OAAA,6CAGA,IAAAC,GAAAV,EAAAW,gBAAAhC,IAAA3B,KAAA4D,YACAvB,UAAAqB,IACAA,EAAAV,EAAAa,wBAAA7D,OAGAqD,EAAAC,KAAA/C,KAAAP,MAEAA,KAAAuC,YACAvC,KAAA8D,MAAAjB,MACA7C,KAAA+D,OAAA1B,OAEAA,SAAArC,KAAAK,KACA6C,EAAAlD,KAAAK,IAAAL,MAGAqC,SAAArC,KAAAyC,UACAzC,KAAAyC,QAAAM,EAAAiB,OAGAhE,KAAAiE,MAAAjC,MAAAhC,KAAAiC,WAGAjC,KAAAkE,KAAA,UAAAlE,KAAAwD,KAGA,IAAAW,IAAAnE,KAAAyC,QAAA2B,UACAV,MAAA,GAAAS,EAAAE,KAAAX,EAAAU,WACAD,EAAAE,KAAAzD,EAAA0D,kBACAtE,KAAAyC,QAAA2B,UAAAD,EAAAI,KAAA,IAGA,IAAAC,KACAjB,GAAAkB,KAAA,SAAAC,KACAA,IAAAvB,KAAAd,SAAAkB,EAAAoB,kBAAAD,IAAAnB,GAAAoB,kBACApB,EAAAd,QAAAmC,iBAAAF,EAAAF,EAAAE,GAAA,WACAnB,EAAAsB,KAAA7C,MAAAuB,GAAAmB,GAAAI,OAAAtC,MAAAuC,UAAAC,MAAAzE,KAAA0B,iBAIAsB,EAAA0B,MAAA,SAAAP,KACAA,IAAAvB,KAAAd,SAAAkB,EAAAoB,kBAAAD,IAAAnB,GAAAoB,kBACApB,EAAAd,QAAAyC,oBAAAR,EAAAF,EAAAE,OAWA1E,KAAAiE,MAAA,WACA,IAAAhC,UAAAkD,OACAnF,KAAAyC,QAAAR,UAAA,GACSA,UAAAkD,QAAA,IACTnF,KAAAoF,MAAAnD,UAAA,GACAjC,KAAAyC,QAAAR,UAAA,KAQAjC,KAAAyC,QACAzC,KAAAoF,MACApF,KAAA2E,iBACA3E,KAAAuC,SAGAd,OAAAC,eAAA1B,KAAA,SACA2B,IAAA,WACA,MAAA3B,MAAAqF,QACSxD,IAAA,SAAAC,GACT,GAAAO,SAAArC,KAAAqF,OAOA,SAAA5B,OAAA,6DAAAzD,KAAAqF,OAAA,IANArF,MAAAqF,OAAAvD,EAEAjC,EAAAD,QAAAgC,KACA5B,KAAAkE,KAAA,QAAAlE,KAAAqF,WAYArF,KAAAsC,IAAA,WACAtC,KAAAsF,MAAAtD,MAAAhC,WAAAyC,QAAAF,SAAA4C,QAAAL,OAAAlC,EAAAX,cAOAjC,KAAAsF,MAAA,SAAAC,GAGA,OAFAC,GAAAC,EAAAzD,MAAAhC,KAAAiC,WAEAyD,EAAA,EAAqBA,EAAAF,EAAAL,OAAeO,IAAA,CACpC,GAAAC,GAAAH,EAAAE,EAGA,IAFA1F,KAAAuC,SAAAqD,OAAAL,EAAAG,EAAA,EAAAC,IAEAvD,EAAAuD,GACA,SAAAlC,OAAA,sBAGAkC,GAAA5B,OAAA1B,OACAsD,EAAAd,KAAA,gBAEA,IAAAgB,GAAA7F,KAAAuC,SAAA,EAAAmD,EAAAH,EACAlD,UAAAwD,EACA7F,KAAAyC,QAAAqD,YAAAH,EAAAlD,SAEAzC,KAAAyC,QAAAsD,aAAAJ,EAAAlD,QAAAoD,EAAApD,SAGAkD,EAAA5B,OAAA/D,KACA2F,EAAAd,KAAA,YAIA,IAAAtB,GAAAvD,IACA2F,GAAAK,kBAAA,WAAqD,MAAAzC,GAAA0C,kBACrDjD,EAAAkD,mBAAAP,GAAA3F,KAAAiG,oBAUAjG,KAAAmG,UAAAnG,KAAAoG,cAAA,SAAAP,GACA,GAAAL,GAAA5C,EAAAX,WAAA+C,MAAA,EACA,IAAA3C,SAAAwD,EACA7F,KAAAsC,IAAAN,MAAAhC,KAAAwF,OACS,CACT,GAAAD,GAAAvF,KAAAuC,SAAA8D,QAAAR,EACA7F,MAAAsF,MAAAtD,MAAAhC,MAAAuF,GAAAT,OAAAU,MAUAxF,KAAAsG,OAAA,WACA,GAAAC,GAAAC,EAAAxE,MAAAhC,KAAAiC,UACAsE,KAAAE,KAAA,SAAAC,EAAAC,GACA,MAAAA,GAAAD,GAGA,QAAAE,GAAA,EAAoBA,EAAAL,EAAApB,OAAmByB,IAAA,CACvC,GAAAC,GAAAN,EAAAK,GACAnG,EAAAT,KAAAuC,SAAAsE,EAEA,IAAAxE,SAAA5B,EACA,SAAAgD,OAAA,8BAAAoD,EAGApG,GAAAsD,OAAA1B,OACArC,KAAAuC,SAAAqD,OAAAiB,EAAA,GACA7G,KAAAyC,QAAAqE,YAAA9G,KAAAyC,QAAAsE,WAAAF,IAEApG,EAAAoE,KAAA,mBASA7E,KAAAkE,KAAA,WACA,OAAAjC,UAAAkD,OAAA,CACA,KAAAlD,UAAA,YAAAR,SAKa,CACb,GAAAuF,GAAAhH,KAAAyC,QAAAwE,aAAAhF,UAAA,GACA,eAAA+E,EACA3E,OAEA2E,EATA,GAAAE,GAAAjF,UAAA,EACA,QAAA+E,KAAAE,GACAnE,EAAAoE,aAAAnH,KAAAyC,QAAAuE,EAAA/E,UAAA,GAAA+E,QAUS,CACT,GAAAA,GAAA/E,UAAA,EACA,IAAAI,SAAAJ,UAAA,IACA,GAAAmF,GAAAnF,UAAA,EACAc,GAAAoE,aAAAnH,KAAAyC,QAAAR,UAAA,GAAAmF,OAEApH,MAAAyC,QAAA4E,gBAAAL,KAKAvF,OAAAC,eAAA1B,KAAA,WAEA2B,IAAA,WACA,eAAA3B,KAAAyC,QAAA6E,MAAAC,SAGS1F,IAAA,SAAA2F,GACTA,EACAnF,SAAArC,KAAAyH,eACAzH,KAAAyC,QAAA6E,MAAAC,QAAAvH,KAAAyH,cACAzH,KAAAyH,cAAApF,QAEArC,KAAAyC,QAAA6E,MAAAC,QAAA,IAGA,KAAAvH,KAAAyC,QAAA6E,MAAAC,SAAA,SAAAvH,KAAAyC,QAAA6E,MAAAC,UACAvH,KAAAyH,cAAAzH,KAAAyC,QAAA6E,MAAAC,SAGAvH,KAAAyC,QAAA6E,MAAAC,QAAA,WAMA9F,OAAAC,eAAA1B,KAAA,SAEA2B,IAAA,WACA,MAAA+F,UAAAC,gBAAA3H,KAAAyC,SAGSZ,IAAA,SAAA+F,GACTA,EACA5H,KAAAyC,QAAAoF,QAEA7H,KAAAyC,QAAAqF,UAKArG,OAAAC,eAAA1B,KAAA,SACA2B,IAAA,WACA,MAAA3B,MAAA+H,QAGSlG,IAAA,SAAAmG,GACT,GAAA3F,SAAA2F,EAAA,CACA,GAAAC,GAAAjI,KAAAgG,mBACA3D,UAAA4F,EACAjF,EAAAkF,gBAAAlI,KAAAgD,EAAAmF,qBAAAF,EAAAjI,OAEAgD,EAAAkF,gBAAAlI,KAAAqC,QAGArC,KAAAiG,iBAAAgC,MAEa,CACbjF,EAAAkF,gBAAAlI,KAAAgI,EACA,IAAAI,GAAAJ,EAAArG,IAAA3B,KAEAA,MAAAiG,iBADA5D,SAAArC,KAAAgG,oBACAhD,EAAAqF,oBAAArI,KAAAgG,oBAAAoC,EAAAE,mBAEAF,EAAAE,kBAIAtI,KAAA+H,OAAAC,EACAhF,EAAAkD,kBAAAlG,KAAAuC,SAAAvC,KAAAiG,qBAIAxE,OAAAC,eAAA1B,KAAA,kBAGA2B,IAAA,WACA,MAAAoB,GAAAwF,kBAAAvI,KAAAyC,UAGSZ,IAAA,SAAA2G,GACTzF,EAAA0F,kBAAAzI,KAAAyC,QAAA+F,EAAA,GAAAA,EAAA,OAIAxI,KAAA+B,OAAA,WACAA,EAAA/B,OAEAA,KAAAkC,OAAA,WACAA,EAAAlC,OAMAA,KAAAgG,kBAAA,aACAhG,KAAAiG,iBAEAjG,KAAA+H,OACA/H,KAAA0I,aACA1I,KAAAyH,cACAzH,KAAA2I,oBAIA9I,EAAAD,QAAAgC,KAAA,CAIA,IAAAG,GAAAlC,EAAAD,QAAAmC,OAAA,WACA,GAAAE,UAAA,YAAAO,OACA,GAAAU,GAAAjB,UAAA,OAEA,IAAAiB,GAAAjB,SAGA,WAAAyF,SAAAkB,KAAA,SAAAnF,OAAA,sCAEA,QAAAmD,GAAA,EAAgBA,EAAA1D,EAAAiC,OAAqByB,IACrCc,SAAAkB,KAAA9C,YAAA5C,EAAA0D,GAAAnE,UAIAP,EAAArC,EAAAD,QAAAsC,OAAA,WACA,GAAAD,UAAA,YAAAO,OACA,GAAAU,GAAAjB,UAAA,OAEA,IAAAiB,GAAAjB,SAGA,QAAA2E,GAAA,EAAgBA,EAAA1D,EAAAiC,OAAqByB,IACrCc,SAAAkB,KAAA9B,YAAA5D,EAAA0D,GAAAnE,SAMA5C,GAAAD,QAAAuC,WAAA,SAAA0G,GACA,GAAAC,GAAApB,SAAAqB,eAAAC,eAAA,4CACAJ,EAAAE,EAAAG,cAAA,OACAH,GAAAI,gBAAApD,YAAA8C,GACAO,WAAA,WACAN,KACK,GAOL,IAAArC,GAAA3G,EAAAD,QAAA4G,yBAAA,WACA,GAAAjD,GAAAvD,IAEA,IAAAiC,UAAA,YAAAO,OACA,GAAA+D,GAAAtE,UAAA,OAEA,IAAAsE,GAAA/D,MAAAuC,UAAAC,MAAAzE,KAAA0B,UAGA,OAAAsE,GAAA6C,IAAA,SAAAC,EAAAC,GACA,GAAAlH,EAAAiH,GAAA,CACA,GAAA9D,GAAAhC,EAAAhB,SAAA8D,QAAAgD,EACA,SAAA9D,EACA,SAAA9B,OAAA,6BAAA6F,EAAA,iCAEA,OAAA/D,GAEA,MAAA8D,MAOA5D,EAAA5F,EAAAD,QAAA6F,wBAAA,WACA,WAAAxD,UAAAkD,OACAlD,UAAA,YAAAO,OACAP,UAAA,IAEAA,UAAA,IAGAW,EAAAX,WAAA+C,MAAA,KH+GM,SAASnF,EAAQD,EAASM,GI/PhC,QAAAqJ,GAAAjC,EAAAkC,GACA,GAAAC,KACA,QAAAC,KAAAF,GAAA,CACA,GAAApC,GAAAoC,EAAAE,GAGAC,EAAAD,EAAAE,MAAA,KACAC,KACAC,IACA,QAAAlD,KAAA+C,GAAA,CACA,GAAAI,GAAAJ,EAAA/C,GACAoD,EAAAC,EAAAF,EACAC,aAAAE,GACAL,EAAAxF,KAAA0F,GAEAD,EAAAzF,KAAA0F,GAKA,OAAAF,EAAA1E,OACAgF,EAAAT,EAAAtC,GACAgD,EAAA9C,EAAAoC,EAAA,IAAApC,EAAAlD,UAAA,IAAAsF,EAAAtC,OAES,CAETyC,EAAApD,MACA,IAAA4D,GAAAR,EAAAtF,KAAA,IAIA,IAHAlC,SAAAoH,EAAAY,KACAZ,EAAAY,OAEA,IAAAP,EAAA3E,OACArC,EAAAwH,MAAAb,EAAAY,GAAAjD,OACa,CACb0C,EAAArD,MACA,IAAA8D,GAAAT,EAAAvF,KAAA,KAEAiG,IACAA,GAAA,KAAAD,GAAAnD,EAEAtE,EAAAwH,MAAAb,EAAAY,GAAAG,KAKA,MAAAf,GAQA,QAAAgB,GAAAhB,GAKA,OAJAiB,GAAAjJ,OAAAkJ,KAAAlB,GAAAmB,UAAAxB,IAAA,SAAAtH,GACA,OAAgB4H,IAAA5H,EAAA+I,MAAA/I,EAAA8H,MAAA,QAGhBhD,EAAA,EAAgBA,EAAA8D,EAAAvF,OAAkCyB,IAElD,OADAkE,GAAAJ,EAAA9D,GACAmE,EAAA,EAAoBA,GAAAL,EAAAvF,OAAqC4F,IACzD,OAAAC,GAAApE,EAAA,EAA0BoE,EAAAN,EAAAvF,QAAA4F,EAAA,GAAwCC,IAAA,CAClE,GAAAC,GAAAC,EAAAzB,GAAAqB,GAAAhG,OAAA4F,EAAA1F,MAAAgG,EAAAD,IACAE,GAAAvB,MAAAD,GACA3G,EAAAwH,MAAAb,EAAAwB,EAAAvB,KAAAuB,EAAA7D,OAEAqC,EAAAwB,EAAAvB,KAAAuB,EAAA7D,OAmNA,QAAA+D,GAAAC,EAAAC,GACA,UAAAD,EAAA3I,QAAA6I,WACA,QAEA,IAAA/I,GAAA6I,EAAA3I,QAAA6I,WAAA/I,SACAgD,EAAA/C,MAAAuC,UAAAsB,QAAA9F,KAAAgC,EAAA6I,EAAA3I,QACA,OAAA4I,GAAA9F,GAGA,QAAAgG,GAAAH,EAAAI,GACA,UAAAJ,EAAA3I,QAAA6I,WACA,QAEA,IAAA/I,GAAA6I,EAAA3I,QAAA6I,WAAA/I,SACAgD,EAAAhD,EAAA4C,OAAAsG,SAAAD,EACA,OAAAjJ,GAAAgD,KAAA6F,EAAA3I,QAKA,QAAAiJ,GAAAF,GACA,GAAAX,GAAAW,EAAAG,MAAAC,EACA,WAAAf,EACA,SAAApH,OAAA,wBAAA+H,EAAA,gBAEA,IAAAnJ,SAAAwI,EAAA,GACA,GAAAgB,GAAAhB,EAAA,GACAiB,EAAAjB,EAAA,OAEA,IAAAgB,GAAAhB,EAAA,GACAiB,EAAAjB,EAAA,EAQA,OALAgB,GAAAxJ,SAAAwJ,EAAA,EACAJ,SAAAI,GACAC,EAAAzJ,SAAAyJ,EAAA,EACAL,SAAAK,GAEA,IAAAA,EACA,SAAAvG,GACA,MAAAA,GAAA,IAAAsG,GAGA,SAAAtG,GACA,OAAAA,EAAA,EAAAsG,GAAAC,EAAA,OAQA,QAAAC,GAAAC,EAAA5E,GAEA,0BAAA/E,SAAA4J,EAAAD,GACA5E,EAAA,KAEAA,EAAA8E,WAIA,QAAA9B,GAAA7G,EAAAwG,EAAAoC,EAAAC,GAEA,GAAAC,KACA,QAAA3C,KAAA0C,GAAA,CACA,GAAAhF,GAAAgF,EAAA1C,EAEA,IAAAtC,YAAA3F,QAKA,SAAAgC,OAAA,4CAAAsG,EAAA,uBAJA,IAAAuC,GAAA5C,EACAsC,EAAAO,EAAAD,EACAD,GAAAL,GAAAD,EAAAC,EAAA5E,GAOAoF,EAAA3K,IAAAsK,EAAAE,GAGA9I,EAAAkJ,oBACAlJ,EAAAkJ,iBAAAN,GAAAE,EAKA,QAAAlC,GAAAJ,EAAAP,GACA,OAAAE,KAAAF,GAAA,CACA,GAAApC,GAAAoC,EAAAE,EAEA,IAAAgD,EAAAtF,GACA,SAAA3D,OAAA,gCAAAsG,EAAA,sBACS,eAAAL,EACT,SAAAjG,OAAA,kDAAAsG,EAAA,IACS,cAAAL,EACT,SAAAjG,OAAA,iDAAAsG,EAAA,IACS,QAAAL,EAAArD,QAAA,KACT,SAAA5C,OAAA,wDAAAsG,EAAA,MAOA,QAAAE,GAAA0C,GACA,GAAAC,GAAAD,EAAAhB,MAAAkB,EACA,WAAAD,EAAA,SAAAnJ,OAAA,gBAAAkJ,EAAA,eACA,QAAYG,QAAAF,EAAA,GAAApB,UAAAoB,EAAA,IAMZ,QAAAG,GAAAhD,EAAAqC,GACA,GAAAY,MACAC,IACA,QAAAvD,KAAA0C,GAAA,CACA,GAAAhF,GAAAgF,EAAA1C,EAEA,QAAAA,EAAArD,QAAA,OACA,GAAA6G,GAAAxD,EAAAyD,OAAA,EACA,SAAAD,EACA,SAAAzJ,OAAA,qDAGAwJ,GAAAC,GAAA9F,MAEA4F,GAAAtD,GAAAtC,EAKA,GAAAgG,KACA,QAAAF,KAAAD,GAAA,CACA,GAAA7F,GAAA6F,EAAAC,EAEAR,GAAAtF,GACAgG,EAAArD,EAAA,IAAAmD,GAAA9F,EAEAtE,EAAAwH,MAAA8C,EAAAL,EAAAhD,EAAA,IAAAmD,EAAApK,EAAAwH,SAAgH0C,EAAA5F,KAOhH,MAFAgG,GAAArD,GAAAiD,EAEAI,EAoBA,QAAAV,GAAAW,GACA,MAAAhL,UAAAgL,EAAA/E,kBAKA,QAAAiE,GAAAP,GACA,OAAApF,GAAA,EAAgBA,EAAAoF,EAAA7G,OAAuByB,IAAA,CACvC,GAAA0G,GAAAtB,EAAAuB,WAAA3G,EACA0G,IAAAE,GAAAC,GAAAH,IACAtB,IAAAhH,MAAA,EAAA4B,GAAA,IAAA8G,OAAAC,aAAAL,EAAAM,GAAA5B,EAAAhH,MAAA4B,EAAA,GACAA,KAIA,MAAAoF,GAzuBA,GAAA6B,GAAA3N,EAAA,IACAyC,EAAAzC,EAAA,IACA4N,EAAA5N,EAAA,IAEA4C,EAAA5C,EAAA,IAGA6N,GAFA7N,EAAA,IAEA,oBACA8N,EAAA,EAEAxB,EAAAqB,EAAAI,YAAAvG,SACA8E,GAAA0B,aAAA1B,EAAA2B,cACA,IAAAC,GAAAP,EAAAI,YAAAvG,SACA0G,GAAAF,aAAAE,EAAAD,cAGA,IAAAvN,GAAAf,EAAAD,QAAA+C,EAAA,WAEA3C,KAAAsE,iBAAA,YASAtE,KAAAsD,KAAA,SAAA+K,EAAAC,GACAjM,SAAAiM,UACAjM,SAAAiM,EAAAC,mBAAA,GAEAvO,KAAAoE,UAAA2J,EAAAC,EACAA,IAEAhO,KAAAsI,qBACAtI,KAAAwO,gBAEA,IAAAC,MACAjF,KACAkF,IACA,QAAAhF,KAAA2E,GAAA,CACA,GAAAjH,GAAAiH,EAAA3E,EAEA,eAAAA,EAAA,CACA,KAAAtC,YAAAuH,WAAA,SAAAlL,OAAA,mEACAzD,MAAA4O,MAAAxH,MAEa,cAAAsC,EAAA,CACb,KAAAtC,YAAAuH,WAAA,SAAAlL,OAAA,iEACAzD,MAAA6O,KAAAzH,MAEa,eAAAsC,EAAA,CACb,KAAAtC,YAAAuH,WAAA,SAAAlL,OAAA,oEACAzD,MAAA8O,aAAA1H,MAEa,QAAAsC,EAAArD,QAAA,OACb,GAAA0D,GAAAwC,EAAA7C,EAAAyD,OAAA,GACA,SAAApD,EACA,SAAAtG,OAAA,qDAGAX,GAAAwH,MAAAd,EAAAuD,EAAAhD,EAAA3C,QAEa,QAAAsC,EAAArD,QAAA,MACb,GAAAiI,EAAAC,QACA,SAAA9K,OAAA,mCAAAiG,EAAA,8CAEA,IAAAtE,GAAAsE,EAAAyD,OAAA,EACA,SAAA/H,EACA,SAAA3B,OAAA,6CAGAgL,GAAArJ,GAAAgC,MAEa,IAAAsF,EAAAtF,GACbpH,KAAAsI,kBAAAoB,GAAAtC,MAEa,IAAAA,YAAA3F,QACbzB,KAAAsI,kBAAAoB,GAAA9I,EAAAwG,OACa,CACb,GAAAkF,GAAA5C,EACAsC,EAAAO,EAAAD,EACAoC,GAAA1C,GAAAD,EAAAC,EAAA5E,IAKA,GAAAkH,aACA,GAAAS,GAAAvC,MAEA,IAAAuC,GAAAX,CAWA,IARAW,EAAAlN,IAAA,IAAA7B,KAAAoE,UAAAsK,GAGA1O,KAAAyM,oBACAzM,KAAAyM,iBAAA,IAAAzM,KAAAoE,WAAAsK,EAIAjN,OAAAkJ,KAAA8D,GAAAtJ,OAAA,GACA,GAAA6J,GAAAlM,EAAAwH,SAA0CoE,EAAA1O,KAAAsI,kBAE1C,QAAAlD,KAAAqJ,GACA,GAAA/B,EAAA+B,EAAArJ,IACApF,KAAAwO,cAAApJ,GAAAqJ,EAAArJ,OACiB,CACjB,GAAA6J,GAAAnM,EAAAwH,SAAoD0E,EAAAP,EAAArJ,GACpDpF,MAAAwO,cAAApJ,GAAAxE,EAAAqO,GAAoEV,SAAA,KAMpE,GAAA9M,OAAAkJ,KAAAnB,GAAArE,OAAA,GAEA,GAAAsE,GAAAF,EAAAvJ,KAAAwJ,EACAiB,GAAAhB,EAKA,IAAAyF,MACAC,KACAC,IACA,QAAA1F,KAAAD,GAAA,CACA,GAAAiD,EAAAjD,EAAAC,IACAD,EAAAC,GAAAD,EAAAC,OACiB,CACjB,GAAA2F,GAAAzO,EAAAkC,EAAAwH,SAAuDoE,EAAAjF,EAAAC,IAGvD,QAAAqB,KAAA/K,MAAAsI,kBACAjG,SAAAgN,EAAA/G,kBAAAyC,KACAsE,EAAA/G,kBAAAyC,GAAA/K,KAAAsI,kBAAAyC,GAEA,QAAAA,KAAA/K,MAAAwO,cACAnM,SAAAgN,EAAAb,cAAAzD,KACAsE,EAAAb,cAAAzD,GAAA/K,KAAAwO,cAAAzD,GAGAtB,GAAAC,GAAA2F,EAKA,OADA1F,GAAAD,EAAAE,MAAA,KACAhD,EAAA,EAA4BA,EAAA+C,EAAAxE,OAA0ByB,IAAA,CACtD,GAAAmD,GAAAJ,EAAA/C,EACA,SAAAsI,EAAA7I,QAAA0D,GAAA,CACAmF,EAAA7K,KAAA0F,EAEA,IAAAC,GAAAC,EAAAF,GACAuF,EAAApF,EAAAF,YACAuF,GAAoCD,MACpCjN,UAAAiN,EAAAE,mBACAD,EAAA/D,UAAA8D,EAAAE,iBAAAxF,EAAAwB,YAEA4D,EAAArF,GAAAwF,GAIAJ,EAAA9K,MAAAsF,EAAAF,EAAAC,KAIA,GAAA+F,GAAA,SAAArE,GAEA,OADAtH,MACA8C,EAAA,EAA4BA,EAAAsI,EAAA/J,OAAgCyB,IAAA,CAC5D,GAAAmD,GAAAmF,EAAAtI,GACA8I,EAAAN,EAAArF,EACAjG,GAAAiG,GAAA2F,EAAAJ,IAAAK,MAAAvE,EAAAsE,EAAAlE,WAGA,MAAA1H,IAGAP,EAAAvD,KACA4P,EAAA,SAAAlH,EAAA0C,EAAAtH,GAGA,OAFA+L,GAAA,EACAC,EAAAvM,EACAqD,EAAA,EAA4BA,EAAAuI,EAAAhK,OAAgCyB,IAAA,CAE5D,OADA+C,GAAAwF,EAAAvI,GAAA,GACAoE,EAAA,EAAgCA,EAAArB,EAAAxE,QAChCrB,EAAA6F,EAAAqB,IAD0DA,KAM1DA,IAAArB,EAAAxE,QAAA6F,EAAA6E,IACAA,EAAA7E,EACA8E,EAAAX,EAAAvI,GAAA,IAIAkJ,IAAApH,IACA0C,EAAA9D,MAAAwI,IASAC,EAAA,SAAAzI,GACA,GAAA0I,GAAA1I,EAAAsH,KACAtH,GAAAsH,MAAA,SAAAxD,GACA,GAAA7H,GAAAvD,IAEAA,MAAA2I,oBACA,IAAA7E,GAAA2L,EAAArE,EACA,QAAArB,KAAAqF,IACyB,SAAArF,EAAAkG,GACzB1M,EAAAoF,kBAAAoB,GAAAkG,EAAAX,IAAAV,MAAAxD,EAAA,WACAtH,EAAAiG,IAAA,EACA6F,EAAArM,EAAA6H,EAAAtH,IAC6B,WAC7BA,EAAAiG,IAAA,EACA6F,EAAArM,EAAA6H,EAAAtH,IAC6BmM,EAAAzE,YAEJzB,EAAAqF,EAAArF,GAGzB6F,GAAArM,EAAA6H,EAAAtH,GAEAzB,SAAA2N,GACAA,EAAAhO,MAAAhC,KAAAiC,WAIA,IAAAiO,GAAA5I,EAAAuH,IACAvH,GAAAuH,KAAA,SAAAzD,GACA,OAAArB,KAAAqF,GAAA,CACA,GAAAa,GAAAb,EAAArF,EACAkG,GAAAX,IAAAT,KAAAzD,EAAApL,KAAA2I,kBAAAoB,IAGA1H,SAAA6N,GACAA,EAAAlO,MAAAhC,KAAAiC,YAOA,QAAAyH,KAAAD,GAAA,CACA,GAAAnC,GAAAmC,EAAAC,EACAqG,GAAAzI,GAGAyI,EAAA/P,QAMAA,KAAAoE,UACApE,KAAAsI,kBACAtI,KAAAwO,cACAxO,KAAA4O,MACA5O,KAAA6O,KAGA7O,KAAA2B,IAAA,SAAAyJ,GACA,GAAA/I,SAAA+I,EAAAhG,MAAA,CACA,GAAA+K,GAAAnQ,KAAAwO,cAAApD,EAAAhG,MACA,IAAA/C,SAAA8N,EACA,MAAAA,GAIA,MAAAnQ,SA+FAkL,EAAA,SAAAkF,EAAAzF,GAGA,OAFA0F,GAAA1F,EAAA,GAAAE,MACAyF,EAAAxN,EAAAwH,SAAoC8F,EAAAzF,EAAA,GAAAjB,MACpC9C,EAAA,EAAgBA,EAAA+D,EAAAxF,OAAeyB,IAAA,CAG/B,OAFA8C,GAAAiB,EAAA/D,GAEAoE,EAAA,EAAoBA,EAAAtB,EAAAmB,MAAA1F,OAAoB6F,IAAA,CACxC,GAAAuF,GAAA7G,EAAAmB,MAAAG,EACA,MAAAqF,EAAAhK,QAAAkK,IACAF,EAAAhM,KAAAkM,GAKAzN,EAAAwH,MAAAgG,EAAAF,EAAA1G,QAGA,OAAYA,IAAA2G,EAAA9L,KAAA,KAAA6C,MAAAkJ,IAUZpG,GACAsG,OACAb,MAAA,SAAAvE,GAEA,OADA5F,GAAAkC,SAAA+I,iBAAA,UACA7J,EAAA,EAAwBA,EAAApB,EAAAL,OAAgByB,IACxC,GAAApB,EAAAoB,KAAAwE,EAAA3I,QACA,QAGA,WAEAmM,MAAA,SAAAxD,EAAAsF,EAAAC,GAMA,MALAvF,GAAAwF,GAAA,uBACAF,MAEAtF,EAAAwF,GAAA,WAAAD,IAEoBE,MAAAH,EAAAI,IAAAH,IAEpB9B,KAAA,SAAAzD,EAAAtH,GACAsH,EAAA2F,IAAA,YAAAjN,EAAA+M,OACAzF,EAAA2F,IAAA,WAAAjN,EAAAgN,OAGAE,SACArB,MAAA,SAAAvE,GACA,MAAAA,GAAA6F,UAEArC,MAAA,SAAAxD,EAAAsF,EAAAC,GACA,GAAAO,KASA,OARA9F,GAAAwF,GAAA,SAAAM,EAAAC,SAAA,WACA/F,EAAA6F,SACAP,IAEAC,MAIAO,GAEArC,KAAA,SAAAzD,EAAAtH,GACAsH,EAAAgG,eAAA,SAAAtN,EAAAqN,YAGAE,UACA1B,MAAA,SAAAvE,GACA,MAAA/I,UAAA+I,EAAAlH,KAAA,aAEA0K,MAAA,SAAAxD,EAAAsF,EAAAC,GACA,GAAAW,GAAA,GAAAC,kBAAA,WACAlP,SAAA+I,EAAAlH,KAAA,YACAwM,IAEAC,KAMA,OAFAW,GAAAzO,QAAAuI,EAAA3I,SAAiDyE,YAAA,KAE7BoK,aAEpBzC,KAAA,SAAAzD,EAAAtH,GACAA,EAAAwN,SAAAE,eAGAC,cACA9B,MAAA,SAAAvE,GACA,MAAAG,GAAAH,EAAA,MAEAwD,MAAA,SAAAxD,EAAAsF,EAAAC,GACA,GAAAW,GAAA,GAAAC,kBAAA,WACAhG,EAAAH,EAAA,KACAsF,IAEAC,MAIAe,EAAA,WAEAJ,EAAAzO,QAAAuI,EAAArH,OAAAtB,SAA4DkP,WAAA,IAc5D,OAXAtP,UAAA+I,EAAArH,QACA2N,IAGAtG,EAAAwF,GAAA,uBACAc,MAEAtG,EAAAwF,GAAA,2BACAU,EAAAE,gBAGoBF,aAEpBzC,KAAA,SAAAzD,EAAAtH,GACAA,EAAAwN,SAAAE,eAGAI,aAEAjC,MAAA,SAAAvE,EAAAyG,GACA,MAAA1G,GAAAC,EAAAyG,IAEAjD,MAAA,SAAAxD,EAAAsF,EAAAC,EAAAkB,GAEA,GAAAC,GAAA,WACA3G,EAAAC,EAAAyG,GACAnB,IAEAC,KAIAW,EAAA,GAAAC,kBAAA,WACAO,MAGAJ,EAAA,WAEAJ,EAAAzO,QAAAuI,EAAArH,OAAAtB,SAA4DkP,WAAA,IAgB5D,OAbAtP,UAAA+I,EAAArH,QACA2N,IAGAtG,EAAAwF,GAAA,uBACAc,IACAI,MAEA1G,EAAAwF,GAAA,2BACAU,EAAAE,aACAM,OAGoBR,aAEpBzC,KAAA,SAAAzD,EAAAtH,GACAA,EAAAwN,SAAAE,cAEAhC,iBAAA,SAAAhE,GACA,MAAAE,GAAAF,KAmBA3L,GAAAD,QAAAmS,eAAA,SAAAvO,EAAA8L,GACA,GAAAjN,SAAA6H,EAAA1G,GAAA,SAAAC,OAAA,oBAAAD,EAAA,wBAEA0G,GAAA1G,GAAA8L,EAuBA,IAAA1D,GAAA,oDAoFAiB,EAAA,uBAgDAZ,GACA+F,eAAA,EACAC,eAAA,EACAC,YAAA,EACAC,cAAA,EACAC,cAAA,EACAC,cAAA,EACAC,QAAA,EACAC,MAAA,EACAC,QAAA,EACAC,OAAA,EACAC,UAAA,EACAC,KAAA,GAQAnF,EAAA,IAAAD,WAAA,GAAAE,EAAA,IAAAF,WAAA,GAAAK,EAAA,IAAAL,WAAA,GAAAC,EAeAoF,GACAC,QAAA,SACAC,kBAAA,WACAC,iBAAA,IACAC,eAAA,MAGAC,UAAA,MACA1L,QAAA,eACA2L,UAAA,GACAC,cAAA,OAMAC,iBAAA,SACAf,cAAA,SACAgB,mBAAA,OACAC,sBAAA,UACAC,kBAAA,OACAf,QAAA,IACAgB,cAAA,GACAC,MAAA,GACAC,SAAA,WACAC,OAAA,GACAC,SAAA,GACAC,eAAA,GACAC,gBAAA,GACAC,oBAAA,GACAC,MAAA,GACAC,aAAA,GACAC,OAAA,GACAC,aAAA,OACAC,cAAA,IACAC,iBAAA,OAEAC,eAAA,GACAC,OAAA,GACAC,cAAA,SACA/B,OAAA,IACAgC,eAAA,SAGAjI,GAAA3K,IAAA,IAAAjB,EAAA0D,iBAAAsO,GAEApG,EAAA3K,IAAA,SACA6S,OAAA,YAGA7U,EAAAD,QAAAqD,KAEApD,GAAAD,QAAA+U,eAAA,GAAA7G,IJoiBM,SAASjO,EAAQD,EAASM,GKt0ChC,IAAAS,GAAAT,EAAA,GACAyC,EAAAzC,EAAA,GACAA,GAAA,GAEAL,EAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,KAAA,SAEAxD,KAAAsD,KAAA,WACA,OAAArB,UAAAkD,OACA,GAAAyP,GAAA3S,UAAA,GACA4S,EAAA5S,UAAA,OAEA,IAAAmD,GAAAnD,UAAA,GACA2S,EAAA3S,UAAA,GACA4S,EAAA5S,UAAA,EAGAjC,MAAAyC,QAAAiF,SAAAuB,cAAA,UACA5F,EAAAC,KAAA/C,KAAAP,MAEAA,KAAAoF,QACApF,KAAA4U,SACA5U,KAAA6U,SAKApT,OAAAC,eAAA1B,KAAA,SACA2B,IAAA,WACA,MAAA3B,MAAAyC,QAAAoS,OACShT,IAAA,SAAAC,GACT9B,KAAAyC,QAAAoS,MAAA/S,KAGAL,OAAAC,eAAA1B,KAAA,UACA2B,IAAA,WACA,MAAA3B,MAAAyC,QAAAmS,QACS/S,IAAA,SAAAC,GACT9B,KAAAyC,QAAAmS,OAAA9S,KAIA9B,KAAA8U,QAAA,WACA,MAAA9U,MAAAyC,QAAAsS,WAAA/S,MAAAhC,KAAAyC,QAAAR,YAGAjC,KAAAgV,MAAAhV,KAAAiV,UAAA,WACA,MAAAjV,MAAAyC,QAAAwS,gBL+0CM,SAASpV,EAAQD,EAASM,GMj4ChC,GAAAS,GAAAT,EAAA,GACAyC,EAAAzC,EAAA,GAEAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,KAAA,YAKAxD,KAAAsD,KAAA,WACA,mBAAArB,WAAA,GACA,GAAAiT,GAAAjT,cAEA,IAAAmD,GAAAnD,UAAA,GACAiT,EAAA1S,MAAAuC,UAAAC,MAAAzE,KAAA0B,UAAA,EAGAoB,GAAAC,KAAA/C,KAAAP,MAEAA,KAAAoF,QAEA/C,SAAA6S,GACAlV,KAAAsC,IAAAN,MAAAhC,KAAAkV,ON04CM,SAASrV,EAAQD,EAASM,GOn6ChC,GAAAS,GAAAT,EAAA,GACAyC,EAAAzC,EAAA,GAEAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,KAAA,SAKAxD,KAAAsD,KAAA,WACA,GAAArB,UAAAkD,QAAA,EACA,GAAAC,GAAAnD,UAAA,GACAkT,EAAAlT,UAAA,OAEA,IAAAkT,GAAAlT,UAAA,EAGAjC,MAAAyC,QAAAiF,SAAAuB,cAAA,SACA5F,EAAAC,KAAA/C,KAAAP,MAEAA,KAAAoF,QACApF,KAAAkE,KAAA,iBACAlE,KAAAmV,QAGA1T,OAAAC,eAAA1B,KAAA,QACA2B,IAAA,WACA,MAAA3B,MAAAkE,KAAA,UAEArC,IAAA,SAAAsT,GACAnV,KAAAkE,KAAA,QAAAiR,SP86CM,SAAStV,EAAQD,EAASM,GQ/8ChC,GAAAS,GAAAT,EAAA,GACAyC,EAAAzC,EAAA,GAEAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAEArD,KAAAwD,KAAA,WAGAxD,KAAAsD,KAAA,SAAA8B,GAGApF,KAAAyC,QAAAiF,SAAAuB,cAAA,SACA5F,EAAAC,KAAA/C,KAAAP,MAEAA,KAAAoF,QACApF,KAAAkE,KAAA,oBAGAzC,OAAAC,eAAA1B,KAAA,YAEA2B,IAAA,WACA,MAAA3B,MAAAyC,QAAAuO,SAGAnP,IAAA,SAAAmP,GACA,GAAAoE,GAAApE,KAAA,EACAqE,EAAArV,KAAAyC,QAAAuO,OACAqE,KAAAD,IAEApV,KAAAyC,QAAAuO,QAAAoE,EACApV,KAAA6E,KAAA,iBRy9CM,SAAShF,EAAQD,EAASM,GSv/ChC,GAAAS,GAAAT,EAAA,GACAyC,EAAAzC,EAAA,GAEAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,KAAA,QAEAxD,KAAAsD,KAAA,WACA,OAAArB,UAAAkD,OACA,GAAAmQ,GAAArT,UAAA,OAEA,IAAAmD,GAAAnD,UAAA,GACAqT,EAAArT,UAAA,EAGAjC,MAAAyC,QAAAiF,SAAAuB,cAAA,OACA5F,EAAAC,KAAA/C,KAAAP,KAIAA,MAAAoF,QACA/C,SAAAiT,IAAAtV,KAAAuV,IAAAD,IAKA7T,OAAAC,eAAA1B,KAAA,OACA2B,IAAA,WACA,MAAA3B,MAAAyC,QAAA8S,KACS1T,IAAA,SAAAC,GACT9B,KAAAyC,QAAA8S,IAAAzT,QTigDM,SAASjC,EAAQD,EAASM,GUjiDhC,GAAAyC,GAAAzC,EAAA,IAEAS,EAAAT,EAAA,GACAU,EAAAV,EAAA,GAEAsV,EAAAtV,EAAA,GAEAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwV,OAEAxV,KAAAwD,KAAA,OAIAxD,KAAAsD,KAAA,WACA,GAAArB,UAAA,YAAAO,OACA,GAAAiT,GAAAxT,UAAA,OACS,CACT,GAAAA,UAAA,YAAAO,OACA,GAAAiT,GAAAxT,UAAA,OACa,IAAAA,UAAA,YAAAO,OACb,GAAAiT,GAAAxT,UAAA,EAGA,qBAAAA,WAAA,GACA,GAAAyT,GAAAzT,UAAA,OACa,CACb,oBAAAA,WAAA,GACA,GAAAyT,GAAAzT,UAAA,OAEA,IAAAyT,IAAA,CAGA,oBAAAzT,WAAA,GACA,GAAAmD,GAAAnD,UAAA,IAKA,GAAAyT,EACA,GAAAC,GAAA,SACS,CACT,GAAAA,GAAA,IACA3V,MAAA4V,aAAAhV,GACAiV,cAAA,YASA,GAJA7V,KAAAyC,QAAAiF,SAAAuB,cAAA0M,GACAtS,EAAAC,KAAA/C,KAAAP,MACAA,KAAAoF,QAEA/C,SAAAoT,EACA,OAAA7O,GAAA,EAAwBA,EAAA6O,EAAAtQ,OAAmByB,IAC3C5G,KAAA8V,KAAAL,EAAA7O,KAKA5G,KAAA8V,KAAA,WACA,GAAAA,GAAAN,EAAAxT,MAAAhC,KAAAiC,UAEA,OADAjC,MAAAsC,IAAAwT,GACAA,MVyiDM,SAASjW,EAAQD,EAASM,GWj4ChC,QAAA6V,GAAAC,EAAA/C,GACA,GAAAgD,GAAAD,EAAAE,MAAAD,QACAE,EAAA1U,OAAAkJ,KAAAsL,GACA1Q,EAAA4Q,EAAA9P,QAAA2P,EAAA9R,KAAA,SACA,QAAA+O,GAAA1N,IAAA4Q,EAAAhR,OAAA,EACA,GAAAiR,GAAAH,EAAAE,EAAA,QACK,SAAAlD,GAAA,IAAA1N,EACL,GAAA6Q,GAAAH,EAAAE,IAAAhR,OAAA,QAGA,IAAAiR,GAAAH,EAAAE,EAAA5Q,EAAA0N,GAGAmD,GAAAnF,UAAA,EACAmF,EAAAvO,QAGA,QAAAwO,GAAAH,EAAAF,GACA,GAAA/E,GAAAiF,EAAAI,SACAjU,UAAA4O,MAAAxO,QAAAuO,SAAA,GACAgF,EAAAvT,QAAAuO,SAAA,EACAkF,EAAAI,UAAAN,EAGA,QAAAO,GAAAC,EAAAC,GACA,MAAAC,MAAAC,MAAAD,KAAAE,UAAAH,EAAAD,MAnQA,GAAA7T,GAAAzC,EAAA,IACA2W,EAAA3W,EAAA,IAAA2W,aAEAlW,EAAAT,EAAA,GAEA4W,EAAAP,EAAA,SAGA1W,GAAAD,QAAA+C,EAAAkU,EAAA,WAIA7W,KAAAwD,KAAA,QAMAxD,KAAAsD,KAAA,SAAA+N,GAEArR,KAAAqR,cAAA,GAAAhP,SAAAgP,EACArR,KAAAiW,WACAjW,KAAA8W,iBAIA9W,KAAAgW,OAAA,WACA,GAAA/T,UAAAkD,QAAA,EACA,GAAAC,GAAAnD,UAAA,GACAmF,EAAAnF,UAAA,OAEA,IAAAmF,GAAAnF,UAAA,EAGA,IAAAI,SAAArC,KAAAiW,QAAA7O,GACA,SAAA3D,OAAA,4EAAA2D,EAAA,KAGA,IAAA4O,GAAAe,EAAA/W,KAAAoF,EAAAgC,EAAA,cAAApH,KAAA8W,YAOA,OANA9W,MAAAiW,QAAA7O,GAAA4O,EAEAhW,KAAAqR,UAAAhP,SAAArC,KAAAsW,YACAN,EAAA/E,UAAA,GAGA+E,GAIAvU,OAAAC,eAAA1B,KAAA,YACA2B,IAAA,WACA,MAAA3B,MAAAsW,WAEAzU,IAAA,WACA,SAAA4B,OAAA,2CAIAhC,OAAAC,eAAA1B,KAAA,OAEA2B,IAAA,WACA,GAAAsP,GAAAjR,KAAAsW,SACA,OAAAjU,UAAA4O,EAAA5O,OAEA4O,EAAA/M,KAAA,UAMArC,IAAA,SAAAuF,GACA,GAAA/E,SAAA+E,EAAA,CACA,GAAA6J,GAAAjR,KAAAsW,SACAjU,UAAA4O,IACAA,YAAA,OAEa,CACb,GAAA+E,GAAAhW,KAAAiW,QAAA7O,EACA,IAAA/E,SAAA2T,EAAA,SAAAvS,OAAA,yDAAA2D,EAAA,IAEA4O,GAAA/E,UAAA,MAWAjR,KAAAsG,OAAA,WACA,GAAArE,UAAA,YAAAO,OACA,GAAA+D,GAAAtE,UAAA,OAEA,IAAAsE,GAAAtE,SAGA,QAAA2E,GAAA,EAAoBA,EAAAL,EAAApB,OAAmByB,IAAA,CACvC,GAAAC,GAAAN,EAAAK,EAEA,IAAAC,YAAAkQ,GAAA,CACA,GAAAf,GAAAnP,EACAO,EAAAP,EAAAmQ,GAEA,IAAAhX,KAAAiW,QAAA7O,KAAAP,EACA,SAAApD,OAAA,8BAAAmD,EAAA,kCAEa,CACb,GAAAoP,GAAAhW,KAAAiW,QAAApP,GACAO,EAAAP,CAEA,IAAAxE,SAAA2T,EACA,SAAAvS,OAAA,yDAAA2D,EAAA,KAIA,GAAA6P,GAAAjX,KAAAiR,QACAjR,MAAAiR,WAAA+E,IACAhW,KAAAsW,UAAAjU,QAGArC,KAAAiW,QAAA7O,GAAA8O,MAAA7T,aACArC,MAAAiW,QAAA7O,GAGA,GAAApH,KAAAqR,UAAAhP,SAAArC,KAAAiR,SACA,OAAAnP,KAAA9B,MAAAiW,QAAA,CACAjW,KAAAiW,QAAAnU,GAAAmP,UAAA,CACA,WAESgG,KAAAjX,KAAAiR,UACTjR,KAAA6E,KAAA,YAMA,IAAAkS,GAAApU,EAAAhC,EAAA,SAAA0C,GACArD,KAAAwD,KAAA,cAEAxD,KAAAsD,KAAA,SAAA4T,EAAA9R,EAAAgC,EAAA5D,GACAxD,KAAAyC,QAAAiF,SAAAuB,cAAA,SACA5F,EAAAC,KAAA/C,KAAAP,MAEAA,KAAAoF,QACApF,KAAAkW,MAAAgB,EAEAlX,KAAAkE,KAAA,gBACAlE,KAAAkE,KAAA,OAAAV,GACAxD,KAAAgX,IAAA5P,CAEA,IAAA7D,GAAAvD,IACAA,MAAA4Q,GAAA,qBAAAlM,GACAA,EAAAyS,iBAEA5T,EAAA2S,MAAA7E,SACA9N,EAAA0N,YAAA,IACA1N,EAAA0N,UAAA,GAGA1N,EAAA0N,UAAA1N,EAAA0N,WAGAjR,KAAA4Q,GAAA,iBAAAlM,GACAA,EAAAyS,mBAEAnX,KAAA4Q,GAAA,mBAAAlM,GACA,KAAAA,EAAA0S,SAAA,KAAA1S,EAAA0S,SACA1S,EAAAyS,iBACA5T,EAAA8T,eACa,KAAA3S,EAAA0S,SAAA,KAAA1S,EAAA0S,WACb1S,EAAAyS,iBACA5T,EAAA+T,qBAKA7V,OAAAC,eAAA1B,KAAA,OAEA2B,IAAA,WACA,MAAA3B,MAAAkE,KAAA,UAIArC,IAAA,SAAAuF,GACA,GAAA/E,SAAArC,KAAAkW,MAAAD,QAAA7O,GACA,SAAA3D,OAAA,4EAAA2D,EAAA,KAGA,IAAAmQ,GAAAvX,KAAAgX,GACAhX,MAAAkE,KAAA,QAAAkD,GACA/E,SAAAkV,SAAAvX,MAAAkW,MAAAD,QAAAsB,GACAvX,KAAAkW,MAAAD,QAAA7O,GAAApH,QAKAyB,OAAAC,eAAA1B,KAAA,YAEA2B,IAAA,WACA,MAAA3B,MAAAyC,QAAAuO,SAIAnP,IAAA,SAAAuF,GACA,GAAAoQ,GAAApQ,KAAA,CACA,IAAApH,KAAAiR,WAAA7J,EAAA,CAEA,GAAAoQ,EAAA,CACA,GAAAC,GAAAzX,KAAAkW,MAAAjF,QACAoF,GAAArW,KAAAkW,MAAAlW,MACAqC,SAAAoV,GACAA,EAAA5S,KAAA,cACa,CACb,GAAA7E,KAAAkW,MAAA7E,SAAA,SAAA5N,OAAA,mDACAzD,MAAAyC,QAAAuO,SAAA,EACAhR,KAAAkW,MAAAI,UAAAjU,OAEArC,KAAA6E,KAAA,UACA7E,KAAAkW,MAAArR,KAAA,cAIA7E,KAAAqX,WAAA,WACAtB,EAAA/V,KAAA,IAEAA,KAAAsX,eAAA,WACAvB,EAAA/V,KAAA,QXipDM,SAASH,EAAQD,EAASM,GYr3DhC,GAAAS,GAAAT,EAAA,GACAyC,EAAAzC,EAAA,IAEAwX,EAAAxX,EAAA,GAGAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,KAAA,SAEAxD,KAAA0X,SAEA1X,KAAAsD,KAAA,WACA,GAAArB,UAAA,YAAAR,QACA,GAAAkW,GAAA1V,UAAA,OAEA,IAAAmD,GAAAnD,UAAA,GACA0V,EAAA1V,UAAA,EAGAjC,MAAAyC,QAAAiF,SAAAuB,cAAA,UACA5F,EAAAC,KAAA/C,KAAAP,MACAA,KAAAoF,QAEApF,KAAA2X,UAEA,QAAAvQ,KAAAuQ,GACA3X,KAAA4X,OAAAxQ,EAAAuQ,EAAAvQ,KAOA3F,OAAAC,eAAA1B,KAAA,OAEA2B,IAAA,WACA,OAAAyF,KAAApH,MAAA2X,QACA,GAAA3X,KAAA2X,QAAAvQ,GAAA6J,SACA,MAAA7J,IAKAvF,IAAA,SAAAuF,GACA,GAAAwQ,GAAA5X,KAAA2X,QAAAvQ,EACA,IAAA/E,SAAAuV,EAAA,SAAAnU,OAAA,qDAAA2D,EAAA,IACAwQ,GAAA3G,UAAA,KAIAjR,KAAA4X,OAAA,WACA,OAAA3V,UAAAkD,OACA,GAAAiC,GAAAnF,UAAA,GACAkT,EAAAlT,UAAA,OACS,QAAAA,UAAAkD,OAKT,SAAA1B,OAAA,8BAJA,IAAA2B,GAAAnD,UAAA,GACAmF,EAAAnF,UAAA,GACAkT,EAAAlT,UAAA,GAKA,GAAA4V,GAAAH,EAAAtS,EAAAgC,EAAA+N,EAGA,OAFAnV,MAAAsC,IAAAuV,GAEAA,GAKA7X,KAAAsF,MAAA,SAAAC,GACA,GAAAhC,GAAAvD,KAEA8X,EAAAnX,EAAA8E,wBAAAzD,MAAAhC,KAAAiC,UAGA6V,GAAAC,QAAA,SAAAH,GACA,GAAAvV,SAAAkB,EAAAoU,QAAAC,EAAAZ,KACA,SAAAvT,OAAA,yEAAAmU,EAAAZ,IAAA,QAIA3T,EAAAiC,MAAA/E,KAAAP,KAAAuF,EAAAuS,EAGA,IAAAE,IAAA,CACAF,GAAAC,QAAA,SAAAH,GACAA,EAAA3G,WAAA+G,GAAA,GACAzU,EAAAoU,QAAAC,EAAAZ,KAAAY,EAKAA,EAAAhH,GAAA,uBACAgH,EAAA7T,OAAAiT,IAAAY,EAAAZ,QAIAgB,GACAhY,KAAA6E,KAAA,WAKA7E,KAAAsG,OAAA,WACA,GAAA/C,GAAAvD,KAEAiY,EAAAtX,EAAA6F,yBAAAxE,MAAAhC,KAAAiC,WACAsE,EAAA0R,EAAA7O,IAAA,SAAA7D,GACA,MAAAhC,GAAAhB,SAAAgD,IAGAlC,GAAAiD,OAAA/F,KAAAP,KAAAiY,EAGA,IAAAC,IAAA,CACA3R,GAAAwR,QAAA,SAAAH,GACAA,EAAA3G,WAAAiH,GAAA,SACA3U,GAAAoU,QAAAC,EAAAZ,OAGAkB,GAEAlY,KAAA6E,KAAA,WAOA7E,KAAAmY,sBAAA,SAAAhC,GACA,GAAA/O,GAAA+O,EAAA,EAEA,QAAAiC,KAAApY,MAAA2X,QACA,GAAAS,IAAAhR,EAAA,CACA,GAAAwQ,GAAA5X,KAAA2X,QAAAS,EACAR,GAAA3G,YAAA,GACA2G,EAAAS,kBAAA,QZk4DM,SAASxY,EAAQD,EAASM,Gax9DhC,QAAAoY,GAAA/U,EAAAgV,EAAAC,GACA,GAAAC,GAAAF,EAAAvW,MAAAK,OAAAmW,EAEA,OADAjV,GAAAjB,IAAAmW,GACAA,EAzDA,GAAA9V,GAAAzC,EAAA,IAEAS,EAAAT,EAAA,GACAU,EAAAV,EAAA,GAEAwY,EAAAxY,EAAA,IACAyY,EAAAzY,EAAA,IACA0Y,EAAA1Y,EAAA,GAEAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,KAAA,QAEAxD,KAAA4V,aAAAhV,GACAiY,cAAA,IAGA7Y,KAAA2Y,MACA3Y,KAAA0Y,SACA1Y,KAAA4Y,OAKA5Y,KAAAsD,KAAA,WACA,GAAArB,UAAA,YAAAO,OACA,GAAAsW,GAAA7W,UAAA,OAEA,IAAAmD,GAAAnD,UAAA,GACA6W,EAAA7W,UAAA,EAOA,IAJAjC,KAAAyC,QAAAiF,SAAAuB,cAAA,SACA5F,EAAAC,KAAA/C,KAAAP,MACAA,KAAAoF,QAEA/C,SAAAyW,EACA,OAAAlS,GAAA,EAAwBA,EAAAkS,EAAA3T,OAAoByB,IAC5C5G,KAAAyY,IAAAK,EAAAlS,KAKA5G,KAAA+Y,OAAA,WACA,MAAAT,GAAAtY,KAAA0Y,EAAAzW,YAGAjC,KAAAyY,IAAA,WACA,MAAAH,GAAAtY,KAAA2Y,EAAA1W,eb4hEM,SAASpC,EAAQD,EAASM,Gc9kEhC,GAAAS,GAAAT,EAAA,GACAyC,EAAAzC,EAAA,GAEAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,KAAA,WAEAxD,KAAAsD,KAAA,SAAA8B,GACApF,KAAAyC,QAAAiF,SAAAuB,cAAA,YACA5F,EAAAC,KAAA/C,KAAAP,MACAA,KAAAoF,SAOA3D,OAAAC,eAAA1B,KAAA,OAEA2B,IAAA,WACA,MAAA3B,MAAAyC,QAAA2E,OAIAvF,IAAA,SAAAuF,GACApH,KAAAgX,MAAA5P,IAEApH,KAAAyC,QAAA2E,QACApH,KAAA6E,KAAA,iBdwlEM,SAAShF,EAAQD,EAASM,GetnEhC,GAAAS,GAAAT,EAAA,GACAyC,EAAAzC,EAAA,IAEA6C,EAAA7C,EAAA,GAEAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,KAAA,YAEAxD,KAAAsD,KAAA,WACA,OAAArB,UAAAkD,OACA,GAAA6T,GAAA/W,UAAA,OACS,IAAAA,UAAAkD,OAAA,EACT,GAAAC,GAAAnD,UAAA,GACA+W,EAAA/W,UAAA,EAGAjC,MAAAyC,QAAAiF,SAAAuB,cAAA,SACA5F,EAAAC,KAAA/C,KAAAP,MAEAA,KAAAoF,QACApF,KAAAyC,QAAA2B,UAAA,QACArB,EAAAoE,aAAAnH,KAAAyC,QAAA,eACAuW,GACAjW,EAAAoE,aAAAnH,KAAAyC,QAAA,oBAMAhB,OAAAC,eAAA1B,KAAA,OAEA2B,IAAA,WACA,MAAA3B,MAAAyC,QAAA2E,OAIAvF,IAAA,SAAAuF,GACApH,KAAAgX,MAAA5P,IAEApH,KAAAyC,QAAA2E,QACApH,KAAA6E,KAAA,iBfioEM,SAAShF,EAAQD,EAASM,GgB5qEhC,GAAAS,GAAAT,EAAA,GACAyC,EAAAzC,EAAA,IACAU,EAAAV,EAAA,EAEAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,KAAA,OAEAxD,KAAA4V,aAAAhV,GACAqY,WAAA,QAGAjZ,KAAAsD,KAAA,WACA,OAAArB,UAAAkD,OACA,GAAAgQ,GAAAlT,UAAA,OAEA,IAAAmD,GAAAnD,UAAA,GACAkT,EAAAlT,UAAA,EAGAI,UAAA8S,MAAA,IAEA9R,EAAAC,KAAA/C,KAAAP,KAEA,IAAAuD,GAAAvD,IAEAA,MAAAoF,QACApF,KAAAmV,OAEAnV,KAAA4Q,GAAA,iBAAAsI,GACA,GAAAC,IAA6BC,QAAAF,EAAAG,WAAAC,YAAAC,QAAAhW,EAAAgW,QAC7BhW,GAAAgW,QAAAJ,EAAAC,UAIApZ,KAAA4Q,GAAA,gBAAAsI,GACA,GAAAC,IAA6BC,QAAAF,EAAAG,WAAAC,YAAAC,QAAAhW,EAAAiW,UAC7BjW,GAAAiW,UAAAL,EAAAC,WAOA3X,OAAAC,eAAA1B,KAAA,QACA2B,IAAA,WACA,MAAA3B,MAAAyC,QAAA6W,aACSzX,IAAA,SAAAC,GACT9B,KAAAyC,QAAAgX,UAAA3X,QhBsrEM,SAASjC,GiBjuEf,GAAAuO,GAAA,WAMA,QAAAsL,GAAAC,GAGA,OAFAC,GAAAD,EAAAE,UAAAF,EAAAC,UACAE,KACApU,EAAA,EAAuBA,EAAAkU,EAAAzU,OAAkBO,IAAA,CAEzC,GAAAqU,GAAAC,EAAAJ,EAAAlU,GAAAqU,aACAD,GAAAC,KACAD,EAAAC,OAEAD,EAAAC,GAAA1V,MACAsV,QACApU,MAAAG,EACA4B,MAAAsS,EAAAlU,GAAA4B,QAGA,MAAAwS,GAGA,QAAAG,GAAAN,EAAAxN,GACA,GAAAyN,GAAAD,EAAAE,UAAAF,EAAAC,UACAE,IAEA3N,KAAA+N,aACA,QAAAxU,GAAA,EAAuBA,EAAAkU,EAAAzU,OAAkBO,IAAA,CACzC,GAAAqU,GAAAH,EAAAlU,GAAAqU,cAEAA,MAAA5N,GAAA4N,GAAAI,EAAAhO,IAAA4N,GAAAK,EAAAjO,IACA2N,EAAAzV,MACAsV,QACApU,MAAAG,EACA4B,MAAAsS,EAAAlU,GAAA4B,QAIA,MAAAwS,GAGA,QAAAO,GAAAV,EAAAxN,GACA,GAAAyN,GAAAD,EAAAE,UAAAF,EAAAC,UACArU,EAAAqU,EAAAzU,OACAmV,EAAAC,EAAAZ,EAAAxN,EAAAyN,EAAArU,EAMA,OAJA+U,IACAE,EAAAb,EAAAxN,EAAA5G,IAIAoU,QACApU,QACA+B,MAAAsS,EAAArU,GAAA+B,OAIA,QAAAkT,GAAAb,EAAAxN,EAAA5G,GACAoU,EAAAc,WACAd,EAAAc,WAAAtO,EAAA,OAA6C5G,GAE7CoU,EAAAU,QAAAlO,EAAA,KAAA5G,GAKA,QAAAgV,GAAAZ,EAAAxN,EAAAyN,EAAArU,GACA,GAAAmV,GACAC,CAEA,IAAAC,EAAAC,KAAA1O,GACAuO,EAAAvO,EACAwO,EAAAG,EAAA3O,OACS,KAAA4O,EAAAF,KAAA1O,GAIT,QAHAuO,GAAAV,EAAA7N,GACAwO,EAAAxO,EAgBA,MAXA6O,KAEAR,EAAAb,EAAAe,EAAAnV,GACAqU,EAAAzU,QAAAI,IACAyV,GAAA,IAGAA,GACAR,EAAAb,EAAAgB,EAAApV,IAGA,EAGA,QAAAyU,GAAA7N,GACA,MAAAA,GAAA8O,QAAAF,EAAA,SAAApP,EAAAuP,EAAAC,EAAAC,GACA,MAAAF,GAAA,KAAAE,IAIA,QAAAN,GAAA3O,GACA,MAAAA,GAAA8O,QAAAL,EAAA,SAAAjP,EAAAuP,EAAAC,GACA,UAAAA,IAIA,QAAAE,GAAAC,GACA,GAAA3B,GAAA2B,EAAA3B,KACAA,GAAA4B,WACA5B,EAAA4B,WAAAD,EAAA/V,OACSoU,EAAA0B,YACT1B,EAAA0B,WAAAC,EAAA/V,OAIA,QAAAiW,GAAAC,EAAAlG,GACA,OAAA7L,KAAA6L,GACAA,EAAAmG,eAAAhS,KAEA+R,EAAA/R,GAAA6L,EAAA7L,GAEA,OAAA+R,GAGA,QAAAE,GAAA/B,GAEA,OADAgC,MACAlW,EAAA,EAAuBA,EAAAkU,EAAAzU,OAAkBO,IACzC8V,EAAAI,EAAAC,EAAAjC,EAAAlU,GAAA4B,OAEA,OAAAsU,GAGA,QAAAC,GAAAvU,GAEA,OADAwU,MACApW,EAAA,EAAuBA,EAAA4B,EAAAnC,OAAkBO,IACzCoW,EAAAxU,EAAA5B,IAAA4B,EAAAyU,EAAAzU,EAAA5B,IAEA,OAAAoW,GAKA,QAAA3B,GAAAhO,GAIA,IAHA,GAAA6P,GAAA,GACAC,EAAA,EAEA,OAAAtQ,MAAAuQ,EAAArB,KAAA1O,KACA,KAAAR,MAAA,IAEAqQ,GAAA7P,EAAAgQ,UAAAF,EAAAtQ,MAAApG,OACAyW,GAAA7P,EAAAgB,OAAAxB,MAAApG,MAAAoG,MAAA,GAAAxG,OAAAwG,MAAA,GAAAxG,QACA6W,GAAA7P,EAAAgB,OAAAxB,MAAApG,MAAAoG,MAAA,GAAAxG,QACA8W,EAAAtQ,MAAApG,MAAAoG,MAAA,GAAAxG,MAIA,OAFA6W,IAAA7P,EAAAgB,OAAA8O,GAMA,QAAA7B,GAAAjO,GACA,MAAAyO,GAAAC,KAAA1O,GACA2O,EAAA3O,GAEAA,EAGA,QAAAiQ,GAAAd,EAAAe,GACA,OAAA3S,KAAA2S,GAAA,CACA,GAAAjV,GAAAiV,EAAA3S,GACA4S,EAAAlV,EAAAf,QAAA,cAGAiV,GAAAhU,MAAAiV,eAAA7S,GACA4S,EAAA,EACAhB,EAAAhU,MAAAkV,YAAA9S,EAAAtC,EAAA+F,OAAA,EAAAmP,GAAA,aAEAhB,EAAAhU,MAAAkV,YAAA9S,EAAAtC,IAKA,QAAA2U,GAAAU,GACA,MAAAA,GAAAxB,QAAA,qBAAAtP,EAAA+Q,GACA,MAAAA,GAAAC,gBAIA,QAAAC,GAAAC,GACA,GAAAC,KACA,QAAApT,KAAAmT,GACAC,EAAAC,EAAArT,IAAAmT,EAAAnT,EAEA,OAAAoT,GAGA,QAAAC,GAAAN,GACA,MAAAA,GAAAxB,QAAA,oBAAAtP,EAAA+Q,GACA,UAAAA,EAAAxC,gBAvMA,GAGAc,GAHAkB,EAAA,0CACAtB,EAAA,uDACAG,EAAA,4DAyMAiC,EAAA,SAAAC,GACAjd,KAAAid,MACAjd,KAAAkd,KAAAld,KAAAid,IAAAC,MAAAld,KAAAid,IAAAE,qBAAA,WACAnd,KAAAod,OAAApd,KAAAid,IAAAI,gBAGAL,GAAAjY,WAEApD,IAAA,SAAAwK,GACA,IAAAnM,KAAAkO,aACA,QAEA,IAAA/B,EACA,MAAAwP,GAAA1B,EAAAja,KAAAkO,aAAA/B,GAEA,IAAAyN,GAAAF,EAAA1Z,KAAAkO,aACA,KAAA/B,IAAAyN,GACAA,EAAAzN,GAAAwP,EAAA/B,EAAAzN,GAEA,OAAAyN,IAGA0D,OAAA,SAAAnR,GAEA,OADAkQ,MACA3W,EAAA,EAA2BA,EAAA1F,KAAAod,OAAAjY,OAAwBO,IACnD8V,EAAAa,EAAAV,EAAA1B,EAAAja,KAAAod,OAAA1X,GAAAyG,IAEA,OAAAkQ,IAGAxa,IAAA,SAAAsK,EAAAkQ,GACArc,KAAAkO,eACAlO,KAAAkO,aAAAlO,KAAAmO,gBAEAkO,EAAAO,EAAAP,EACA,IAAAzC,GAAAK,EAAAja,KAAAkO,aAAA/B,EACAyN,GAAAzU,SACAyU,GAAAS,EAAAra,KAAAkO,aAAA/B,IAEA,QAAAzG,GAAA,EAA2BA,EAAAkU,EAAAzU,OAAkBO,IAC7C0W,EAAAxC,EAAAlU,GAAA2W,IAIA/V,OAAA,SAAA6F,GACA,GAAAnM,KAAAkO,aAAA,CAEA,IAAA/B,EAGA,MAFAnM,MAAAud,aAAAvd,KAAAkO,yBACAlO,MAAAkO,YAIA,QADA0L,GAAAK,EAAAja,KAAAkO,aAAA/B,GACAzG,EAAA,EAA2BA,EAAAkU,EAAAzU,OAAkBO,IAC7C2V,EAAAzB,EAAAlU,GAEA,OAAAkU,GAAAzU,SAEAgJ,aAAA,WACA,GAAAqP,GAAAxd,KAAAid,IAAAhU,cAAA,QAIA,OAHAuU,GAAA7H,KAAA,WACA6H,EAAAC,IAAA,aACAzd,KAAAkd,KAAApX,YAAA0X,GACAA,EAAA7D,OAEA4D,aAAA,SAAA5D,GACA,GAAAhU,GAAAgU,EAAA+D,SACA/X,GAAA2F,WAAAxE,YAAAnB,IAIA,IAAA/F,GAAA,GAAAod,GAAAtV,SAIA,OAHA9H,GAAAqO,YAAA,SAAAgP,GACA,UAAAD,GAAAC,IAEArd,IAGA,oBAAAC,MAAAD,UAAAC,EAAAD,QAAAwO,IjB8uEM,SAASvO,EAAQD,EAASM,GkB5+EhC,QAAAyd,GAAAC,EAAAC,GACA,GAAAC,GAAAF,EAAA,GACAG,EAAAH,EAAA,EAEA,QAAAlU,KAAAqU,GACAtc,OAAAia,eAAAnb,KAAAwd,EAAArU,KACAmU,GAAAC,EAAApU,YAAAjI,SAAAsc,EAAArU,YAAAjI,QACAkc,GAAAG,EAAApU,GAAAqU,EAAArU,KAAA,GAEAoU,EAAApU,GAAAqU,EAAArU,GAKA,IAAAkU,EAAAzY,OAAA,GACA,GAAA6Y,IAAAF,GAAAhZ,OAAA8Y,EAAA5Y,MAAA,GACA,OAAA2Y,GAAAK,EAAAH,GAEA,MAAAC,GAIA,QAAAG,GAAAvX,GACA,MAAAlE,OAAAuC,UAAAC,MAAAzE,KAAAmG,EAAA,GAxDA,IAMA4D,IANApK,EAAA,IAMAN,EAAA0K,MAAA,WACA,MAAAqT,GAAAM,EAAAhc,YAAA,IAKArC,GAAAse,UAAA,WACA,MAAAP,GAAAM,EAAAhc,YAAA,IAIArC,EAAAue,kBAAA,SAAAzX,EAAAC,GACA,GAAAyX,KAGA,OAFA9T,GAAA8T,EAAA1X,GACA4D,EAAA8T,EAAAzX,GACAyX,GAIAxe,EAAAwD,WAAA,SAAAib,GACA,GAAApT,KAIA,OAHAoT,GAAAtG,QAAA,SAAAjW,GACAmJ,EAAAnJ,IAAA,IAEAmJ,IlBijFM,SAASpL,EAAQD,EAASM,GmB98EhC,QAAAoe,GAAAlT,EAAA9D,GAEA8D,EAAAmT,kBADAlc,SAAAiF,GAAAjF,SAAAiF,EAAAsH,MACAtH,EAAAsH,MAAAxD,GAEA/I,OAIA,QAAAmc,GAAApT,GACA,GAAA1C,GAAA0C,EAAA1C,YACA,IAAArG,SAAAqG,GAAArG,SAAAqG,EAAAkG,MAAA,CACA,GAAAvM,SAAAqG,EAAAmG,KACA,SAAApL,OAAA,wFAEAiF,GAAAmG,KAAAzD,IAAAmT,oBAKA,QAAAE,GAAArT,EAAA9D,GACAjF,SAAAiF,GAAAjF,SAAAiF,EAAAwH,eAEA5G,EAAAkD,EAAA9D,EAAAwH,aAAA1D,EAAAtH,MAAA4a,UACAtT,EAAAtH,MAAA8M,GAAA,oBACA1I,EAAAkD,EAAA9D,EAAAwH,aAAA1D,EAAAtH,MAAA4a,aAMA,QAAAC,GAAAvT,EAAA9D,GACA,GAAAoB,GAAA0C,EAAA1C,YACArG,UAAAqG,IACA0C,EAAA3I,QAAA2B,UAAAgH,EAAA3I,QAAA2B,UAAA6W,QAAA,GAAA2D,QAAA,QAAAlW,EAAAtE,UAAA,YAEA/B,SAAAiF,IACA8D,EAAA3I,QAAA2B,UAAAkD,EAAAlD,UAAA,IAAAgH,EAAA3I,QAAA2B,UAAAya,QAIA,QAAAC,GAAAlJ,GACA,KAAAA,YAAAhV,IACA,SAAA6C,OAAA,+CACK,IACLpB,SAAAuT,EAAAhH,OAAAvM,SAAAuT,EAAA/G,MAAAxM,SAAAuT,EAAA9G,cACArN,OAAAkJ,KAAAiL,EAAAtN,mBAAAnD,OAAA,GAAA1D,OAAAkJ,KAAAiL,EAAApH,eAAArJ,OAAA,EAGA,SAAA1B,OAAA;CAjLA,GAAAqK,GAAA5N,EAAA,IAEAU,EAAAV,EAAA,GACA4C,EAAA5C,EAAA,GAEAN,GAAA+D,gBAAA,GAAAmK,EAIA,IAAA5H,GAAAtG,EAAAsG,kBAAA,SAAAhD,EAAA+E,GACA,OAAArB,GAAA,EAAgBA,EAAA1D,EAAAiC,OAAqByB,IAAA,CACrC,GAAAnG,GAAAyC,EAAA0D,EAGA,IAAAvE,SAAA5B,EAAAsH,OACA,GAAA1F,SAAA4F,EACAC,EAAAzH,EAAA4B,YACa,CACb,GAAA0c,GAAA5W,EAAAF,EAAAxH,EACA4B,UAAA0c,GACA7W,EAAAzH,EAAAse,GAMA,GAAAC,EACA3c,UAAA5B,EAAAsH,OACAiX,EAAAve,EAAAsH,OAAApG,IAAAlB,GACS4B,SAAA4F,IACT+W,EAAA7W,EAAAF,EAAAxH,GACA4B,SAAA2c,IACAA,IAAArd,IAAAlB,KAMAA,EAAAwF,iBAFA5D,SAAA2c,EACA3c,SAAA4F,EACAI,EAAAJ,EAAA+W,EAAA1W,mBAEA0W,EAAA1W,kBAGAL,EAGA/B,EAAAzF,EAAA8B,SAAA9B,EAAAwF,oBAMAkC,EAAAvI,EAAAuI,qBAAA,SAAAF,EAAAgX,GAEA,IADA,GAAArb,GAAAqb,EAAArb,YACAvB,SAAAuB,GAAA,CACA,GAAA0D,GAAAW,EAAArE,EAAAJ,KACA,IAAAnB,SAAAiF,EACA,MAAAA,EAEA1D,KAAAG,SAOAsE,EAAAzI,EAAAyI,oBAAA,SAAA6W,EAAAC,GACA,GAAAC,GAAAxe,EAAA+T,eAAAhT,KAAAud,EAAAC,GAMA,OALA9c,UAAA+c,IACAA,EAAAtc,EAAAqb,kBAAAe,EAAAC,GACAve,EAAA+T,eAAA9S,KAAAqd,EAAAC,GAAAC,IAGAA,GAIAlX,EAAAtI,EAAAsI,gBAAA,SAAAkD,EAAA9D,GACA,GAAAA,IAAA8D,EAAA1C,aAAA,CAEA,GAAArG,SAAAiF,EACA,GAAAc,GAAAd,EAAA3F,IAAAyJ,OAEA,IAAAhD,GAAAd,CAEAqX,GAAAvT,EAAAhD,GACAoW,EAAApT,GACAA,EAAA1C,aAAAN,EACAkW,EAAAlT,EAAAhD,GACAqW,EAAArT,EAAAhD,IAIAxI,GAAAiE,wBAAA,SAAAN,GACAlB,SAAAkB,EAAAqS,cACAkJ,EAAAvb,EAAAqS,aAMA,KAFA,GAAAyJ,MACAC,EAAA/b,EAAAK,YACAvB,SAAAid,GACAjd,SAAAid,EAAA1J,cACAyJ,EAAAhb,KAAAib,EAAA1J,cAEA0J,IAAAvb,MAIA,IAAAwb,KASA,IARAF,EAAAzU,UAAAmN,QAAA,SAAAzQ,GACA,OAAAyD,KAAAzD,GAAAmF,iBAAA,CACA3J,EAAAwH,MAAAiV,EAAAjY,EAAAmF,iBAAA1B,GACA,UAKAtJ,OAAAkJ,KAAA4U,GAAApa,OAAA,EACA,GAAAzB,GAAA9C,EAAA2e,GAAwDC,WAAA,QAExD,IAAA9b,IAAA,CAGA,OADA9D,GAAA+D,gBAAA9B,IAAA0B,EAAAK,YAAAF,GACAA,InB8oFM,SAAS7D,EAAQD,EAASM,GoB3oFhC,QAAAuf,GAAAlc,EAAAmc,EAAAhb,GACAib,EAAApc,EAAAmc,GAAAhb,MACAib,EAAApc,EAAAqc,EAAAF,IAAAhb,GAMA,QAAAib,GAAAE,EAAAnb,GACA,GAAArC,SAAAwd,EACA,OAAAjZ,GAAA,EAAoBA,EAAAiZ,EAAA1a,OAAsByB,IAC1CiZ,EAAAjZ,GAAAlC,GAKA,QAAAob,GAAAvc,EAAAmc,EAAAhb,EAAAmE,GAOA,GANAnE,YAAAiK,YAEA9F,EAAAnE,EACAA,EAAArC,QAGAA,SAAAqC,GAAArC,SAAAwG,EAAA,CACA,GAAAgX,GAAAtc,EAAAmc,GAAAhb,EACArC,UAAAwd,IACAA,EAAAtc,EAAAmc,GAAAhb,OAGAmb,EAAAxb,KAAAwE,OAEAtF,GAAAqc,EAAAF,IAAArb,KAAAwE,GAIA,QAAAkX,GAAAxc,EAAAmc,EAAAhb,EAAAmE,GAOA,GANAnE,YAAAiK,YAEA9F,EAAAnE,EACAA,EAAArC,QAGAA,SAAAqC,GAAArC,SAAAwG,EACAmX,EAAAzc,EAAAmc,GAAAhb,GAAAmE,OACK,IAAAxG,SAAAqC,QACLnB,GAAAmc,GAAAhb,OACK,IAAArC,SAAAwG,EAAA,CACL,GAAAoX,GAAAL,EAAAF,EACAM,GAAAzc,EAAA0c,GAAApX,OACK,CACL,GAAAoX,GAAAL,EAAAF,EACAnc,GAAAmc,MACAnc,EAAA0c,OAIA,QAAAL,GAAAF,GACA,uBAAAA,EACA,kBACA,kBAAAA,EACA,mBADA,OAIA,QAAAM,GAAAE,EAAArX,GACA,GAAAtD,GAAA2a,EAAA7Z,QAAAwC,EACAqX,GAAAta,OAAAL,EAAA,GAlMA,GAAAsR,GAAA3W,EAAA,IAAA2W,aACAlU,EAAAzC,EAAA,IACA4C,EAAA5C,EAAA,GAEAL,GAAAD,QAAA+C,EAAAkU,EAAA,SAAAxT,GAEArD,KAAAsD,KAAA,WACAD,EAAArB,MAAAhC,KAAAiC,WAEAjC,KAAAwE,gBACAxE,KAAAmgB,iBACAngB,KAAAogB,mBACApgB,KAAAqgB,qBASArgB,KAAAyE,KAAA,SAAAC,EAAAmE,GACA,GAAAnE,YAAAiK,UAAA,CACA9F,EAAAnE,CACA,QAAA4b,KAAAtgB,MAAAugB,QACAvgB,KAAAwgB,UAAAF,GAAAnb,OAAA,GACA0D,EAAAyX,OAGStgB,MAAAwgB,UAAA9b,GAAAS,OAAA,GACT0D,EAAAnE,EAGAob,GAAA9f,KAAA,eAAA0E,EAAAmE,IAQA7I,KAAAygB,WAAA,SAAA/b,EAAAmE,GACAkX,EAAA/f,KAAA,eAAA0E,EAAAmE,IAQA7I,KAAAiF,MAAA,SAAAP,EAAAmE,GACAiX,EAAA9f,KAAA,gBAAA0E,EAAAmE,IAQA7I,KAAA0gB,YAAA,SAAAhc,EAAAmE,GACAkX,EAAA/f,KAAA,gBAAA0E,EAAAmE,IAOA7I,KAAA2gB,MAAA,SAAAC,EAAAjJ,GAEA,GADAtV,SAAAsV,UACAtV,SAAAsV,EAAAkJ,OACA,GAAAA,GAAA/d,EAAAM,WAAAuU,EAAAkJ,QACAC,EAAA,SAAApc,GAA2C,QAAAA,IAAAmc,SAClC,IAAAxe,SAAAsV,EAAAoJ,KACT,GAAAA,GAAAje,EAAAM,WAAAuU,EAAAoJ,MACAD,EAAA,SAAApc,GAA2C,MAAAA,KAAAqc,QAE3C,IAAAD,GAAA,WAAsC,SAGtC,IAAAE,GAAAzd,EAAAvD,IACAA,MAAAyE,KAAA,SAAAC,GACAoc,EAAApc,IACAkc,EAAAhQ,GAAAlM,EAAAsc,EAAA,WACAzd,EAAAsB,KAAA7C,MAAAuB,GAAAmB,GAAAI,OAAAtC,MAAAuC,UAAAC,MAAAzE,KAAA0B,iBAIAjC,KAAAiF,MAAA,SAAAP,GACAoc,EAAApc,IACAkc,EAAA7P,IAAArM,EAAAsc,MAIAhhB,KAAA4Q,GAAA5Q,KAAAihB,YAAA,SAAAvc,GACA,GAAAwc,GAAA,IAAAlhB,KAAAwgB,UAAA9b,GAAAS,MACA9B,GAAA0B,UAAA6L,GAAA5O,MAAAhC,KAAAiC,WACAif,GAAAzB,EAAAzf,KAAA,eAAA0E,IAGA1E,KAAA+Q,IAAA/Q,KAAAoR,eAAA,SAAA1M,GACA,GAAAyc,GAAA,IAAAnhB,KAAAwgB,UAAA9b,GAAAS,MACA9B,GAAA0B,UAAAqM,eAAApP,MAAAhC,KAAAiC,WACAkf,GAAA1B,EAAAzf,KAAA,gBAAA0E,IAEA1E,KAAAohB,mBAAA,SAAA1c,GACA,GAAA2c,KACA,IAAAhf,SAAAqC,EACA1E,KAAAwgB,UAAA9b,GAAAS,OAAA,GACAkc,EAAAhd,KAAAK,OAGA,QAAAA,KAAA1E,MAAAugB,QACAvgB,KAAAwgB,UAAA9b,GAAAS,OAAA,GACAkc,EAAAhd,KAAAK,EAKArB,GAAA0B,UAAAqc,mBAAApf,MAAAhC,KAAAiC,UAEA,QAAA2E,GAAA,EAAoBA,EAAAya,EAAAlc,OAAgCyB,IACpD6Y,EAAAzf,KAAA,gBAAAqhB,EAAAza,QpB41FM,SAAS/G,EAAQD,GqBxzFvB,QAAA0hB,GAAAC,EAAA1Y,GAGA,IAFA,GAAAlD,GAAA6b,GAAAD,GAEA5b,EAAA6b,EAAAC,OACA,MAAA9b,EAAA+b,UACA,GAAA7Y,EAAAlD,MAAA,EACA,UAGA,KADA,GAAAD,GAAAC,EAAAoB,WAAA5B,OACAO,KACA8b,EAAAnd,KAAAsB,EAAAoB,WAAArB,IAMA,QAAAic,GAAAhc,EAAAic,GAGA,OAFAC,GAAA,EACAC,GAAA,EACAlb,EAAA,EAAgBgb,EAAAhb,EAAAib,GAAAjb,EAAAjB,EAAAR,OAAqDyB,IACrE,yBAAAP,QAAAV,EAAA2T,YAAA1S,IACAkb,EACAD,IAEAC,GAAA,EAEAA,GAAA,CAIA,OAAAD,GAzLA,GAAAlc,GAAA9F,EAAAD,QAAA+F,KAAA,SAAAgQ,EAAAvR,EAAAuT,GACA,GAAAoK,GAAAra,SAAAuB,cAAA0M,EAEA,IAAAtT,SAAAsV,EAAA,CACA,GAAAtV,SAAAsV,EAAAzT,KACA,OAAA8C,KAAA2Q,GAAAzT,KACA8d,gBAAAD,EAAA/a,EAAA2Q,EAAAzT,KAAA8C,GAGA3E,UAAAsV,EAAA2B,cACAyI,EAAAzI,YAAA3B,EAAA2B,aAOA,MAHAjX,UAAA+B,IACA2d,EAAA3d,aAEA2d,EAIAliB,GAAAD,QAAAoE,IAAA,SAAAI,EAAAuT,GACA,MAAAhS,GAAA,MAAAvB,EAAAuT,GAIA9X,GAAAD,QAAAuH,aAAA,WACA,OAAAlF,UAAAkD,OACA,GAAA1C,GAAAzC,KAAAyC,QACAkT,EAAA1T,UAAA,GACAmF,EAAAnF,UAAA,OACK,QAAAA,UAAAkD,OAKL,SAAA1B,OAAA,gEAJA,IAAAhB,GAAAR,UAAA,GACA0T,EAAA1T,UAAA,GACAmF,EAAAnF,UAAA,GAIA,GAAAiC,GAAAwD,SAAAsa,gBAAArM,EACAzR,GAAAkD,QACA3E,EAAAwf,iBAAA/d,GAOAtE,GAAA6I,kBAAA,SAAAyZ,EAAArR,EAAAC,GAEA,aAAAoR,EAAAC,UAAA,aAAAD,EAAAC,SACAD,EAAAzZ,kBAAAoI,EAAAC,OACK,CACL,GAAAsR,GAAA,EAAAC,EAAA3a,SAAA4a,aACAD,GAAAE,SAAAL,EAAA,GACAG,EAAAG,UAAA,EACA,IAAAC,IAAA,CAEAnB,GAAAY,EAAA,SAAAvc,GACA,GAAAkc,GAAAF,EAAAhc,IAAAR,QACAud,EAAAN,EAAAzc,EAAAR,OAAA0c,CAEA,KAAAY,GAAA5R,GAAAuR,GAAAM,GAAA7R,EAAA,CACA,GAAA8R,GAAA9R,EAAAuR,EACAQ,EAAAjB,EAAAhc,EAAAgd,EACAN,GAAAE,SAAA5c,EAAAgd,EAAAC,GACAH,GAAA,EAGA,GAAAA,GAAA3R,GAAAsR,GAAAM,GAAA5R,EAAA,CACA,GAAA6R,GAAA7R,EAAAsR,EACAS,EAAAlB,EAAAhc,EAAAgd,EAEA,OADAN,GAAAS,OAAAnd,EAAAgd,EAAAE,IACA,EAGAT,EAAAM,GAGA,IAAAK,GAAAC,OAAAC,cACAF,GAAAG,kBACAH,EAAAI,SAAAd,KAOAziB,EAAA2I,kBAAA,SAAAgZ,GAKA,OAHA/Y,GAAAwa,OAAAC,eACAG,EAAA,UAAA7B,EAAAY,UAAA,aAAAZ,EAAAY,SAEAvb,EAAA,EAAgBA,EAAA4B,EAAA6a,WAAwBzc,IAAA,CACxC,GAAAyb,GAAA7Z,EAAA8a,WAAA,EACA,KAAAF,EAIS,CACT,GAAAG,GAAAhC,EAAAiC,SAAAnB,EAAAoB,eACA,IAAAF,EACA,GAAAG,GAAAnC,EACAoC,GAAA,MAEA,IAAAD,GAAArB,EAAAuB,wBACAD,GAAA,EACAE,GAAA,CAGA,IAAAhT,GAAAC,EAAAgT,EAAA,CA0BA,OAzBAxC,GAAAoC,EAAA,SAAAK,GACA,GAAAJ,GASiB,IAAAJ,IAAAhC,EAAAiC,SAAAO,GACjB,aAVA,CAKA,GAJAA,IAAA1B,EAAAoB,iBACAI,GAAA,IAGAtC,EAAAiC,SAAAO,KAAAF,EACA,MACAA,KACAF,GAAA,GAQA,MAHAI,KAAA1B,EAAAoB,iBACA5S,EAAAiT,EAAAzB,EAAA2B,YAAArC,EAAAoC,EAAA1B,EAAA2B,cAEAD,IAAA1B,EAAA4B,cACAnT,EAAAgT,EAAAzB,EAAA6B,UAAAvC,EAAAoC,EAAA1B,EAAA6B,YACA,QAGAJ,GAAAC,EAAA5e,OAAAwc,EAAAoC,IAAA5e,WAGA9C,SAAAwO,GAAA8S,GAGAthB,SAAAwO,IACAA,EAAA,GAEAxO,SAAAyO,IACAA,EAAAgT,IAGAjT,EAAAC,IATAzO,OAzCA,GAAAggB,EAAA2B,cAAA3B,EAAA6B,WAAA7B,EAAAoB,eAAAlhB,SAAA8f,EAAA2B,eAAAzC,EACA,OAAAA,EAAA4C,eAAA5C,EAAA6C,iBrBqjGM,SAASvkB,EAAQD,EAASM,GsBvpGhC,GAAAS,GAAAT,EAAA,GACAyC,EAAAzC,EAAA,IACAU,EAAAV,EAAA,EAEAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,KAAA,WAEAxD,KAAA4V,aAAAhV,GACA2G,QAAA,cAKAvH,KAAAsD,KAAA,WACA,GAAArB,UAAAkD,QAAA,EACA,GAAAkf,GAAApiB,UAAA,OAEA,IAAAmD,GAAAnD,UAAA,GACAoiB,EAAApiB,UAAA,EAGAjC,MAAAyC,QAAAiF,SAAAuB,cAAA,MACA5F,EAAAC,KAAA/C,KAAAP,MACAA,KAAAoF,QAEAif,YAAA1jB,GACAX,KAAAsC,IAAA+hB,GACGhiB,SAAAgiB,IACHrkB,KAAAyC,QAAA6W,YAAA+K,OtBiqGM,SAASxkB,EAAQD,EAASM,GuB9rGhC,GAAAS,GAAAT,EAAA,GACAU,EAAAV,EAAA,GACAyC,EAAAzC,EAAA,GAIAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,KAAA,SAEAxD,KAAA4V,aAAAhV,GACA2G,QAAA,UAMAvH,KAAAsD,KAAA,SAAA8B,EAAAgC,EAAA+N,GACAnV,KAAAyC,QAAAiF,SAAAuB,cAAA,UACA5F,EAAAC,KAAA/C,KAAAP,MAEAA,KAAAoF,QAEApF,KAAAmV,OACAnV,KAAAgX,IAAA5P,GAGA3F,OAAAC,eAAA1B,KAAA,OAEA2B,IAAA,WACA,MAAA3B,MAAAkE,KAAA,UAIArC,IAAA,SAAAuF,GACA,GAAA/E,SAAArC,KAAA+D,OAAA,CACA,GAAA1B,SAAArC,KAAA+D,OAAA4T,QAAAvQ,GACA,SAAA3D,OAAA,wFAAA2D,EAAA,KAGA,QAAApH,KAAAgX,WACAhX,MAAA+D,OAAA4T,QAAA3X,KAAAgX,KAGAhX,KAAA+D,OAAA4T,QAAAvQ,GAAApH,KAGAA,KAAAkE,KAAA,QAAAkD,MAMA3F,OAAAC,eAAA1B,KAAA,YAEA2B,IAAA,WACA,MAAA3B,MAAAyC,QAAAwO,UAIApP,IAAA,SAAAuF,GACA,GAAAoQ,GAAApQ,KAAA,CACA,OAAApH,MAAAiR,WAAAuG,GAAA,GAEAnV,SAAArC,KAAA+D,QACA/D,KAAA+D,OAAAoU,uBAAAnY,KAAAgX,MAEAhX,KAAAqY,iBAAAb,QAEAnV,SAAArC,KAAA+D,QACA/D,KAAA+D,OAAAc,KAAA,eAIApD,OAAAC,eAAA1B,KAAA,QACA2B,IAAA,WACA,MAAA3B,MAAAyC,QAAA6W,aAGAzX,IAAA,SAAAsT,GACAnV,KAAAyC,QAAAgX,UAAAtE,KAQAnV,KAAAqY,iBAAA,SAAAb,GACAxX,KAAAiR,WAAAuG,IAEAxX,KAAAyC,QAAAwO,SAAAuG,EACAxX,KAAA6E,KAAA,evBwsGM,SAAShF,EAAQD,EAASM,GwBtyGhC,GAAAokB,GAAApkB,EAAA,GAEAL,GAAAD,QAAA0kB,EAAA,qBxB8yGM,SAASzkB,EAAQD,EAASM,GyBlzGhC,GAAAokB,GAAApkB,EAAA,GAEAL,GAAAD,QAAA0kB,EAAA,kBzByzGM,SAASzkB,EAAQD,EAASM,G0B3zGhC,GAAAS,GAAAT,EAAA,GACAyC,EAAAzC,EAAA,GAEAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,KAAA,YAKAxD,KAAAsD,KAAA,WACA,GAAArB,UAAAkD,QAAA,EACA,GAAAkf,GAAApiB,UAAA,OAEA,IAAAmD,GAAAnD,UAAA,GACAoiB,EAAApiB,UAAA,EAGAjC,MAAAyC,QAAAiF,SAAAuB,cAAA,MACA5F,EAAAC,KAAA/C,KAAAP,MACAA,KAAAoF,QAEAif,YAAA1jB,GACAX,KAAAsC,IAAA+hB,GACGhiB,SAAAgiB,IACHrkB,KAAAyC,QAAA6W,YAAA+K,IAIArkB,KAAAukB,QAAA,SAAAC,GACAxkB,KAAAkE,KAAA,UAAAsgB,O1Bo0GM,SAAS3kB,G2B/0Gf,QAAAgX,KACA7W,KAAAugB,QAAAvgB,KAAAugB,YACAvgB,KAAAykB,cAAAzkB,KAAAykB,eAAApiB,OAuQA,QAAAqiB,GAAAC,GACA,wBAAAA,GAGA,QAAAC,GAAAD,GACA,sBAAAA,GAGA,QAAAE,GAAAF,GACA,sBAAAA,IAAA,OAAAA,EAGA,QAAAG,GAAAH,GACA,gBAAAA,EAlRA9kB,EAAAD,QAAAiX,EAGAA,iBAEAA,EAAA9R,UAAAwb,QAAAle,OACAwU,EAAA9R,UAAA0f,cAAApiB,OAIAwU,EAAAkO,oBAAA,GAIAlO,EAAA9R,UAAAigB,gBAAA,SAAApe,GACA,IAAAge,EAAAhe,IAAA,EAAAA,GAAAqe,MAAAre,GACA,KAAAse,WAAA,8BAEA,OADAllB,MAAAykB,cAAA7d,EACA5G,MAGA6W,EAAA9R,UAAAF,KAAA,SAAA8Q,GACA,GAAAwP,GAAAnE,EAAAoE,EAAA5M,EAAA9S,EAAA8a,CAMA,IAJAxgB,KAAAugB,UACAvgB,KAAAugB,YAGA,UAAA5K,KACA3V,KAAAugB,QAAA8E,OACAR,EAAA7kB,KAAAugB,QAAA8E,SAAArlB,KAAAugB,QAAA8E,MAAAlgB,QAAA,CAEA,GADAggB,EAAAljB,UAAA,GACAkjB,YAAA1hB,OACA,KAAA0hB,EAEA,MAAAD,WAAA,wCAMA,GAFAlE,EAAAhhB,KAAAugB,QAAA5K,GAEAmP,EAAA9D,GACA,QAEA,IAAA0D,EAAA1D,GACA,OAAA/e,UAAAkD,QAEA,OACA6b,EAAAzgB,KAAAP,KACA,MACA,QACAghB,EAAAzgB,KAAAP,KAAAiC,UAAA,GACA,MACA,QACA+e,EAAAzgB,KAAAP,KAAAiC,UAAA,GAAAA,UAAA,GACA,MAEA,SAGA,IAFAmjB,EAAAnjB,UAAAkD,OACAqT,EAAA,GAAAhW,OAAA4iB,EAAA,GACA1f,EAAA,EAAmB0f,EAAA1f,EAASA,IAC5B8S,EAAA9S,EAAA,GAAAzD,UAAAyD,EACAsb,GAAAhf,MAAAhC,KAAAwY,OAEG,IAAAqM,EAAA7D,GAAA,CAGH,IAFAoE,EAAAnjB,UAAAkD,OACAqT,EAAA,GAAAhW,OAAA4iB,EAAA,GACA1f,EAAA,EAAe0f,EAAA1f,EAASA,IACxB8S,EAAA9S,EAAA,GAAAzD,UAAAyD,EAIA,KAFA8a,EAAAQ,EAAAhc,QACAogB,EAAA5E,EAAArb,OACAO,EAAA,EAAe0f,EAAA1f,EAASA,IACxB8a,EAAA9a,GAAA1D,MAAAhC,KAAAwY,GAGA,UAGA3B,EAAA9R,UAAAkc,YAAA,SAAAtL,EAAAxE,GACA,GAAA3Q,EAEA,KAAAkkB,EAAAvT,GACA,KAAA+T,WAAA,8BAuBA,IArBAllB,KAAAugB,UACAvgB,KAAAugB,YAIAvgB,KAAAugB,QAAA+E,aACAtlB,KAAA6E,KAAA,cAAA8Q,EACA+O,EAAAvT,YACAA,cAEAnR,KAAAugB,QAAA5K,GAGAkP,EAAA7kB,KAAAugB,QAAA5K,IAEA3V,KAAAugB,QAAA5K,GAAAtR,KAAA8M,GAGAnR,KAAAugB,QAAA5K,IAAA3V,KAAAugB,QAAA5K,GAAAxE,GANAnR,KAAAugB,QAAA5K,GAAAxE,EASA0T,EAAA7kB,KAAAugB,QAAA5K,MAAA3V,KAAAugB,QAAA5K,GAAA4P,OAAA,CACA,GAAA/kB,EAIAA,GAHAskB,EAAA9kB,KAAAykB,eAGA5N,EAAAkO,oBAFA/kB,KAAAykB,cAKAjkB,KAAA,GAAAR,KAAAugB,QAAA5K,GAAAxQ,OAAA3E,IACAR,KAAAugB,QAAA5K,GAAA4P,QAAA,EACAC,QAAAH,MAAA,mIAGArlB,KAAAugB,QAAA5K,GAAAxQ,QACA,kBAAAqgB,SAAAC,OAEAD,QAAAC,SAKA,MAAAzlB,OAGA6W,EAAA9R,UAAA6L,GAAAiG,EAAA9R,UAAAkc,YAEApK,EAAA9R,UAAA2gB,KAAA,SAAA/P,EAAAxE,GAMA,QAAAwU,KACA3lB,KAAAoR,eAAAuE,EAAAgQ,GAEAC,IACAA,GAAA,EACAzU,EAAAnP,MAAAhC,KAAAiC,YAVA,IAAAyiB,EAAAvT,GACA,KAAA+T,WAAA,8BAEA,IAAAU,IAAA,CAcA,OAHAD,GAAAxU,WACAnR,KAAA4Q,GAAA+E,EAAAgQ,GAEA3lB,MAIA6W,EAAA9R,UAAAqM,eAAA,SAAAuE,EAAAxE,GACA,GAAA+O,GAAAxM,EAAAvO,EAAAO,CAEA,KAAAgf,EAAAvT,GACA,KAAA+T,WAAA,8BAEA,KAAAllB,KAAAugB,UAAAvgB,KAAAugB,QAAA5K,GACA,MAAA3V,KAMA,IAJAkgB,EAAAlgB,KAAAugB,QAAA5K,GACAxQ,EAAA+a,EAAA/a,OACAuO,EAAA,GAEAwM,IAAA/O,GACAuT,EAAAxE,EAAA/O,WAAA+O,EAAA/O,mBACAnR,MAAAugB,QAAA5K,GACA3V,KAAAugB,QAAAnP,gBACApR,KAAA6E,KAAA,iBAAA8Q,EAAAxE,OAEG,IAAA0T,EAAA3E,GAAA,CACH,IAAAxa,EAAAP,EAAoBO,IAAA,GACpB,GAAAwa,EAAAxa,KAAAyL,GACA+O,EAAAxa,GAAAyL,UAAA+O,EAAAxa,GAAAyL,aAAA,CACAuC,EAAAhO,CACA,OAIA,KAAAgO,EACA,MAAA1T,KAEA,KAAAkgB,EAAA/a,QACA+a,EAAA/a,OAAA,QACAnF,MAAAugB,QAAA5K,IAEAuK,EAAAta,OAAA8N,EAAA,GAGA1T,KAAAugB,QAAAnP,gBACApR,KAAA6E,KAAA,iBAAA8Q,EAAAxE,GAGA,MAAAnR,OAGA6W,EAAA9R,UAAAqc,mBAAA,SAAAzL,GACA,GAAAjM,GAAA8W,CAEA,KAAAxgB,KAAAugB,QACA,MAAAvgB,KAGA,KAAAA,KAAAugB,QAAAnP,eAKA,MAJA,KAAAnP,UAAAkD,OACAnF,KAAAugB,WACAvgB,KAAAugB,QAAA5K,UACA3V,MAAAugB,QAAA5K,GACA3V,IAIA,QAAAiC,UAAAkD,OAAA,CACA,IAAAuE,IAAA1J,MAAAugB,QACA,mBAAA7W,GACA1J,KAAAohB,mBAAA1X,EAIA,OAFA1J,MAAAohB,mBAAA,kBACAphB,KAAAugB,WACAvgB,KAKA,GAFAwgB,EAAAxgB,KAAAugB,QAAA5K,GAEA+O,EAAAlE,GACAxgB,KAAAoR,eAAAuE,EAAA6K,OAGA,MAAAA,EAAArb,QACAnF,KAAAoR,eAAAuE,EAAA6K,IAAArb,OAAA,GAIA,cAFAnF,MAAAugB,QAAA5K,GAEA3V,MAGA6W,EAAA9R,UAAAyb,UAAA,SAAA7K,GACA,GAAAkQ,EAOA,OAHAA,GAHA7lB,KAAAugB,SAAAvgB,KAAAugB,QAAA5K,GAEA+O,EAAA1kB,KAAAugB,QAAA5K,KACA3V,KAAAugB,QAAA5K,IAEA3V,KAAAugB,QAAA5K,GAAA3Q,YAIA6R,EAAAiP,cAAA,SAAAlF,EAAAjL,GACA,GAAAkQ,EAOA,OAHAA,GAHAjF,EAAAL,SAAAK,EAAAL,QAAA5K,GAEA+O,EAAA9D,EAAAL,QAAA5K,IACA,EAEAiL,EAAAL,QAAA5K,GAAAxQ,OAJA,I3Bi4GM,SAAStF,G4BvpHf,YAMA,SAAA8C,KACA,GAAA6V,GAAAvW,SAEA,OAAAuW,EAAArT,OACA,GAAApB,IAAsBT,KAAAyiB,GACtBC,EAAAxN,EAAA,OAGA,IAAAzU,GAAAyU,EAAA,GACAwN,EAAAxN,EAAA,EAIA,IAAAyN,KACA,OAAAxiB,MAAAyiB,UAAAC,WAAAC,eAAAC,YAAAnB,UAAAoB,UAAAjgB,QAAAtC,KACAA,EAAAwiB,EAAAxiB,EAAAkiB,GAIA,IAAAO,GAAA,oBAEAR,GAAAS,GADAD,EACAziB,EAAA0iB,GAEA1iB,CAIA,IAAAgB,GAAA,GAAAihB,GAAAjiB,EACAkiB,GAAAziB,KAAAuB,EAAAvB,MAGAuB,EAAAzB,IAAAkjB,IACAzhB,EAAAzB,GAAA,WACAS,EAAA/B,MAAAhC,KAAAiC,YAKA,IAAAykB,GAAA,YACAA,GAAAD,GAAA1hB,CAEA,IAAA4hB,GAAA5hB,EAAAvB,KAAAuB,EAAAvB,KAAA,EACA,IAAAuB,EAAAzB,KAAAjB,GAAA0C,EAAAzB,KAAAyiB,EACA,GAAAa,GAAA,GAAAjY,UAAA,IACA,mBAAAgY,EAAA,sBAGAD,OAGA,IAAAE,GAAA,GAAAjY,UAAA,gBACA,mBAAAgY,EAAA,8GASAD,EAAA3hB,EAAAzB,GAAAX,EAAAkkB,GAGA9hB,GAAAnB,YAAAgjB,CAGA,QAAAhgB,KAAA7B,GACA+hB,EAAAF,EAAA7hB,EAAA6B,EAIA,QAAAA,KAAA7C,GACAgjB,EAAAxmB,KAAAwD,EAAA6C,IAAAggB,EAAAhgB,KAAAvE,GACAykB,EAAAF,EAAA7iB,EAAA6C,EAOA,OAHAggB,GAAA7iB,SACA6iB,EAAAH,GAAA1hB,EAEA6hB,EAOA,QAAAL,GAAAS,EAAAf,GACA,QAAAgB,KACA,GAAAC,GAAA,GAAAF,GAAA/kB,UAAA,GAcA,OAbAilB,GAAA1jB,KAAAyiB,EAAAziB,KAEAxD,KAAAmnB,QAAAD,EAAAC,QACA1lB,OAAAC,eACAD,OAAAC,eAAA1B,KAAA,SACA2B,IAAA,WACA,MAAAulB,GAAAE,SAIApnB,KAAAonB,MAAAF,EAAAE,MAGApnB,KAGA,GAAAqnB,GAAA,YAIA,OAHAA,GAAAtiB,UAAAiiB,EAAAjiB,UACAkiB,EAAAliB,UAAA,GAAAsiB,GAEAJ,EAGA,QAAAH,GAAAQ,EAAAviB,EAAAwiB,GACA,IACA,GAAAhY,GAAA9N,OAAA+lB,yBAAAziB,EAAAwiB,EACAhY,GAAA5N,MAAAU,GAAAkN,EAAA5N,MAAAU,GAAAZ,OAAAC,iBAAAW,EACAZ,OAAAC,eAAA4lB,EAAAC,EAAAhY,GAEA+X,EAAAC,GAAAxiB,EAAAwiB,GAEK,MAAAE,KA5HL,GAEAplB,GAFA0jB,EAAA,aAEAU,EAAA,YAAAI,EAAA,YAAAvjB,EAAA,OAAAyjB,KAAkGrL,cAoFlG/Y,GAAAkkB,MAEAhnB,EAAAD,QAAA+C,G5BosHM,SAAS9C,EAAQD,G6B/xHvB,GAAA8nB,GAAAC,EAAAC,GAOA,SAAAjoB,GAGAgoB,KAAAD,EAAA,EAAAE,EAAA,kBAAAF,KAAA1lB,MAAApC,EAAA+nB,GAAAD,IAAArlB,SAAAulB,IAAA/nB,EAAAD,QAAAgoB,KAUC,WAED,QAAA9Z,GAAA+Z,GAEA,OADA7nB,KAAA8nB,QACA7lB,UAAAkD,QACA,YACA,QAAAnF,KAAA+nB,KAAAF,EAA4B,MAC5B,SAAAG,EAAAhoB,KAAAiC,YA0IA,QAAA+lB,GAAA5e,EAAAoP,GACA,OAAA9S,GAAA,EAAiBA,EAAA8S,EAAArT,OAAiBO,GAAA,EAClC0D,EAAAvH,IAAA2W,EAAA9S,GAAA8S,EAAA9S,EAAA,IAIA,QAAAuiB,GAAAC,GACA,kBAEA,MADAA,GAAAlmB,MAAAhC,KAAAiC,WACAjC,MAIA,QAAAmoB,GAAAC,EAAAC,GAEA5mB,OAAAC,gBACAD,OAAAC,eAAA0mB,EAAAC,GAAqCC,YAAA,IAtJrC,GAAA3lB,GAAAmL,EAAA/I,WACAnB,YAAAkK,EAEAnM,IAAA,SAAA+H,GACA,GAAAwP,GAAAlZ,KAAAuoB,MAAAvoB,KAAAwoB,KAAA9e,GACA,OAAAwP,MAAA,IAGArX,IAAA,SAAA6H,EAAAtC,GAEApH,KAAAuoB,MAAAvoB,KAAAwoB,KAAA9e,OAAAtC,IAGA4gB,MAAA,WACAA,EAAAhoB,KAAAiC,YAGA8lB,KAAA,SAAAF,GACA,OAAAne,KAAAme,GAAAU,MACAvoB,KAAAuoB,MAAA7e,GAAAme,EAAAU,MAAA7e,IAIA+e,IAAA,SAAA/e,GACA,MAAA1J,MAAAwoB,KAAA9e,IAAA1J,MAAAuoB,OAGAG,OAAA,SAAAthB,GACA,OAAAsC,KAAA1J,MAAAuoB,MACA,GAAAvoB,KAAAuoB,MAAA7e,GAAA,KAAAtC,EACA,MAAApH,MAAAuoB,MAAA7e,GAAA,EAIA,cAGApD,OAAA,SAAAoD,SACA1J,MAAAuoB,MAAAvoB,KAAAwoB,KAAA9e,KAGAiM,KAAA,SAAAjM,GACA,GAAA+S,GAAAhb,OAAAsD,UAAAmH,SAAA3L,KAAAmJ,GACAiM,EAAA8G,EAAAzX,MAAA,MAAAkV,aAEA,qBAAAvE,GAAAjM,EAGAiM,EAFAjM,EAAA,IAKAiB,KAAA,WACA,GAAAA,KAEA,OADA3K,MAAA+X,QAAA,SAAA3Q,EAAAsC,GAAsCiB,EAAAtG,KAAAqF,KACtCiB,GAGAwL,OAAA,WACA,GAAAA,KAEA,OADAnW,MAAA+X,QAAA,SAAA3Q,GAAiC+O,EAAA9R,KAAA+C,KACjC+O,GAGAwS,MAAA,WACA,MAAA3oB,MAAA2K,OAAAxF,QAGA2iB,MAAA,WAEA9nB,KAAAuoB,UAGAK,MAAA,WACA,UAAA9a,GAAA9N,OAGAwoB,KAAA,SAAA9e,GACA,OAAA1J,KAAA2V,KAAAjM,IACA,gBACA,WACA,cACA,aACA,aACA,MAAAA,GAAA,EAEA,YACA,UAAAA,EAAAmf,SAEA,cACA,UAAAnf,CAEA,aAEA,OADAof,MACApjB,EAAA,EAAoBA,EAAAgE,EAAAvE,OAAgBO,IACpCojB,EAAApjB,GAAA1F,KAAAwoB,KAAA9e,EAAAhE,GAEA,WAAAojB,EAAAvkB,KAAA,IAEA,SAOA,MALAmF,GAAAqf,UACArf,EAAAqf,UAAAjb,EAAAkb,IACAb,EAAAze,EAAA,YAGA,IAAcA,EAAAqf,UAIdhR,QAAA,SAAAkR,GACA,OAAAvf,KAAA1J,MAAAuoB,MAAA,CACA,GAAArP,GAAAlZ,KAAAuoB,MAAA7e,EACAuf,GAAA1oB,KAAAP,KAAAkZ,EAAA,GAAAA,EAAA,MAKApL,GAAAkb,IAAA,CAIA,QAAAE,KAAAvmB,GAEA,mBAAAumB,GAAAvmB,EAAA+Y,eAAAwN,GAAA,CAGA,GAAAhB,GAAAvlB,EAAAumB,EACA,MAAAhB,EAAAhc,WAAA7F,QAAA,aACA1D,EAAAumB,GAAAjB,EAAAC,IA0BA,MAAApa,M7BuyHM,SAASjO,G8B79HfA,EAAAD,QAAA,SAAAupB,GAIA,OAHA3Q,GAAAhW,MAAAuC,UAAAC,MAAAzE,KAAA4oB,EAAA,GAEAR,EAAA,EACA/hB,EAAA4R,EAAArT,OAAA,EAA4ByB,GAAA,GAC5BvE,SAAAmW,EAAA5R,GADkCA,IAElC+hB,GAKA,OADAnQ,GAAA5S,OAAA4S,EAAArT,OAAAwjB,KACAnQ,I9Bu+HM,SAAS3Y,EAAQD,EAASM,G+B/5HhC,QAAAkpB,GAAA7B,GAKA,MAJAA,aAAA/kB,SACA+kB,IAAArb,WAAAtC,MAAA,MAGA2d,EAGA,QAAA8B,GAAA3K,EAAA4K,GAEA,OADAC,GAAA7K,EACA9X,EAAA,EAAgBA,EAAA0iB,EAAAnkB,OAAA,EAAyByB,IACzC2iB,IAAAD,EAAA1iB,GAGA,QAAYwhB,IAAAmB,EAAA7f,IAAA4f,EAAA1iB,IA8GZ,QAAA4iB,GAAAjmB,EAAA+lB,EAAAliB,EAAAuQ,GACA,GAAA8R,GAAAJ,EAAA9lB,EAAAmb,QAAA4K,GAEAI,EAAAtiB,CACAuQ,GAAAgS,SAAA,IACAviB,IAAAsX,SAGA+K,EAAArB,IAAAqB,EAAA/f,KAAAtC,CAEA,IAAA1C,IAAiBiR,KAAA,MAAA4R,SAAA+B,EACjBjnB,UAAAsV,EAAAtX,KAAAqE,EAAArE,GAAAsX,EAAAtX,IACAkD,EAAAsB,KAAA,SAAAH,GAEArC,SAAAsV,EAAAgS,OACAC,EAAArmB,EAAAmmB,EAAAJ,EAAA3R,EAAAgS,OAGA,QAAAE,GAAAtmB,EAAA+lB,EAAA9Q,EAAAb,GACA,GAAA0G,GAAAyL,EAAAvmB,EAAAmb,QAAA4K,GACAS,EAAA1L,EAAAlZ,MACAkZ,GAAAha,KAAArC,MAAAqc,EAAA7F,EAEA,IAAAwR,GAAAC,EAAA5L,EAAA0L,EAAAvR,EAAArT,OAAAwS,EAAAgS,OAEAjlB,GAAiBiR,KAAA,QAAA4R,SAAA+B,EAAA/jB,MAAAwkB,EAAApB,MAAA,EACjBtmB,UAAAsV,EAAAtX,KAAAqE,EAAArE,GAAAsX,EAAAtX,IACAkD,EAAAsB,KAAA,SAAAH,GAEAwlB,EAAA3mB,EAAAymB,EAAAV,EAAA3R,EAAAgS,OAGA,QAAAQ,GAAA5mB,EAAA+lB,EAAA9Q,EAAAb,GACA,GAAApS,GAAAiT,EAAA,GACA4R,EAAA5R,EAAA,GAEA6F,EAAAyL,EAAAvmB,EAAAmb,QAAA4K,GACAre,EAAAoT,EAAAzY,OAAA5D,MAAAqc,EAAA7F,EAEA,IAAA4R,EAAA,GACA,GAAA1lB,IAAqBiR,KAAA,UAAA4R,SAAA+B,EAAA/jB,QAAA8kB,QAAApf,EACrB5I,UAAAsV,EAAAtX,KAAAqE,EAAArE,GAAAsX,EAAAtX,IACAkD,EAAAsB,KAAA,SAAAH,GAEA,GAAA8T,EAAArT,OAAA,GACA,GAAAT,IAAqBiR,KAAA,QAAA4R,SAAA+B,EAAA/jB,QAAAojB,MAAAnQ,EAAArT,OAAA,GAErB6kB,EAAAC,EAAA5L,EAAA9Y,EAAAb,EAAAikB,MAAAhR,EAAAgS,MAEAtnB,UAAAsV,EAAAtX,KAAAqE,EAAArE,GAAAsX,EAAAtX,IACAkD,EAAAsB,KAAA,SAAAH,GAEAwlB,EAAA3mB,EAAAymB,EAAAV,EAAA3R,EAAAgS,OAGA,MAAA1e,GAIA,QAAAqf,GAAA/mB,EAAA+lB,EAAA9Q,EAAAb,GACA,GAAA4S,GAAA/R,EAAA,EACA,QAAA+R,EAAAplB,OAAA,CAEA,GAAAkZ,GAAAyL,EAAAvmB,EAAAmb,QAAA4K,GACAS,EAAA1L,EAAAlZ,OAEAqlB,GAAAT,EAAA,EACAS,KAAA1lB,OAAAylB,EACA,IAAAE,GAAApM,EAAAlZ,MACAkZ,GAAAzY,OAAA5D,MAAAqc,EAAAmM,EAEA,IAAAR,GAAAC,EAAA5L,EAAAoM,EAAApM,EAAAlZ,OAAAwS,EAAAgS,OAEAjlB,GAAiBiR,KAAA,QAAA4R,SAAA+B,EAAA/jB,MAAAwkB,EAAApB,MAAA4B,EAAAplB,OACjB9C,UAAAsV,EAAAtX,KAAAqE,EAAArE,GAAAsX,EAAAtX,IACAkD,EAAAsB,KAAA,SAAAH,GAEAwlB,EAAA3mB,EAAAymB,EAAAV,EAAA3R,EAAAgS,QAKA,QAAAM,GAAA5L,EAAAxN,EAAA8X,EAAAgB,GACA,GAAAK,KACA,IAAA3nB,SAAAsnB,EAEA,OADAe,GAAA7Z,EAAA8X,EACA/hB,EAAAiK,EAAwB6Z,EAAA9jB,EAAYA,IACpCojB,EAAA3lB,MAAoC+jB,IAAA/J,EAAAzX,GAAArB,MAAAqB,IACpC+iB,KAAA,IACAtL,EAAAzX,GAAAyX,EAAAzX,GAAA8X,QAIA,OAAAsL,GAKA,QAAAE,GAAA3mB,EAAAymB,EAAAV,EAAA9G,GACA,OAAA5b,GAAA,EAAgBA,EAAAojB,EAAA7kB,OAA4ByB,IAC5CgjB,EAAArmB,EAAAymB,EAAApjB,GAAAwhB,IAAAkB,EAAAxkB,OAAAklB,EAAApjB,GAAArB,OAAAid,GAWA,QAAAoH,GAAArmB,EAAAonB,EAAArB,EAAA9G,GACA,GAAAoI,GAAAtB,EAAAnkB,MAEA,IAAA9C,SAAAsoB,EAAA/Z,IAAAvO,SAAAsoB,EAAA9lB,MAAAxC,SAAAsoB,EAAAvZ,gBAAA/O,SAAAsoB,EAAA9oB,IACA,SAAA4B,OAAA,qDAGA,IAAAonB,GAAAC,EACAC,KAAAC,IACAL,GAAA/Z,GAAA,SAAAia,EAAA,SAAAI,GACA,QAAAD,EAAA3kB,QAAA4kB,GAAA,CACA,GAAAzI,EACA,GAAA+E,GAAA+B,EAAAxkB,OAAAmmB,EAAA1D,cAEA,IAAAA,GAAA+B,EAAAxkB,QAAA,YAAAA,OAAAmmB,EAAA1D,SAGA,IAAA2D,GAAApoB,EAAAwH,SAAgD2gB,GAAW1D,YAC3DwD,GAAA1mB,KAAA6mB,GACA3nB,EAAAsB,KAAA,SAAAqmB,MAGA3nB,EAAAqN,GAAA,SAAAka,EAAA,SAAAG,GACA,GAAAE,GAAAF,EAAA1D,SAAApiB,OAEAimB,EAAAC,EAAA/B,EAAA2B,GACAK,EAAAF,EAAAG,SACAC,EAAAJ,EAAAK,aAEA,IAAAH,GAAA,KAAAP,EAAA1kB,QAAA4kB,GAAA,CACA,GAAAzI,EACA,GAAA+E,GAAA0D,EAAA1D,SAAAviB,MAAA4lB,OAEA,IAAArD,GAAA0D,EAAA1D,SAAAviB,MAAA4lB,EAAA,EAGA,IAAAc,GAAA5oB,EAAAwH,SAAmD2gB,GAAW1D,YAC9DyD,GAAA3mB,KAAAqnB,GACAf,EAAA9lB,KAAA,SAAA6mB,OACS,IAAAF,EACT,WAAAP,EAAAtV,KACAgW,QACa,gBAAAV,EAAAtV,KAAA,CACb,GAAAiW,GAAAtC,EAAA2B,EAAA1D,SAAApiB,QACA0mB,EAAAZ,EAAA1lB,OAAAqmB,MAAAX,EAAA1lB,MAAA0lB,EAAAZ,QAAAllB,OAAA,EACA2mB,EAAAb,EAAA1lB,MAAA0lB,EAAAZ,QAAAllB,OAAA,EAAAymB,IAEAC,IAAAjB,EAAA,GAAAO,EACAQ,IACiBG,IACjBxC,EAAA2B,EAAA1D,SAAApiB,QAAAymB,EAAAX,EAAAZ,QAAAllB,YAEa,cAAA8lB,EAAAtV,KAAA,CACb,GAAAiW,GAAAtC,EAAA2B,EAAA1D,SAAApiB,OACA8lB,GAAA1lB,MAAAqmB,IACAtC,EAAA2B,EAAA1D,SAAApiB,QAAAymB,EAAAX,EAAAtC,SAMA,IAAAgD,GAAA,WACAhB,EAAAvZ,eAAA,SAAAyZ,GACAtnB,EAAA6N,eAAA,SAAA0Z,IAUA,QAAAO,GAAA/B,EAAA2B,GAKA,OAJAL,GAAAtB,EAAAnkB,OAEAmmB,GAAA,EACAE,GAAA,EACA5kB,EAAA,EAAgBgkB,EAAAhkB,EAAqBA,IACrCqkB,EAAA1D,SAAA3gB,KAAA0iB,EAAA1iB,KACA0kB,GAAA,EACA1kB,EAAAqkB,EAAA1D,SAAApiB,SACAqmB,GAAA,GAWA,OANAP,GAAA1D,SAAApiB,QAAAylB,EACAU,GAAA,EAEAE,GAAA,GAGYC,cAAAD,EAAAD,SAAAD,GA9ZZ,GAAA3oB,GAAAzC,EAAA,IACA2W,EAAA3W,EAAA,IAAA2W,aACA/T,EAAA5C,EAAA,IAqGA4pB,GA7FAjqB,EAAAD,QAAA+C,EAAAkU,EAAA,WAIA7W,KAAAsD,KAAA,SAAA8kB,GACApoB,KAAA0e,QAAA0J,EAEApoB,KAAAglB,gBAAA,MAOAhlB,KAAA2B,IAAA,SAAA4lB,GACA,MAAAwE,GAAA/rB,KAAAopB,EAAA7B,KAMAvnB,KAAA6B,IAAA,SAAA0lB,EAAAngB,GACAoiB,EAAAxpB,KAAAopB,EAAA7B,GAAAngB,OAIApH,KAAAqE,KAAA,WACAwlB,EAAA7pB,QAAAiC,eAOAjC,KAAA4F,OAAA,WACA,MAAAukB,GAAAnqB,QAAAiC,eAIAjC,KAAAgsB,OAAA,WACA1B,EAAAtqB,QAAAiC,eAGAjC,KAAAK,GAAA,SAAAA,GACA,MAAA0rB,GAAA/rB,SAAwCK,QAcxCL,KAAA2pB,MAAA,SAAAnH,GAEA,MADAngB,UAAAmgB,OAAA,GACAuJ,EAAA/rB,SAAwC2pB,MAAAnH,OAiCxC3iB,EAAAD,QAAAkqB,iBAAA,SAAApL,EAAA6I,GACA,GAAAkC,GAAAJ,EAAA3K,EAAA6I,EACA,OAAAllB,UAAAonB,EAAA/f,IACA+f,EAAArB,IAAAqB,EAAA/f,KAEA+f,EAAArB,MAQA2D,EAAAppB,EAAAkU,EAAA,WAEA7W,KAAAsD,KAAA,SAAAS,EAAAulB,EAAA3R,GACA3X,KAAA2X,QAAAtV,SAAAsV,KACAA,EAGA3X,KAAAisB,gBADA5pB,SAAA0B,EAAAkoB,gBACAloB,EAAAkoB,gBAEAloB,EAEA/D,KAAAunB,SAAA+B,EACAtpB,KAAA0e,QAAAoL,EAAA/lB,EAAA2a,QAAA4K,EAEA,IAAA/lB,GAAAvD,IACA+D,GAAA6M,GAAA,kBAAAqa,GACA,GAAAG,GAAAC,EAAA9nB,EAAAgkB,SAAA0D,EAEA,IAAAG,EAAAG,SACAhoB,EAAAsB,KAAA,UAAqC8Q,KAAAsV,EAAAtV,KAAA4R,SAAA0D,EAAA1D,SAAAviB,MAAAzB,EAAAgkB,SAAApiB,QAAAI,MAAA0lB,EAAA1lB,MAAAojB,MAAAsC,EAAAtC,MAAA0B,QAAAY,EAAAZ,cACxB,IAAAe,EAAAK,cACb,eAAAR,EAAAtV,KAAA,CACA,GAAAiW,GAAAroB,EAAAgkB,SAAA0D,EAAA1D,SAAApiB,QACA+mB,EAAAjB,EAAA1lB,MAAA0lB,EAAAZ,QAAAllB,OAAA,EAAAymB,CAEAM,KACA3oB,EAAAgkB,SAAA0D,EAAA1D,SAAApiB,QAAAymB,EAAAX,EAAAZ,QAAAllB,YAEiB,cAAA8lB,EAAAtV,KAAA,CACjB,GAAAiW,GAAAroB,EAAAgkB,SAAA0D,EAAA1D,SAAApiB,OACA8lB,GAAA1lB,MAAAqmB,IACAroB,EAAAgkB,SAAA0D,EAAA1D,SAAApiB,QAAAymB,EAAAX,EAAAtC,WAOA3oB,KAAA2B,IAAA,SAAA4lB,GACA,MAAAvnB,MAAAisB,gBAAAtqB,IAAA3B,KAAAunB,SAAAziB,OAAAskB,EAAA7B,MAGAvnB,KAAA6B,IAAA,SAAA0lB,EAAAngB,GACAoiB,EAAAxpB,KAAAisB,gBAAAjsB,KAAAunB,SAAAziB,OAAAskB,EAAA7B,IAAAngB,EAAApH,KAAA2X,UAGA3X,KAAAqE,KAAA,WACAwlB,EAAA7pB,KAAAisB,gBAAAjsB,KAAAunB,SAAAtlB,UAAAjC,KAAA2X,UAGA3X,KAAA4F,OAAA,WACAukB,EAAAnqB,KAAAisB,gBAAAjsB,KAAAunB,SAAAtlB,UAAAjC,KAAA2X,UAGA3X,KAAAgsB,OAAA,WACA1B,EAAAtqB,KAAAisB,gBAAAjsB,KAAAunB,SAAAtlB,UAAAjC,KAAA2X,UAGA3X,KAAAK,GAAA,SAAAA,GACA,MAAA0rB,GAAA/rB,UAAAunB,SAAAzkB,EAAAwH,SAAgEtK,KAAA2X,SAAiBtX,SAIjFL,KAAA2pB,MAAA,SAAAnH,GAEA,MADAngB,UAAAmgB,OAAA,GACAuJ,EAAA/rB,QAAA8C,EAAAwH,SAAqDtK,KAAA2X,SAAiBgS,MAAAnH,S/BquIhE,SAAS3iB,EAAQD,EAASM,GgC15IhC,GAAAyC,GAAAzC,EAAA,IAEAS,EAAAT,EAAA,GACAU,EAAAV,EAAA,GACA0Y,EAAA1Y,EAAA,GAKAL,GAAAD,QAAA,SAAAusB,EAAA3oB,GACA,MAAAb,GAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,OAEAxD,KAAA4V,aAAAhV,GACA2G,QAAA,cAMAvH,KAAAsD,KAAA,WACA,GAAArB,UAAA,YAAAO,OACA,GAAA4pB,GAAAnqB,UAAA,OAEA,IAAAmD,GAAAnD,UAAA,GACAmqB,EAAAnqB,UAAA,EAOA,IAJAjC,KAAAyC,QAAAiF,SAAAuB,cAAAkjB,GACA9oB,EAAAC,KAAA/C,KAAAP,MACAA,KAAAoF,QAEA/C,SAAA+pB,EACA,OAAAxlB,GAAA,EAA4BA,EAAAwlB,EAAAjnB,OAAkByB,IAC9C5G,KAAAqsB,KAAAD,EAAAxlB,KAKA5G,KAAAqsB,KAAA,WACA,GAAAA,GAAAzT,EAAA5W,MAAAK,OAAAJ,UAEA,OADAjC,MAAAsC,IAAA+pB,GACAA,OhCm6IM,SAASxsB,EAAQD,EAASM,IiCh9IhC,SAAAosB,GAyBA,QAAAC,GAAA1hB,EAAA2hB,GAGA,OADAC,GAAA,EACA/mB,EAAAmF,EAAA1F,OAAA,EAAgCO,GAAA,EAAQA,IAAA,CACxC,GAAAgnB,GAAA7hB,EAAAnF,EACA,OAAAgnB,EACA7hB,EAAAjF,OAAAF,EAAA,GACK,OAAAgnB,GACL7hB,EAAAjF,OAAAF,EAAA,GACA+mB,KACKA,IACL5hB,EAAAjF,OAAAF,EAAA,GACA+mB,KAKA,GAAAD,EACA,KAAUC,IAAMA,EAChB5hB,EAAA8hB,QAAA,KAIA,OAAA9hB,GA+JA,QAAA+hB,GAAAC,EAAAC,GACA,GAAAD,EAAAD,OAAA,MAAAC,GAAAD,OAAAE,EAEA,QADAC,MACArnB,EAAA,EAAmBA,EAAAmnB,EAAA1nB,OAAeO,IAClConB,EAAAD,EAAAnnB,KAAAmnB,IAAAE,EAAA1oB,KAAAwoB,EAAAnnB,GAEA,OAAAqnB,GAhKA,GAAAC,GACA,gEACAC,EAAA,SAAAC,GACA,MAAAF,GAAAnS,KAAAqS,GAAAloB,MAAA,GAKApF,GAAAutB,QAAA,WAIA,OAHAC,GAAA,GACAC,GAAA,EAEA3nB,EAAAzD,UAAAkD,OAAA,EAAoCO,GAAA,KAAA2nB,EAA8B3nB,IAAA,CAClE,GAAA4nB,GAAA5nB,GAAA,EAAAzD,UAAAyD,GAAA4mB,EAAAiB,KAGA,oBAAAD,GACA,SAAApI,WAAA,4CACKoI,KAILF,EAAAE,EAAA,IAAAF,EACAC,EAAA,MAAAC,EAAAE,OAAA,IAWA,MAJAJ,GAAAb,EAAAK,EAAAQ,EAAAxjB,MAAA,cAAAlJ,GACA,QAAAA,KACG2sB,GAAA9oB,KAAA,MAEH8oB,EAAA,QAAAD,GAAA,KAKAxtB,EAAA6tB,UAAA,SAAAH,GACA,GAAAI,GAAA9tB,EAAA8tB,WAAAJ,GACAK,EAAA,MAAAxgB,EAAAmgB,EAAA,GAcA,OAXAA,GAAAf,EAAAK,EAAAU,EAAA1jB,MAAA,cAAAlJ,GACA,QAAAA,KACGgtB,GAAAnpB,KAAA,KAEH+oB,GAAAI,IACAJ,EAAA,KAEAA,GAAAK,IACAL,GAAA,MAGAI,EAAA,QAAAJ,GAIA1tB,EAAA8tB,WAAA,SAAAJ,GACA,YAAAA,EAAAE,OAAA,IAIA5tB,EAAA2E,KAAA,WACA,GAAAqpB,GAAAprB,MAAAuC,UAAAC,MAAAzE,KAAA0B,UAAA,EACA,OAAArC,GAAA6tB,UAAAb,EAAAgB,EAAA,SAAAltB,GACA,mBAAAA,GACA,SAAAwkB,WAAA,yCAEA,OAAAxkB,KACG6D,KAAA,OAMH3E,EAAAiuB,SAAA,SAAAC,EAAAC,GAIA,QAAAlP,GAAAmP,GAEA,IADA,GAAAnd,GAAA,EACUA,EAAAmd,EAAA7oB,QACV,KAAA6oB,EAAAnd,GAD8BA,KAK9B,IADA,GAAAC,GAAAkd,EAAA7oB,OAAA,EACU2L,GAAA,GACV,KAAAkd,EAAAld,GADoBA,KAIpB,MAAAD,GAAAC,KACAkd,EAAAhpB,MAAA6L,EAAAC,EAAAD,EAAA,GAfAid,EAAAluB,EAAAutB,QAAAW,GAAA3gB,OAAA,GACA4gB,EAAAnuB,EAAAutB,QAAAY,GAAA5gB,OAAA,EAsBA,QALA8gB,GAAApP,EAAAiP,EAAAlkB,MAAA,MACAskB,EAAArP,EAAAkP,EAAAnkB,MAAA,MAEAzE,EAAAuR,KAAAF,IAAAyX,EAAA9oB,OAAA+oB,EAAA/oB,QACAgpB,EAAAhpB,EACAO,EAAA,EAAiBP,EAAAO,EAAYA,IAC7B,GAAAuoB,EAAAvoB,KAAAwoB,EAAAxoB,GAAA,CACAyoB,EAAAzoB,CACA,OAKA,OADA0oB,MACA1oB,EAAAyoB,EAA+BzoB,EAAAuoB,EAAA9oB,OAAsBO,IACrD0oB,EAAA/pB,KAAA,KAKA,OAFA+pB,KAAAtpB,OAAAopB,EAAAlpB,MAAAmpB,IAEAC,EAAA7pB,KAAA,MAGA3E,EAAAyuB,IAAA,IACAzuB,EAAA0uB,UAAA,IAEA1uB,EAAA2uB,QAAA,SAAAjB,GACA,GAAAriB,GAAAgiB,EAAAK,GACA5tB,EAAAuL,EAAA,GACAujB,EAAAvjB,EAAA,EAEA,OAAAvL,IAAA8uB,GAKAA,IAEAA,IAAArhB,OAAA,EAAAqhB,EAAArpB,OAAA,IAGAzF,EAAA8uB,GARA,KAYA5uB,EAAA6uB,SAAA,SAAAnB,EAAAoB,GACA,GAAA5B,GAAAG,EAAAK,GAAA,EAKA,OAHAoB,IAAA5B,EAAA3f,OAAA,GAAAuhB,EAAAvpB,UAAAupB,IACA5B,IAAA3f,OAAA,EAAA2f,EAAA3nB,OAAAupB,EAAAvpB,SAEA2nB,GAIAltB,EAAA+uB,QAAA,SAAArB,GACA,MAAAL,GAAAK,GAAA,GAaA,IAAAngB,GAAA,WAAAA,OAAA,IACA,SAAAsP,EAAA5L,EAAAuU,GAAkC,MAAA3I,GAAAtP,OAAA0D,EAAAuU,IAClC,SAAA3I,EAAA5L,EAAAuU,GAEA,MADA,GAAAvU,MAAA4L,EAAAtX,OAAA0L,GACA4L,EAAAtP,OAAA0D,EAAAuU,MjCs9I8B7kB,KAAKX,EAASM,EAAoB,MAI1D,SAASL,EAAQD,EAASM,GkCrqJhC,QAAAyd,GAAAC,EAAAC,GACA,GAAAC,GAAAF,EAAA,GACAG,EAAAH,EAAA,EAEA,QAAAlU,KAAAqU,GACAtc,OAAAia,eAAAnb,KAAAwd,EAAArU,KACAmU,GAAAC,EAAApU,YAAAjI,SAAAsc,EAAArU,YAAAjI,QACAkc,GAAAG,EAAApU,GAAAqU,EAAArU,KAAA,GAEAoU,EAAApU,GAAAqU,EAAArU,GAKA,IAAAkU,EAAAzY,OAAA,GACA,GAAA6Y,IAAAF,GAAAhZ,OAAA8Y,EAAA5Y,MAAA,GACA,OAAA2Y,GAAAK,EAAAH,GAEA,MAAAC,GAIA,QAAAG,GAAAvX,GACA,MAAAlE,OAAAuC,UAAAC,MAAAzE,KAAAmG,EAAA,GAvCAxG,EAAA,IAMAN,EAAA0K,MAAA,WACA,MAAAqT,GAAAM,EAAAhc,YAAA,IAKArC,EAAAse,UAAA,WACA,MAAAP,GAAAM,EAAAhc,YAAA,KlCytJM,SAASpC,GmCrqJf,QAAAkmB,MAjEA,GAAAuG,GAAAzsB,EAAAD,UAEA0sB,GAAAsC,SAAA,WACA,GAAAC,GAAA,mBAAA7L,SACAA,OAAA8L,aACAC,EAAA,mBAAA/L,SACAA,OAAAzR,iBACAyd,EAAA,mBAAAhM,SACAA,OAAAiM,aAAAjM,OAAApe,gBAGA,IAAAiqB,EACA,gBAAA/B,GAA6B,MAAA9J,QAAA8L,aAAAhC,GAG7B,IAAAoC,KAEA,IAAAH,EAAA,CACA,GAAAI,GAAAznB,SAAAuB,cAAA,OACAqI,EAAA,GAAAC,kBAAA,WACA,GAAA6d,GAAAF,EAAAlqB,OACAkqB,GAAA/pB,OAAA,EACAiqB,EAAArX,QAAA,SAAAmQ,GACAA,OAMA,OAFA5W,GAAAzO,QAAAssB,GAAqCjoB,YAAA,IAErC,SAAAghB,GACAgH,EAAA/pB,QACAgqB,EAAAhoB,aAAA,YAEA+nB,EAAA7qB,KAAA6jB,IAIA,MAAA8G,IACAhM,OAAApe,iBAAA,mBAAAyqB,GACA,GAAAC,GAAAD,EAAAC,MACA,KAAAA,IAAAtM,QAAA,OAAAsM,IAAA,iBAAAD,EAAAnW,OACAmW,EAAAE,kBACAL,EAAA/pB,OAAA,IACA,GAAA+iB,GAAAgH,EAAAM,OACAtH,QAGS,GAET,SAAAA,GACAgH,EAAA7qB,KAAA6jB,GACAlF,OAAAiM,YAAA,sBAIA,SAAA/G,GACA/e,WAAA+e,EAAA,OAIAoE,EAAAmD,MAAA,UACAnD,EAAAoD,SAAA,EACApD,EAAAqD,OACArD,EAAAsD,QAIAtD,EAAA1b,GAAAmV,EACAuG,EAAArL,YAAA8E,EACAuG,EAAA5G,KAAAK,EACAuG,EAAAvb,IAAAgV,EACAuG,EAAAlb,eAAA2U,EACAuG,EAAAlL,mBAAA2E,EACAuG,EAAAznB,KAAAkhB,EAEAuG,EAAAuD,QAAA,WACA,SAAApsB,OAAA,qCAIA6oB,EAAAiB,IAAA,WAA2B,WAC3BjB,EAAAwD,MAAA,WACA,SAAArsB,OAAA","file":"blocks.umd.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"blocks\"] = factory();\n\telse\n\t\troot[\"blocks\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"blocks\"] = factory();\n\telse\n\t\troot[\"blocks\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports.Block = __webpack_require__(1)\r\n\texports.Style = __webpack_require__(2)\r\n\t\r\n\texports.Canvas = __webpack_require__(3)\r\n\texports.Container = __webpack_require__(4)\r\n\texports.Button = __webpack_require__(5)\r\n\texports.CheckBox = __webpack_require__(6)\r\n\texports.Image = __webpack_require__(7)\r\n\texports.List = __webpack_require__(8)\r\n\t//exports.MultiSelect = require(\"Components/MultiSelect\") // not ready yet\r\n\texports.Radio = __webpack_require__(9)\r\n\texports.Select = __webpack_require__(10)\r\n\texports.Table = __webpack_require__(11)\r\n\texports.TextArea = __webpack_require__(12)\r\n\texports.TextField = __webpack_require__(13)\r\n\texports.Text = __webpack_require__(14)\r\n\t\r\n\t\r\n\t\r\n\tObject.defineProperty(exports, 'dev', {\r\n\t    get: function() {\r\n\t        return exports.Block.dev\r\n\t    }, set: function(v) {\r\n\t        exports.Block.dev = v\r\n\t    }\r\n\t})\r\n\t\r\n\texports.attach = function(/*component,component,.. or components*/) {\r\n\t    exports.Block.attach.apply(this,arguments)\r\n\t}\r\n\texports.detach = function(/*component,component,.. or components*/) {\r\n\t    exports.Block.detach.apply(this,arguments)\r\n\t}\r\n\t\r\n\texports.createBody = function(callback) {\r\n\t    exports.Block.detach.apply(this,arguments)\r\n\t}\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar EventEmitterB = __webpack_require__(18)\n\tvar proto = __webpack_require__(26);\n\tvar trimArguments = __webpack_require__(28)\n\tvar observe = __webpack_require__(29)\n\t\n\tvar utils = __webpack_require__(16)\n\tvar domUtils = __webpack_require__(19)\n\tvar blockStyleUtils = __webpack_require__(17)\n\t\n\tvar Style = __webpack_require__(2)\n\tStyle.isDev = function() {return module.exports.dev}\n\t\n\tvar components = {};\n\t\n\tvar setOfBrowserEvents = utils.arrayToMap([\n\t    'abort','afterprint','animationend','animationiteration','animationstart','audioprocess','beforeprint','beforeunload',\n\t    'beginEvent','blocked','blur','cached','canplay','canplaythrough','change','chargingchange','chargingtimechange',\n\t    'checking','click','close','compassneedscalibration','complete','compositionend','compositionstart','compositionupdate','contextmenu',\n\t    'copy','cut','dblclick','decivelight','devicemotion','deviceorientation','deviceproximity','dischargingtimechange','DOMContentLoaded',\n\t    'downloading','drag','dragend','dragenter','dragleave','dragover','dragstart','drop','durationchange','emptied','ended','endEvent',\n\t    'error','focus','focusin','focusout','fullscreenchange','fullscreenerror','gamepadconnected','gamepaddisconnected','hashchange',\n\t    'input','invalid','keydown','keypress','keyup','languagechange','levelchange','load','loadeddata','loadedmetadata','loadend',\n\t    'loadstart','message','mousedown','mouseenter','mouseleave','mousemove','mouseout','mouseover','mouseup','noupdate','obsolete',\n\t    'offline','online','open','orientationchange','pagehide','pageshow','paste','pause','pointerlockchange','pointerlockerror','play',\n\t    'playing','popstate','progress','ratechange','readystatechange','repeatEvent','reset','resize','scroll','seeked','seeking','select',\n\t    'show','stalled','storage','submit','success','suspend','SVGAbort','SVGError','SVGLoad','SVGResize','SVGScroll','SVGUnload','SVGZoom',\n\t    'timeout','timeupdate','touchcancel','touchend','touchenter','touchleave','touchmove','touchstart','transitionend','unload',\n\t    'updateready','upgradeneeded','userproximity','versionchange','visibilitychange','volumechange','waiting','wheel'\n\t])\n\t\n\t// events:\n\t    // newParent - emits this when a component gets a new parent\n\t    // parentRemoved - emits this when a component is detached from its parent\n\tvar Block = module.exports = proto(EventEmitterB,function(superclass) {\n\t\n\t    // static properties\n\t\n\t    // constructor\n\t\tthis.init = function() {\n\t        var that = this\n\t\n\t        if(this.name === undefined) {\n\t            throw new Error(\"The 'name' property is required for Blocks\")\n\t        }\n\t\n\t        var defaultBlockStyle = blockStyleUtils.defaultStyleMap.get(this.constructor)\n\t        if(defaultBlockStyle === undefined) {\n\t            defaultBlockStyle = blockStyleUtils.createDefaultBlockStyle(this)\n\t        }\n\t\n\t        superclass.init.call(this)\n\t\n\t        this.children = []\n\t        this.state = observe({})\n\t        this.parent = undefined;\n\t\n\t\t\tif (this.id !== undefined) {\n\t\t\t\tcomponents[this.id] = this;\n\t\t\t}\n\t\n\t        if(this.domNode === undefined) {\n\t            this.domNode = domUtils.div()\n\t        }\n\t\n\t        this.build.apply(this, arguments)\n\t\n\t        //if(module.exports.dev) {\n\t            this.attr('blkName', this.name)\n\t        //}\n\t\n\t        var classList = [this.domNode.className]\n\t        if(defaultBlockStyle !== false) classList.push(defaultBlockStyle.className)\n\t        classList.push(Style.defaultClassName)\n\t        this.domNode.className = classList.join(' ') // note that the order of classes doesn't matter\n\t\n\t        // set up dom event handlers\n\t        var ifonHandlers={}\n\t        that.ifon(function(event) {\n\t            if(event in setOfBrowserEvents && (that.excludeDomEvents === undefined || !(event in that.excludeDomEvents))) {\n\t                that.domNode.addEventListener(event, ifonHandlers[event]=function() {\n\t                    that.emit.apply(that, [event].concat(Array.prototype.slice.call(arguments)))\n\t                })\n\t            }\n\t        })\n\t        that.ifoff(function(event) {\n\t            if(event in setOfBrowserEvents && (that.excludeDomEvents === undefined || !(event in that.excludeDomEvents))) {\n\t                that.domNode.removeEventListener(event,ifonHandlers[event])\n\t            }\n\t        })\n\t\t}\n\t\n\t    // sub-constructor - called by the constructor\n\t    // parameters:\n\t        // label - (Optional) A label that can be used to style a component differently.\n\t                   // Intended to be some string describing what the component is being used for.\n\t                   // Note, tho, that labels are not dynamic - changing the label won't affect styling until a new style is applied to the component)\n\t        // domNode - (Optional) A domNode to be used as the container domNode instead of the default (a div)\n\t    this.build = function(/*[label,] domNode*/) {\n\t        if(arguments.length === 1) {\n\t            this.domNode = arguments[0]\n\t        } else if(arguments.length >= 2) {\n\t            this.label = arguments[0]\n\t            this.domNode = arguments[1]\n\t        }\n\t    }\n\t\t\n\t\n\t\t// instance properties\n\t\n\t\t\n\t\tthis.domNode;\n\t    this.label;\n\t    this.excludeDomEvents;\n\t    this.children;     // a list of child components that are a part of a Block object (these are used so Styles can be propogated down to child components)\n\t\n\t\n\t    Object.defineProperty(this, 'label', {\n\t        get: function() {\n\t            return this._label\n\t        }, set: function(v) {\n\t            if(this._label === undefined) {\n\t                this._label = v\n\t\n\t                if(module.exports.dev) {\n\t                    this.attr('label', this._label)\n\t                }\n\t            } else {\n\t                throw new Error(\"A Block's label can only be set once (was already set to: \"+this._label+\")\")\n\t            }\n\t        }\n\t    })\n\t\n\t    // adds elements to the components main domNode\n\t    // arguments can be one of the following:\n\t        // component, component, component, ...\n\t        // listOfBlocks\n\t    this.add = function() {\n\t        this.addAt.apply(this, [this.domNode.children.length].concat(trimArguments(arguments)))\n\t\t}\n\t\n\t    // adds nodes at a particular index\n\t    // nodes can be one of the following:\n\t        // component, component, component, ...\n\t        // listOfBlocks\n\t    this.addAt = function(index/*, nodes...*/) {\n\t        var nodes = normalizeAddAtArguments.apply(this, arguments)\n\t\n\t        for (var i=0;i<nodes.length;i++) {\n\t\t\t\tvar node = nodes[i];\n\t            this.children.splice(index+i, 0, node)\n\t\n\t            if(!isBlock(node)) {\n\t                throw new Error(\"node is not a Block\")\n\t            }\n\t\n\t            node.parent = undefined\n\t            node.emit('parentRemoved')\n\t\n\t            var beforeChild = this.children[1+i+index]\n\t            if(beforeChild === undefined) {\n\t                this.domNode.appendChild(node.domNode)\n\t            } else {\n\t                this.domNode.insertBefore(node.domNode, beforeChild.domNode)\n\t            }\n\t\n\t            node.parent = this;\n\t            node.emit('newParent')\n\t\n\t            // apply styles\n\t            //if(itsaBlock) { // its always a component now\n\t                var that = this\n\t                node.getParentStyleMap = function() {return that.computedStyleMap}\n\t                blockStyleUtils.propogateStyleSet([node], this.computedStyleMap)\n\t            //}\n\t\t\t}\n\t    }\n\t\n\t\t// add a list of nodes before a particular node\n\t    // if beforeChild is undefined, this will append the given nodes\n\t    // arguments can be one of the following:\n\t        // component, component, component, ...\n\t        // listOfBlocks\n\t    this.addBefore = this.addBeforeNode = function(beforeChild) {\n\t        var nodes = trimArguments(arguments).slice(1)\n\t        if(beforeChild === undefined) {\n\t            this.add.apply(this, nodes)\n\t        } else {\n\t            var index = this.children.indexOf(beforeChild)\n\t            this.addAt.apply(this, [index].concat(nodes))\n\t        }\n\t    }\n\t\n\t\n\t    // arguments can be one of the following:\n\t        // component, component, component, ...\n\t        // index, index, index, ... - each index is the numerical index to remove\n\t        // arrayOfComponents\n\t        // arrayOfIndexes\n\t    this.remove = function() {\n\t        var removals = normalizeRemoveArguments.apply(this, arguments)\n\t        removals = removals.sort(function(a,b) {\n\t            return b-a // reverse sort (so that removing multiple indexes doesn't mess up)\n\t        })\n\t\n\t        for(var n=0; n<removals.length; n++) {\n\t            var r = removals[n]\n\t            var c = this.children[r]\n\t\n\t            if(c === undefined) {\n\t                throw new Error(\"There is no child at index \"+r)\n\t            }\n\t\n\t            c.parent = undefined\n\t            this.children.splice(r, 1)\n\t            this.domNode.removeChild(this.domNode.childNodes[r])\n\t\n\t            c.emit('parentRemoved')\n\t        }\n\t    }\n\t\n\t    // sets or gets an attribute on the components domNode\n\t    // parameter sets:\n\t    // if one argument is passed, the attribute's value is returned (if there is no attribute, undefined is returned)\n\t    // if there are two arguments passed, the attribute is set\n\t        // if 'value' is undefined, the attribute is removed\n\t    this.attr = function(/*attribute, value OR attributeObject*/) {\n\t        if(arguments.length === 1) {\n\t            if(arguments[0] instanceof Object) {\n\t                var attributes = arguments[0]\n\t                for(var attribute in attributes) {\n\t                    domUtils.setAttribute(this.domNode, attribute, arguments[0][attribute])\n\t                }\n\t            } else {\n\t                var attribute = this.domNode.getAttribute(arguments[0])\n\t                if(attribute === null) {\n\t                    return undefined // screw null\n\t                } else {\n\t                    return attribute\n\t                }\n\t            }\n\t        } else {\n\t            var attribute = arguments[0]\n\t            if(arguments[1] !== undefined) {\n\t                var value = arguments[1]\n\t                domUtils.setAttribute(this.domNode, arguments[0], value)\n\t            } else {\n\t                this.domNode.removeAttribute(attribute)\n\t            }\n\t        }\n\t    }\n\t\n\t    Object.defineProperty(this, 'visible', {\n\t        // returns true if the element is visible\n\t        get: function() {\n\t            return this.domNode.style.display !== 'none';\n\t\n\t        // sets whether or not the element is visible\n\t        }, set: function(setToVisible) {\n\t            if(setToVisible) {\n\t                if (this._displayStyle !== undefined) {\n\t                    this.domNode.style.display = this._displayStyle // set back to its previous inline style\n\t                    this._displayStyle = undefined\n\t                } else {\n\t                    this.domNode.style.display = ''\n\t                }\n\t            } else {\n\t                if(this.domNode.style.display !== '' && this.domNode.style.display !== 'none') { // domNode has inline style\n\t                    this._displayStyle = this.domNode.style.display\n\t                }\n\t\n\t                this.domNode.style.display = 'none'\n\t            }\n\t        }\n\t    })\n\t\n\t\n\t    Object.defineProperty(this, 'focus', {\n\t        // returns true if the element is in focus\n\t        get: function() {\n\t            return document.activeElement === this.domNode\n\t\n\t        // sets whether or not the element is in focus (setting it to true gives it focus, setting it to false blurs it)\n\t        }, set: function(setToInFocus) {\n\t            if(setToInFocus) {\n\t                this.domNode.focus()\n\t            } else {\n\t                this.domNode.blur()\n\t            }\n\t        }\n\t    })\n\t\n\t    Object.defineProperty(this, 'style', {\n\t        get: function() {\n\t            return this._style\n\t\n\t        // sets the style, replacing one if one already exists\n\t        }, set: function(styleObject) {\n\t            if(styleObject === undefined) {\n\t                var styleMap = this.getParentStyleMap()\n\t                if(styleMap !== undefined) {\n\t                    blockStyleUtils.setCurrentStyle(this, blockStyleUtils.getStyleForComponent(styleMap, this))\n\t                } else {\n\t                    blockStyleUtils.setCurrentStyle(this, undefined)\n\t                }\n\t\n\t                this.computedStyleMap = styleMap\n\t\n\t            } else {\n\t                blockStyleUtils.setCurrentStyle(this, styleObject)\n\t                var specificStyle = styleObject.get(this)\n\t                if(this.getParentStyleMap() !== undefined) {\n\t                    this.computedStyleMap = blockStyleUtils.styleMapConjunction(this.getParentStyleMap(), specificStyle.componentStyleMap)\n\t                } else {\n\t                    this.computedStyleMap = specificStyle.componentStyleMap\n\t                }\n\t            }\n\t\n\t            this._style = styleObject\n\t            blockStyleUtils.propogateStyleSet(this.children, this.computedStyleMap) // propogate styles to children\n\t        }\n\t    })\n\t\n\t    Object.defineProperty(this, 'selectionRange', {\n\t        // returns the visible character selection range inside the element\n\t        // returns an array like [offsetStart, offsetEnd]\n\t        get: function() {\n\t            return domUtils.getSelectionRange(this.domNode)\n\t\n\t        // sets the visible character selection range\n\t        }, set: function(selection) {\n\t            domUtils.setSelectionRange(this.domNode, selection[0], selection[1])\n\t        }\n\t    })\n\t\n\t    this.attach = function() {\n\t        attach(this)\n\t    }\n\t    this.detach = function() {\n\t        detach(this)\n\t    }\n\t\n\t\n\t\t// private instance variables/functions\n\t\n\t    this.getParentStyleMap = function() {/*default returns undefined*/}  // should be set to a function that returns the computedStyleMap of the component containing this one (so Styles objects can be inherited)\n\t    this.computedStyleMap;  // a map of style objects computed from the Styles set on a given component and its parent components\n\t\n\t\tthis._style;              // the object's explicit Style object (undefined if it inherits a style)\n\t    this.currentStyle;       // the object's current Style (inherited or explicit)\n\t    this._displayStyle;      // temporariliy stores an inline display style while the element is hidden (for use when 'show' is called)\n\t    this._styleSetupStates   // place to put states for setup functions (used for css pseudoclass emulation)\n\t});\n\t\n\t\n\tmodule.exports.dev = false // set to true to enable dom element naming (so you can see boundaries of components when inspecting the dom)\n\t\n\t\n\t// appends components to the body\n\tvar attach = module.exports.attach = function(/*component,component,.. or components*/) {\n\t    if(arguments[0] instanceof Array) {\n\t        var components = arguments[0]\n\t    } else {\n\t        var components = arguments\n\t    }\n\t\n\t    if(document.body === null) throw new Error(\"Your document does not have a body.\")\n\t\n\t    for(var n=0; n<components.length; n++) {\n\t        document.body.appendChild(components[n].domNode)\n\t    }\n\t}\n\t// removes components from the body\n\tvar detach = module.exports.detach = function(/*component,component,.. or components*/) {\n\t    if(arguments[0] instanceof Array) {\n\t        var components = arguments[0]\n\t    } else {\n\t        var components = arguments\n\t    }\n\t\n\t    for(var n=0; n<components.length; n++) {\n\t        document.body.removeChild(components[n].domNode)\n\t    }\n\t}\n\t\n\t// creates a body tag (only call this if document.body is null)\n\t\n\tmodule.exports.createBody = function(callback) {\n\t    var dom = document.implementation.createDocument('http://www.w3.org/1999/xhtml', 'html', null);\n\t    var body = dom.createElement(\"body\")\n\t    dom.documentElement.appendChild(body)\n\t    setTimeout(function() {  // set timeout is needed because the body tag is only added after javascript goes back to the scheduler\n\t        callback()\n\t    },0)\n\t}\n\t\n\t\n\t\n\t\n\t// returns a list of indexes to remove from Block.remove's arguments\n\t/*private*/ var normalizeRemoveArguments = module.exports.normalizeRemoveArguments = function() {\n\t    var that = this\n\t\n\t    if(arguments[0] instanceof Array) {\n\t        var removals = arguments[0]\n\t    } else {\n\t        var removals = Array.prototype.slice.call(arguments)\n\t    }\n\t\n\t    return removals.map(function(removal, parameterIndex) {\n\t        if(isBlock(removal)) {\n\t            var index = that.children.indexOf(removal)\n\t            if(index === -1) {\n\t                throw new Error(\"The Block passed at index \"+parameterIndex+\" is not a child of this Block.\")\n\t            }\n\t            return index\n\t        } else {\n\t            return removal\n\t        }\n\t\n\t    })\n\t}\n\t\n\t// returns a list of nodes to add\n\t/*private*/ var normalizeAddAtArguments = module.exports.normalizeAddAtArguments = function() {\n\t    if(arguments.length === 2) {\n\t        if(arguments[1] instanceof Array) {\n\t            return arguments[1]\n\t        } else {\n\t            return [arguments[1]]\n\t        }\n\t    } else { // > 2\n\t        return trimArguments(arguments).slice(1)\n\t    }\n\t}\n\t\n\tfunction isBlock(c) {\n\t    return c.add !== undefined && c.children instanceof Array && c.domNode !== undefined\n\t}\n\tfunction isDomNode(node) {\n\t    return node.nodeName !== undefined\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar jssModule = __webpack_require__(15)\n\tvar proto = __webpack_require__(26)\n\tvar HashMap = __webpack_require__(27)\n\t\n\tvar utils = __webpack_require__(16)\n\tvar blockStyleUtils = __webpack_require__(17)\n\t\n\tvar baseClassName = '_ComponentStyle_' // the base name for generated class names\n\tvar nextClassNumber = 0\n\t\n\tvar defaultJss = jssModule.forDocument(document) // must be created before the jss object (so that the styles there override the styles in the default sheet)\n\tdefaultJss.defaultSheet = defaultJss._createSheet() // create its sheet first (before the regular jss sheet)\n\tvar jss = jssModule.forDocument(document)\n\tjss.defaultSheet = jss._createSheet()\n\t\n\t// creates a style object\n\tvar Style = module.exports = proto(function() {\n\t\n\t    this.defaultClassName = '_default_'     // the name of the default class (used to prevent style inheritance)\n\t\n\t    // styleDefinition is an object where key-value pairs can be any of the following:\n\t    // <cssPropertyName>: the value should be a valid css value for that style attribute\n\t    // <ComponentName>: the value can either be a Style object or a nested styleDefinition object\n\t    // $setup: the value is a function to be run on a component when the style is applied to it\n\t    // $kill: the value is a function to be run on a component when a style is removed from it\n\t    // $state: the value should be a state handler function\n\t    // $<label>: the value should be a nested styleDefinition object that does not contain any label styles.\n\t    this.init = function(styleDefinition, privateOptions) {\n\t        if(privateOptions === undefined) privateOptions = {}\n\t        if(privateOptions.inLabel===undefined) inLabel = false\n\t\n\t        this.className = baseClassName+nextClassNumber\n\t        nextClassNumber++\n\t\n\t        this.componentStyleMap = {}\n\t        this.labelStyleMap = {}\n\t\n\t        var labelStyles = {}\n\t        var pseudoClassStyles = {}\n\t        var cssProperties = {}\n\t        for(var key in styleDefinition) {\n\t            var value = styleDefinition[key]\n\t\n\t            if(key === '$setup') {\n\t                if(!(value instanceof Function)) throw new Error(\"$setup key must be a function ('setup' can't be used as a label)\")\n\t                this.setup = value\n\t\n\t            } else if(key === '$kill') {\n\t                if(!(value instanceof Function)) throw new Error(\"$kill key must be a function ('kill' can't be used as a label)\")\n\t                this.kill = value\n\t\n\t            } else if(key === '$state') {\n\t                if(!(value instanceof Function)) throw new Error(\"$state key must be a function ('$state' can't be used as a label)\")\n\t                this.stateHandler = value\n\t\n\t            } else if(key.indexOf('$$') === 0) { // pseudo-class style\n\t                var pseudoClass = mapCamelCase(key.substr(2))\n\t                if(pseudoClass === '') {\n\t                    throw new Error(\"Empty pseudo-class name not valid (style key '$$')\")\n\t                }\n\t\n\t                utils.merge(pseudoClassStyles, flattenPseudoClassStyles(pseudoClass, value))\n\t\n\t            } else if(key.indexOf('$') === 0) {   // label style\n\t                if(privateOptions.inLabel)\n\t                    throw new Error(\"Can't create nested label style \"+key+\" because components can only have one label\")\n\t\n\t                var label = key.substr(1)\n\t                if(label === '') {\n\t                    throw new Error(\"Empty label name not valid (style key '$')\")\n\t                }\n\t\n\t                labelStyles[label] = value\n\t\n\t            } else if(isStyleObject(value)) {\n\t                this.componentStyleMap[key] = value\n\t\n\t            } else if(value instanceof Object) {\n\t                this.componentStyleMap[key] = Style(value)  // turn the object description into a full fledged style object\n\t            } else {\n\t                var cssStyle = key\n\t                var cssStyleName = mapCamelCase(cssStyle)\n\t                cssProperties[cssStyleName] = cssValue(cssStyleName, value)\n\t            }\n\t        }\n\t\n\t        // create the css class\n\t        if(privateOptions.default) {\n\t            var jssSheet = defaultJss\n\t        } else {\n\t            var jssSheet = jss\n\t        }\n\t\n\t        jssSheet.set('.'+this.className, cssProperties)\n\t\n\t        //if(module.exports.isDev) {\n\t            this.styleDefinitions = {}\n\t            this.styleDefinitions['.'+this.className] = cssProperties\n\t        //}\n\t\n\t        // create label styles\n\t        if(Object.keys(labelStyles).length > 0) {\n\t            var baseStyle = utils.merge({}, cssProperties, this.componentStyleMap)\n\t\n\t            for(var label in labelStyles) {\n\t                if(isStyleObject(labelStyles[label])) {\n\t                    this.labelStyleMap[label] = labelStyles[label]\n\t                } else {\n\t                    var mergedStyle = utils.merge({}, baseStyle, labelStyles[label])\n\t                    this.labelStyleMap[label] = Style(mergedStyle, {inLabel:true})\n\t                }\n\t            }\n\t        }\n\t\n\t        // create pseudoclass styles\n\t        if(Object.keys(pseudoClassStyles).length > 0) {\n\t\n\t            var tieredPseudoClasses = createTieredPseudoClasses(this, pseudoClassStyles)\n\t            pseudoclassCombinations(tieredPseudoClasses) // mutates tieredPseudoClasses\n\t\n\t            // turn the emulatable pseudo classes into Style objects\n\t            // also build up the set of psuedoclasses that will be emulated\n\t            // also build up a map of pseudoclasses-to-emulate to the emulation functions for those pseudoclasses\n\t            var pseudoClasesToEmulate = []\n\t            var preSplitPseudoClasses = [] // a list where each element looks like: [pseudoClassList, styleObject]  (this is primarily for performance - so we don't have to split the key every time we check for state changes)\n\t            var pseudoClassesToEmulationInfo = {}\n\t            for(var key in tieredPseudoClasses) {\n\t                if(isStyleObject(tieredPseudoClasses[key])) {\n\t                    tieredPseudoClasses[key] = tieredPseudoClasses[key]\n\t                } else {\n\t                    var newStyle = Style(utils.merge({}, cssProperties, tieredPseudoClasses[key])) // pseudoClassStyles merged with parent css styles\n\t\n\t                    // merge in componentStyleMap and labelStyleMap\n\t                    for(var k in this.componentStyleMap) {\n\t                        if(newStyle.componentStyleMap[k] === undefined)\n\t                            newStyle.componentStyleMap[k] = this.componentStyleMap[k]\n\t                    }\n\t                    for(var k in this.labelStyleMap) {\n\t                        if(newStyle.labelStyleMap[k] === undefined)\n\t                            newStyle.labelStyleMap[k] = this.labelStyleMap[k]\n\t                    }\n\t\n\t                    tieredPseudoClasses[key] = newStyle\n\t                }\n\t\n\t\n\t                var pseudoClassList = key.split(\":\")\n\t                for(var n=0; n<pseudoClassList.length; n++) {\n\t                    var pseudoClass = pseudoClassList[n]\n\t                    if(pseudoClasesToEmulate.indexOf(pseudoClass) === -1) {\n\t                        pseudoClasesToEmulate.push(pseudoClass)\n\t\n\t                        var pseudoClassParts = getPseudoClassParts(pseudoClass)\n\t                        var fns = emulatedPseudoClasses[pseudoClassParts.class]\n\t                        var info = {fns: fns}\n\t                        if(fns.processParameter !== undefined) {\n\t                            info.parameter = fns.processParameter(pseudoClassParts.parameter)\n\t                        }\n\t                        pseudoClassesToEmulationInfo[pseudoClass] = info\n\t                    }\n\t                }\n\t\n\t                preSplitPseudoClasses.push([pseudoClassList, tieredPseudoClasses[key]])\n\t            }\n\t\n\t            // create functions that initialize and keep track of state\n\t            var initializeState = function(component) {\n\t                var state = {}\n\t                for(var n=0; n<pseudoClasesToEmulate.length; n++) {\n\t                    var pseudoClass = pseudoClasesToEmulate[n]\n\t                    var pseudoClassEmulationInfo = pseudoClassesToEmulationInfo[pseudoClass]\n\t                    state[pseudoClass] = pseudoClassEmulationInfo.fns.check(component, pseudoClassEmulationInfo.parameter)\n\t                }\n\t\n\t                return state\n\t            }\n\t\n\t            var that = this\n\t            var changeStyleIfNecessary = function(currentStyle, component, state) {\n\t                var longestMatchingLength = 0;\n\t                var mostSpecificMatchingStyle = that; // if nothing else matches, change back to the base style object\n\t                for(var n=0; n<preSplitPseudoClasses.length; n++) {\n\t                    var pseudoClassList = preSplitPseudoClasses[n][0]\n\t                    for(var j=0; j<pseudoClassList.length; j++) {\n\t                        if(!state[pseudoClassList[j]]) {\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    if(j === pseudoClassList.length && j > longestMatchingLength) {\n\t                        longestMatchingLength = j\n\t                        mostSpecificMatchingStyle = preSplitPseudoClasses[n][1]\n\t                    }\n\t                }\n\t\n\t                if(mostSpecificMatchingStyle !== currentStyle) {\n\t                    component.style = mostSpecificMatchingStyle\n\t\n\t                    //blockStyleUtils.setCurrentStyle(component, mostSpecificMatchingStyle)\n\t                    //blockStyleUtils.propogateStyleSet(component.children, component.computedStyleMap) // propogate styles to children\n\t                }\n\t            }\n\t\n\t            // setup pseudoclass emulation with $setup and $kill handlers\n\t\n\t            var wrapSetupAndKill = function(style) {\n\t                var originalSetup = style.setup\n\t                style.setup = function(component) {\n\t                    var that = this\n\t\n\t                    this._styleSetupStates = {} // maps pseudoClass to setupState\n\t                    var state = initializeState(component)\n\t                    for(var pseudoClass in pseudoClassesToEmulationInfo) {\n\t                        ;(function(pseudoClass, emulationInfo){   // close over those variables (so they keep the value they had when the function was setup)\n\t                            that._styleSetupStates[pseudoClass] = emulationInfo.fns.setup(component, function() { // start\n\t                                state[pseudoClass] = true\n\t                                changeStyleIfNecessary(that, component, state)\n\t                            }, function() { // end\n\t                                state[pseudoClass] = false\n\t                                changeStyleIfNecessary(that, component, state)\n\t                            }, emulationInfo.parameter)\n\t\n\t                        })(pseudoClass, pseudoClassesToEmulationInfo[pseudoClass])\n\t                    }\n\t\n\t                    changeStyleIfNecessary(that, component, state)\n\t\n\t                    if(originalSetup !== undefined) {\n\t                        originalSetup.apply(this, arguments)\n\t                    }\n\t                }\n\t\n\t                var originalKill = style.kill\n\t                style.kill = function(component) {\n\t                    for(var pseudoClass in pseudoClassesToEmulationInfo) {\n\t                        var emulationInfo = pseudoClassesToEmulationInfo[pseudoClass]\n\t                        emulationInfo.fns.kill(component, this._styleSetupStates[pseudoClass])\n\t                    }\n\t\n\t                    if(originalKill !== undefined) {\n\t                        originalKill.apply(this, arguments)\n\t                    }\n\t                }\n\t            }\n\t\n\t            // wrap all the setup and kill functions\n\t\n\t            for(var key in tieredPseudoClasses) {\n\t                var style = tieredPseudoClasses[key]\n\t                wrapSetupAndKill(style)\n\t            }\n\t\n\t            wrapSetupAndKill(this)\n\t        }\n\t    }\n\t\n\t    // instance properties\n\t\n\t    this.className          // the css classname for this style\n\t    this.componentStyleMap; // maps a Component name to a Style object for that component\n\t    this.labelStyleMap;     // maps a label name to a Style object for that label\n\t    this.setup;             // run some javascript on any element this class is applied to\n\t    this.kill;              // a function to run on removal of the style (should reverse setup)\n\t\n\t    // gets the style object for a component based on the current style object (takes into account whether the component has a label\n\t    this.get = function(component) {\n\t        if(component.label !== undefined) {\n\t            var labelStyle = this.labelStyleMap[component.label]\n\t            if(labelStyle !==  undefined) {\n\t                return labelStyle\n\t            }\n\t        }\n\t        // else\n\t        return this\n\t    }\n\t})\n\t\n\t\n\t// private\n\t\n\t\n\t// returns a two-level map where the top-level keys are emulatable psuedo classes, and non-emulatable pseudo classes are at the second level\n\t// the classes will also be sorted and deduped\n\t// Example return value: {\"hover:lastChild\": {color:'red', \"$$visited:disabled\": {fontWeight: 'bold'}}, }\n\t// parameters:\n\t    // style - the style object being created\n\t    // pseudoClassStyles - a flat object where each key is a list of pseudoclasses separated by colons (e.g. \"hover\" or \"hover:focus\") and the value is an object of styles that don't contain pseudoclasses\n\tfunction createTieredPseudoClasses(style, pseudoClassStyles) {\n\t    var tieredPseudoClasses = {} // the two-level map\n\t    for(var key in pseudoClassStyles) {\n\t        var value = pseudoClassStyles[key]\n\t\n\t        // split key into pseudoclass list\n\t        var pseudoClassList = key.split(\":\")\n\t        var emulatablePseudoClasses = []\n\t        var nonEmulatablePseudoClasses = []\n\t        for(var n in pseudoClassList) {\n\t            var pseudoClass = pseudoClassList[n]\n\t            var pseudoClassParts = getPseudoClassParts(pseudoClass)\n\t            if(pseudoClassParts.class in emulatedPseudoClasses) {\n\t                emulatablePseudoClasses.push(pseudoClass)\n\t            } else {\n\t                nonEmulatablePseudoClasses.push(pseudoClass)\n\t            }\n\t        }\n\t\n\t        // todo: add a third branch as an optimization: if the Style can be rendered without emulation - do that\n\t        if(emulatablePseudoClasses.length === 0) { // if none of the pseudoclasses can be emulated using javascript\n\t            validatePurePseudoClassStyles(key, value)                        // then validate the value and\n\t            createPseudoClassRules(style, key, '.'+style.className+\":\"+key, value)   // create pseudoClassRules\n\t\n\t        } else { // if some of the pseudoclasses can be emulated using javascript\n\t\n\t            emulatablePseudoClasses.sort()\n\t            var emulatablePseudoClassKey = emulatablePseudoClasses.join(':')\n\t            if(tieredPseudoClasses[emulatablePseudoClassKey] === undefined)\n\t                tieredPseudoClasses[emulatablePseudoClassKey] = {}\n\t\n\t            if(nonEmulatablePseudoClasses.length === 0) {\n\t                utils.merge(tieredPseudoClasses[emulatablePseudoClassKey], value)\n\t            } else {\n\t                nonEmulatablePseudoClasses.sort()\n\t                var nonEmulatablePsuedoClassKey = nonEmulatablePseudoClasses.join(':')\n\t\n\t                var secondTier = {}\n\t                secondTier['$$'+nonEmulatablePsuedoClassKey] = value\n\t\n\t                utils.merge(tieredPseudoClasses[emulatablePseudoClassKey], secondTier)\n\t            }\n\t        }\n\t    }\n\t\n\t    return tieredPseudoClasses\n\t}\n\t\n\t\n\t\n\t// make combinations of the emulatable pseudoclasses, so that they combine like the non-emulated ones do\n\t// info about mathematical combination: https://en.wikipedia.org/wiki/Combination\n\t// mutates tieredPseudoClasses\n\tfunction pseudoclassCombinations(tieredPseudoClasses) {\n\t    var tieredPseudoClassesKeys = Object.keys(tieredPseudoClasses).reverse().map(function(v) {    // reverse first so that more specific pseudoclasses go first\n\t        return {key: v, parts: v.split(':')} // so it doesn't have to split every time\n\t    })\n\t\n\t    for(var n=0; n<tieredPseudoClassesKeys.length; n++) {\n\t        var keyA = tieredPseudoClassesKeys[n]\n\t        for(var k=2; k <= tieredPseudoClassesKeys.length; k++) { // k is the number of psuedoclasses to combine\n\t            for(var j=n+1; j<tieredPseudoClassesKeys.length-(k-2); j++) {\n\t                var result = combinePseudoclasses(tieredPseudoClasses, [keyA].concat(tieredPseudoClassesKeys.slice(j, k)))\n\t                if(result.key in tieredPseudoClasses) {\n\t                    utils.merge(tieredPseudoClasses[result.key], result.value)\n\t                } else { // new key\n\t                    tieredPseudoClasses[result.key] = result.value\n\t                }\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\t\n\t\n\t// keys is a list of objects where each object has the members:\n\t    // key - the original string key\n\t    // parts - the key split by \":\"\n\t// returns an object with the following members:\n\t    // key - the new combined key\n\t    // value - the new merged value\n\tvar combinePseudoclasses = function(pseudoclasses, keys) {\n\t    var resultKeyParts = keys[0].parts\n\t    var resultValue = utils.merge({}, pseudoclasses[keys[0].key]) // make a copy\n\t    for(var n=1; n<keys.length; n++) {\n\t        var key = keys[n]\n\t        // merge all psuedoclasses that don't already exist into the resultKey\n\t        for(var j=0; j<key.parts.length; j++) {\n\t            var part = key.parts[j]\n\t            if(resultKeyParts.indexOf(part) === -1) {\n\t                resultKeyParts.push(part)\n\t            }\n\t        }\n\t\n\t        // merge the value into resultValue\n\t        utils.merge(resultValue, pseudoclasses[key.key])\n\t    }\n\t\n\t    return {key: resultKeyParts.join(':'), value: resultValue}\n\t}\n\t\n\t// a map of pseudoclass names and how they are emulated with javascript\n\t// each pseudoclass sets up the following functions:\n\t    // check - a function that checks if that pseudoclass currently applies to the component when its called\n\t    // setup - calls a callback when the pseudoClass starts and stops applying\n\t        // should return an object that will be passed to the kill function (as its 'state' parameter)\n\t    // kill - cleans up anything set up in the 'setup' function\n\t    // processParameter - takes the pseudoclass parameter and returns some object representing it that will be used by the setup and check functions\n\tvar emulatedPseudoClasses = {\n\t    hover: {\n\t        check: function(component) {\n\t            var nodes = document.querySelectorAll( \":hover\" )\n\t            for(var n=0; n<nodes.length; n++) {\n\t                if(nodes[n] === component.domNode) {\n\t                    return true\n\t                }\n\t            }\n\t            return false\n\t        },\n\t        setup: function(component, startCallback, endCallback) {\n\t            component.on(\"mouseover\", function() {\n\t                startCallback()\n\t            })\n\t            component.on(\"mouseout\", endCallback)\n\t\n\t            return {start: startCallback, end: endCallback}\n\t        },\n\t        kill: function(component, state) {\n\t            component.off(\"mouseover\", state.start)\n\t            component.off(\"mouseout\", state.end)\n\t        }\n\t    },\n\t    checked: {\n\t        check: function(component) {\n\t            return component.selected\n\t        },\n\t        setup: function(component, startCallback, endCallback) {\n\t            var setupState = {}\n\t            component.on(\"change\", setupState.listener = function() {\n\t                if(component.selected) {\n\t                    startCallback()\n\t                } else {\n\t                    endCallback()\n\t                }\n\t            })\n\t\n\t            return setupState\n\t        },\n\t        kill: function(component, state) {\n\t            component.removeListener(\"change\", state.listener)\n\t        }\n\t    },\n\t    required: {\n\t        check: function(component) {\n\t            return component.attr('required') !== undefined\n\t        },\n\t        setup: function(component, startCallback, endCallback) {\n\t            var observer = new MutationObserver(function() {\n\t                if(component.attr('required') !== undefined) {\n\t                    startCallback()\n\t                } else {\n\t                    endCallback()\n\t                }\n\t            })\n\t\n\t            observer.observe(component.domNode, {attributes: true})\n\t\n\t            return {observer: observer}\n\t        },\n\t        kill: function(component, state) {\n\t            state.observer.disconnect()\n\t        }\n\t    },\n\t    'last-child': {\n\t        check: function(component) {\n\t            return nthLastChildCheck(component, '1')\n\t        },\n\t        setup: function(component, startCallback, endCallback) {\n\t            var observer = new MutationObserver(function() {\n\t                if(nthLastChildCheck(component, '1')) {\n\t                    startCallback()\n\t                } else {\n\t                    endCallback()\n\t                }\n\t            })\n\t\n\t            var setupObserver = function() {\n\t                // note that since this uses the component parent rather than domNode.parentNode, this won't work for components added to non-component nodes (and there's no good way to do it, because you would have to poll for parent changes)\n\t                observer.observe(component.parent.domNode, {childList: true})\n\t            }\n\t\n\t            if(component.parent !== undefined) {\n\t                setupObserver()\n\t            }\n\t\n\t            component.on('newParent', function() {\n\t                setupObserver()\n\t            })\n\t            component.on('parentRemoved', function() {\n\t                observer.disconnect()\n\t            })\n\t\n\t            return {observer: observer}\n\t        },\n\t        kill: function(component, state) {\n\t            state.observer.disconnect()\n\t        }\n\t    },\n\t    'nth-child': {\n\t        // todo: support full an+b parameters for nth-child https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-child\n\t        check: function(component, parameterCheck) {\n\t            return nthChildCheck(component, parameterCheck)\n\t        },\n\t        setup: function(component, startCallback, endCallback, parameterCheck) {\n\t\n\t            var checkAndCallCallbacks = function() {\n\t                if(nthChildCheck(component, parameterCheck)) {\n\t                    startCallback()\n\t                } else {\n\t                    endCallback()\n\t                }\n\t            }\n\t\n\t            var observer = new MutationObserver(function() {\n\t                checkAndCallCallbacks()\n\t            })\n\t\n\t            var setupObserver = function() {\n\t                // note that since this uses the component parent rather than domNode.parentNode, this won't work for components added to non-component nodes (and there's no good way to do it, because you would have to poll for parent changes)\n\t                observer.observe(component.parent.domNode, {childList: true})\n\t            }\n\t\n\t            if(component.parent !== undefined) {\n\t                setupObserver()\n\t            }\n\t\n\t            component.on('newParent', function() {\n\t                setupObserver()\n\t                checkAndCallCallbacks()\n\t            })\n\t            component.on('parentRemoved', function() {\n\t                observer.disconnect()\n\t                checkAndCallCallbacks()\n\t            })\n\t\n\t            return {observer: observer}\n\t        },\n\t        kill: function(component, state) {\n\t            state.observer.disconnect()\n\t        },\n\t        processParameter: function(parameter) {\n\t            return nthChildParameterFn(parameter)\n\t        }\n\t    },\n\t\n\t    // not's parameter is a statement consisting of pseudoclasses separated either by & or ,\n\t    // $$not(pseudoclass1&pseudoclass2,psuedoclass3) translates to the css :not(:pseudoclass1:pseudoclass2,:psuedoclass3)\n\t    /*not: {\n\t        check: function() {\n\t\n\t        },\n\t    }*/\n\t}\n\t\n\t// name is the name of the new pseudoclass\n\t// fns is an object with the members:\n\t    // check(component) - returns true if the pseudoclass applies to the component\n\t    // setup(component, startCallback, endCallback, parameter) - a function that should call startCallback when the pseudoclass starts applying, and endCallback when it stops applying\n\t        // parameter - the parameter passed to the pseudoclass (e.g. in :not(:first-child), \":first-child\" is the parameter)\n\t    // kill - a function that cleans up any event listeners or anything else set up in the 'setup' function\n\tmodule.exports.addPseudoClass = function(name, fns) {\n\t    if(emulatedPseudoClasses[name] !== undefined) throw new Error(\"The pseudoclass '\"+name+\"' is already defined.\")\n\t    // else\n\t    emulatedPseudoClasses[name] = fns\n\t}\n\t\n\t\n\tfunction nthChildCheck(component, testFn) {\n\t    if(component.domNode.parentNode === null)\n\t        return false\n\t\n\t    var children = component.domNode.parentNode.children                    // must be domNode.parentNode, because child nodes may not be Components\n\t    var index = Array.prototype.indexOf.call(children, component.domNode)\n\t    return testFn(index)\n\t}\n\t\n\tfunction nthLastChildCheck(component, parameter) {\n\t    if(component.domNode.parentNode === null)\n\t        return false\n\t\n\t    var children = component.domNode.parentNode.children                    // must be domNode.parentNode, because child nodes may not be Components\n\t    var index = children.length - parseInt(parameter)\n\t    return children[index] === component.domNode\n\t}\n\t\n\t// returns a function that takes an index and tell you if that index applies to the nthChildParameter\n\tvar nthChildParameter = /^(((-?\\d*)(([+-]\\d*)n?)?)|((-?\\d)*n?([+-]\\d*)?))$/\n\tfunction nthChildParameterFn(parameter) {\n\t    var parts = parameter.match(nthChildParameter)\n\t    if(parts === null)\n\t        throw new Error(\"nth-child parameter '\"+parameter+\"' isn't valid\")\n\t\n\t    if(parts[2] !== undefined) {\n\t        var constant = parts[3]\n\t        var variable = parts[5]\n\t    } else {\n\t        var constant = parts[8]\n\t        var variable = parts[7]\n\t    }\n\t\n\t    if(constant === undefined) constant = 0\n\t    else                       constant = parseInt(constant)\n\t    if(variable === undefined) variable = 0\n\t    else                       variable = parseInt(variable)\n\t\n\t    if(variable === 0) {\n\t        return function(index) {\n\t            return index+1 === constant\n\t        }\n\t    } else {\n\t        return function(index) {\n\t            return ((index+1-constant)/variable) % 1 === 0\n\t        }\n\t    }\n\t\n\t}\n\t\n\t// maps a style value to a css value\n\t// style values that are numbers are mapped to strings, usually with px postfix\n\tfunction cssValue(cssStyleName, value) {\n\t    // If a number was passed in, add 'px' to the (except for certain CSS properties) [also taken from jquery's code]\n\t    if(typeof(value) === \"number\" && cssNumber[cssStyleName] === undefined) {\n\t        return value+\"px\"\n\t    } else {\n\t        return value.toString()\n\t    }\n\t}\n\t\n\tfunction createPseudoClassRules(that, pseudoClass, selector, pseudoClassStyle) {\n\t\n\t    var pseudoClassCss = {}\n\t    for(var key in pseudoClassStyle) {\n\t        var value = pseudoClassStyle[key]\n\t\n\t        if(!(value instanceof Object)) {\n\t            var cssStyle = key\n\t            var cssStyleName = mapCamelCase(cssStyle)\n\t            pseudoClassCss[cssStyleName] = cssValue(cssStyleName, value)\n\t        } else {\n\t            throw new Error(\"All properties within the pseudoclasses '\"+pseudoClass+\"' must be css styles\")\n\t        }\n\t    }\n\t\n\t    // create immediate pseudo class style\n\t    defaultJss.set(selector, pseudoClassCss) // create the css class with the pseudoClass\n\t\n\t    //if(module.exports.isDev) {\n\t        that.styleDefinitions = {}\n\t        that.styleDefinitions[selector] = pseudoClassCss\n\t    //}\n\t}\n\t\n\t// throws exceptions for various style configurations that are unsupported by pure pseudo classes (ones that can't be emulated usuing javascript)\n\tfunction validatePurePseudoClassStyles(pseudoClass, pseudoClassStyles) {\n\t    for(var key in pseudoClassStyles) {\n\t        var value = pseudoClassStyles[key]\n\t\n\t        if(isStyleObject(value)) {\n\t            throw new Error(\"Can't set the pseudoclasses '\"+pseudoClass+\"' to a Style object\")\n\t        } else if(key === '$setup') {\n\t            throw new Error(\"$setup can't be used within the pseudoclasses '\"+pseudoClass+\"'\")\n\t        } else if(key === '$kill') {\n\t            throw new Error(\"$kill can't be used within the pseudoclasses '\"+pseudoClass+\"'\")\n\t        } else if(key.indexOf('$') === 0) {   // label style\n\t            throw new Error(\"Block labels can't be used within the pseudoclasses '\"+pseudoClass+\"'\")\n\t        }\n\t    }\n\t}\n\t\n\t// e.g. pulls out 'nth-child' and '2+3n' from 'nth-child(2+3n)'\n\tvar pseudoClassRegex = /^([^(]*)(\\((.*)\\))?$/\n\tfunction getPseudoClassParts(fullPsuedoClass) {\n\t    var x = fullPsuedoClass.match(pseudoClassRegex)\n\t    if(x === null) throw new Error(\"Pseudoclass '\"+fullPsuedoClass+\"' is invalid\")\n\t    return {class: x[1], parameter: x[3]}\n\t}\n\t\n\t\n\t// takes in a list of pseudoClassRules and changes any nesting like {hover: {focus: {}}} into something like {hover: {}, \"hover:focus\": {}}\n\t// also does some validation\n\tfunction flattenPseudoClassStyles(pseudoClass, pseudoClassStyle) {\n\t    var nonPseudoClassStyles = {}\n\t    var subpseudoClasses = {}\n\t    for(var key in pseudoClassStyle) {\n\t        var value = pseudoClassStyle[key]\n\t\n\t        if(key.indexOf('$$') === 0) { // pseudo-class style\n\t            var subPseudoClass = key.substr(2)\n\t            if(subPseudoClass === '') {\n\t                throw new Error(\"Empty pseudo-class name not valid (style key '$$')\")\n\t            }\n\t\n\t            subpseudoClasses[subPseudoClass] = value\n\t        } else {\n\t            nonPseudoClassStyles[key] = value\n\t        }\n\t    }\n\t\n\t    // create flattened styles (with merged in styles from its parent pseudoclass\n\t    var flattenedStyles = {}\n\t    for(var subPseudoClass in subpseudoClasses) {\n\t        var value = subpseudoClasses[subPseudoClass]\n\t\n\t        if(isStyleObject(value)) {\n\t            flattenedStyles[pseudoClass+\":\"+subPseudoClass] =  value\n\t        } else {\n\t            utils.merge(flattenedStyles, flattenPseudoClassStyles(pseudoClass+\":\"+subPseudoClass, utils.merge({}, nonPseudoClassStyles, value)))\n\t        }\n\t    }\n\t\n\t    // write the top-level pseudoClass\n\t    flattenedStyles[pseudoClass] = nonPseudoClassStyles\n\t\n\t    return flattenedStyles\n\t}\n\t\n\t\n\t// taken from jquery's code\n\tvar cssNumber = {\n\t    \"column-count\": 1,\n\t    \"fill-opacity\": 1,\n\t    \"flex-grow\": 1,\n\t    \"flex-shrink\": 1,\n\t    \"font-weight\": 1,\n\t    \"line-height\": 1,\n\t    \"opacity\": 1,\n\t    \"order\": 1,\n\t    \"orphans\": 1,\n\t    \"widows\": 1,\n\t    \"z-index\": 1,\n\t    \"zoom\": 1\n\t}\n\t\n\tfunction isStyleObject(o) {\n\t    return o.componentStyleMap !== undefined\n\t}\n\t\n\t\n\tvar asciiA = 'A'.charCodeAt(0), asciiZ = 'Z'.charCodeAt(0), difference = 'a'.charCodeAt(0) - asciiA\n\tfunction mapCamelCase(cssStyleName) {\n\t    for(var n=0; n<cssStyleName.length; n++) {\n\t        var ascii = cssStyleName.charCodeAt(n)\n\t        if(asciiA <= ascii && ascii <= asciiZ) { // found capital letter\n\t            cssStyleName = cssStyleName.slice(0, n) + '-'+String.fromCharCode(ascii+difference) + cssStyleName.slice(n+1)\n\t            n++ // increment a second time for the dash\n\t        }\n\t    }\n\t\n\t    return cssStyleName\n\t}\n\t\n\t// maps all the styles that are inherited by descendant nodes to their default values\n\t// source: http://stackoverflow.com/questions/5612302/which-css-styles-are-inherited\n\tvar defaultStyleValues = {\n\t    'azimuth': 'center',\n\t    'border-collapse': 'separate',\n\t    'border-spacing': '0',\n\t    'caption-side': 'top',\n\t    //'color': 'black',         // let this inherit\n\t    //'cursor': 'auto',         // let this one inherit - its weird otherwise\n\t    'direction': 'ltr',\n\t     display: 'inline-block', // changes the default display to inline-block\n\t    'elevation': '',\n\t    'empty-cells': 'show',\n\t    // 'font-family': '',       // let this inherit\n\t    // 'font-size': 'medium',   // let this inherit\n\t    //'font-style': 'normal',   // let this inherit\n\t    //'font-variant': 'normal', // let this inherit\n\t    //'font-weight': 'normal',  // let this inherit\n\t    'letter-spacing': 'normal',\n\t    'line-height': 'normal',\n\t    'list-style-image': 'none',\n\t    'list-style-position': 'outside',\n\t    'list-style-type': 'disc',\n\t    'orphans': '2',\n\t    'pitch-range': '',\n\t    'pitch': '',\n\t     position: 'relative', // changes the default positioning so that absolute is relative to its parent by default\n\t    'quotes': '',\n\t    'richness': '',\n\t    'speak-header': '',\n\t    'speak-numeral': '',\n\t    'speak-punctuation': '',\n\t    'speak': '',\n\t    'speak-rate': '',\n\t    'stress': '',\n\t    'text-align': 'left',\n\t    'text-indent': '0',\n\t    'text-transform': 'none',\n\t    //'visibility': 'visible',    // let this inherit - otherwise you just hide the container and not the contents\n\t    'voice-family': '',\n\t    'volume': '',\n\t    'white-space': 'normal',\n\t    'widows': '2',\n\t    'word-spacing': 'normal'\n\t}\n\t\n\tdefaultJss.set('.'+Style.defaultClassName, defaultStyleValues) // creates default css class in order to prevent inheritance\n\t\n\tdefaultJss.set('input', { // chrome and firefox user agent stylesheets mess with this otherwise\n\t    cursor: 'inherit'\n\t})\n\t\n\t/*private*/ module.exports.isDev; // should be set by Block\n\t\n\tvar computedStyles = module.exports.computedStyles = new HashMap() // stores a map from styleMap components, to the combined style map\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(26)\n\tvar Style = __webpack_require__(2)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t    //static properties\n\t\n\t    this.name = 'Canvas'\n\t\n\t    this.init = function(/*[label,] height, width*/) {\n\t        if(arguments.length === 2) {\n\t            var height = arguments[0]\n\t            var width = arguments[1]\n\t        } else {\n\t            var label = arguments[0]\n\t            var height = arguments[1]\n\t            var width = arguments[2]\n\t        }\n\t\n\t        this.domNode = document.createElement('canvas') // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t\n\t        this.label = label\n\t        this.height = height\n\t        this.width = width\n\t    }\n\t\n\t    // instance properties\n\t\n\t    Object.defineProperty(this, 'width', {\n\t        get: function() {\n\t            return this.domNode.width\n\t        }, set: function(v) {\n\t            this.domNode.width = v\n\t        }\n\t    })\n\t    Object.defineProperty(this, 'height', {\n\t        get: function() {\n\t            return this.domNode.height\n\t        }, set: function(v) {\n\t            this.domNode.height = v\n\t        }\n\t    })\n\t\n\t    this.context = function() {\n\t        return this.domNode.getContext.apply(this.domNode, arguments)\n\t    }\n\t\n\t    this.toImg = this.toDataURL = function() {\n\t        return this.domNode.toDataURL()\n\t    }\n\t});\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(26)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t\t// static properties\n\t\n\t    this.name = 'Container'\n\t\n\t\n\t\t// instance properties\n\t\n\t\tthis.init = function (/*[label,] content*/) {\n\t        if(typeof(arguments[0]) !== 'string') {\n\t            var contentArgs = arguments\n\t        } else {\n\t            var label = arguments[0]\n\t            var contentArgs = Array.prototype.slice.call(arguments, 1)\n\t        }\n\t\n\t        superclass.init.call(this) // superclass constructor\n\t\n\t        this.label = label\n\t\n\t\t\tif(contentArgs !== undefined)\n\t            this.add.apply(this,contentArgs)\n\t\t}\n\t})\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(26)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t    // static variables\n\t\n\t    this.name = 'Button'\n\t\n\t\n\t    // instance properties\n\t\n\t\tthis.init = function(/*[label,] text*/) {\n\t        if(arguments.length >= 2) {\n\t            var label = arguments[0]\n\t            var text = arguments[1]\n\t        } else {\n\t            var text = arguments[0]\n\t        }\n\t\n\t        this.domNode = document.createElement(\"input\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t\n\t        this.label = label\n\t\t\tthis.attr('type','button');\n\t\t\tthis.text = text\n\t\t}\n\t\n\t    Object.defineProperty(this, 'text', {\n\t        get: function() {\n\t            return this.attr('value')\n\t        },\n\t        set: function(text) {\n\t            this.attr('value', text)\n\t        }\n\t    })\n\t\n\t})\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(26)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\t// static variables\n\t    this.name = 'CheckBox'\n\t\n\t\t// instance methods\n\t\tthis.init = function(label) {\n\t        var that = this\n\t\n\t        this.domNode = document.createElement(\"input\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t\n\t        this.label = label\n\t\t\tthis.attr('type','checkbox')\n\t\t}\n\t\n\t    Object.defineProperty(this, 'selected', {\n\t        // returns whether or not the checkbox is checked\n\t        get: function() {\n\t            return this.domNode.checked\n\t        },\n\t        // sets the value of the checkbox to the passed value (true for checked)\n\t        set: function(checked) {\n\t            var newValue = checked === true\n\t            var curValue = this.domNode.checked\n\t            if(curValue === newValue) return;  // do nothing if nothing's changing\n\t\n\t            this.domNode.checked = newValue\n\t            this.emit('change') // the browser has no listenable event that is triggered on change of the 'checked' property\n\t        }\n\t    })\n\t})\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(26)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t    //static properties\n\t\n\t    this.name = 'Image'\n\t\n\t    this.init = function(/*[label,] imageSource*/) {\n\t        if(arguments.length === 1) {\n\t            var imageSource = arguments[0]\n\t        } else {\n\t            var label = arguments[0]\n\t            var imageSource = arguments[1]\n\t        }\n\t\n\t        this.domNode = document.createElement('img') // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t\n\t        var that = this\n\t\n\t        this.label = label\n\t        if(imageSource !==  undefined) this.src = imageSource\n\t    }\n\t\n\t    // instance properties\n\t\n\t    Object.defineProperty(this, 'src', {\n\t        get: function() {\n\t            return this.domNode.src\n\t        }, set: function(v) {\n\t            this.domNode.src = v\n\t        }\n\t    })\n\t});\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar proto = __webpack_require__(26)\n\t\n\tvar Block = __webpack_require__(1)\n\tvar Style = __webpack_require__(2)\n\t\n\tvar Item = __webpack_require__(20);\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t\t// static properties\n\t\n\t\tthis.Item = Item\n\t\n\t    this.name = 'List'\n\t\n\t\t// instance properties\n\t\n\t\tthis.init = function(/*[label,] [ordered,] listInit*/) {\n\t\t\tif(arguments[0] instanceof Array) {\n\t            var listInit = arguments[0]\n\t        } else {\n\t            if(arguments[1] instanceof Array) {\n\t                var listInit = arguments[1]\n\t            } else if(arguments[2] instanceof Array) {\n\t                var listInit = arguments[2]\n\t            }\n\t\n\t            if(typeof(arguments[0]) === 'boolean') {\n\t                var ordered = arguments[0]\n\t            } else {\n\t                if(typeof(arguments[1]) === 'boolean') {\n\t                    var ordered = arguments[1]\n\t                } else {\n\t                    var ordered = false // default\n\t                }\n\t\n\t                if(typeof(arguments[0]) === 'string') {\n\t                    var label = arguments[0]\n\t                }\n\t            }\n\t        }\n\t\n\t        if(ordered) {\n\t            var type = 'ol'\n\t        } else {\n\t            var type = 'ul'\n\t            this.defaultStyle = Style({\n\t                listStyleType: 'decimal'\n\t            })\n\t        }\n\t\n\t\n\t        this.domNode = document.createElement(type) // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t        this.label = label\n\t\n\t        if(listInit !== undefined) {\n\t            for(var n=0; n<listInit.length; n++) {\n\t                this.item(listInit[n])\n\t            }\n\t        }\n\t\t}\n\t\n\t\tthis.item = function() {\n\t\t\tvar item = Item.apply(this, arguments)\n\t        this.add(item)\n\t        return item\n\t\t}\n\t});\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar proto = __webpack_require__(26)\n\tvar EventEmitter = __webpack_require__(25).EventEmitter\n\t\n\tvar Block = __webpack_require__(1)\n\t\n\tvar randomStart = getRandomInt(0,999999) // a random number used to start off the numbers given to radio button names (using a random number in case there are somehow two different instances of blocks.js on the page)\n\t\n\t// A group of radio buttons\n\tmodule.exports = proto(EventEmitter, function(superclass) {\n\t\n\t\t// static properties\n\t\n\t    this.name = 'Radio'\n\t\n\t\t// instance properties\n\t\n\t\n\t    // required - If true, a radio button must always be selected. Otherwise, radio buttons can be deselected by clicking on them.\n\t\tthis.init = function(required) {\n\t        //this.selected\n\t        this.required = required === true || required === undefined\n\t        this.buttons = {} // maps values to the buttons that have each value\n\t        this.randomStart = randomStart++\n\t\t}\n\t\n\t    // returns a new radio button\n\t    this.button = function(/*[label,] value*/) {\n\t        if(arguments.length >= 2) {\n\t            var label = arguments[0]\n\t            var value = arguments[1]\n\t        } else {\n\t            var value = arguments[0]\n\t        }\n\t\n\t        if(this.buttons[value] !== undefined) {\n\t            throw new Error(\"Can't give a RadioButton the same value as another in the group (value: '\"+value+\"')\")\n\t        }\n\t\n\t        var button = RadioButton(this, label, value, \"_radioblock\"+this.randomStart)\n\t        this.buttons[value] = button\n\t\n\t        if(this.required && this._selected === undefined) {\n\t            button.selected = true\n\t        }\n\t\n\t        return button\n\t    }\n\t\n\t    // returns the RadioButton in the group that's selected (or undefined if none are selected)\n\t    Object.defineProperty(this, 'selected', {\n\t        get: function() {\n\t            return this._selected\n\t        },\n\t        set: function() {\n\t            throw new Error(\"Can't set selected on a Radio object\")\n\t        }\n\t    })\n\t\n\t    Object.defineProperty(this, 'val', {\n\t        // returns the value of the selected radio button in the group (undefined if none are selected)\n\t        get: function() {\n\t            var selected = this._selected\n\t            if(selected === undefined) return undefined\n\t            // else\n\t            return selected.attr('value')\n\t        },\n\t\n\t        // sets the value of the checkbox to the passed value (true for checked)\n\t        // throws an exception if none of the radio buttons have that value\n\t        // throws an exception if an unset is attempted for a required Radio set\n\t        set: function(value) {\n\t            if(value === undefined) {\n\t                var selected = this._selected\n\t                if(selected !== undefined) {\n\t                    selected.selected = false\n\t                }\n\t            } else {\n\t                var button = this.buttons[value]\n\t                if(button === undefined) throw new Error(\"There is no RadioButton in the group with the value: '\"+value+\"'\")\n\t\n\t                button.selected = true\n\t            }\n\t        }\n\t    })\n\t\n\t\n\t    // arguments can be one of the following:\n\t        // RadioButton, RadioButton, RadioButton, ...\n\t        // value, value, value, ... - each value is the value of the RadioButton to remove\n\t        // arrayOfRadioButtons\n\t        // arrayOfValues\n\t    this.remove = function() {\n\t        if(arguments[0] instanceof Array) {\n\t            var removals = arguments[0]\n\t        } else {\n\t            var removals = arguments\n\t        }\n\t\n\t        for(var n=0; n<removals.length; n++) {\n\t            var r = removals[n]\n\t\n\t            if(r instanceof RadioButton) {\n\t                var button = r\n\t                var value = r.val\n\t\n\t                if(this.buttons[value] !== r) {\n\t                    throw new Error(\"The button passed at index \"+n+\" is not part of the group.\")\n\t                }\n\t            } else {\n\t                var button = this.buttons[r]\n\t                var value = r\n\t\n\t                if(button === undefined) {\n\t                    throw new Error(\"There is no RadioButton in the group with the value: '\"+value+\"'\")\n\t                }\n\t            }\n\t\n\t            var originalSelected = this.selected\n\t            if(this.selected === button) {\n\t                this._selected = undefined\n\t            }\n\t\n\t            this.buttons[value].group = undefined // fully remove it from the group\n\t            delete this.buttons[value]\n\t        }\n\t\n\t        if(this.required && this.selected === undefined) {\n\t            for(var v in this.buttons) {\n\t                this.buttons[v].selected = true // just select the first one\n\t                break; // yes this doesn't loop\n\t            }\n\t        } else if(originalSelected !== this.selected) {\n\t            this.emit('change')\n\t        }\n\t    }\n\t\n\t})\n\t\n\tvar RadioButton = proto(Block, function(superclass) {\n\t    this.name = 'RadioButton'\n\t\n\t    this.init = function(radioGroup, label, value, name) {\n\t        this.domNode = document.createElement(\"input\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t\n\t        this.label = label\n\t        this.group = radioGroup\n\t\n\t        this.attr('type', 'radio')\n\t        this.attr('name', name) // the name is needed so that using tab to move through page elements can tab between different radio groups\n\t        this.val = value\n\t\n\t        var that = this\n\t\t\tthis.on(\"mousedown\",function(event) {\n\t            event.preventDefault()           // this needs to be here otherwise the radio button can't be changed\n\t\n\t\t\t\tif(that.group.required) {\n\t                if(that.selected === false) {\n\t                    that.selected = true\n\t                }\n\t            } else {\n\t                that.selected = !that.selected // toggle\n\t            }\n\t\t\t})\n\t        this.on(\"click\",function(event) {\n\t            event.preventDefault()         // this needs to be here otherwise the radio button can't be *unset*\n\t        })\n\t        this.on(\"keydown\",function(event) {\n\t            if(event.keyCode === 40 || event.keyCode === 39) { // down or right\n\t                event.preventDefault()         // this needs to be here otherwise the radio button strangely calls the click handler which causes things to mess up\n\t                that.selectNext()\n\t            } else if(event.keyCode === 38 || event.keyCode === 37) { // up or left\n\t                event.preventDefault()         // this needs to be here otherwise the radio button strangely calls the click handler which causes things to mess up\n\t                that.selectPrevious()\n\t            }\n\t        })\n\t    }\n\t\n\t    Object.defineProperty(this, 'val', {\n\t        // returns the value attribute of the checkbox\n\t        get: function() {\n\t            return this.attr('value')\n\t        },\n\t\n\t        // sets the value attribute of the checkbox\n\t        set: function(value) {\n\t            if(this.group.buttons[value] !== undefined) {\n\t                throw new Error(\"Can't give a RadioButton the same value as another in the group (value: '\"+value+\"')\")\n\t            }\n\t\n\t            var oldValue = this.val\n\t            this.attr('value', value)\n\t            if(oldValue !== undefined) delete this.group.buttons[oldValue]\n\t            this.group.buttons[value] = this\n\t        }\n\t    })\n\t\n\t\n\t    Object.defineProperty(this, 'selected', {\n\t        // returns whether or not the checkbox is checked\n\t        get: function() {\n\t            return this.domNode.checked\n\t        },\n\t\n\t        // sets the selected state of the checkbox to the passed value (true for checked)\n\t        set: function(value) {\n\t            var booleanValue = value === true\n\t            if(this.selected === value) return; // ignore if there's no change\n\t\n\t            if(booleanValue) {\n\t                var previouslySelected = this.group.selected\n\t                setButtonInGroup(this.group, this)\n\t                if(previouslySelected !== undefined)\n\t                    previouslySelected.emit('change')\n\t            } else {\n\t                if(this.group.required) throw new Error(\"Can't unset this Radio set, a value is required.\")\n\t                this.domNode.checked = false\n\t                this.group._selected = undefined\n\t            }\n\t            this.emit('change') // the browser has no listenable event that is triggered on change of the 'checked' property\n\t            this.group.emit('change')\n\t        }\n\t    })\n\t\n\t    this.selectNext = function() {\n\t        selectSibling(this,1)\n\t    }\n\t    this.selectPrevious = function() {\n\t        selectSibling(this,-1)\n\t    }\n\t\n\t})\n\t\n\t// direction can be +1 or -1\n\tfunction selectSibling(button, direction) {\n\t    var buttons = button.group.buttons\n\t    var values = Object.keys(buttons)\n\t    var index = values.indexOf(button.attr('value'))\n\t    if(direction === 1 && index === values.length-1) {\n\t        var buttonToSelect = buttons[values[0]]\n\t    } else if(direction === -1 && index === 0) {\n\t        var buttonToSelect = buttons[values[values.length-1]]\n\t\n\t    } else {\n\t        var buttonToSelect = buttons[values[index+direction]]\n\t    }\n\t\n\t    buttonToSelect.selected = true\n\t    buttonToSelect.focus()\n\t}\n\t\n\tfunction setButtonInGroup(group, button) {\n\t    var selected = group._selected\n\t    if(selected !== undefined) selected.domNode.checked = false\n\t    button.domNode.checked = true\n\t    group._selected = button\n\t}\n\t\n\tfunction getRandomInt(min, max) {\n\t  return Math.floor(Math.random() * (max - min)) + min;\n\t}\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(26)\n\t\n\tvar Option = __webpack_require__(21)\n\t\n\t// emits a 'change' event when its 'val' changes\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t\t// static variables\n\t\n\t    this.name = 'Select'\n\t\n\t    this.Option = Option\n\t\n\t\tthis.init = function(/*[label,] options*/) {\n\t        if(arguments[0] instanceof Object) {\n\t            var options = arguments[0]\n\t        } else {\n\t            var label = arguments[0]\n\t            var options = arguments[1]\n\t        }\n\t\n\t        this.domNode = document.createElement(\"select\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t        this.label = label\n\t\n\t        this.options = {}\n\t\n\t\t\tfor(var value in options) {\n\t\t\t\tthis.option(value, options[value])\n\t\t\t}\n\t\t}\n\t\n\t\n\t\t// instance methods\n\t\n\t    Object.defineProperty(this, 'val', {\n\t        // returns the value that is selected\n\t        get: function() {\n\t            for(var value in this.options) {\n\t                if(this.options[value].selected) {\n\t                    return value\n\t                }\n\t            }\n\t        },\n\t\n\t        set: function(value) {\n\t            var option = this.options[value]\n\t            if(option === undefined) throw new Error(\"There is no Option in the Select with the value: '\"+value+\"'\")\n\t            option.selected = true\n\t        }\n\t    })\n\t\t\n\t\tthis.option = function(/*[label,] value,text*/) {\n\t        if(arguments.length === 2) {\n\t            var value = arguments[0]\n\t            var text = arguments[1]\n\t        } else if(arguments.length === 3) {\n\t            var label = arguments[0]\n\t            var value = arguments[1]\n\t            var text = arguments[2]\n\t        } else {\n\t            throw new Error(\"Invalid number of arguments\")\n\t        }\n\t\n\t        var newOption = Option(label, value,text)\n\t        this.add(newOption)\n\t\n\t        return newOption\n\t\n\t\t}\n\t\n\t    // same interface as Block.addAt\n\t    /*override*/ this.addAt = function(index/*, nodes...*/) {\n\t        var that = this\n\t\n\t        var nodesToAdd = Block.normalizeAddAtArguments.apply(this, arguments)\n\t\n\t        // validation first\n\t        nodesToAdd.forEach(function(option) {\n\t            if(that.options[option.val] !== undefined) {\n\t                throw new Error(\"Can't give an Option the same value as another in the Select (value: '\"+option.val+\"')\")\n\t            }\n\t        })\n\t\n\t        superclass.addAt.call(this, index, nodesToAdd)\n\t\n\t        // Select specific state modifications - this must be done after the superclass call in case an error is thrown from it\n\t        var anyWereSelected = false\n\t        nodesToAdd.forEach(function(option) {\n\t            if(option.selected) anyWereSelected = true\n\t            that.options[option.val] = option\n\t\n\t            // set up Select events\n\t            // todo: remove events when the Option is removed\n\t\n\t            option.on(\"mousedown\",function(event) {\n\t                option.parent.val = option.val      // select this one\n\t            })\n\t        })\n\t\n\t        if(anyWereSelected) {\n\t            this.emit('change')\n\t        }\n\t    }\n\t\n\t    // same interface as Block.remove\n\t    /*override*/ this.remove = function() {\n\t        var that = this\n\t\n\t        var removalIndexes = Block.normalizeRemoveArguments.apply(this, arguments)\n\t        var removals = removalIndexes.map(function(index) {\n\t            return that.children[index]\n\t        })\n\t\n\t        superclass.remove.call(this, removalIndexes)\n\t\n\t        // Select specific state modifications - this must be done after the superclass call in case an error is thrown from it\n\t        var theSelectedWasRemoved = false\n\t        removals.forEach(function(option) {\n\t            if(option.selected) theSelectedWasRemoved = true\n\t            delete that.options[option.val]\n\t        })\n\t\n\t        if(theSelectedWasRemoved) {\n\t            //this.children[0].selected = true // I think the browser does this automatically??\n\t            this.emit('change')\n\t        }\n\t    }\n\t\n\t\n\t    // private\n\t\n\t    this.prepareForValueChange = function(values) {\n\t        var value = values[0]\n\t\n\t        for(var optionValue in this.options) {\n\t            if(optionValue !== value) {\n\t                var option = this.options[optionValue]\n\t                if(option.selected === true) {\n\t                    option.setSelectedQuiet(false)\n\t                }\n\t            }\n\t        }\n\t    }\n\t})\n\t\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar proto = __webpack_require__(26)\n\t\n\tvar Block = __webpack_require__(1)\n\tvar Style = __webpack_require__(2)\n\t\n\tvar Header = __webpack_require__(22);\n\tvar Row = __webpack_require__(23);\n\tvar Cell = __webpack_require__(24);\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t\t// static properties\n\t\n\t    this.name = 'Table'\n\t\n\t    this.defaultStyle = Style({\n\t        borderSpacing: 0\n\t    })\n\t\n\t    this.Row = Row\n\t\tthis.Header = Header\n\t    this.Cell = Cell\n\t\n\t\n\t\t// instance properties\n\t\n\t\tthis.init = function(/*[label,] tableInit*/) {\n\t\t\tif(arguments[0] instanceof Array) {\n\t            var tableInit = arguments[0]\n\t        } else {\n\t            var label = arguments[0]\n\t            var tableInit = arguments[1]\n\t        }\n\t\n\t        this.domNode = document.createElement(\"table\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t        this.label = label\n\t\n\t        if(tableInit !== undefined) {\n\t            for(var n=0; n<tableInit.length; n++) {\n\t                this.row(tableInit[n])\n\t            }\n\t        }\n\t\t}\n\t\t\n\t\tthis.header = function(/*[]label,] listOfBlocksOrText*/) {\n\t        return headerOrRegularRow(this, Header, arguments)\n\t\t}\n\t\n\t\tthis.row = function() {\n\t\t\treturn headerOrRegularRow(this, Row, arguments)\n\t\t}\n\t});\n\t\n\tfunction headerOrRegularRow(that, Prototype, args) {\n\t    var row = Prototype.apply(undefined, args)\n\t    that.add(row)\n\t    return row\n\t}\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(26)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t\t// static variables\n\t\n\t    this.name = 'TextArea'\n\t\n\t\tthis.init = function(label) {\n\t        this.domNode = document.createElement(\"textarea\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t\t\tthis.label = label\n\t\t}\n\t\n\t\n\t\t// instance properties\n\t\n\t\n\t    Object.defineProperty(this, 'val', {\n\t        // returns the value of the Option\n\t        get: function() {\n\t            return this.domNode.value\n\t        },\n\t\n\t        // sets the value of the Option\n\t        set: function(value) {\n\t            if(this.val === value) return; // do nothing if there's no change\n\t\n\t            this.domNode.value = value\n\t            this.emit('change')\n\t        }\n\t    })\n\t});\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(26)\n\t\n\tvar domUtils = __webpack_require__(19)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t\t// static properties\n\t\n\t    this.name = 'TextField'\n\t\n\t\tthis.init = function(/*[label,] password*/) {\n\t        if(arguments.length === 1) {\n\t            var password = arguments[0]\n\t        } else if(arguments.length > 1) {\n\t            var label = arguments[0]\n\t            var password = arguments[1]\n\t        }\n\t\n\t        this.domNode = document.createElement(\"input\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t\n\t\t\tthis.label = label\n\t        this.domNode.className = 'field'\n\t\t\tdomUtils.setAttribute(this.domNode,'type','text');\n\t        if(password)\n\t            domUtils.setAttribute(this.domNode, 'type', 'password')\n\t\t}\n\t\n\t\n\t\t// instance properties\n\t\n\t    Object.defineProperty(this, 'val', {\n\t        // returns the value of the Option\n\t        get: function() {\n\t            return this.domNode.value\n\t        },\n\t\n\t        // sets the value of the Option\n\t        set: function(value) {\n\t            if(this.val === value) return; // do nothing if there's no change\n\t\n\t            this.domNode.value = value\n\t            this.emit('change')\n\t        }\n\t    })\n\t\n\t});\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(26)\n\tvar Style = __webpack_require__(2)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t    //static properties\n\t\n\t    this.name = 'Text'\n\t\n\t    this.defaultStyle = Style({\n\t        whiteSpace: 'pre'\n\t    })\n\t\n\t    this.init = function(/*[label,] text*/) {\n\t        if(arguments.length === 1) {\n\t            var text = arguments[0]\n\t        } else {\n\t            var label = arguments[0]\n\t            var text = arguments[1]\n\t        }\n\t\n\t        if (text === undefined) text = '';\n\t\n\t        superclass.init.call(this) // superclass constructor\n\t\n\t        var that = this\n\t\n\t        this.label = label\n\t        this.text = text\n\t\n\t        this.on(\"input\",function(data) {\n\t            var eventData = {newText:data.srcElement.textContent,oldText:that.oldText};\n\t            that.oldText = eventData.newText;\n\t            //that.emit(\"input\",eventData);\n\t        });\n\t\n\t        this.on(\"blur\",function(data) {\n\t            var eventData = {newText:data.srcElement.textContent,oldText:that.lastFocus};\n\t            that.lastFocus = eventData.newText;\n\t            //that.emit(\"blur\",eventData);\n\t        });\n\t    }\n\t\n\t    // instance properties\n\t\n\t    Object.defineProperty(this, 'text', {\n\t        get: function() {\n\t            return this.domNode.textContent\n\t        }, set: function(v) {\n\t            this.domNode.innerText = v   // apparently textContent can't be set or something\n\t        }\n\t    })\n\t});\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t * JSS v0.6 - JavaScript Stylesheets\r\n\t * https://github.com/Box9/jss\r\n\t *\r\n\t * Copyright (c) 2011, David Tang\r\n\t * MIT Licensed (http://www.opensource.org/licenses/mit-license.php)\r\n\t */\r\n\tvar jss = (function() {\r\n\t    var adjSelAttrRegex = /((?:\\.|#)[^\\.\\s#]+)((?:\\.|#)[^\\.\\s#]+)/g;\r\n\t    var doubleColonPseudoElRegex = /(::)(before|after|first-line|first-letter|selection)/;\r\n\t    var singleColonPseudoElRegex = /([^:])(:)(before|after|first-line|first-letter|selection)/;\r\n\t    var singleColonForPseudoElements; // flag for older browsers\r\n\t\r\n\t    function getSelectorsAndRules(sheet) {\r\n\t        var rules = sheet.cssRules || sheet.rules || [];\r\n\t        var results = {};\r\n\t        for (var i = 0; i < rules.length; i++) {\r\n\t            // Older browsers and FF report pseudo element selectors in an outdated format\r\n\t            var selectorText = toDoubleColonPseudoElements(rules[i].selectorText);\r\n\t            if (!results[selectorText]) {\r\n\t                results[selectorText] = [];\r\n\t            }\r\n\t            results[selectorText].push({\r\n\t                sheet: sheet,\r\n\t                index: i,\r\n\t                style: rules[i].style\r\n\t            });\r\n\t        }\r\n\t        return results;\r\n\t    }\r\n\t\r\n\t    function getRules(sheet, selector) {\r\n\t        var rules = sheet.cssRules || sheet.rules || [];\r\n\t        var results = [];\r\n\t        // Browsers report selectors in lowercase\r\n\t        selector = selector.toLowerCase();\r\n\t        for (var i = 0; i < rules.length; i++) {\r\n\t            var selectorText = rules[i].selectorText;\r\n\t            // Note - certain rules (e.g. @rules) don't have selectorText\r\n\t            if (selectorText && (selectorText == selector || selectorText == swapAdjSelAttr(selector) || selectorText == swapPseudoElSyntax(selector))) {\r\n\t                results.push({\r\n\t                    sheet: sheet,\r\n\t                    index: i,\r\n\t                    style: rules[i].style\r\n\t                });\r\n\t            }\r\n\t        }\r\n\t        return results;\r\n\t    }\r\n\t\r\n\t    function addRule(sheet, selector) {\r\n\t        var rules = sheet.cssRules || sheet.rules || [];\r\n\t        var index = rules.length;\r\n\t        var pseudoElementRule = addPseudoElementRule(sheet, selector, rules, index);\r\n\t\r\n\t        if (!pseudoElementRule) {\r\n\t            addRuleToSheet(sheet, selector, index);\r\n\t        }\r\n\t\r\n\t        return {\r\n\t            sheet: sheet,\r\n\t            index: index,\r\n\t            style: rules[index].style\r\n\t        };\r\n\t    };\r\n\t\r\n\t    function addRuleToSheet(sheet, selector, index) {\r\n\t        if (sheet.insertRule) {\r\n\t            sheet.insertRule(selector + ' { }', index);\r\n\t        } else {\r\n\t            sheet.addRule(selector, null, index);\r\n\t        }\r\n\t    }\r\n\t\r\n\t    // Handles single colon syntax for older browsers and bugzilla.mozilla.org/show_bug.cgi?id=949651\r\n\t    function addPseudoElementRule(sheet, selector, rules, index) {\r\n\t        var doubleColonSelector;\r\n\t        var singleColonSelector;\r\n\t\r\n\t        if (doubleColonPseudoElRegex.exec(selector)) {\r\n\t            doubleColonSelector = selector;\r\n\t            singleColonSelector = toSingleColonPseudoElements(selector);\r\n\t        } else if (singleColonPseudoElRegex.exec(selector)) {\r\n\t            doubleColonSelector = toDoubleColonPseudoElements(selector);\r\n\t            singleColonSelector = selector;\r\n\t        } else {\r\n\t            return false; // Not dealing with a pseudo element\r\n\t        }\r\n\t\r\n\t        if (!singleColonForPseudoElements) {\r\n\t            // Assume modern browser and then check if successful\r\n\t            addRuleToSheet(sheet, doubleColonSelector, index);\r\n\t            if (rules.length <= index) {\r\n\t                singleColonForPseudoElements = true;\r\n\t            }\r\n\t        }\r\n\t        if (singleColonForPseudoElements) {\r\n\t            addRuleToSheet(sheet, singleColonSelector, index);\r\n\t        }\r\n\t\r\n\t        return true;\r\n\t    }\r\n\t\r\n\t    function toDoubleColonPseudoElements(selector) {\r\n\t        return selector.replace(singleColonPseudoElRegex, function (match, submatch1, submatch2, submatch3) {\r\n\t            return submatch1 + '::' + submatch3;\r\n\t        });\r\n\t    }\r\n\t\r\n\t    function toSingleColonPseudoElements(selector) {\r\n\t        return selector.replace(doubleColonPseudoElRegex, function(match, submatch1, submatch2) {\r\n\t            return ':' + submatch2;\r\n\t        })\r\n\t    }\r\n\t\r\n\t    function removeRule(rule) {\r\n\t        var sheet = rule.sheet;\r\n\t        if (sheet.deleteRule) {\r\n\t            sheet.deleteRule(rule.index);\r\n\t        } else if (sheet.removeRule) {\r\n\t            sheet.removeRule(rule.index);\r\n\t        }\r\n\t    }\r\n\t\r\n\t    function extend(dest, src) {\r\n\t        for (var key in src) {\r\n\t            if (!src.hasOwnProperty(key))\r\n\t                continue;\r\n\t            dest[key] = src[key];\r\n\t        }\r\n\t        return dest;\r\n\t    }\r\n\t\r\n\t    function aggregateStyles(rules) {\r\n\t        var aggregate = {};\r\n\t        for (var i = 0; i < rules.length; i++) {\r\n\t            extend(aggregate, declaredProperties(rules[i].style));\r\n\t        }\r\n\t        return aggregate;\r\n\t    }\r\n\t\r\n\t    function declaredProperties(style) {\r\n\t        var declared = {};\r\n\t        for (var i = 0; i < style.length; i++) {\r\n\t            declared[style[i]] = style[toCamelCase(style[i])];\r\n\t        }\r\n\t        return declared;\r\n\t    }\r\n\t\r\n\t    // IE9 stores rules with attributes (classes or ID's) adjacent in the opposite order as defined\r\n\t    // causing them to not be found, so this method swaps [#|.]sel1[#|.]sel2 to become [#|.]sel2[#|.]sel1\r\n\t    function swapAdjSelAttr(selector) {\r\n\t        var swap = '';\r\n\t        var lastIndex = 0;\r\n\t\r\n\t        while ((match = adjSelAttrRegex.exec(selector)) != null) {\r\n\t            if (match[0] === '')\r\n\t                break;\r\n\t            swap += selector.substring(lastIndex, match.index);\r\n\t            swap += selector.substr(match.index + match[1].length, match[2].length);\r\n\t            swap += selector.substr(match.index, match[1].length);\r\n\t            lastIndex = match.index + match[0].length;\r\n\t        }\r\n\t        swap += selector.substr(lastIndex);\r\n\t\r\n\t        return swap;\r\n\t    };\r\n\t\r\n\t    // FF and older browsers store rules with pseudo elements using single-colon syntax\r\n\t    function swapPseudoElSyntax(selector) {\r\n\t        if (doubleColonPseudoElRegex.exec(selector)) {\r\n\t            return toSingleColonPseudoElements(selector);\r\n\t        }\r\n\t        return selector;\r\n\t    }\r\n\t\r\n\t    function setStyleProperties(rule, properties) {\r\n\t        for (var key in properties) {\r\n\t            var value = properties[key];\r\n\t            var importantIndex = value.indexOf(' !important');\r\n\t\r\n\t            // Modern browsers seem to handle overrides fine, but IE9 doesn't\r\n\t            rule.style.removeProperty(key);\r\n\t            if (importantIndex > 0) {\r\n\t                rule.style.setProperty(key, value.substr(0, importantIndex), 'important');\r\n\t            } else {\r\n\t                rule.style.setProperty(key, value);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    function toCamelCase(str) {\r\n\t        return str.replace(/-([a-z])/g, function (match, submatch) {\r\n\t            return submatch.toUpperCase();\r\n\t        });\r\n\t    }\r\n\t\r\n\t    function transformCamelCasedPropertyNames(oldProps) {\r\n\t        var newProps = {};\r\n\t        for (var key in oldProps) {\r\n\t            newProps[unCamelCase(key)] = oldProps[key];\r\n\t        }\r\n\t        return newProps;\r\n\t    }\r\n\t\r\n\t    function unCamelCase(str) {\r\n\t        return str.replace(/([A-Z])/g, function(match, submatch) {\r\n\t            return '-' + submatch.toLowerCase();\r\n\t        });\r\n\t    }\r\n\t\r\n\t    var Jss = function(doc) {\r\n\t        this.doc = doc;\r\n\t        this.head = this.doc.head || this.doc.getElementsByTagName('head')[0];\r\n\t        this.sheets = this.doc.styleSheets || [];\r\n\t    };\r\n\t\r\n\t    Jss.prototype = {\r\n\t        // Returns JSS rules (selector is optional)\r\n\t        get: function(selector) {\r\n\t            if (!this.defaultSheet) {\r\n\t                return {};\r\n\t            }\r\n\t            if (selector) {\r\n\t                return aggregateStyles(getRules(this.defaultSheet, selector));\r\n\t            }\r\n\t            var rules = getSelectorsAndRules(this.defaultSheet);\r\n\t            for (selector in rules) {\r\n\t                rules[selector] = aggregateStyles(rules[selector]);\r\n\t            }\r\n\t            return rules;\r\n\t        },\r\n\t        // Returns all rules (selector is required)\r\n\t        getAll: function(selector) {\r\n\t            var properties = {};\r\n\t            for (var i = 0; i < this.sheets.length; i++) {\r\n\t                extend(properties, aggregateStyles(getRules(this.sheets[i], selector)));\r\n\t            }\r\n\t            return properties;\r\n\t        },\r\n\t        // Adds JSS rules for the selector based on the given properties\r\n\t        set: function(selector, properties) {\r\n\t            if (!this.defaultSheet) {\r\n\t                this.defaultSheet = this._createSheet();\r\n\t            }\r\n\t            properties = transformCamelCasedPropertyNames(properties);\r\n\t            var rules = getRules(this.defaultSheet, selector);\r\n\t            if (!rules.length) {\r\n\t                rules = [addRule(this.defaultSheet, selector)];\r\n\t            }\r\n\t            for (var i = 0; i < rules.length; i++) {\r\n\t                setStyleProperties(rules[i], properties);\r\n\t            }\r\n\t        },\r\n\t        // Removes JSS rules (selector is optional)\r\n\t        remove: function(selector) {\r\n\t            if (!this.defaultSheet)\r\n\t                return;\r\n\t            if (!selector) {\r\n\t                this._removeSheet(this.defaultSheet);\r\n\t                delete this.defaultSheet;\r\n\t                return;\r\n\t            }\r\n\t            var rules = getRules(this.defaultSheet, selector);\r\n\t            for (var i = 0; i < rules.length; i++) {\r\n\t                removeRule(rules[i]);\r\n\t            }\r\n\t            return rules.length;\r\n\t        },\r\n\t        _createSheet: function() {\r\n\t            var styleNode = this.doc.createElement('style');\r\n\t            styleNode.type = 'text/css';\r\n\t            styleNode.rel = 'stylesheet';\r\n\t            this.head.appendChild(styleNode);\r\n\t            return styleNode.sheet;\r\n\t        },\r\n\t        _removeSheet: function(sheet) {\r\n\t            var node = sheet.ownerNode;\r\n\t            node.parentNode.removeChild(node);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    var exports = new Jss(document);\r\n\t    exports.forDocument = function(doc) {\r\n\t        return new Jss(doc);\r\n\t    };\r\n\t    return exports;\r\n\t})();\r\n\t\r\n\ttypeof module !== 'undefined' && module.exports && (module.exports = jss); // CommonJS support\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// utilities needed by the configuration (excludes dependencies the configs don't need so the webpack bundle is lean)\r\n\t\r\n\tvar path = __webpack_require__(31)\r\n\t\r\n\t\r\n\t// Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1\r\n\t// any number of objects can be passed into the function and will be merged into the first argument in order\r\n\t// returns obj1 (now mutated)\r\n\tvar merge = exports.merge = function(obj1, obj2/*, moreObjects...*/){\r\n\t    return mergeInternal(arrayify(arguments), false)\r\n\t}\r\n\t\r\n\t// like merge, but traverses the whole object tree\r\n\t// the result is undefined for objects with circular references\r\n\tvar deepMerge = exports.deepMerge = function(obj1, obj2/*, moreObjects...*/) {\r\n\t    return mergeInternal(arrayify(arguments), true)\r\n\t}\r\n\t\r\n\t// returns a new object where properties of b are merged onto a (a's properties may be overwritten)\r\n\texports.objectConjunction = function(a, b) {\r\n\t    var objectCopy = {}\r\n\t    merge(objectCopy, a)\r\n\t    merge(objectCopy, b)\r\n\t    return objectCopy\r\n\t}\r\n\t\r\n\t// turns an array of values into a an object where those values are all keys that point to 'true'\r\n\texports.arrayToMap = function(array) {\r\n\t    var result = {}\r\n\t    array.forEach(function(v) {\r\n\t        result[v] = true\r\n\t    })\r\n\t    return result\r\n\t}\r\n\t\r\n\tfunction mergeInternal(objects, deep) {\r\n\t    var obj1 = objects[0]\r\n\t    var obj2 = objects[1]\r\n\t\r\n\t    for(var key in obj2){\r\n\t       if(Object.hasOwnProperty.call(obj2, key)) {\r\n\t            if(deep && obj1[key] instanceof Object && obj2[key] instanceof Object) {\r\n\t                mergeInternal([obj1[key], obj2[key]], true)\r\n\t            } else {\r\n\t                obj1[key] = obj2[key]\r\n\t            }\r\n\t       }\r\n\t    }\r\n\t\r\n\t    if(objects.length > 2) {\r\n\t        var newObjects = [obj1].concat(objects.slice(2))\r\n\t        return mergeInternal(newObjects, deep)\r\n\t    } else {\r\n\t        return obj1\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction arrayify(a) {\r\n\t    return Array.prototype.slice.call(a, 0)\r\n\t}\r\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// some functionality that is needed by Block.js but is related to styling (some things are also needed by Style.js)\r\n\t\r\n\tvar HashMap = __webpack_require__(27)\r\n\t\r\n\tvar Style = __webpack_require__(2)\r\n\tvar utils = __webpack_require__(16)\r\n\t\r\n\texports.defaultStyleMap = new HashMap() // maps from a proto class to its computed default style\r\n\t\r\n\t// propogates a style-set change to a set of components\r\n\t    // styleMap should be a *copy* of a Style's componentStyleMap property (because it will be modified)\r\n\tvar propogateStyleSet = exports.propogateStyleSet = function (components, styleMap) {\r\n\t    for(var n=0; n<components.length; n++) {\r\n\t        var c = components[n]\r\n\t\r\n\t        // object inherits style if its in the styleSet and if it doesn't have an explicitly set style\r\n\t        if(c._style === undefined) {\r\n\t            if(styleMap === undefined) {\r\n\t                setCurrentStyle(c, undefined)\r\n\t            } else {\r\n\t                var styleFromMap = getStyleForComponent(styleMap, c)\r\n\t                if(styleFromMap !== undefined) {\r\n\t                    setCurrentStyle(c, styleFromMap)\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        // set the computed style set\r\n\t        var mainStyle; // the style directly given to a component, either its `style` property, or its inherited style\r\n\t        if(c._style !== undefined) {\r\n\t            mainStyle = c._style.get(c)\r\n\t        } else if(styleMap !== undefined) {\r\n\t            mainStyle = getStyleForComponent(styleMap, c)\r\n\t            if(mainStyle !== undefined) {\r\n\t                mainStyle = mainStyle.get(c) // get the specific style (taking into account any label)\r\n\t            }\r\n\t        }\r\n\t\r\n\t        if(mainStyle !== undefined) {\r\n\t            if(styleMap !== undefined) {\r\n\t                c.computedStyleMap = styleMapConjunction(styleMap, mainStyle.componentStyleMap)\r\n\t            } else {\r\n\t                c.computedStyleMap = mainStyle.componentStyleMap\r\n\t            }\r\n\t        } else {\r\n\t            c.computedStyleMap = styleMap\r\n\t        }\r\n\t\r\n\t        propogateStyleSet(c.children, c.computedStyleMap)\r\n\t    }\r\n\t}\r\n\t\r\n\t// gets the right style from the styleMap\r\n\t// takes the component's inheritance tree into account (relies on the block.constructor.parent property)\r\n\tvar getStyleForComponent = exports.getStyleForComponent = function (styleMap, block) {\r\n\t    var constructor = block.constructor\r\n\t    while(constructor !== undefined) {\r\n\t        var style = styleMap[constructor.name]\r\n\t        if(style !== undefined) {\r\n\t            return style\r\n\t        } else {\r\n\t            constructor = constructor.parent\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\t// returns the conjunction of two style maps\r\n\t// gets it from the computedStyles cache if its already in there\r\n\tvar styleMapConjunction = exports.styleMapConjunction = function (secondaryStyleMap, primaryStyleMap) {\r\n\t    var cachedStyleMap = Style.computedStyles.get([secondaryStyleMap, primaryStyleMap])\r\n\t    if(cachedStyleMap === undefined) {\r\n\t        cachedStyleMap = utils.objectConjunction(secondaryStyleMap, primaryStyleMap)\r\n\t        Style.computedStyles.set([secondaryStyleMap, primaryStyleMap], cachedStyleMap)\r\n\t    }\r\n\t\r\n\t    return cachedStyleMap\r\n\t}\r\n\t\r\n\t// takes labels into account\r\n\tvar setCurrentStyle = exports.setCurrentStyle = function (component, style) {\r\n\t    if(style === component.currentStyle) return; // do nothing\r\n\t\r\n\t    if(style !== undefined)\r\n\t        var specificStyle = style.get(component)\r\n\t    else\r\n\t        var specificStyle = style\r\n\t\r\n\t    setStyleClass(component, specificStyle)\r\n\t    applyStyleKillFunction(component)\r\n\t    component.currentStyle = specificStyle\r\n\t    applyStyleSetupFunction(component, specificStyle)\r\n\t    applyStateHandler(component, specificStyle)\r\n\t}\r\n\t\r\n\t\r\n\texports.createDefaultBlockStyle = function (that) {\r\n\t    if(that.defaultStyle !== undefined) {\r\n\t        validateDefaultStyle(that.defaultStyle)\r\n\t    }\r\n\t\r\n\t    // get list of default styles\r\n\t    var defaultStyles = []\r\n\t    var nextConstructor = that.constructor\r\n\t    while(nextConstructor !== undefined) {\r\n\t        if(nextConstructor.defaultStyle !== undefined) {\r\n\t            defaultStyles.push(nextConstructor.defaultStyle)\r\n\t        }\r\n\t        nextConstructor = nextConstructor.parent\r\n\t    }\r\n\t\r\n\t    // generate merged default style\r\n\t    var defaultStyleSet = {}\r\n\t    defaultStyles.reverse().forEach(function(style) {\r\n\t        for(var k in style.styleDefinitions) {\r\n\t            utils.merge(defaultStyleSet, style.styleDefinitions[k])\r\n\t            break; // just do first key (shouldn't be more than one key, because only simple stylings are allowed for default styles)\r\n\t        }\r\n\t\r\n\t    })\r\n\t\r\n\t    if(Object.keys(defaultStyleSet).length > 0)\r\n\t        var defaultBlockStyle = Style(defaultStyleSet, {default:true})\r\n\t    else\r\n\t        var defaultBlockStyle = false // no special default\r\n\t\r\n\t    exports.defaultStyleMap.set(that.constructor, defaultBlockStyle)\r\n\t    return defaultBlockStyle\r\n\t}\r\n\t\r\n\t\r\n\t// applies setup appropriately\r\n\tfunction applyStyleSetupFunction(component, style) {\r\n\t    if(style !== undefined && style.setup !== undefined) {\r\n\t        component._styleSetupObject = style.setup(component) // call setup on the component\r\n\t    } else {\r\n\t        component._styleSetupObject = undefined\r\n\t    }\r\n\t}\r\n\t// applies kill appropriately\r\n\tfunction applyStyleKillFunction(component) {\r\n\t    var currentStyle = component.currentStyle\r\n\t    if(currentStyle !== undefined && currentStyle.setup !== undefined) {\r\n\t        if(currentStyle.kill === undefined)\r\n\t            throw new Error('style has been unset but does not have a \"kill\" function to undo its \"setup\" function')\r\n\t\r\n\t        currentStyle.kill(component, component._styleSetupObject)\r\n\t    }\r\n\t}\r\n\t\r\n\t// initializes and sets up state-change handler\r\n\tfunction applyStateHandler(component, style) {\r\n\t    if(style !== undefined && style.stateHandler !== undefined) {\r\n\t        // todo: using setCurrentStyle is a stopgap until I can implement better style application for $state and pseudoclasses (which probably will require a rewrite of much of the style logic)\r\n\t        setCurrentStyle(component, style.stateHandler(component.state.subject))\r\n\t        component.state.on('change', function() {\r\n\t            setCurrentStyle(component, style.stateHandler(component.state.subject))\r\n\t        })\r\n\t    }\r\n\t}\r\n\t\r\n\t// sets the style, replacing one if one already exists\r\n\tfunction setStyleClass(component, style) {\r\n\t    var currentStyle = component.currentStyle\r\n\t    if(currentStyle !== undefined) {\r\n\t        component.domNode.className = component.domNode.className.replace(new RegExp(\" ?\\\\b\"+currentStyle.className+\"\\\\b\"),'') // remove the previous css class\r\n\t    }\r\n\t    if(style !== undefined) {\r\n\t        component.domNode.className = style.className+' '+component.domNode.className.trim() // note that the order of classes doesn't matter\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction validateDefaultStyle(defaultStyle) {\r\n\t    if(!(defaultStyle instanceof Style)) {\r\n\t        throw new Error(\"defaultStyle property must be a Style object\")\r\n\t    } else if(\r\n\t        defaultStyle.setup !== undefined || defaultStyle.kill !== undefined || defaultStyle.stateHandler !== undefined ||\r\n\t        Object.keys(defaultStyle.componentStyleMap).length > 0 || Object.keys(defaultStyle.labelStyleMap).length > 0 /*||\r\n\t        Object.keys(defaultStyle.pseudoClassStyles).length > 0*/\r\n\t    ) {\r\n\t        throw new Error(\"A Block's defaultStyle can only contain basic css stylings, no Block, label, or pseudoclass stylings, nor run/kill javascript\")\r\n\t    }\r\n\t}\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar EventEmitter = __webpack_require__(25).EventEmitter\r\n\tvar proto = __webpack_require__(26)\r\n\tvar utils = __webpack_require__(16)\r\n\t\r\n\tmodule.exports = proto(EventEmitter, function(superclass) {\r\n\t\r\n\t    this.init = function() {\r\n\t        superclass.apply(this, arguments)\r\n\t\r\n\t        this.ifonHandlers = {}\r\n\t        this.ifoffHandlers = {}\r\n\t        this.ifonAllHandlers = []\r\n\t        this.ifoffAllHandlers = []\r\n\t    }\r\n\t\r\n\t    // callback will be triggered immediately if there is already a listener attached, or\r\n\t    // callback will be triggered when the first listener for the event is added\r\n\t    // (regardless of whether its done through on or once)\r\n\t    // parameters can be:\r\n\t        // event, callback - attach an ifon handler for the passed event\r\n\t        // callback - attach an ifon handler for all events\r\n\t    this.ifon = function(event, callback) {\r\n\t        if(event instanceof Function) {     // event not passed, only a callback\r\n\t            callback = event // fix the argument\r\n\t            for(var eventName in this._events) {\r\n\t                if(this.listeners(eventName).length > 0) {\r\n\t                    callback(eventName)\r\n\t                }\r\n\t            }\r\n\t        } else if(this.listeners(event).length > 0) {\r\n\t            callback(event)\r\n\t        }\r\n\t\r\n\t        addHandlerToList(this, 'ifonHandlers', event, callback)\r\n\t    }\r\n\t\r\n\t    // removes either:\r\n\t        // removeIfon() - all ifon handlers (if no arguments are passed), or\r\n\t        // removeIfon(event) - all ifon handlers for the passed event, or\r\n\t        // removeIfon(callback) - the passed ifon-all handler (if the first parameter is the callback)\r\n\t        // removeIfon(event, callback) - the specific passed callback for the passed event\r\n\t    this.removeIfon = function(event, callback) {\r\n\t        removeFromHandlerList(this, 'ifonHandlers', event, callback)\r\n\t    }\r\n\t\r\n\t    // callback will be triggered when the last listener for the 'click' event is removed (will not trigger immediately if there is no event listeners on call of ifoff)\r\n\t    // (regardless of whether this is done through removeListener or as a result of 'once' being fulfilled)\r\n\t    // parameters can be:\r\n\t        // event, callback - attach an ifoff handler for the passed event\r\n\t        // callback - attach an ifoff handler for all events\r\n\t    this.ifoff = function(event, callback) {\r\n\t        addHandlerToList(this, 'ifoffHandlers', event, callback)\r\n\t    }\r\n\t\r\n\t    // removes either:\r\n\t        // removeIfoff() - all ifoff handlers (if no arguments are passed), or\r\n\t        // removeIfoff(event) - all ifoff handlers for the passed event, or\r\n\t        // removeIfoff(callback) - the passed ifoff-all handler (if the first parameter is the callback)\r\n\t        // removeIfoff(event, callback) - the specific passed callback for the passed event\r\n\t    this.removeIfoff = function(event, callback) {\r\n\t        removeFromHandlerList(this, 'ifoffHandlers', event, callback)\r\n\t    }\r\n\t\r\n\t    // emitter is the emitter to proxy handler binding to\r\n\t    // options can have one of the following properties:\r\n\t        // only - an array of events to proxy\r\n\t        // except - an array of events to *not* proxy\r\n\t    this.proxy = function(emitter, options) {\r\n\t        if(options === undefined) options = {}\r\n\t        if(options.except !== undefined) {\r\n\t            var except = utils.arrayToMap(options.except)\r\n\t            var handleIt = function(event){return !(event in except)}\r\n\t        } else if(options.only !== undefined) {\r\n\t            var only = utils.arrayToMap(options.only)\r\n\t            var handleIt = function(event){return event in only}\r\n\t        } else {\r\n\t            var handleIt = function(){return true}\r\n\t        }\r\n\t\r\n\t        var that = this, handler;\r\n\t        this.ifon(function(event) {\r\n\t            if(handleIt(event)) {\r\n\t                emitter.on(event, handler = function() {\r\n\t                    that.emit.apply(that, [event].concat(Array.prototype.slice.call(arguments)))\r\n\t                })\r\n\t            }\r\n\t        })\r\n\t        this.ifoff(function(event) {\r\n\t            if(handleIt(event))\r\n\t                emitter.off(event, handler)\r\n\t        })\r\n\t    }\r\n\t\r\n\t    /*override*/ this.on = this.addListener = function(event, callback) {\r\n\t        var triggerIfOn = this.listeners(event).length === 0\r\n\t        superclass.prototype.on.apply(this,arguments)\r\n\t        if(triggerIfOn) triggerIfHandlers(this, 'ifonHandlers', event)\r\n\t    }\r\n\t\r\n\t    /*override*/ this.off = this.removeListener = function(event, callback) {\r\n\t        var triggerIfOff = this.listeners(event).length === 1\r\n\t        superclass.prototype.removeListener.apply(this,arguments)\r\n\t        if(triggerIfOff) triggerIfHandlers(this, 'ifoffHandlers', event)\r\n\t    }\r\n\t    /*override*/ this.removeAllListeners = function(event) {\r\n\t        var triggerIfOffForEvents = []\r\n\t        if(event !== undefined) {\r\n\t            if(this.listeners(event).length > 0) {\r\n\t                triggerIfOffForEvents.push(event)\r\n\t            }\r\n\t        } else {\r\n\t            for(var event in this._events) {\r\n\t                if(this.listeners(event).length > 0) {\r\n\t                    triggerIfOffForEvents.push(event)\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        superclass.prototype.removeAllListeners.apply(this,arguments)\r\n\t\r\n\t        for(var n=0; n<triggerIfOffForEvents.length; n++) {\r\n\t            triggerIfHandlers(this, 'ifoffHandlers', triggerIfOffForEvents[n])\r\n\t        }\r\n\t    }\r\n\t\r\n\t})\r\n\t\r\n\t\r\n\t// triggers the if handlers from the normal list and the \"all\" list\r\n\tfunction triggerIfHandlers(that, handlerListName, event) {\r\n\t    triggerIfHandlerList(that[handlerListName][event], event)\r\n\t    triggerIfHandlerList(that[normalHandlerToAllHandlerProperty(handlerListName)], event)\r\n\t}\r\n\t\r\n\t\r\n\t// triggers the if handlers from a specific list\r\n\t// ya these names are confusing, sorry : (\r\n\tfunction triggerIfHandlerList(handlerList, event) {\r\n\t    if(handlerList !== undefined) {\r\n\t        for(var n=0; n<handlerList.length; n++) {\r\n\t            handlerList[n](event)\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction addHandlerToList(that, handlerListName, event, callback) {\r\n\t    if(event instanceof Function) {\r\n\t        // correct arguments\r\n\t        callback = event\r\n\t        event = undefined\r\n\t    }\r\n\t\r\n\t    if(event !== undefined && callback !== undefined) {\r\n\t        var handlerList = that[handlerListName][event]\r\n\t        if(handlerList === undefined) {\r\n\t            handlerList = that[handlerListName][event] = []\r\n\t        }\r\n\t\r\n\t        handlerList.push(callback)\r\n\t    } else {\r\n\t        that[normalHandlerToAllHandlerProperty(handlerListName)].push(callback)\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction removeFromHandlerList(that, handlerListName, event, callback) {\r\n\t    if(event instanceof Function) {\r\n\t        // correct arguments\r\n\t        callback = event\r\n\t        event = undefined\r\n\t    }\r\n\t\r\n\t    if(event !== undefined && callback !== undefined) {\r\n\t        removeCallbackFromList(that[handlerListName][event], callback)\r\n\t    } else if(event !== undefined) {\r\n\t        delete that[handlerListName][event]\r\n\t    } else if(callback !== undefined) {\r\n\t        var allHandlerListName = normalHandlerToAllHandlerProperty(handlerListName)\r\n\t        removeCallbackFromList(that[allHandlerListName], callback)\r\n\t    } else {\r\n\t        var allHandlerListName = normalHandlerToAllHandlerProperty(handlerListName)\r\n\t        that[handlerListName] = {}\r\n\t        that[allHandlerListName] = []\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction normalHandlerToAllHandlerProperty(handlerListName) {\r\n\t    if(handlerListName === 'ifonHandlers')\r\n\t        return 'ifonAllHandlers'\r\n\t    if(handlerListName === 'ifoffHandlers')\r\n\t        return 'ifoffAllHandlers'\r\n\t}\r\n\t\r\n\tfunction removeCallbackFromList(list, callback) {\r\n\t    var index = list.indexOf(callback)\r\n\t    list.splice(index,1)\r\n\t}\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t// creates a dom element optionally with a class and attributes\r\n\t var node = module.exports.node = function(type, className, options) {\r\n\t    var elem = document.createElement(type)\r\n\t\r\n\t    if(options !== undefined) {\r\n\t        if(options.attr !== undefined) {\r\n\t            for(var attribute in options.attr) {\r\n\t                createAttribute(elem, attribute, options.attr[attribute])\r\n\t            }\r\n\t        }\r\n\t        if(options.textContent !== undefined) {\r\n\t            elem.textContent = options.textContent\r\n\t        }\r\n\t    }\r\n\t\r\n\t    if(className !== undefined)\r\n\t        elem.className = className\r\n\t\r\n\t    return elem\r\n\t}\r\n\t\r\n\t// convenience function for creating a div\r\n\tmodule.exports.div = function(className, options) {\r\n\t    return node('div', className, options)\r\n\t}\r\n\t\r\n\t// adds an attribute to a domNode\r\n\tvar setAttribute = module.exports.setAttribute = function(/*[domNode,] type, value*/) {\r\n\t    if (arguments.length === 2) {\r\n\t        var domNode = this.domNode;\r\n\t        var type = arguments[0];\r\n\t        var value = arguments[1];\r\n\t    } else if (arguments.length === 3) {\r\n\t        var domNode = arguments[0];\r\n\t        var type = arguments[1];\r\n\t        var value = arguments[2];\r\n\t    } else {\r\n\t        throw new Error(\"This function expects arguments to be: [domNode,] type, value\");\r\n\t    }\r\n\t    var attr = document.createAttribute(type)\r\n\t    attr.value = value\r\n\t    domNode.setAttributeNode(attr)\r\n\t}\r\n\t\r\n\t\r\n\t// sets the selection\r\n\t//\r\n\t// works for contenteditable elements\r\n\texports.setSelectionRange = function(containerEl, start, end) {\r\n\t\r\n\t    if(containerEl.nodeName === 'INPUT' || containerEl.nodeName === 'TEXTAREA') {\r\n\t        containerEl.setSelectionRange(start, end)\r\n\t    } else {\r\n\t        var charIndex = 0, range = document.createRange();\r\n\t        range.setStart(containerEl, 0);\r\n\t        range.collapse(true);\r\n\t        var foundStart = false;\r\n\t\r\n\t        iterateThroughLeafNodes(containerEl, function(node) {\r\n\t            var hiddenCharacters = findHiddenCharacters(node, node.length)\r\n\t            var nextCharIndex = charIndex + node.length - hiddenCharacters;\r\n\t\r\n\t            if (!foundStart && start >= charIndex && start <= nextCharIndex) {\r\n\t                var nodeIndex = start-charIndex\r\n\t                var hiddenCharactersBeforeStart = findHiddenCharacters(node, nodeIndex)\r\n\t                range.setStart(node, nodeIndex + hiddenCharactersBeforeStart);\r\n\t                foundStart = true;\r\n\t            }\r\n\t\r\n\t            if (foundStart && end >= charIndex && end <= nextCharIndex) {\r\n\t                var nodeIndex = end-charIndex\r\n\t                var hiddenCharactersBeforeEnd = findHiddenCharacters(node, nodeIndex)\r\n\t                range.setEnd(node, nodeIndex + hiddenCharactersBeforeEnd);\r\n\t                return true; // stop the iteration - we're done here\r\n\t            }\r\n\t\r\n\t            charIndex = nextCharIndex\r\n\t        })\r\n\t\r\n\t        var sel = window.getSelection();\r\n\t        sel.removeAllRanges();\r\n\t        sel.addRange(range);\r\n\t    }\r\n\t}\r\n\t\r\n\t// gets the character offsets of a selection within a particular dom node\r\n\t// returns undefined if there is no selection in the element\r\n\t// note: yes this code doesn't work in older versions of IE (or possibly any versions) - if you want it to work in IE, please use http://modernizr.com/ or a polyfill for ranges\r\n\texports.getSelectionRange = function (element) {\r\n\t\r\n\t    var selection = window.getSelection()\r\n\t    var isInputOrArea = element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA'\r\n\t\r\n\t    for(var n=0; n<selection.rangeCount; n++) {\r\n\t        var range = selection.getRangeAt(0)\r\n\t        if(isInputOrArea) {\r\n\t            if(range.startOffset === range.endOffset && range.startContainer.children[range.startOffset] === element /*|| range.startContainer === element || */) { // I don't think the input or textarea itself will ever be the startContainer\r\n\t                return [element.selectionStart, element.selectionEnd]\r\n\t            }\r\n\t        } else {\r\n\t            var startsInElement = element.contains(range.startContainer)\r\n\t            if(startsInElement) {\r\n\t                var elementToIterateThrough = element\r\n\t                var startFound = true\r\n\t            } else {\r\n\t                var elementToIterateThrough = range.commonAncestorContainer\r\n\t                var startFound = false\r\n\t                var startContainerFound = false\r\n\t            }\r\n\t\r\n\t            var visibleCharacterOffset = 0, start, end;\r\n\t            iterateThroughLeafNodes(elementToIterateThrough, function(leaf) {\r\n\t                if(!startFound) {\r\n\t                    if(leaf === range.startContainer) {\r\n\t                        startContainerFound = true\r\n\t                    }\r\n\t\r\n\t                    if(!element.contains(leaf) || !startContainerFound)\r\n\t                        return; // continue\r\n\t                    else if(startContainerFound)\r\n\t                       startFound = true\r\n\t                } else if(!startsInElement && !element.contains(leaf)) {\r\n\t                    return true // done!\r\n\t                }\r\n\t\r\n\t                if(leaf === range.startContainer) {\r\n\t                    start = visibleCharacterOffset + range.startOffset - findHiddenCharacters(leaf, range.startOffset)\r\n\t                }\r\n\t                if(leaf === range.endContainer) {\r\n\t                    end = visibleCharacterOffset + range.endOffset - findHiddenCharacters(leaf, range.endOffset)\r\n\t                    return true // done!\r\n\t                }\r\n\t\r\n\t                visibleCharacterOffset += leaf.length - findHiddenCharacters(leaf, leaf.length)\r\n\t            })\r\n\t\r\n\t            if(start === undefined && !startFound) {\r\n\t                return undefined\r\n\t            } else {\r\n\t                if(start === undefined) {\r\n\t                    start = 0 // start is at the beginning\r\n\t                }\r\n\t                if(end === undefined) {\r\n\t                    end = visibleCharacterOffset // end is all the way at the end (the selection may continue in other elements)\r\n\t                }\r\n\t\r\n\t                return [start, end]\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\t\r\n\t// iterate through the leaf nodes inside element\r\n\t// callback(node) - a function called for each leaf node\r\n\t    // returning true from this ends the iteration\r\n\tfunction iterateThroughLeafNodes(element, callback) {\r\n\t    var nodeStack = [element], node;\r\n\t\r\n\t    while (node = nodeStack.pop()) {\r\n\t        if (node.nodeType == 3) {\r\n\t            if(callback(node) === true)\r\n\t                break;\r\n\t        } else {\r\n\t            var i = node.childNodes.length;\r\n\t            while (i--) {\r\n\t                nodeStack.push(node.childNodes[i]);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction findHiddenCharacters(node, beforeCaretIndex) {\r\n\t    var hiddenCharacters = 0\r\n\t    var lastCharWasWhiteSpace=true\r\n\t    for(var n=0; n-hiddenCharacters<beforeCaretIndex &&n<node.length; n++) {\r\n\t        if([' ','\\n','\\t','\\r'].indexOf(node.textContent[n]) !== -1) {\r\n\t            if(lastCharWasWhiteSpace)\r\n\t                hiddenCharacters++\r\n\t            else\r\n\t                lastCharWasWhiteSpace = true\r\n\t        } else {\r\n\t            lastCharWasWhiteSpace = false\r\n\t        }\r\n\t    }\r\n\t\r\n\t    return hiddenCharacters\r\n\t}\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(26)\n\tvar Style = __webpack_require__(2)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t\t// static properties\n\t\n\t\tthis.name = 'ListItem'\n\t\n\t    this.defaultStyle = Style({\n\t        display: 'list-item'\n\t    })\n\t\n\t\t// instance properties\n\t\n\t\tthis.init = function(/*[label,] contents*/) {\n\t        if(arguments.length <= 1) {\n\t            var contents = arguments[0]\n\t        } else {\n\t            var label = arguments[0]\n\t            var contents = arguments[1]\n\t        }\n\t\n\t        this.domNode = document.createElement(\"li\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t\t\tsuperclass.init.call(this) // superclass constructor\n\t\t\tthis.label = label\n\t\n\t        if(contents instanceof Block) {\n\t\t\t\tthis.add(contents)\n\t\t\t} else if(contents !== undefined) {\n\t            this.domNode.textContent = contents\n\t        }\n\t\t}\n\t});\n\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// note: this is  not intended to be used directly - only through Select and MultiSelect\r\n\t\r\n\tvar Block = __webpack_require__(1)\r\n\tvar Style = __webpack_require__(2)\r\n\tvar proto = __webpack_require__(26)\r\n\t//var htmlEntities = require('he')\r\n\t\r\n\t// emits a 'change' event when its 'selected' value changes\r\n\tmodule.exports = proto(Block, function(superclass) {\r\n\t\r\n\t    // staic members\r\n\t\r\n\t    this.name = 'Option'\r\n\t\r\n\t    this.defaultStyle = Style({\r\n\t        display: 'block'\r\n\t    })\r\n\t\r\n\t\r\n\t    // instance members\r\n\t\r\n\t    this.init = function(label, value, text) {\r\n\t        this.domNode = document.createElement(\"option\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\r\n\t        superclass.init.call(this) // superclass constructor\r\n\t\r\n\t        this.label = label\r\n\t\r\n\t        this.text = text\r\n\t        this.val = value\r\n\t    }\r\n\t\r\n\t    Object.defineProperty(this, 'val', {\r\n\t        // returns the value of the Option\r\n\t        get: function() {\r\n\t            return this.attr('value')\r\n\t        },\r\n\t\r\n\t        // sets the value of the Option\r\n\t        set: function(value) {\r\n\t            if(this.parent !== undefined) {\r\n\t                if(this.parent.options[value] !== undefined) {\r\n\t                    throw new Error(\"Can't give an Option the same value as another in the Select or MultiSelect (value: '\"+value+\"')\")\r\n\t                }\r\n\t\r\n\t                if(this.val !== null) {\r\n\t                    delete this.parent.options[this.val]\r\n\t                }\r\n\t\r\n\t                this.parent.options[value] = this\r\n\t            }\r\n\t\r\n\t            this.attr('value', value)\r\n\t\r\n\t        }\r\n\t    })\r\n\t\r\n\t\r\n\t    Object.defineProperty(this, 'selected', {\r\n\t        // returns whether or not the option is selected\r\n\t        get: function() {\r\n\t            return this.domNode.selected\r\n\t        },\r\n\t\r\n\t        // sets the selected state of the option to the passed value (true for selected)\r\n\t        set: function(value) {\r\n\t            var booleanValue = value === true\r\n\t            if(this.selected === booleanValue) return false; // ignore if there's no change\r\n\t\r\n\t            if(this.parent !== undefined)\r\n\t                this.parent.prepareForValueChange([this.val])\r\n\t\r\n\t            this.setSelectedQuiet(booleanValue)\r\n\t\r\n\t            if(this.parent !== undefined)\r\n\t                this.parent.emit('change')\r\n\t        }\r\n\t    })\r\n\t\r\n\t    Object.defineProperty(this, 'text', {\r\n\t        get: function() {\r\n\t            return this.domNode.textContent\r\n\t        },\r\n\t\r\n\t        set: function(text) {\r\n\t            this.domNode.innerText = text // apparently textContent can't be set or something? unclear\r\n\t        }\r\n\t    })\r\n\t\r\n\t\r\n\t    // private\r\n\t\r\n\t    // does everything for setting the selected state except emit the parent's change event\r\n\t    this.setSelectedQuiet = function setOptionSelected(booleanValue) {\r\n\t        if(this.selected === booleanValue) return; // ignore if there's no change\r\n\t\r\n\t        this.domNode.selected = booleanValue\r\n\t        this.emit('change') // the browser has no listenable event that is triggered on change of the 'checked' property\r\n\t    }\r\n\t})\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\tvar RowlikeGenerator = __webpack_require__(30);\n\t\n\tmodule.exports = RowlikeGenerator('th', \"TableHeader\")\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar RowlikeGenerator = __webpack_require__(30);\n\t\n\tmodule.exports = RowlikeGenerator('tr', \"TableRow\")\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(26)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t\t// static properties\n\t\n\t\tthis.name = 'TableCell'\n\t\t\n\t\n\t\t// instance properties\n\t\n\t\tthis.init = function(/*[label,] contents*/) {\n\t        if(arguments.length <= 1) {\n\t            var contents = arguments[0]\n\t        } else {\n\t            var label = arguments[0]\n\t            var contents = arguments[1]\n\t        }\n\t\n\t        this.domNode = document.createElement(\"td\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t\t\tsuperclass.init.call(this) // superclass constructor\n\t\t\tthis.label = label\n\t\n\t        if(contents instanceof Block) {\n\t\t\t\tthis.add(contents)\n\t\t\t} else if(contents !== undefined) {\n\t            this.domNode.textContent = contents\n\t        }\n\t\t}\n\t\n\t\tthis.colspan = function(cols) {\n\t\t\tthis.attr('colspan',cols);\n\t\t}\n\t});\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tfunction EventEmitter() {\n\t  this._events = this._events || {};\n\t  this._maxListeners = this._maxListeners || undefined;\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!isNumber(n) || n < 0 || isNaN(n))\n\t    throw TypeError('n must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var er, handler, len, args, i, listeners;\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error') {\n\t    if (!this._events.error ||\n\t        (isObject(this._events.error) && !this._events.error.length)) {\n\t      er = arguments[1];\n\t      if (er instanceof Error) {\n\t        throw er; // Unhandled 'error' event\n\t      }\n\t      throw TypeError('Uncaught, unspecified \"error\" event.');\n\t    }\n\t  }\n\t\n\t  handler = this._events[type];\n\t\n\t  if (isUndefined(handler))\n\t    return false;\n\t\n\t  if (isFunction(handler)) {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        len = arguments.length;\n\t        args = new Array(len - 1);\n\t        for (i = 1; i < len; i++)\n\t          args[i - 1] = arguments[i];\n\t        handler.apply(this, args);\n\t    }\n\t  } else if (isObject(handler)) {\n\t    len = arguments.length;\n\t    args = new Array(len - 1);\n\t    for (i = 1; i < len; i++)\n\t      args[i - 1] = arguments[i];\n\t\n\t    listeners = handler.slice();\n\t    len = listeners.length;\n\t    for (i = 0; i < len; i++)\n\t      listeners[i].apply(this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  var m;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // To avoid recursion in the case that type === \"newListener\"! Before\n\t  // adding it to the listeners, first emit \"newListener\".\n\t  if (this._events.newListener)\n\t    this.emit('newListener', type,\n\t              isFunction(listener.listener) ?\n\t              listener.listener : listener);\n\t\n\t  if (!this._events[type])\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  else if (isObject(this._events[type]))\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t  else\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t\n\t  // Check for listener leak\n\t  if (isObject(this._events[type]) && !this._events[type].warned) {\n\t    var m;\n\t    if (!isUndefined(this._maxListeners)) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = EventEmitter.defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t      console.error('(node) warning: possible EventEmitter memory ' +\n\t                    'leak detected. %d listeners added. ' +\n\t                    'Use emitter.setMaxListeners() to increase limit.',\n\t                    this._events[type].length);\n\t      if (typeof console.trace === 'function') {\n\t        // not supported in IE 10\n\t        console.trace();\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  var list, position, length, i;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events || !this._events[type])\n\t    return this;\n\t\n\t  list = this._events[type];\n\t  length = list.length;\n\t  position = -1;\n\t\n\t  if (list === listener ||\n\t      (isFunction(list.listener) && list.listener === listener)) {\n\t    delete this._events[type];\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t\n\t  } else if (isObject(list)) {\n\t    for (i = length; i-- > 0;) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener)) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0)\n\t      return this;\n\t\n\t    if (list.length === 1) {\n\t      list.length = 0;\n\t      delete this._events[type];\n\t    } else {\n\t      list.splice(position, 1);\n\t    }\n\t\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  var key, listeners;\n\t\n\t  if (!this._events)\n\t    return this;\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!this._events.removeListener) {\n\t    if (arguments.length === 0)\n\t      this._events = {};\n\t    else if (this._events[type])\n\t      delete this._events[type];\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    for (key in this._events) {\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  listeners = this._events[type];\n\t\n\t  if (isFunction(listeners)) {\n\t    this.removeListener(type, listeners);\n\t  } else {\n\t    // LIFO order\n\t    while (listeners.length)\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t  }\n\t  delete this._events[type];\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  var ret;\n\t  if (!this._events || !this._events[type])\n\t    ret = [];\n\t  else if (isFunction(this._events[type]))\n\t    ret = [this._events[type]];\n\t  else\n\t    ret = this._events[type].slice();\n\t  return ret;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  var ret;\n\t  if (!emitter._events || !emitter._events[type])\n\t    ret = 0;\n\t  else if (isFunction(emitter._events[type]))\n\t    ret = 1;\n\t  else\n\t    ret = emitter._events[type].length;\n\t  return ret;\n\t};\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t/* Copyright (c) 2013 Billy Tetrud - Free to use for any purpose: MIT License*/\r\n\t\r\n\tvar noop = function() {}\r\n\t\r\n\tvar prototypeName='prototype', undefined, protoUndefined='undefined', init='init', ownProperty=({}).hasOwnProperty; // minifiable variables\r\n\tfunction proto() {\r\n\t    var args = arguments // minifiable variables\r\n\t\r\n\t    if(args.length == 1) {\r\n\t        var parent = {init: noop}\r\n\t        var prototypeBuilder = args[0]\r\n\t\r\n\t    } else { // length == 2\r\n\t        var parent = args[0]\r\n\t        var prototypeBuilder = args[1]\r\n\t    }\r\n\t\r\n\t    // special handling for Error objects\r\n\t    var namePointer = {}    // name used only for Error Objects\r\n\t    if([Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError].indexOf(parent) !== -1) {\r\n\t        parent = normalizeErrorObject(parent, namePointer)\r\n\t    }\r\n\t\r\n\t    // set up the parent into the prototype chain if a parent is passed\r\n\t    var parentIsFunction = typeof(parent) === \"function\"\r\n\t    if(parentIsFunction) {\r\n\t        prototypeBuilder[prototypeName] = parent[prototypeName]\r\n\t    } else {\r\n\t        prototypeBuilder[prototypeName] = parent\r\n\t    }\r\n\t\r\n\t    // the prototype that will be used to make instances\r\n\t    var prototype = new prototypeBuilder(parent)\r\n\t    namePointer.name = prototype.name\r\n\t\r\n\t    // if there's no init, assume its inheriting a non-proto class, so default to applying the superclass's constructor.\r\n\t    if(!prototype[init] && parentIsFunction) {\r\n\t        prototype[init] = function() {\r\n\t            parent.apply(this, arguments)\r\n\t        }\r\n\t    }\r\n\t\r\n\t    // constructor for empty object which will be populated via the constructor\r\n\t    var F = function() {}\r\n\t        F[prototypeName] = prototype    // set the prototype for created instances\r\n\t\r\n\t    var constructorName = prototype.name?prototype.name:''\r\n\t    if(prototype[init] === undefined || prototype[init] === noop) {\r\n\t        var ProtoObjectFactory = new Function('F',\r\n\t            \"return function \" + constructorName + \"(){\" +\r\n\t                \"return new F()\" +\r\n\t            \"}\"\r\n\t        )(F)\r\n\t    } else {\r\n\t        // dynamically creating this function cause there's no other way to dynamically name a function\r\n\t        var ProtoObjectFactory = new Function('F','i','u','n', // shitty variables cause minifiers aren't gonna minify my function string here\r\n\t            \"return function \" + constructorName + \"(){ \" +\r\n\t                \"var x=new F(),r=i.apply(x,arguments)\\n\" +    // populate object via the constructor\r\n\t                \"if(r===n)\\n\" +\r\n\t                    \"return x\\n\" +\r\n\t                \"else if(r===u)\\n\" +\r\n\t                    \"return n\\n\" +\r\n\t                \"else\\n\" +\r\n\t                    \"return r\\n\" +\r\n\t            \"}\"\r\n\t        )(F, prototype[init], proto[protoUndefined]) // note that n is undefined\r\n\t    }\r\n\t\r\n\t    prototype.constructor = ProtoObjectFactory;    // set the constructor property on the prototype\r\n\t\r\n\t    // add all the prototype properties onto the static class as well (so you can access that class when you want to reference superclass properties)\r\n\t    for(var n in prototype) {\r\n\t        addProperty(ProtoObjectFactory, prototype, n)\r\n\t    }\r\n\t\r\n\t    // add properties from parent that don't exist in the static class object yet\r\n\t    for(var n in parent) {\r\n\t        if(ownProperty.call(parent, n) && ProtoObjectFactory[n] === undefined) {\r\n\t            addProperty(ProtoObjectFactory, parent, n)\r\n\t        }\r\n\t    }\r\n\t\r\n\t    ProtoObjectFactory.parent = parent;            // special parent property only available on the returned proto class\r\n\t    ProtoObjectFactory[prototypeName] = prototype  // set the prototype on the object factory\r\n\t\r\n\t    return ProtoObjectFactory;\r\n\t}\r\n\t\r\n\tproto[protoUndefined] = {} // a special marker for when you want to return undefined from a constructor\r\n\t\r\n\tmodule.exports = proto\r\n\t\r\n\tfunction normalizeErrorObject(ErrorObject, namePointer) {\r\n\t    function NormalizedError() {\r\n\t        var tmp = new ErrorObject(arguments[0])\r\n\t        tmp.name = namePointer.name\r\n\t\r\n\t        this.message = tmp.message\r\n\t        if(Object.defineProperty) {\r\n\t            /*this.stack = */Object.defineProperty(this, 'stack', { // getter for more optimizy goodness\r\n\t                get: function() {\r\n\t                    return tmp.stack\r\n\t                }\r\n\t            })\r\n\t        } else {\r\n\t            this.stack = tmp.stack\r\n\t        }\r\n\t\r\n\t        return this\r\n\t    }\r\n\t\r\n\t    var IntermediateInheritor = function() {}\r\n\t        IntermediateInheritor.prototype = ErrorObject.prototype\r\n\t    NormalizedError.prototype = new IntermediateInheritor()\r\n\t\r\n\t    return NormalizedError\r\n\t}\r\n\t\r\n\tfunction addProperty(factoryObject, prototype, property) {\r\n\t    try {\r\n\t        var info = Object.getOwnPropertyDescriptor(prototype, property)\r\n\t        if(info.get !== undefined || info.get !== undefined && Object.defineProperty !== undefined) {\r\n\t            Object.defineProperty(factoryObject, property, info)\r\n\t        } else {\r\n\t            factoryObject[property] = prototype[property]\r\n\t        }\r\n\t    } catch(e) {\r\n\t        // do nothing, if a property (like `name`) can't be set, just ignore it\r\n\t    }\r\n\t}\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\r\n\t * HashMap - HashMap Class for JavaScript\r\n\t * @author Ariel Flesler <aflesler@gmail.com>\r\n\t * @version 2.0.1\r\n\t * Homepage: https://github.com/flesler/hashmap\r\n\t */\r\n\t\r\n\t(function(factory) {\r\n\t\tif (true) {\r\n\t\t\t// AMD. Register as an anonymous module.\r\n\t\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t\t} else if (typeof module === 'object') {\r\n\t\t\t// Node js environment\r\n\t\t\tvar HashMap = module.exports = factory();\r\n\t\t\t// Keep it backwards compatible\r\n\t\t\tHashMap.HashMap = HashMap;\r\n\t\t} else {\r\n\t\t\t// Browser globals (this is window)\r\n\t\t\tthis.HashMap = factory();\r\n\t\t}\r\n\t}(function() {\r\n\t\r\n\t\tfunction HashMap(other) {\r\n\t\t\tthis.clear();\r\n\t\t\tswitch (arguments.length) {\r\n\t\t\t\tcase 0: break;\r\n\t\t\t\tcase 1: this.copy(other); break;\r\n\t\t\t\tdefault: multi(this, arguments); break;\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar proto = HashMap.prototype = {\r\n\t\t\tconstructor:HashMap,\r\n\t\r\n\t\t\tget:function(key) {\r\n\t\t\t\tvar data = this._data[this.hash(key)];\r\n\t\t\t\treturn data && data[1];\r\n\t\t\t},\r\n\t\r\n\t\t\tset:function(key, value) {\r\n\t\t\t\t// Store original key as well (for iteration)\r\n\t\t\t\tthis._data[this.hash(key)] = [key, value];\r\n\t\t\t},\r\n\t\r\n\t\t\tmulti:function() {\r\n\t\t\t\tmulti(this, arguments);\r\n\t\t\t},\r\n\t\r\n\t\t\tcopy:function(other) {\r\n\t\t\t\tfor (var key in other._data) {\r\n\t\t\t\t\tthis._data[key] = other._data[key];\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\thas:function(key) {\r\n\t\t\t\treturn this.hash(key) in this._data;\r\n\t\t\t},\r\n\t\r\n\t\t\tsearch:function(value) {\r\n\t\t\t\tfor (var key in this._data) {\r\n\t\t\t\t\tif (this._data[key][1] === value) {\r\n\t\t\t\t\t\treturn this._data[key][0];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn null;\r\n\t\t\t},\r\n\t\r\n\t\t\tremove:function(key) {\r\n\t\t\t\tdelete this._data[this.hash(key)];\r\n\t\t\t},\r\n\t\r\n\t\t\ttype:function(key) {\r\n\t\t\t\tvar str = Object.prototype.toString.call(key);\r\n\t\t\t\tvar type = str.slice(8, -1).toLowerCase();\r\n\t\t\t\t// Some browsers yield DOMWindow for null and undefined, works fine on Node\r\n\t\t\t\tif (type === 'domwindow' && !key) {\r\n\t\t\t\t\treturn key + '';\r\n\t\t\t\t}\r\n\t\t\t\treturn type;\r\n\t\t\t},\r\n\t\r\n\t\t\tkeys:function() {\r\n\t\t\t\tvar keys = [];\r\n\t\t\t\tthis.forEach(function(value, key) { keys.push(key); });\r\n\t\t\t\treturn keys;\r\n\t\t\t},\r\n\t\r\n\t\t\tvalues:function() {\r\n\t\t\t\tvar values = [];\r\n\t\t\t\tthis.forEach(function(value) { values.push(value); });\r\n\t\t\t\treturn values;\r\n\t\t\t},\r\n\t\r\n\t\t\tcount:function() {\r\n\t\t\t\treturn this.keys().length;\r\n\t\t\t},\r\n\t\r\n\t\t\tclear:function() {\r\n\t\t\t\t// TODO: Would Object.create(null) make any difference\r\n\t\t\t\tthis._data = {};\r\n\t\t\t},\r\n\t\r\n\t\t\tclone:function() {\r\n\t\t\t\treturn new HashMap(this);\r\n\t\t\t},\r\n\t\r\n\t\t\thash:function(key) {\r\n\t\t\t\tswitch (this.type(key)) {\r\n\t\t\t\t\tcase 'undefined':\r\n\t\t\t\t\tcase 'null':\r\n\t\t\t\t\tcase 'boolean':\r\n\t\t\t\t\tcase 'number':\r\n\t\t\t\t\tcase 'regexp':\r\n\t\t\t\t\t\treturn key + '';\r\n\t\r\n\t\t\t\t\tcase 'date':\r\n\t\t\t\t\t\treturn ':' + key.getTime();\r\n\t\r\n\t\t\t\t\tcase 'string':\r\n\t\t\t\t\t\treturn '\"' + key;\r\n\t\r\n\t\t\t\t\tcase 'array':\r\n\t\t\t\t\t\tvar hashes = [];\r\n\t\t\t\t\t\tfor (var i = 0; i < key.length; i++) {\r\n\t\t\t\t\t\t\thashes[i] = this.hash(key[i]);\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\treturn '[' + hashes.join('|');\r\n\t\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t// TODO: Don't use expandos when Object.defineProperty is not available?\r\n\t\t\t\t\t\tif (!key._hmuid_) {\r\n\t\t\t\t\t\t\tkey._hmuid_ = ++HashMap.uid;\r\n\t\t\t\t\t\t\thide(key, '_hmuid_');\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\treturn '{' + key._hmuid_;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tforEach:function(func) {\r\n\t\t\t\tfor (var key in this._data) {\r\n\t\t\t\t\tvar data = this._data[key];\r\n\t\t\t\t\tfunc.call(this, data[1], data[0]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\tHashMap.uid = 0;\r\n\t\r\n\t\t//- Automatically add chaining to some methods\r\n\t\r\n\t\tfor (var method in proto) {\r\n\t\t\t// Skip constructor, valueOf, toString and any other built-in method\r\n\t\t\tif (method === 'constructor' || !proto.hasOwnProperty(method)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tvar fn = proto[method];\r\n\t\t\tif (fn.toString().indexOf('return ') === -1) {\r\n\t\t\t\tproto[method] = chain(fn);\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\t//- Utils\r\n\t\r\n\t\tfunction multi(map, args) {\r\n\t\t\tfor (var i = 0; i < args.length; i += 2) {\r\n\t\t\t\tmap.set(args[i], args[i+1]);\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction chain(fn) {\r\n\t\t\treturn function() {\r\n\t\t\t\tfn.apply(this, arguments);\r\n\t\t\t\treturn this;\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\tfunction hide(obj, prop) {\r\n\t\t\t// Make non iterable if supported\r\n\t\t\tif (Object.defineProperty) {\r\n\t\t\t\tObject.defineProperty(obj, prop, {enumerable:false});\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\treturn HashMap;\r\n\t}));\r\n\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// resolves varargs variable into more usable form\n\t// args - should be a function arguments variable\n\t// returns a javascript Array object of arguments that doesn't count trailing undefined values in the length\n\tmodule.exports = function(theArguments) {\n\t    var args = Array.prototype.slice.call(theArguments, 0)\n\t\n\t    var count = 0;\n\t    for(var n=args.length-1; n>=0; n--) {\n\t        if(args[n] === undefined)\n\t            count++\n\t        else\n\t            break\n\t    }\n\t    args.splice(args.length-count, count)\n\t    return args\n\t}\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar proto = __webpack_require__(26)\r\n\tvar EventEmitter = __webpack_require__(25).EventEmitter\r\n\tvar utils = __webpack_require__(32)\r\n\t\r\n\t\r\n\t// emits the event:\r\n\t    // change - the event data is an object of one of the following forms:\r\n\t        // {id:_, type: 'set', property: propertyList}\r\n\t        // {id:_, type: 'added', property: propertyList, index:_, count: numberOfElementsAdded}\r\n\t        // {id:_, type: 'removed', property: propertyList, index:_, values: removedValues}\r\n\tvar Observe = module.exports = proto(EventEmitter, function() {\r\n\t\r\n\t    // static members\r\n\t\r\n\t    this.init = function(obj) {\r\n\t        this.subject = obj\r\n\t\r\n\t        this.setMaxListeners(1000)\r\n\t    }\r\n\t\r\n\t    // instance members\r\n\t\r\n\t    // gets an element or member of the subject and returns another Observee\r\n\t    // changes to the returned Observee will be emitted by its parent as well\r\n\t    this.get = function(property) {\r\n\t        return ObserveeChild(this, parsePropertyList(property))\r\n\t    }\r\n\t\r\n\t    // sets a value on the subject\r\n\t    // property - either an array of members to select, or a string where properties to select are separated by dots\r\n\t    // value - the value to set\r\n\t    this.set = function(property, value) {\r\n\t        setInternal(this, parsePropertyList(property), value, {})\r\n\t    }\r\n\t\r\n\t    // pushes a value onto a list\r\n\t    this.push = function(/*value...*/) {\r\n\t        pushInternal(this, [], arguments, {})\r\n\t    }\r\n\t\r\n\t\r\n\t    // index is the index to remove/insert at\r\n\t    // countToRemove is the number to remove\r\n\t    // elementsToAdd is a list of elements to add\r\n\t    this.splice = function(/*index, countToRemove[, elementsToAdd]*/) {\r\n\t        return spliceInternal(this, [], arguments, {})\r\n\t    }\r\n\t\r\n\t    // use this instead of concat for mutation behavior\r\n\t    this.append = function(arrayToAppend) {\r\n\t        appendInternal(this, [], arguments, {})\r\n\t    }\r\n\t\r\n\t    this.id = function(id) {\r\n\t        return ObserveeChild(this, [], {id: id})\r\n\t        //return idFunction(this, [], id)\r\n\t    }\r\n\t\r\n\t    // For the returned object, any property added via set, push, splice, or append joins an internal observee together with this observee, so that\r\n\t    //      the internal observee and the containing observee will both send 'change' events appropriately\r\n\t    // collapse - (default: false) if true, any property added will be set to the subject of the value added (so that value won't be an observee anymore\r\n\t        // note: only use collapse:true if the observees you're unioning isn't actually an object that inherits from an observee - any instance methods on the observee that come from child classes won't be accessible anymore\r\n\t        // e.g. var x = observe({a:5})\r\n\t        //      var b = observe({})\r\n\t        //      x.subject.a === 5    ;; true\r\n\t        //      b.union(true).set('x', x)\r\n\t        //      b.subject.x.a === 5            ;; true\r\n\t        //      b.subject.x.subject.a === 5    ;; false\r\n\t    this.union = function(collapse) {\r\n\t        if(collapse === undefined) collapse = false\r\n\t        return ObserveeChild(this, [], {union: collapse})\r\n\t    }\r\n\t\r\n\t\r\n\t    /* pause and unpause may cause weird affects in certain cases (e.g. if you remove an element at index 4 and *then* add an element at index 2)\r\n\t    // pause sending events (for when you want to do a lot of things to an object)\r\n\t    this.pause = function() {\r\n\t        this.paused = true\r\n\t    }\r\n\t    this.unpause = function() {\r\n\t        this.paused = undefined\r\n\t        sendEvent(this)\r\n\t    }*/\r\n\t})\r\n\t\r\n\t\r\n\tfunction parsePropertyList(property) {\r\n\t    if(!(property instanceof Array)) {\r\n\t        property = property.toString().split('.')\r\n\t    }\r\n\t\r\n\t    return property\r\n\t}\r\n\t\r\n\tfunction getPropertyPointer(subject, propertyList) {\r\n\t    var current = subject\r\n\t    for(var n=0; n<propertyList.length-1; n++) {\r\n\t        current = current[propertyList[n]]\r\n\t    }\r\n\t\r\n\t    return {obj: current, key:propertyList[n]}\r\n\t}\r\n\t\r\n\tvar getPropertyValue = module.exports.getPropertyValue = function(subject, property) {\r\n\t    var pointer = getPropertyPointer(subject, property)\r\n\t    if(pointer.key !== undefined) {\r\n\t        return pointer.obj[pointer.key]\r\n\t    } else {\r\n\t        return pointer.obj\r\n\t    }\r\n\t}\r\n\t\r\n\t// private\r\n\t\r\n\t// options can have the properties:\r\n\t    // union - if true, any value set, pushed, appended, or spliced onto the observee is unioned\r\n\tvar ObserveeChild = proto(EventEmitter, function() {\r\n\t\r\n\t    this.init = function(parent, propertyList, options) {\r\n\t        if(options === undefined) this.options = {}\r\n\t        else                      this.options = options\r\n\t\r\n\t        if(parent._observeeParent !== undefined)\r\n\t            this._observeeParent = parent._observeeParent\r\n\t        else\r\n\t            this._observeeParent = parent\r\n\t\r\n\t        this.property = propertyList\r\n\t        this.subject = getPropertyValue(parent.subject, propertyList)\r\n\t\r\n\t        var that = this\r\n\t        parent.on('change', function(change) {\r\n\t            var answers = changeQuestions(that.property, change)\r\n\t\r\n\t            if(answers.isWithin ) {\r\n\t                that.emit('change', {type:change.type, property: change.property.slice(that.property.length), index:change.index, count:change.count, removed: change.removed})\r\n\t            } else if(answers.couldRelocate) {\r\n\t                if(change.type === 'removed') {\r\n\t                    var relevantIndex = that.property[change.property.length]\r\n\t                    var removedIndexesAreBeforeIndexOfObserveeChild = change.index + change.removed.length - 1 < relevantIndex\r\n\t\r\n\t                    if(removedIndexesAreBeforeIndexOfObserveeChild) {\r\n\t                        that.property[change.property.length] = relevantIndex - change.removed.length // change the propertyList to match the new index\r\n\t                    }\r\n\t                } else if(change.type === 'added') {\r\n\t                    var relevantIndex = that.property[change.property.length]\r\n\t                    if(change.index < relevantIndex) {\r\n\t                        that.property[change.property.length] = relevantIndex + change.count // change the propertyList to match the new index\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        })\r\n\t    }\r\n\t\r\n\t    this.get = function(property) {\r\n\t        return this._observeeParent.get(this.property.concat(parsePropertyList(property)))\r\n\t    }\r\n\t\r\n\t    this.set = function(property, value) {\r\n\t        setInternal(this._observeeParent, this.property.concat(parsePropertyList(property)), value, this.options)\r\n\t    }\r\n\t\r\n\t    this.push = function(/*values...*/) {\r\n\t        pushInternal(this._observeeParent, this.property, arguments, this.options)\r\n\t    }\r\n\t\r\n\t    this.splice = function(index, countToRemove/*[, elementsToAdd....]*/) {\r\n\t        spliceInternal(this._observeeParent, this.property, arguments, this.options)\r\n\t    }\r\n\t\r\n\t    this.append = function(/*[property,] arrayToAppend*/) {\r\n\t        appendInternal(this._observeeParent, this.property, arguments, this.options)\r\n\t    }\r\n\t\r\n\t    this.id = function(id) {\r\n\t        return ObserveeChild(this, this.property, utils.merge({}, this.options, {id: id}))\r\n\t        //return idFunction(this._observeeParent, this.property, id)\r\n\t    }\r\n\t\r\n\t    this.union = function(collapse) {\r\n\t        if(collapse === undefined) collapse = false\r\n\t        return ObserveeChild(this, [], utils.merge({}, this.options, {union: collapse}))\r\n\t    }\r\n\t\r\n\t})\r\n\t\r\n\t     /*\r\n\tfunction idFunction(that, propertyList, id) {\r\n\t    var result = {\r\n\t        set: function(property, value) {\r\n\t            var fullPropertyList = propertyList.concat(parsePropertyList(property))\r\n\t            setInternal(that, fullPropertyList, value, id)\r\n\t        },\r\n\t        push: function() {\r\n\t            pushInternal(that, propertyList, arguments, id)\r\n\t        },\r\n\t        splice: function() {\r\n\t            spliceInternal(that, propertyList, arguments, id)\r\n\t        },\r\n\t        append: function() {\r\n\t            appendInternal(that, propertyList, arguments, id)\r\n\t        },\r\n\t        get: function() {\r\n\t\r\n\t        }\r\n\t    }\r\n\t}\r\n\t*/\r\n\t\r\n\t// that - the Observee object\r\n\tfunction setInternal(that, propertyList, value, options) {\r\n\t    var pointer = getPropertyPointer(that.subject, propertyList)\r\n\t\r\n\t    var internalObservee = value\r\n\t    if(options.union === true) {\r\n\t        value = value.subject\r\n\t    }\r\n\t\r\n\t    pointer.obj[pointer.key] = value\r\n\t\r\n\t    var event = {type: 'set', property: propertyList}\r\n\t    if(options.id !== undefined) event.id = options.id\r\n\t    that.emit('change',event)\r\n\t\r\n\t    if(options.union !== undefined)\r\n\t        unionizeEvents(that, internalObservee, propertyList, options.union)\r\n\t}\r\n\t\r\n\tfunction pushInternal(that, propertyList, args, options) {\r\n\t    var array = getPropertyValue(that.subject, propertyList)\r\n\t    var originalLength = array.length\r\n\t    array.push.apply(array, args)\r\n\t\r\n\t    var internalObservees = unionizeList(array, originalLength, args.length, options.union)\r\n\t\r\n\t    var event = {type: 'added', property: propertyList, index: originalLength, count: 1}\r\n\t    if(options.id !== undefined) event.id = options.id\r\n\t    that.emit('change', event)\r\n\t\r\n\t    unionizeListEvents(that, internalObservees, propertyList, options.union)\r\n\t}\r\n\t\r\n\tfunction spliceInternal(that, propertyList, args, options) {\r\n\t    var index = args[0]\r\n\t    var countToRemove = args[1]\r\n\t\r\n\t    var array = getPropertyValue(that.subject, propertyList)\r\n\t    var result = array.splice.apply(array, args)\r\n\t\r\n\t    if(countToRemove > 0) {\r\n\t        var event = {type: 'removed', property: propertyList, index: index, removed: result}\r\n\t        if(options.id !== undefined) event.id = options.id\r\n\t        that.emit('change', event)\r\n\t    }\r\n\t    if(args.length > 2) {\r\n\t        var event = {type: 'added', property: propertyList, index: index, count: args.length-2}\r\n\t\r\n\t        var internalObservees = unionizeList(array, index, event.count, options.union)\r\n\t\r\n\t        if(options.id !== undefined) event.id = options.id\r\n\t        that.emit('change', event)\r\n\t\r\n\t        unionizeListEvents(that, internalObservees, propertyList, options.union)\r\n\t    }\r\n\t\r\n\t    return result\r\n\t}\r\n\t\r\n\t// note: I'm not using splice to do this as an optimization (because otherwise the property list would have to be parsed twice and the value gotten twice) - maybe this optimization wasn't worth it but its already done\r\n\tfunction appendInternal(that, propertyList, args, options) {\r\n\t    var arrayToAppend = args[0]\r\n\t    if(arrayToAppend.length === 0) return; //nothing to do\r\n\t\r\n\t    var array = getPropertyValue(that.subject, propertyList)\r\n\t    var originalLength = array.length\r\n\t\r\n\t    var spliceArgs = [originalLength, 0]\r\n\t    spliceArgs = spliceArgs.concat(arrayToAppend)\r\n\t    var oldLength = array.length\r\n\t    array.splice.apply(array, spliceArgs)\r\n\t\r\n\t    var internalObservees = unionizeList(array, oldLength, array.length, options.union)\r\n\t\r\n\t    var event = {type: 'added', property: propertyList, index: originalLength, count: arrayToAppend.length}\r\n\t    if(options.id !== undefined) event.id = options.id\r\n\t    that.emit('change', event)\r\n\t\r\n\t    unionizeListEvents(that, internalObservees, propertyList, options.union)\r\n\t}\r\n\t\r\n\t// sets a slice of elements to their subjects and\r\n\t// returns the original observee objects along with their indexes\r\n\tfunction unionizeList(array, start, count, union) {\r\n\t    var internalObservees = [] // list of observees and their property path\r\n\t    if(union !== undefined) {\r\n\t        var afterEnd = start+count\r\n\t        for(var n=start; n<afterEnd; n++) {\r\n\t            internalObservees.push({obj: array[n], index: n})\r\n\t            if(union === true)\r\n\t                array[n] = array[n].subject\r\n\t        }\r\n\t    }\r\n\t\r\n\t    return internalObservees\r\n\t}\r\n\t\r\n\t// runs unionizeEvents for elements in a list\r\n\t// internalObservees should be the result from `unionizeList`\r\n\tfunction unionizeListEvents(that, internalObservees, propertyList, collapse) {\r\n\t    for(var n=0; n<internalObservees.length; n++) {\r\n\t        unionizeEvents(that, internalObservees[n].obj, propertyList.concat(internalObservees[n].index), collapse)\r\n\t    }\r\n\t}\r\n\t\r\n\t\r\n\t// sets up the union change events for an observee with one of its inner properties\r\n\t// parameters:\r\n\t    // that - the container observee\r\n\t    // innerObservee - the contained observee\r\n\t    // propertyList - the propertyList to unionize\r\n\t    // collapse - the union option (true for collapse)\r\n\tfunction unionizeEvents(that, innerObservee, propertyList, collapse) {\r\n\t    var propertyListDepth = propertyList.length\r\n\t\r\n\t    if(innerObservee.on === undefined || innerObservee.emit === undefined || innerObservee.removeListener === undefined || innerObservee.set === undefined) {\r\n\t        throw new Error(\"Attempting to union a value that isn't an observee\")\r\n\t    }\r\n\t\r\n\t    var innerChangeHandler, containerChangeHandler\r\n\t    var ignorableContainerEvents = [], ignorableInnerEvents = []\r\n\t    innerObservee.on('change', innerChangeHandler = function(change) {\r\n\t        if(ignorableInnerEvents.indexOf(change) === -1) {        // don't run this for events generated by the union event handlers\r\n\t            if(collapse) {\r\n\t                var property = propertyList.concat(change.property)\r\n\t            } else {\r\n\t                var property = propertyList.concat(['subject']).concat(change.property)\r\n\t            }\r\n\t\r\n\t            var containerChange = utils.merge({}, change, {property: property})\r\n\t            ignorableContainerEvents.push(containerChange)\r\n\t            that.emit('change', containerChange)\r\n\t        }\r\n\t    })\r\n\t    that.on('change', containerChangeHandler = function(change) {\r\n\t        var changedPropertyDepth = change.property.length\r\n\t\r\n\t        var answers = changeQuestions(propertyList, change)\r\n\t        var changeIsWithinInnerProperty = answers.isWithin\r\n\t        var changeCouldRelocateInnerProperty = answers.couldRelocate\r\n\t\r\n\t        if(changeIsWithinInnerProperty && ignorableContainerEvents.indexOf(change) === -1) {   // don't run this for events generated by the union event handlers\r\n\t            if(collapse) {\r\n\t                var property = change.property.slice(propertyListDepth)\r\n\t            } else {\r\n\t                var property = change.property.slice(propertyListDepth+1) // +1 for the 'subject'\r\n\t            }\r\n\t\r\n\t            var innerObserveeEvent = utils.merge({}, change, {property: property})\r\n\t            ignorableInnerEvents.push(innerObserveeEvent)\r\n\t            innerObservee.emit('change', innerObserveeEvent)\r\n\t        } else if(changeCouldRelocateInnerProperty) {\r\n\t            if(change.type === 'set' /*&& changedPropertyDepth <= propertyListDepth  - this part already done above*/) {\r\n\t                removeUnion()\r\n\t            } else if(change.type === 'removed') {\r\n\t                var relevantIndex = propertyList[change.property.length]\r\n\t                var removedIndexesContainsIndexOfInnerObservee = change.index <= relevantIndex && relevantIndex <= change.index + change.removed.length - 1\r\n\t                var removedIndexesAreBeforeIndexOfInnerObservee = change.index + change.removed.length - 1 < relevantIndex && relevantIndex\r\n\t\r\n\t                if(removedIndexesContainsIndexOfInnerObservee && changedPropertyDepth <= propertyListDepth+1) {\r\n\t                    removeUnion()\r\n\t                } else if(removedIndexesAreBeforeIndexOfInnerObservee) {\r\n\t                    propertyList[change.property.length] = relevantIndex - change.removed.length // change the propertyList to match the new index\r\n\t                }\r\n\t            } else if(change.type === 'added') {\r\n\t                var relevantIndex = propertyList[change.property.length]\r\n\t                if(change.index < relevantIndex) {\r\n\t                    propertyList[change.property.length] = relevantIndex + change.count // change the propertyList to match the new index\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    })\r\n\t\r\n\t    var removeUnion = function() {\r\n\t        innerObservee.removeListener('change', innerChangeHandler)\r\n\t        that.removeListener('change', containerChangeHandler)\r\n\t    }\r\n\t}\r\n\t\r\n\t\r\n\t// answers certain questions about a change compared to a property list\r\n\t// returns an object like: {\r\n\t    // isWithin: _,           // true if changeIsWithinInnerProperty\r\n\t    // couldRelocate: _       // true if changeCouldRelocateInnerProperty or if innerProperty might be removed\r\n\t// }\r\n\tfunction changeQuestions(propertyList, change) {\r\n\t    var propertyListDepth = propertyList.length\r\n\t\r\n\t    var changeIsWithinInnerProperty = true // assume true until proven otherwise\r\n\t    var changeCouldRelocateInnerProperty = true // assume true until prove otherwise\r\n\t    for(var n=0; n<propertyListDepth; n++) {\r\n\t        if(change.property[n] !== propertyList[n]) {\r\n\t            changeIsWithinInnerProperty = false\r\n\t            if(n<change.property.length) {\r\n\t                changeCouldRelocateInnerProperty = false\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    if(change.property.length <= propertyListDepth) {\r\n\t        changeIsWithinInnerProperty = false\r\n\t    } else {\r\n\t        changeCouldRelocateInnerProperty = false\r\n\t    }\r\n\t\r\n\t    return {couldRelocate: changeCouldRelocateInnerProperty, isWithin: changeIsWithinInnerProperty}\r\n\t}\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar proto = __webpack_require__(26)\r\n\t\r\n\tvar Block = __webpack_require__(1)\r\n\tvar Style = __webpack_require__(2)\r\n\tvar Cell = __webpack_require__(24);\r\n\t\r\n\t// generates either a Header or a Row, depending on what you pass in\r\n\t// elementType should either be \"tr\" or \"th\r\n\t// name should either be \"Header\" or \"Row\r\n\tmodule.exports = function(elementType, name) {\r\n\t    return proto(Block, function(superclass) {\r\n\t\r\n\t        // static properties\r\n\t\r\n\t        this.name = name\r\n\t\r\n\t        this.defaultStyle = Style({\r\n\t            display: 'table-row'\r\n\t        })\r\n\t\r\n\t\r\n\t        // instance properties\r\n\t\r\n\t        this.init = function(/*[label,] rowInit*/) {\r\n\t            if(arguments[0] instanceof Array) {\r\n\t                var rowInit = arguments[0]\r\n\t            } else {\r\n\t                var label = arguments[0]\r\n\t                var rowInit = arguments[1]\r\n\t            }\r\n\t\r\n\t            this.domNode = document.createElement(elementType) // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\r\n\t            superclass.init.call(this) // superclass constructor\r\n\t            this.label = label\r\n\t\r\n\t            if(rowInit !== undefined) {\r\n\t                for(var n=0; n<rowInit.length; n++) {\r\n\t                    this.cell(rowInit[n])\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        this.cell = function(/*[label,] contents*/) {\r\n\t            var cell = Cell.apply(undefined, arguments);\r\n\t            this.add(cell);\r\n\t            return cell;\r\n\t        }\r\n\t    })\r\n\t}\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t// resolves . and .. elements in a path array with directory names there\n\t// must be no slashes, empty elements, or device names (c:\\) in the array\n\t// (so also no leading and trailing slashes - it does not distinguish\n\t// relative and absolute paths)\n\tfunction normalizeArray(parts, allowAboveRoot) {\n\t  // if the path tries to go above the root, `up` ends up > 0\n\t  var up = 0;\n\t  for (var i = parts.length - 1; i >= 0; i--) {\n\t    var last = parts[i];\n\t    if (last === '.') {\n\t      parts.splice(i, 1);\n\t    } else if (last === '..') {\n\t      parts.splice(i, 1);\n\t      up++;\n\t    } else if (up) {\n\t      parts.splice(i, 1);\n\t      up--;\n\t    }\n\t  }\n\t\n\t  // if the path is allowed to go above the root, restore leading ..s\n\t  if (allowAboveRoot) {\n\t    for (; up--; up) {\n\t      parts.unshift('..');\n\t    }\n\t  }\n\t\n\t  return parts;\n\t}\n\t\n\t// Split a filename into [root, dir, basename, ext], unix version\n\t// 'root' is just a slash, or nothing.\n\tvar splitPathRe =\n\t    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n\tvar splitPath = function(filename) {\n\t  return splitPathRe.exec(filename).slice(1);\n\t};\n\t\n\t// path.resolve([from ...], to)\n\t// posix version\n\texports.resolve = function() {\n\t  var resolvedPath = '',\n\t      resolvedAbsolute = false;\n\t\n\t  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n\t    var path = (i >= 0) ? arguments[i] : process.cwd();\n\t\n\t    // Skip empty and invalid entries\n\t    if (typeof path !== 'string') {\n\t      throw new TypeError('Arguments to path.resolve must be strings');\n\t    } else if (!path) {\n\t      continue;\n\t    }\n\t\n\t    resolvedPath = path + '/' + resolvedPath;\n\t    resolvedAbsolute = path.charAt(0) === '/';\n\t  }\n\t\n\t  // At this point the path should be resolved to a full absolute path, but\n\t  // handle relative paths to be safe (might happen when process.cwd() fails)\n\t\n\t  // Normalize the path\n\t  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n\t    return !!p;\n\t  }), !resolvedAbsolute).join('/');\n\t\n\t  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n\t};\n\t\n\t// path.normalize(path)\n\t// posix version\n\texports.normalize = function(path) {\n\t  var isAbsolute = exports.isAbsolute(path),\n\t      trailingSlash = substr(path, -1) === '/';\n\t\n\t  // Normalize the path\n\t  path = normalizeArray(filter(path.split('/'), function(p) {\n\t    return !!p;\n\t  }), !isAbsolute).join('/');\n\t\n\t  if (!path && !isAbsolute) {\n\t    path = '.';\n\t  }\n\t  if (path && trailingSlash) {\n\t    path += '/';\n\t  }\n\t\n\t  return (isAbsolute ? '/' : '') + path;\n\t};\n\t\n\t// posix version\n\texports.isAbsolute = function(path) {\n\t  return path.charAt(0) === '/';\n\t};\n\t\n\t// posix version\n\texports.join = function() {\n\t  var paths = Array.prototype.slice.call(arguments, 0);\n\t  return exports.normalize(filter(paths, function(p, index) {\n\t    if (typeof p !== 'string') {\n\t      throw new TypeError('Arguments to path.join must be strings');\n\t    }\n\t    return p;\n\t  }).join('/'));\n\t};\n\t\n\t\n\t// path.relative(from, to)\n\t// posix version\n\texports.relative = function(from, to) {\n\t  from = exports.resolve(from).substr(1);\n\t  to = exports.resolve(to).substr(1);\n\t\n\t  function trim(arr) {\n\t    var start = 0;\n\t    for (; start < arr.length; start++) {\n\t      if (arr[start] !== '') break;\n\t    }\n\t\n\t    var end = arr.length - 1;\n\t    for (; end >= 0; end--) {\n\t      if (arr[end] !== '') break;\n\t    }\n\t\n\t    if (start > end) return [];\n\t    return arr.slice(start, end - start + 1);\n\t  }\n\t\n\t  var fromParts = trim(from.split('/'));\n\t  var toParts = trim(to.split('/'));\n\t\n\t  var length = Math.min(fromParts.length, toParts.length);\n\t  var samePartsLength = length;\n\t  for (var i = 0; i < length; i++) {\n\t    if (fromParts[i] !== toParts[i]) {\n\t      samePartsLength = i;\n\t      break;\n\t    }\n\t  }\n\t\n\t  var outputParts = [];\n\t  for (var i = samePartsLength; i < fromParts.length; i++) {\n\t    outputParts.push('..');\n\t  }\n\t\n\t  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\t\n\t  return outputParts.join('/');\n\t};\n\t\n\texports.sep = '/';\n\texports.delimiter = ':';\n\t\n\texports.dirname = function(path) {\n\t  var result = splitPath(path),\n\t      root = result[0],\n\t      dir = result[1];\n\t\n\t  if (!root && !dir) {\n\t    // No dirname whatsoever\n\t    return '.';\n\t  }\n\t\n\t  if (dir) {\n\t    // It has a dirname, strip trailing slash\n\t    dir = dir.substr(0, dir.length - 1);\n\t  }\n\t\n\t  return root + dir;\n\t};\n\t\n\t\n\texports.basename = function(path, ext) {\n\t  var f = splitPath(path)[2];\n\t  // TODO: make this comparison case-insensitive on windows?\n\t  if (ext && f.substr(-1 * ext.length) === ext) {\n\t    f = f.substr(0, f.length - ext.length);\n\t  }\n\t  return f;\n\t};\n\t\n\t\n\texports.extname = function(path) {\n\t  return splitPath(path)[3];\n\t};\n\t\n\tfunction filter (xs, f) {\n\t    if (xs.filter) return xs.filter(f);\n\t    var res = [];\n\t    for (var i = 0; i < xs.length; i++) {\n\t        if (f(xs[i], i, xs)) res.push(xs[i]);\n\t    }\n\t    return res;\n\t}\n\t\n\t// String.prototype.substr - negative index don't work in IE8\n\tvar substr = 'ab'.substr(-1) === 'b'\n\t    ? function (str, start, len) { return str.substr(start, len) }\n\t    : function (str, start, len) {\n\t        if (start < 0) start = str.length + start;\n\t        return str.substr(start, len);\n\t    }\n\t;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(33)))\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// utilities needed by the configuration (excludes dependencies the configs don't need so the webpack bundle is lean)\r\n\t\r\n\tvar path = __webpack_require__(31)\r\n\t\r\n\t\r\n\t// Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1\r\n\t// any number of objects can be passed into the function and will be merged into the first argument in order\r\n\t// returns obj1 (now mutated)\r\n\tvar merge = exports.merge = function(obj1, obj2/*, moreObjects...*/){\r\n\t    return mergeInternal(arrayify(arguments), false)\r\n\t}\r\n\t\r\n\t// like merge, but traverses the whole object tree\r\n\t// the result is undefined for objects with circular references\r\n\tvar deepMerge = exports.deepMerge = function(obj1, obj2/*, moreObjects...*/) {\r\n\t    return mergeInternal(arrayify(arguments), true)\r\n\t}\r\n\t\r\n\tfunction mergeInternal(objects, deep) {\r\n\t    var obj1 = objects[0]\r\n\t    var obj2 = objects[1]\r\n\t\r\n\t    for(var key in obj2){\r\n\t       if(Object.hasOwnProperty.call(obj2, key)) {\r\n\t            if(deep && obj1[key] instanceof Object && obj2[key] instanceof Object) {\r\n\t                mergeInternal([obj1[key], obj2[key]], true)\r\n\t            } else {\r\n\t                obj1[key] = obj2[key]\r\n\t            }\r\n\t       }\r\n\t    }\r\n\t\r\n\t    if(objects.length > 2) {\r\n\t        var newObjects = [obj1].concat(objects.slice(2))\r\n\t        return mergeInternal(newObjects, deep)\r\n\t    } else {\r\n\t        return obj1\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction arrayify(a) {\r\n\t    return Array.prototype.slice.call(a, 0)\r\n\t}\r\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\t\n\tprocess.nextTick = (function () {\n\t    var canSetImmediate = typeof window !== 'undefined'\n\t    && window.setImmediate;\n\t    var canMutationObserver = typeof window !== 'undefined'\n\t    && window.MutationObserver;\n\t    var canPost = typeof window !== 'undefined'\n\t    && window.postMessage && window.addEventListener\n\t    ;\n\t\n\t    if (canSetImmediate) {\n\t        return function (f) { return window.setImmediate(f) };\n\t    }\n\t\n\t    var queue = [];\n\t\n\t    if (canMutationObserver) {\n\t        var hiddenDiv = document.createElement(\"div\");\n\t        var observer = new MutationObserver(function () {\n\t            var queueList = queue.slice();\n\t            queue.length = 0;\n\t            queueList.forEach(function (fn) {\n\t                fn();\n\t            });\n\t        });\n\t\n\t        observer.observe(hiddenDiv, { attributes: true });\n\t\n\t        return function nextTick(fn) {\n\t            if (!queue.length) {\n\t                hiddenDiv.setAttribute('yes', 'no');\n\t            }\n\t            queue.push(fn);\n\t        };\n\t    }\n\t\n\t    if (canPost) {\n\t        window.addEventListener('message', function (ev) {\n\t            var source = ev.source;\n\t            if ((source === window || source === null) && ev.data === 'process-tick') {\n\t                ev.stopPropagation();\n\t                if (queue.length > 0) {\n\t                    var fn = queue.shift();\n\t                    fn();\n\t                }\n\t            }\n\t        }, true);\n\t\n\t        return function nextTick(fn) {\n\t            queue.push(fn);\n\t            window.postMessage('process-tick', '*');\n\t        };\n\t    }\n\t\n\t    return function nextTick(fn) {\n\t        setTimeout(fn, 0);\n\t    };\n\t})();\n\t\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\t// TODO(shtylman)\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\n\n/***/ }\n/******/ ])\n});\n\n\n\n/** WEBPACK FOOTER **\n ** blocks.umd.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 8d1ee4cfca7813806c4b\n **/","exports.Block = require('Block')\r\nexports.Style = require('Style')\r\n\r\nexports.Canvas = require('Components/Canvas')\r\nexports.Container = require(\"Components/Container\")\r\nexports.Button = require(\"Components/Button\")\r\nexports.CheckBox = require(\"Components/CheckBox\")\r\nexports.Image = require('Components/Image')\r\nexports.List = require('Components/List')\r\n//exports.MultiSelect = require(\"Components/MultiSelect\") // not ready yet\r\nexports.Radio = require(\"Components/Radio\")\r\nexports.Select = require(\"Components/Select\")\r\nexports.Table = require(\"Components/Table\")\r\nexports.TextArea = require(\"Components/TextArea\")\r\nexports.TextField = require(\"Components/TextField\")\r\nexports.Text = require(\"Components/Text\")\r\n\r\n\r\n\r\nObject.defineProperty(exports, 'dev', {\r\n    get: function() {\r\n        return exports.Block.dev\r\n    }, set: function(v) {\r\n        exports.Block.dev = v\r\n    }\r\n})\r\n\r\nexports.attach = function(/*component,component,.. or components*/) {\r\n    exports.Block.attach.apply(this,arguments)\r\n}\r\nexports.detach = function(/*component,component,.. or components*/) {\r\n    exports.Block.detach.apply(this,arguments)\r\n}\r\n\r\nexports.createBody = function(callback) {\r\n    exports.Block.detach.apply(this,arguments)\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./blocks.browser.js\n ** module id = 0\n ** module chunks = 0\n **/","var EventEmitterB = require('EventEmitterB')\nvar proto = require(\"proto\");\nvar trimArguments = require(\"trimArguments\")\nvar observe = require('observe')\n\nvar utils = require('./utils')\nvar domUtils = require('./domUtils')\nvar blockStyleUtils = require(\"./blockStyleUtils\")\n\nvar Style = require(\"./Style\")\nStyle.isDev = function() {return module.exports.dev}\n\nvar components = {};\n\nvar setOfBrowserEvents = utils.arrayToMap([\n    'abort','afterprint','animationend','animationiteration','animationstart','audioprocess','beforeprint','beforeunload',\n    'beginEvent','blocked','blur','cached','canplay','canplaythrough','change','chargingchange','chargingtimechange',\n    'checking','click','close','compassneedscalibration','complete','compositionend','compositionstart','compositionupdate','contextmenu',\n    'copy','cut','dblclick','decivelight','devicemotion','deviceorientation','deviceproximity','dischargingtimechange','DOMContentLoaded',\n    'downloading','drag','dragend','dragenter','dragleave','dragover','dragstart','drop','durationchange','emptied','ended','endEvent',\n    'error','focus','focusin','focusout','fullscreenchange','fullscreenerror','gamepadconnected','gamepaddisconnected','hashchange',\n    'input','invalid','keydown','keypress','keyup','languagechange','levelchange','load','loadeddata','loadedmetadata','loadend',\n    'loadstart','message','mousedown','mouseenter','mouseleave','mousemove','mouseout','mouseover','mouseup','noupdate','obsolete',\n    'offline','online','open','orientationchange','pagehide','pageshow','paste','pause','pointerlockchange','pointerlockerror','play',\n    'playing','popstate','progress','ratechange','readystatechange','repeatEvent','reset','resize','scroll','seeked','seeking','select',\n    'show','stalled','storage','submit','success','suspend','SVGAbort','SVGError','SVGLoad','SVGResize','SVGScroll','SVGUnload','SVGZoom',\n    'timeout','timeupdate','touchcancel','touchend','touchenter','touchleave','touchmove','touchstart','transitionend','unload',\n    'updateready','upgradeneeded','userproximity','versionchange','visibilitychange','volumechange','waiting','wheel'\n])\n\n// events:\n    // newParent - emits this when a component gets a new parent\n    // parentRemoved - emits this when a component is detached from its parent\nvar Block = module.exports = proto(EventEmitterB,function(superclass) {\n\n    // static properties\n\n    // constructor\n\tthis.init = function() {\n        var that = this\n\n        if(this.name === undefined) {\n            throw new Error(\"The 'name' property is required for Blocks\")\n        }\n\n        var defaultBlockStyle = blockStyleUtils.defaultStyleMap.get(this.constructor)\n        if(defaultBlockStyle === undefined) {\n            defaultBlockStyle = blockStyleUtils.createDefaultBlockStyle(this)\n        }\n\n        superclass.init.call(this)\n\n        this.children = []\n        this.state = observe({})\n        this.parent = undefined;\n\n\t\tif (this.id !== undefined) {\n\t\t\tcomponents[this.id] = this;\n\t\t}\n\n        if(this.domNode === undefined) {\n            this.domNode = domUtils.div()\n        }\n\n        this.build.apply(this, arguments)\n\n        //if(module.exports.dev) {\n            this.attr('blkName', this.name)\n        //}\n\n        var classList = [this.domNode.className]\n        if(defaultBlockStyle !== false) classList.push(defaultBlockStyle.className)\n        classList.push(Style.defaultClassName)\n        this.domNode.className = classList.join(' ') // note that the order of classes doesn't matter\n\n        // set up dom event handlers\n        var ifonHandlers={}\n        that.ifon(function(event) {\n            if(event in setOfBrowserEvents && (that.excludeDomEvents === undefined || !(event in that.excludeDomEvents))) {\n                that.domNode.addEventListener(event, ifonHandlers[event]=function() {\n                    that.emit.apply(that, [event].concat(Array.prototype.slice.call(arguments)))\n                })\n            }\n        })\n        that.ifoff(function(event) {\n            if(event in setOfBrowserEvents && (that.excludeDomEvents === undefined || !(event in that.excludeDomEvents))) {\n                that.domNode.removeEventListener(event,ifonHandlers[event])\n            }\n        })\n\t}\n\n    // sub-constructor - called by the constructor\n    // parameters:\n        // label - (Optional) A label that can be used to style a component differently.\n                   // Intended to be some string describing what the component is being used for.\n                   // Note, tho, that labels are not dynamic - changing the label won't affect styling until a new style is applied to the component)\n        // domNode - (Optional) A domNode to be used as the container domNode instead of the default (a div)\n    this.build = function(/*[label,] domNode*/) {\n        if(arguments.length === 1) {\n            this.domNode = arguments[0]\n        } else if(arguments.length >= 2) {\n            this.label = arguments[0]\n            this.domNode = arguments[1]\n        }\n    }\n\t\n\n\t// instance properties\n\n\t\n\tthis.domNode;\n    this.label;\n    this.excludeDomEvents;\n    this.children;     // a list of child components that are a part of a Block object (these are used so Styles can be propogated down to child components)\n\n\n    Object.defineProperty(this, 'label', {\n        get: function() {\n            return this._label\n        }, set: function(v) {\n            if(this._label === undefined) {\n                this._label = v\n\n                if(module.exports.dev) {\n                    this.attr('label', this._label)\n                }\n            } else {\n                throw new Error(\"A Block's label can only be set once (was already set to: \"+this._label+\")\")\n            }\n        }\n    })\n\n    // adds elements to the components main domNode\n    // arguments can be one of the following:\n        // component, component, component, ...\n        // listOfBlocks\n    this.add = function() {\n        this.addAt.apply(this, [this.domNode.children.length].concat(trimArguments(arguments)))\n\t}\n\n    // adds nodes at a particular index\n    // nodes can be one of the following:\n        // component, component, component, ...\n        // listOfBlocks\n    this.addAt = function(index/*, nodes...*/) {\n        var nodes = normalizeAddAtArguments.apply(this, arguments)\n\n        for (var i=0;i<nodes.length;i++) {\n\t\t\tvar node = nodes[i];\n            this.children.splice(index+i, 0, node)\n\n            if(!isBlock(node)) {\n                throw new Error(\"node is not a Block\")\n            }\n\n            node.parent = undefined\n            node.emit('parentRemoved')\n\n            var beforeChild = this.children[1+i+index]\n            if(beforeChild === undefined) {\n                this.domNode.appendChild(node.domNode)\n            } else {\n                this.domNode.insertBefore(node.domNode, beforeChild.domNode)\n            }\n\n            node.parent = this;\n            node.emit('newParent')\n\n            // apply styles\n            //if(itsaBlock) { // its always a component now\n                var that = this\n                node.getParentStyleMap = function() {return that.computedStyleMap}\n                blockStyleUtils.propogateStyleSet([node], this.computedStyleMap)\n            //}\n\t\t}\n    }\n\n\t// add a list of nodes before a particular node\n    // if beforeChild is undefined, this will append the given nodes\n    // arguments can be one of the following:\n        // component, component, component, ...\n        // listOfBlocks\n    this.addBefore = this.addBeforeNode = function(beforeChild) {\n        var nodes = trimArguments(arguments).slice(1)\n        if(beforeChild === undefined) {\n            this.add.apply(this, nodes)\n        } else {\n            var index = this.children.indexOf(beforeChild)\n            this.addAt.apply(this, [index].concat(nodes))\n        }\n    }\n\n\n    // arguments can be one of the following:\n        // component, component, component, ...\n        // index, index, index, ... - each index is the numerical index to remove\n        // arrayOfComponents\n        // arrayOfIndexes\n    this.remove = function() {\n        var removals = normalizeRemoveArguments.apply(this, arguments)\n        removals = removals.sort(function(a,b) {\n            return b-a // reverse sort (so that removing multiple indexes doesn't mess up)\n        })\n\n        for(var n=0; n<removals.length; n++) {\n            var r = removals[n]\n            var c = this.children[r]\n\n            if(c === undefined) {\n                throw new Error(\"There is no child at index \"+r)\n            }\n\n            c.parent = undefined\n            this.children.splice(r, 1)\n            this.domNode.removeChild(this.domNode.childNodes[r])\n\n            c.emit('parentRemoved')\n        }\n    }\n\n    // sets or gets an attribute on the components domNode\n    // parameter sets:\n    // if one argument is passed, the attribute's value is returned (if there is no attribute, undefined is returned)\n    // if there are two arguments passed, the attribute is set\n        // if 'value' is undefined, the attribute is removed\n    this.attr = function(/*attribute, value OR attributeObject*/) {\n        if(arguments.length === 1) {\n            if(arguments[0] instanceof Object) {\n                var attributes = arguments[0]\n                for(var attribute in attributes) {\n                    domUtils.setAttribute(this.domNode, attribute, arguments[0][attribute])\n                }\n            } else {\n                var attribute = this.domNode.getAttribute(arguments[0])\n                if(attribute === null) {\n                    return undefined // screw null\n                } else {\n                    return attribute\n                }\n            }\n        } else {\n            var attribute = arguments[0]\n            if(arguments[1] !== undefined) {\n                var value = arguments[1]\n                domUtils.setAttribute(this.domNode, arguments[0], value)\n            } else {\n                this.domNode.removeAttribute(attribute)\n            }\n        }\n    }\n\n    Object.defineProperty(this, 'visible', {\n        // returns true if the element is visible\n        get: function() {\n            return this.domNode.style.display !== 'none';\n\n        // sets whether or not the element is visible\n        }, set: function(setToVisible) {\n            if(setToVisible) {\n                if (this._displayStyle !== undefined) {\n                    this.domNode.style.display = this._displayStyle // set back to its previous inline style\n                    this._displayStyle = undefined\n                } else {\n                    this.domNode.style.display = ''\n                }\n            } else {\n                if(this.domNode.style.display !== '' && this.domNode.style.display !== 'none') { // domNode has inline style\n                    this._displayStyle = this.domNode.style.display\n                }\n\n                this.domNode.style.display = 'none'\n            }\n        }\n    })\n\n\n    Object.defineProperty(this, 'focus', {\n        // returns true if the element is in focus\n        get: function() {\n            return document.activeElement === this.domNode\n\n        // sets whether or not the element is in focus (setting it to true gives it focus, setting it to false blurs it)\n        }, set: function(setToInFocus) {\n            if(setToInFocus) {\n                this.domNode.focus()\n            } else {\n                this.domNode.blur()\n            }\n        }\n    })\n\n    Object.defineProperty(this, 'style', {\n        get: function() {\n            return this._style\n\n        // sets the style, replacing one if one already exists\n        }, set: function(styleObject) {\n            if(styleObject === undefined) {\n                var styleMap = this.getParentStyleMap()\n                if(styleMap !== undefined) {\n                    blockStyleUtils.setCurrentStyle(this, blockStyleUtils.getStyleForComponent(styleMap, this))\n                } else {\n                    blockStyleUtils.setCurrentStyle(this, undefined)\n                }\n\n                this.computedStyleMap = styleMap\n\n            } else {\n                blockStyleUtils.setCurrentStyle(this, styleObject)\n                var specificStyle = styleObject.get(this)\n                if(this.getParentStyleMap() !== undefined) {\n                    this.computedStyleMap = blockStyleUtils.styleMapConjunction(this.getParentStyleMap(), specificStyle.componentStyleMap)\n                } else {\n                    this.computedStyleMap = specificStyle.componentStyleMap\n                }\n            }\n\n            this._style = styleObject\n            blockStyleUtils.propogateStyleSet(this.children, this.computedStyleMap) // propogate styles to children\n        }\n    })\n\n    Object.defineProperty(this, 'selectionRange', {\n        // returns the visible character selection range inside the element\n        // returns an array like [offsetStart, offsetEnd]\n        get: function() {\n            return domUtils.getSelectionRange(this.domNode)\n\n        // sets the visible character selection range\n        }, set: function(selection) {\n            domUtils.setSelectionRange(this.domNode, selection[0], selection[1])\n        }\n    })\n\n    this.attach = function() {\n        attach(this)\n    }\n    this.detach = function() {\n        detach(this)\n    }\n\n\n\t// private instance variables/functions\n\n    this.getParentStyleMap = function() {/*default returns undefined*/}  // should be set to a function that returns the computedStyleMap of the component containing this one (so Styles objects can be inherited)\n    this.computedStyleMap;  // a map of style objects computed from the Styles set on a given component and its parent components\n\n\tthis._style;              // the object's explicit Style object (undefined if it inherits a style)\n    this.currentStyle;       // the object's current Style (inherited or explicit)\n    this._displayStyle;      // temporariliy stores an inline display style while the element is hidden (for use when 'show' is called)\n    this._styleSetupStates   // place to put states for setup functions (used for css pseudoclass emulation)\n});\n\n\nmodule.exports.dev = false // set to true to enable dom element naming (so you can see boundaries of components when inspecting the dom)\n\n\n// appends components to the body\nvar attach = module.exports.attach = function(/*component,component,.. or components*/) {\n    if(arguments[0] instanceof Array) {\n        var components = arguments[0]\n    } else {\n        var components = arguments\n    }\n\n    if(document.body === null) throw new Error(\"Your document does not have a body.\")\n\n    for(var n=0; n<components.length; n++) {\n        document.body.appendChild(components[n].domNode)\n    }\n}\n// removes components from the body\nvar detach = module.exports.detach = function(/*component,component,.. or components*/) {\n    if(arguments[0] instanceof Array) {\n        var components = arguments[0]\n    } else {\n        var components = arguments\n    }\n\n    for(var n=0; n<components.length; n++) {\n        document.body.removeChild(components[n].domNode)\n    }\n}\n\n// creates a body tag (only call this if document.body is null)\n\nmodule.exports.createBody = function(callback) {\n    var dom = document.implementation.createDocument('http://www.w3.org/1999/xhtml', 'html', null);\n    var body = dom.createElement(\"body\")\n    dom.documentElement.appendChild(body)\n    setTimeout(function() {  // set timeout is needed because the body tag is only added after javascript goes back to the scheduler\n        callback()\n    },0)\n}\n\n\n\n\n// returns a list of indexes to remove from Block.remove's arguments\n/*private*/ var normalizeRemoveArguments = module.exports.normalizeRemoveArguments = function() {\n    var that = this\n\n    if(arguments[0] instanceof Array) {\n        var removals = arguments[0]\n    } else {\n        var removals = Array.prototype.slice.call(arguments)\n    }\n\n    return removals.map(function(removal, parameterIndex) {\n        if(isBlock(removal)) {\n            var index = that.children.indexOf(removal)\n            if(index === -1) {\n                throw new Error(\"The Block passed at index \"+parameterIndex+\" is not a child of this Block.\")\n            }\n            return index\n        } else {\n            return removal\n        }\n\n    })\n}\n\n// returns a list of nodes to add\n/*private*/ var normalizeAddAtArguments = module.exports.normalizeAddAtArguments = function() {\n    if(arguments.length === 2) {\n        if(arguments[1] instanceof Array) {\n            return arguments[1]\n        } else {\n            return [arguments[1]]\n        }\n    } else { // > 2\n        return trimArguments(arguments).slice(1)\n    }\n}\n\nfunction isBlock(c) {\n    return c.add !== undefined && c.children instanceof Array && c.domNode !== undefined\n}\nfunction isDomNode(node) {\n    return node.nodeName !== undefined\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Block.js\n ** module id = 1\n ** module chunks = 0\n **/","var jssModule = require(\"../external/jss\")\nvar proto = require('proto')\nvar HashMap = require('hashmap')\n\nvar utils = require(\"./utils\")\nvar blockStyleUtils = require(\"./blockStyleUtils\")\n\nvar baseClassName = '_ComponentStyle_' // the base name for generated class names\nvar nextClassNumber = 0\n\nvar defaultJss = jssModule.forDocument(document) // must be created before the jss object (so that the styles there override the styles in the default sheet)\ndefaultJss.defaultSheet = defaultJss._createSheet() // create its sheet first (before the regular jss sheet)\nvar jss = jssModule.forDocument(document)\njss.defaultSheet = jss._createSheet()\n\n// creates a style object\nvar Style = module.exports = proto(function() {\n\n    this.defaultClassName = '_default_'     // the name of the default class (used to prevent style inheritance)\n\n    // styleDefinition is an object where key-value pairs can be any of the following:\n    // <cssPropertyName>: the value should be a valid css value for that style attribute\n    // <ComponentName>: the value can either be a Style object or a nested styleDefinition object\n    // $setup: the value is a function to be run on a component when the style is applied to it\n    // $kill: the value is a function to be run on a component when a style is removed from it\n    // $state: the value should be a state handler function\n    // $<label>: the value should be a nested styleDefinition object that does not contain any label styles.\n    this.init = function(styleDefinition, privateOptions) {\n        if(privateOptions === undefined) privateOptions = {}\n        if(privateOptions.inLabel===undefined) inLabel = false\n\n        this.className = baseClassName+nextClassNumber\n        nextClassNumber++\n\n        this.componentStyleMap = {}\n        this.labelStyleMap = {}\n\n        var labelStyles = {}\n        var pseudoClassStyles = {}\n        var cssProperties = {}\n        for(var key in styleDefinition) {\n            var value = styleDefinition[key]\n\n            if(key === '$setup') {\n                if(!(value instanceof Function)) throw new Error(\"$setup key must be a function ('setup' can't be used as a label)\")\n                this.setup = value\n\n            } else if(key === '$kill') {\n                if(!(value instanceof Function)) throw new Error(\"$kill key must be a function ('kill' can't be used as a label)\")\n                this.kill = value\n\n            } else if(key === '$state') {\n                if(!(value instanceof Function)) throw new Error(\"$state key must be a function ('$state' can't be used as a label)\")\n                this.stateHandler = value\n\n            } else if(key.indexOf('$$') === 0) { // pseudo-class style\n                var pseudoClass = mapCamelCase(key.substr(2))\n                if(pseudoClass === '') {\n                    throw new Error(\"Empty pseudo-class name not valid (style key '$$')\")\n                }\n\n                utils.merge(pseudoClassStyles, flattenPseudoClassStyles(pseudoClass, value))\n\n            } else if(key.indexOf('$') === 0) {   // label style\n                if(privateOptions.inLabel)\n                    throw new Error(\"Can't create nested label style \"+key+\" because components can only have one label\")\n\n                var label = key.substr(1)\n                if(label === '') {\n                    throw new Error(\"Empty label name not valid (style key '$')\")\n                }\n\n                labelStyles[label] = value\n\n            } else if(isStyleObject(value)) {\n                this.componentStyleMap[key] = value\n\n            } else if(value instanceof Object) {\n                this.componentStyleMap[key] = Style(value)  // turn the object description into a full fledged style object\n            } else {\n                var cssStyle = key\n                var cssStyleName = mapCamelCase(cssStyle)\n                cssProperties[cssStyleName] = cssValue(cssStyleName, value)\n            }\n        }\n\n        // create the css class\n        if(privateOptions.default) {\n            var jssSheet = defaultJss\n        } else {\n            var jssSheet = jss\n        }\n\n        jssSheet.set('.'+this.className, cssProperties)\n\n        //if(module.exports.isDev) {\n            this.styleDefinitions = {}\n            this.styleDefinitions['.'+this.className] = cssProperties\n        //}\n\n        // create label styles\n        if(Object.keys(labelStyles).length > 0) {\n            var baseStyle = utils.merge({}, cssProperties, this.componentStyleMap)\n\n            for(var label in labelStyles) {\n                if(isStyleObject(labelStyles[label])) {\n                    this.labelStyleMap[label] = labelStyles[label]\n                } else {\n                    var mergedStyle = utils.merge({}, baseStyle, labelStyles[label])\n                    this.labelStyleMap[label] = Style(mergedStyle, {inLabel:true})\n                }\n            }\n        }\n\n        // create pseudoclass styles\n        if(Object.keys(pseudoClassStyles).length > 0) {\n\n            var tieredPseudoClasses = createTieredPseudoClasses(this, pseudoClassStyles)\n            pseudoclassCombinations(tieredPseudoClasses) // mutates tieredPseudoClasses\n\n            // turn the emulatable pseudo classes into Style objects\n            // also build up the set of psuedoclasses that will be emulated\n            // also build up a map of pseudoclasses-to-emulate to the emulation functions for those pseudoclasses\n            var pseudoClasesToEmulate = []\n            var preSplitPseudoClasses = [] // a list where each element looks like: [pseudoClassList, styleObject]  (this is primarily for performance - so we don't have to split the key every time we check for state changes)\n            var pseudoClassesToEmulationInfo = {}\n            for(var key in tieredPseudoClasses) {\n                if(isStyleObject(tieredPseudoClasses[key])) {\n                    tieredPseudoClasses[key] = tieredPseudoClasses[key]\n                } else {\n                    var newStyle = Style(utils.merge({}, cssProperties, tieredPseudoClasses[key])) // pseudoClassStyles merged with parent css styles\n\n                    // merge in componentStyleMap and labelStyleMap\n                    for(var k in this.componentStyleMap) {\n                        if(newStyle.componentStyleMap[k] === undefined)\n                            newStyle.componentStyleMap[k] = this.componentStyleMap[k]\n                    }\n                    for(var k in this.labelStyleMap) {\n                        if(newStyle.labelStyleMap[k] === undefined)\n                            newStyle.labelStyleMap[k] = this.labelStyleMap[k]\n                    }\n\n                    tieredPseudoClasses[key] = newStyle\n                }\n\n\n                var pseudoClassList = key.split(\":\")\n                for(var n=0; n<pseudoClassList.length; n++) {\n                    var pseudoClass = pseudoClassList[n]\n                    if(pseudoClasesToEmulate.indexOf(pseudoClass) === -1) {\n                        pseudoClasesToEmulate.push(pseudoClass)\n\n                        var pseudoClassParts = getPseudoClassParts(pseudoClass)\n                        var fns = emulatedPseudoClasses[pseudoClassParts.class]\n                        var info = {fns: fns}\n                        if(fns.processParameter !== undefined) {\n                            info.parameter = fns.processParameter(pseudoClassParts.parameter)\n                        }\n                        pseudoClassesToEmulationInfo[pseudoClass] = info\n                    }\n                }\n\n                preSplitPseudoClasses.push([pseudoClassList, tieredPseudoClasses[key]])\n            }\n\n            // create functions that initialize and keep track of state\n            var initializeState = function(component) {\n                var state = {}\n                for(var n=0; n<pseudoClasesToEmulate.length; n++) {\n                    var pseudoClass = pseudoClasesToEmulate[n]\n                    var pseudoClassEmulationInfo = pseudoClassesToEmulationInfo[pseudoClass]\n                    state[pseudoClass] = pseudoClassEmulationInfo.fns.check(component, pseudoClassEmulationInfo.parameter)\n                }\n\n                return state\n            }\n\n            var that = this\n            var changeStyleIfNecessary = function(currentStyle, component, state) {\n                var longestMatchingLength = 0;\n                var mostSpecificMatchingStyle = that; // if nothing else matches, change back to the base style object\n                for(var n=0; n<preSplitPseudoClasses.length; n++) {\n                    var pseudoClassList = preSplitPseudoClasses[n][0]\n                    for(var j=0; j<pseudoClassList.length; j++) {\n                        if(!state[pseudoClassList[j]]) {\n                            break;\n                        }\n                    }\n\n                    if(j === pseudoClassList.length && j > longestMatchingLength) {\n                        longestMatchingLength = j\n                        mostSpecificMatchingStyle = preSplitPseudoClasses[n][1]\n                    }\n                }\n\n                if(mostSpecificMatchingStyle !== currentStyle) {\n                    component.style = mostSpecificMatchingStyle\n\n                    //blockStyleUtils.setCurrentStyle(component, mostSpecificMatchingStyle)\n                    //blockStyleUtils.propogateStyleSet(component.children, component.computedStyleMap) // propogate styles to children\n                }\n            }\n\n            // setup pseudoclass emulation with $setup and $kill handlers\n\n            var wrapSetupAndKill = function(style) {\n                var originalSetup = style.setup\n                style.setup = function(component) {\n                    var that = this\n\n                    this._styleSetupStates = {} // maps pseudoClass to setupState\n                    var state = initializeState(component)\n                    for(var pseudoClass in pseudoClassesToEmulationInfo) {\n                        ;(function(pseudoClass, emulationInfo){   // close over those variables (so they keep the value they had when the function was setup)\n                            that._styleSetupStates[pseudoClass] = emulationInfo.fns.setup(component, function() { // start\n                                state[pseudoClass] = true\n                                changeStyleIfNecessary(that, component, state)\n                            }, function() { // end\n                                state[pseudoClass] = false\n                                changeStyleIfNecessary(that, component, state)\n                            }, emulationInfo.parameter)\n\n                        })(pseudoClass, pseudoClassesToEmulationInfo[pseudoClass])\n                    }\n\n                    changeStyleIfNecessary(that, component, state)\n\n                    if(originalSetup !== undefined) {\n                        originalSetup.apply(this, arguments)\n                    }\n                }\n\n                var originalKill = style.kill\n                style.kill = function(component) {\n                    for(var pseudoClass in pseudoClassesToEmulationInfo) {\n                        var emulationInfo = pseudoClassesToEmulationInfo[pseudoClass]\n                        emulationInfo.fns.kill(component, this._styleSetupStates[pseudoClass])\n                    }\n\n                    if(originalKill !== undefined) {\n                        originalKill.apply(this, arguments)\n                    }\n                }\n            }\n\n            // wrap all the setup and kill functions\n\n            for(var key in tieredPseudoClasses) {\n                var style = tieredPseudoClasses[key]\n                wrapSetupAndKill(style)\n            }\n\n            wrapSetupAndKill(this)\n        }\n    }\n\n    // instance properties\n\n    this.className          // the css classname for this style\n    this.componentStyleMap; // maps a Component name to a Style object for that component\n    this.labelStyleMap;     // maps a label name to a Style object for that label\n    this.setup;             // run some javascript on any element this class is applied to\n    this.kill;              // a function to run on removal of the style (should reverse setup)\n\n    // gets the style object for a component based on the current style object (takes into account whether the component has a label\n    this.get = function(component) {\n        if(component.label !== undefined) {\n            var labelStyle = this.labelStyleMap[component.label]\n            if(labelStyle !==  undefined) {\n                return labelStyle\n            }\n        }\n        // else\n        return this\n    }\n})\n\n\n// private\n\n\n// returns a two-level map where the top-level keys are emulatable psuedo classes, and non-emulatable pseudo classes are at the second level\n// the classes will also be sorted and deduped\n// Example return value: {\"hover:lastChild\": {color:'red', \"$$visited:disabled\": {fontWeight: 'bold'}}, }\n// parameters:\n    // style - the style object being created\n    // pseudoClassStyles - a flat object where each key is a list of pseudoclasses separated by colons (e.g. \"hover\" or \"hover:focus\") and the value is an object of styles that don't contain pseudoclasses\nfunction createTieredPseudoClasses(style, pseudoClassStyles) {\n    var tieredPseudoClasses = {} // the two-level map\n    for(var key in pseudoClassStyles) {\n        var value = pseudoClassStyles[key]\n\n        // split key into pseudoclass list\n        var pseudoClassList = key.split(\":\")\n        var emulatablePseudoClasses = []\n        var nonEmulatablePseudoClasses = []\n        for(var n in pseudoClassList) {\n            var pseudoClass = pseudoClassList[n]\n            var pseudoClassParts = getPseudoClassParts(pseudoClass)\n            if(pseudoClassParts.class in emulatedPseudoClasses) {\n                emulatablePseudoClasses.push(pseudoClass)\n            } else {\n                nonEmulatablePseudoClasses.push(pseudoClass)\n            }\n        }\n\n        // todo: add a third branch as an optimization: if the Style can be rendered without emulation - do that\n        if(emulatablePseudoClasses.length === 0) { // if none of the pseudoclasses can be emulated using javascript\n            validatePurePseudoClassStyles(key, value)                        // then validate the value and\n            createPseudoClassRules(style, key, '.'+style.className+\":\"+key, value)   // create pseudoClassRules\n\n        } else { // if some of the pseudoclasses can be emulated using javascript\n\n            emulatablePseudoClasses.sort()\n            var emulatablePseudoClassKey = emulatablePseudoClasses.join(':')\n            if(tieredPseudoClasses[emulatablePseudoClassKey] === undefined)\n                tieredPseudoClasses[emulatablePseudoClassKey] = {}\n\n            if(nonEmulatablePseudoClasses.length === 0) {\n                utils.merge(tieredPseudoClasses[emulatablePseudoClassKey], value)\n            } else {\n                nonEmulatablePseudoClasses.sort()\n                var nonEmulatablePsuedoClassKey = nonEmulatablePseudoClasses.join(':')\n\n                var secondTier = {}\n                secondTier['$$'+nonEmulatablePsuedoClassKey] = value\n\n                utils.merge(tieredPseudoClasses[emulatablePseudoClassKey], secondTier)\n            }\n        }\n    }\n\n    return tieredPseudoClasses\n}\n\n\n\n// make combinations of the emulatable pseudoclasses, so that they combine like the non-emulated ones do\n// info about mathematical combination: https://en.wikipedia.org/wiki/Combination\n// mutates tieredPseudoClasses\nfunction pseudoclassCombinations(tieredPseudoClasses) {\n    var tieredPseudoClassesKeys = Object.keys(tieredPseudoClasses).reverse().map(function(v) {    // reverse first so that more specific pseudoclasses go first\n        return {key: v, parts: v.split(':')} // so it doesn't have to split every time\n    })\n\n    for(var n=0; n<tieredPseudoClassesKeys.length; n++) {\n        var keyA = tieredPseudoClassesKeys[n]\n        for(var k=2; k <= tieredPseudoClassesKeys.length; k++) { // k is the number of psuedoclasses to combine\n            for(var j=n+1; j<tieredPseudoClassesKeys.length-(k-2); j++) {\n                var result = combinePseudoclasses(tieredPseudoClasses, [keyA].concat(tieredPseudoClassesKeys.slice(j, k)))\n                if(result.key in tieredPseudoClasses) {\n                    utils.merge(tieredPseudoClasses[result.key], result.value)\n                } else { // new key\n                    tieredPseudoClasses[result.key] = result.value\n                }\n            }\n        }\n    }\n}\n\n\n\n// keys is a list of objects where each object has the members:\n    // key - the original string key\n    // parts - the key split by \":\"\n// returns an object with the following members:\n    // key - the new combined key\n    // value - the new merged value\nvar combinePseudoclasses = function(pseudoclasses, keys) {\n    var resultKeyParts = keys[0].parts\n    var resultValue = utils.merge({}, pseudoclasses[keys[0].key]) // make a copy\n    for(var n=1; n<keys.length; n++) {\n        var key = keys[n]\n        // merge all psuedoclasses that don't already exist into the resultKey\n        for(var j=0; j<key.parts.length; j++) {\n            var part = key.parts[j]\n            if(resultKeyParts.indexOf(part) === -1) {\n                resultKeyParts.push(part)\n            }\n        }\n\n        // merge the value into resultValue\n        utils.merge(resultValue, pseudoclasses[key.key])\n    }\n\n    return {key: resultKeyParts.join(':'), value: resultValue}\n}\n\n// a map of pseudoclass names and how they are emulated with javascript\n// each pseudoclass sets up the following functions:\n    // check - a function that checks if that pseudoclass currently applies to the component when its called\n    // setup - calls a callback when the pseudoClass starts and stops applying\n        // should return an object that will be passed to the kill function (as its 'state' parameter)\n    // kill - cleans up anything set up in the 'setup' function\n    // processParameter - takes the pseudoclass parameter and returns some object representing it that will be used by the setup and check functions\nvar emulatedPseudoClasses = {\n    hover: {\n        check: function(component) {\n            var nodes = document.querySelectorAll( \":hover\" )\n            for(var n=0; n<nodes.length; n++) {\n                if(nodes[n] === component.domNode) {\n                    return true\n                }\n            }\n            return false\n        },\n        setup: function(component, startCallback, endCallback) {\n            component.on(\"mouseover\", function() {\n                startCallback()\n            })\n            component.on(\"mouseout\", endCallback)\n\n            return {start: startCallback, end: endCallback}\n        },\n        kill: function(component, state) {\n            component.off(\"mouseover\", state.start)\n            component.off(\"mouseout\", state.end)\n        }\n    },\n    checked: {\n        check: function(component) {\n            return component.selected\n        },\n        setup: function(component, startCallback, endCallback) {\n            var setupState = {}\n            component.on(\"change\", setupState.listener = function() {\n                if(component.selected) {\n                    startCallback()\n                } else {\n                    endCallback()\n                }\n            })\n\n            return setupState\n        },\n        kill: function(component, state) {\n            component.removeListener(\"change\", state.listener)\n        }\n    },\n    required: {\n        check: function(component) {\n            return component.attr('required') !== undefined\n        },\n        setup: function(component, startCallback, endCallback) {\n            var observer = new MutationObserver(function() {\n                if(component.attr('required') !== undefined) {\n                    startCallback()\n                } else {\n                    endCallback()\n                }\n            })\n\n            observer.observe(component.domNode, {attributes: true})\n\n            return {observer: observer}\n        },\n        kill: function(component, state) {\n            state.observer.disconnect()\n        }\n    },\n    'last-child': {\n        check: function(component) {\n            return nthLastChildCheck(component, '1')\n        },\n        setup: function(component, startCallback, endCallback) {\n            var observer = new MutationObserver(function() {\n                if(nthLastChildCheck(component, '1')) {\n                    startCallback()\n                } else {\n                    endCallback()\n                }\n            })\n\n            var setupObserver = function() {\n                // note that since this uses the component parent rather than domNode.parentNode, this won't work for components added to non-component nodes (and there's no good way to do it, because you would have to poll for parent changes)\n                observer.observe(component.parent.domNode, {childList: true})\n            }\n\n            if(component.parent !== undefined) {\n                setupObserver()\n            }\n\n            component.on('newParent', function() {\n                setupObserver()\n            })\n            component.on('parentRemoved', function() {\n                observer.disconnect()\n            })\n\n            return {observer: observer}\n        },\n        kill: function(component, state) {\n            state.observer.disconnect()\n        }\n    },\n    'nth-child': {\n        // todo: support full an+b parameters for nth-child https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-child\n        check: function(component, parameterCheck) {\n            return nthChildCheck(component, parameterCheck)\n        },\n        setup: function(component, startCallback, endCallback, parameterCheck) {\n\n            var checkAndCallCallbacks = function() {\n                if(nthChildCheck(component, parameterCheck)) {\n                    startCallback()\n                } else {\n                    endCallback()\n                }\n            }\n\n            var observer = new MutationObserver(function() {\n                checkAndCallCallbacks()\n            })\n\n            var setupObserver = function() {\n                // note that since this uses the component parent rather than domNode.parentNode, this won't work for components added to non-component nodes (and there's no good way to do it, because you would have to poll for parent changes)\n                observer.observe(component.parent.domNode, {childList: true})\n            }\n\n            if(component.parent !== undefined) {\n                setupObserver()\n            }\n\n            component.on('newParent', function() {\n                setupObserver()\n                checkAndCallCallbacks()\n            })\n            component.on('parentRemoved', function() {\n                observer.disconnect()\n                checkAndCallCallbacks()\n            })\n\n            return {observer: observer}\n        },\n        kill: function(component, state) {\n            state.observer.disconnect()\n        },\n        processParameter: function(parameter) {\n            return nthChildParameterFn(parameter)\n        }\n    },\n\n    // not's parameter is a statement consisting of pseudoclasses separated either by & or ,\n    // $$not(pseudoclass1&pseudoclass2,psuedoclass3) translates to the css :not(:pseudoclass1:pseudoclass2,:psuedoclass3)\n    /*not: {\n        check: function() {\n\n        },\n    }*/\n}\n\n// name is the name of the new pseudoclass\n// fns is an object with the members:\n    // check(component) - returns true if the pseudoclass applies to the component\n    // setup(component, startCallback, endCallback, parameter) - a function that should call startCallback when the pseudoclass starts applying, and endCallback when it stops applying\n        // parameter - the parameter passed to the pseudoclass (e.g. in :not(:first-child), \":first-child\" is the parameter)\n    // kill - a function that cleans up any event listeners or anything else set up in the 'setup' function\nmodule.exports.addPseudoClass = function(name, fns) {\n    if(emulatedPseudoClasses[name] !== undefined) throw new Error(\"The pseudoclass '\"+name+\"' is already defined.\")\n    // else\n    emulatedPseudoClasses[name] = fns\n}\n\n\nfunction nthChildCheck(component, testFn) {\n    if(component.domNode.parentNode === null)\n        return false\n\n    var children = component.domNode.parentNode.children                    // must be domNode.parentNode, because child nodes may not be Components\n    var index = Array.prototype.indexOf.call(children, component.domNode)\n    return testFn(index)\n}\n\nfunction nthLastChildCheck(component, parameter) {\n    if(component.domNode.parentNode === null)\n        return false\n\n    var children = component.domNode.parentNode.children                    // must be domNode.parentNode, because child nodes may not be Components\n    var index = children.length - parseInt(parameter)\n    return children[index] === component.domNode\n}\n\n// returns a function that takes an index and tell you if that index applies to the nthChildParameter\nvar nthChildParameter = /^(((-?\\d*)(([+-]\\d*)n?)?)|((-?\\d)*n?([+-]\\d*)?))$/\nfunction nthChildParameterFn(parameter) {\n    var parts = parameter.match(nthChildParameter)\n    if(parts === null)\n        throw new Error(\"nth-child parameter '\"+parameter+\"' isn't valid\")\n\n    if(parts[2] !== undefined) {\n        var constant = parts[3]\n        var variable = parts[5]\n    } else {\n        var constant = parts[8]\n        var variable = parts[7]\n    }\n\n    if(constant === undefined) constant = 0\n    else                       constant = parseInt(constant)\n    if(variable === undefined) variable = 0\n    else                       variable = parseInt(variable)\n\n    if(variable === 0) {\n        return function(index) {\n            return index+1 === constant\n        }\n    } else {\n        return function(index) {\n            return ((index+1-constant)/variable) % 1 === 0\n        }\n    }\n\n}\n\n// maps a style value to a css value\n// style values that are numbers are mapped to strings, usually with px postfix\nfunction cssValue(cssStyleName, value) {\n    // If a number was passed in, add 'px' to the (except for certain CSS properties) [also taken from jquery's code]\n    if(typeof(value) === \"number\" && cssNumber[cssStyleName] === undefined) {\n        return value+\"px\"\n    } else {\n        return value.toString()\n    }\n}\n\nfunction createPseudoClassRules(that, pseudoClass, selector, pseudoClassStyle) {\n\n    var pseudoClassCss = {}\n    for(var key in pseudoClassStyle) {\n        var value = pseudoClassStyle[key]\n\n        if(!(value instanceof Object)) {\n            var cssStyle = key\n            var cssStyleName = mapCamelCase(cssStyle)\n            pseudoClassCss[cssStyleName] = cssValue(cssStyleName, value)\n        } else {\n            throw new Error(\"All properties within the pseudoclasses '\"+pseudoClass+\"' must be css styles\")\n        }\n    }\n\n    // create immediate pseudo class style\n    defaultJss.set(selector, pseudoClassCss) // create the css class with the pseudoClass\n\n    //if(module.exports.isDev) {\n        that.styleDefinitions = {}\n        that.styleDefinitions[selector] = pseudoClassCss\n    //}\n}\n\n// throws exceptions for various style configurations that are unsupported by pure pseudo classes (ones that can't be emulated usuing javascript)\nfunction validatePurePseudoClassStyles(pseudoClass, pseudoClassStyles) {\n    for(var key in pseudoClassStyles) {\n        var value = pseudoClassStyles[key]\n\n        if(isStyleObject(value)) {\n            throw new Error(\"Can't set the pseudoclasses '\"+pseudoClass+\"' to a Style object\")\n        } else if(key === '$setup') {\n            throw new Error(\"$setup can't be used within the pseudoclasses '\"+pseudoClass+\"'\")\n        } else if(key === '$kill') {\n            throw new Error(\"$kill can't be used within the pseudoclasses '\"+pseudoClass+\"'\")\n        } else if(key.indexOf('$') === 0) {   // label style\n            throw new Error(\"Block labels can't be used within the pseudoclasses '\"+pseudoClass+\"'\")\n        }\n    }\n}\n\n// e.g. pulls out 'nth-child' and '2+3n' from 'nth-child(2+3n)'\nvar pseudoClassRegex = /^([^(]*)(\\((.*)\\))?$/\nfunction getPseudoClassParts(fullPsuedoClass) {\n    var x = fullPsuedoClass.match(pseudoClassRegex)\n    if(x === null) throw new Error(\"Pseudoclass '\"+fullPsuedoClass+\"' is invalid\")\n    return {class: x[1], parameter: x[3]}\n}\n\n\n// takes in a list of pseudoClassRules and changes any nesting like {hover: {focus: {}}} into something like {hover: {}, \"hover:focus\": {}}\n// also does some validation\nfunction flattenPseudoClassStyles(pseudoClass, pseudoClassStyle) {\n    var nonPseudoClassStyles = {}\n    var subpseudoClasses = {}\n    for(var key in pseudoClassStyle) {\n        var value = pseudoClassStyle[key]\n\n        if(key.indexOf('$$') === 0) { // pseudo-class style\n            var subPseudoClass = key.substr(2)\n            if(subPseudoClass === '') {\n                throw new Error(\"Empty pseudo-class name not valid (style key '$$')\")\n            }\n\n            subpseudoClasses[subPseudoClass] = value\n        } else {\n            nonPseudoClassStyles[key] = value\n        }\n    }\n\n    // create flattened styles (with merged in styles from its parent pseudoclass\n    var flattenedStyles = {}\n    for(var subPseudoClass in subpseudoClasses) {\n        var value = subpseudoClasses[subPseudoClass]\n\n        if(isStyleObject(value)) {\n            flattenedStyles[pseudoClass+\":\"+subPseudoClass] =  value\n        } else {\n            utils.merge(flattenedStyles, flattenPseudoClassStyles(pseudoClass+\":\"+subPseudoClass, utils.merge({}, nonPseudoClassStyles, value)))\n        }\n    }\n\n    // write the top-level pseudoClass\n    flattenedStyles[pseudoClass] = nonPseudoClassStyles\n\n    return flattenedStyles\n}\n\n\n// taken from jquery's code\nvar cssNumber = {\n    \"column-count\": 1,\n    \"fill-opacity\": 1,\n    \"flex-grow\": 1,\n    \"flex-shrink\": 1,\n    \"font-weight\": 1,\n    \"line-height\": 1,\n    \"opacity\": 1,\n    \"order\": 1,\n    \"orphans\": 1,\n    \"widows\": 1,\n    \"z-index\": 1,\n    \"zoom\": 1\n}\n\nfunction isStyleObject(o) {\n    return o.componentStyleMap !== undefined\n}\n\n\nvar asciiA = 'A'.charCodeAt(0), asciiZ = 'Z'.charCodeAt(0), difference = 'a'.charCodeAt(0) - asciiA\nfunction mapCamelCase(cssStyleName) {\n    for(var n=0; n<cssStyleName.length; n++) {\n        var ascii = cssStyleName.charCodeAt(n)\n        if(asciiA <= ascii && ascii <= asciiZ) { // found capital letter\n            cssStyleName = cssStyleName.slice(0, n) + '-'+String.fromCharCode(ascii+difference) + cssStyleName.slice(n+1)\n            n++ // increment a second time for the dash\n        }\n    }\n\n    return cssStyleName\n}\n\n// maps all the styles that are inherited by descendant nodes to their default values\n// source: http://stackoverflow.com/questions/5612302/which-css-styles-are-inherited\nvar defaultStyleValues = {\n    'azimuth': 'center',\n    'border-collapse': 'separate',\n    'border-spacing': '0',\n    'caption-side': 'top',\n    //'color': 'black',         // let this inherit\n    //'cursor': 'auto',         // let this one inherit - its weird otherwise\n    'direction': 'ltr',\n     display: 'inline-block', // changes the default display to inline-block\n    'elevation': '',\n    'empty-cells': 'show',\n    // 'font-family': '',       // let this inherit\n    // 'font-size': 'medium',   // let this inherit\n    //'font-style': 'normal',   // let this inherit\n    //'font-variant': 'normal', // let this inherit\n    //'font-weight': 'normal',  // let this inherit\n    'letter-spacing': 'normal',\n    'line-height': 'normal',\n    'list-style-image': 'none',\n    'list-style-position': 'outside',\n    'list-style-type': 'disc',\n    'orphans': '2',\n    'pitch-range': '',\n    'pitch': '',\n     position: 'relative', // changes the default positioning so that absolute is relative to its parent by default\n    'quotes': '',\n    'richness': '',\n    'speak-header': '',\n    'speak-numeral': '',\n    'speak-punctuation': '',\n    'speak': '',\n    'speak-rate': '',\n    'stress': '',\n    'text-align': 'left',\n    'text-indent': '0',\n    'text-transform': 'none',\n    //'visibility': 'visible',    // let this inherit - otherwise you just hide the container and not the contents\n    'voice-family': '',\n    'volume': '',\n    'white-space': 'normal',\n    'widows': '2',\n    'word-spacing': 'normal'\n}\n\ndefaultJss.set('.'+Style.defaultClassName, defaultStyleValues) // creates default css class in order to prevent inheritance\n\ndefaultJss.set('input', { // chrome and firefox user agent stylesheets mess with this otherwise\n    cursor: 'inherit'\n})\n\n/*private*/ module.exports.isDev; // should be set by Block\n\nvar computedStyles = module.exports.computedStyles = new HashMap() // stores a map from styleMap components, to the combined style map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Style.js\n ** module id = 2\n ** module chunks = 0\n **/","var Block = require('Block')\nvar proto = require('proto')\nvar Style = require(\"Style\")\n\nmodule.exports = proto(Block, function(superclass) {\n\n    //static properties\n\n    this.name = 'Canvas'\n\n    this.init = function(/*[label,] height, width*/) {\n        if(arguments.length === 2) {\n            var height = arguments[0]\n            var width = arguments[1]\n        } else {\n            var label = arguments[0]\n            var height = arguments[1]\n            var width = arguments[2]\n        }\n\n        this.domNode = document.createElement('canvas') // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n\n        this.label = label\n        this.height = height\n        this.width = width\n    }\n\n    // instance properties\n\n    Object.defineProperty(this, 'width', {\n        get: function() {\n            return this.domNode.width\n        }, set: function(v) {\n            this.domNode.width = v\n        }\n    })\n    Object.defineProperty(this, 'height', {\n        get: function() {\n            return this.domNode.height\n        }, set: function(v) {\n            this.domNode.height = v\n        }\n    })\n\n    this.context = function() {\n        return this.domNode.getContext.apply(this.domNode, arguments)\n    }\n\n    this.toImg = this.toDataURL = function() {\n        return this.domNode.toDataURL()\n    }\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Canvas.js\n ** module id = 3\n ** module chunks = 0\n **/","var Block = require('../Block')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static properties\n\n    this.name = 'Container'\n\n\n\t// instance properties\n\n\tthis.init = function (/*[label,] content*/) {\n        if(typeof(arguments[0]) !== 'string') {\n            var contentArgs = arguments\n        } else {\n            var label = arguments[0]\n            var contentArgs = Array.prototype.slice.call(arguments, 1)\n        }\n\n        superclass.init.call(this) // superclass constructor\n\n        this.label = label\n\n\t\tif(contentArgs !== undefined)\n            this.add.apply(this,contentArgs)\n\t}\n})\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Container.js\n ** module id = 4\n ** module chunks = 0\n **/","var Block = require('Block')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\n    // static variables\n\n    this.name = 'Button'\n\n\n    // instance properties\n\n\tthis.init = function(/*[label,] text*/) {\n        if(arguments.length >= 2) {\n            var label = arguments[0]\n            var text = arguments[1]\n        } else {\n            var text = arguments[0]\n        }\n\n        this.domNode = document.createElement(\"input\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n\n        this.label = label\n\t\tthis.attr('type','button');\n\t\tthis.text = text\n\t}\n\n    Object.defineProperty(this, 'text', {\n        get: function() {\n            return this.attr('value')\n        },\n        set: function(text) {\n            this.attr('value', text)\n        }\n    })\n\n})\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Button.js\n ** module id = 5\n ** module chunks = 0\n **/","var Block = require('Block')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\t// static variables\n    this.name = 'CheckBox'\n\n\t// instance methods\n\tthis.init = function(label) {\n        var that = this\n\n        this.domNode = document.createElement(\"input\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n\n        this.label = label\n\t\tthis.attr('type','checkbox')\n\t}\n\n    Object.defineProperty(this, 'selected', {\n        // returns whether or not the checkbox is checked\n        get: function() {\n            return this.domNode.checked\n        },\n        // sets the value of the checkbox to the passed value (true for checked)\n        set: function(checked) {\n            var newValue = checked === true\n            var curValue = this.domNode.checked\n            if(curValue === newValue) return;  // do nothing if nothing's changing\n\n            this.domNode.checked = newValue\n            this.emit('change') // the browser has no listenable event that is triggered on change of the 'checked' property\n        }\n    })\n})\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/CheckBox.js\n ** module id = 6\n ** module chunks = 0\n **/","var Block = require('Block')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\n    //static properties\n\n    this.name = 'Image'\n\n    this.init = function(/*[label,] imageSource*/) {\n        if(arguments.length === 1) {\n            var imageSource = arguments[0]\n        } else {\n            var label = arguments[0]\n            var imageSource = arguments[1]\n        }\n\n        this.domNode = document.createElement('img') // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n\n        var that = this\n\n        this.label = label\n        if(imageSource !==  undefined) this.src = imageSource\n    }\n\n    // instance properties\n\n    Object.defineProperty(this, 'src', {\n        get: function() {\n            return this.domNode.src\n        }, set: function(v) {\n            this.domNode.src = v\n        }\n    })\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Image.js\n ** module id = 7\n ** module chunks = 0\n **/","var proto = require('proto')\n\nvar Block = require('Block')\nvar Style = require(\"Style\")\n\nvar Item = require(\"./Item\");\n\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static properties\n\n\tthis.Item = Item\n\n    this.name = 'List'\n\n\t// instance properties\n\n\tthis.init = function(/*[label,] [ordered,] listInit*/) {\n\t\tif(arguments[0] instanceof Array) {\n            var listInit = arguments[0]\n        } else {\n            if(arguments[1] instanceof Array) {\n                var listInit = arguments[1]\n            } else if(arguments[2] instanceof Array) {\n                var listInit = arguments[2]\n            }\n\n            if(typeof(arguments[0]) === 'boolean') {\n                var ordered = arguments[0]\n            } else {\n                if(typeof(arguments[1]) === 'boolean') {\n                    var ordered = arguments[1]\n                } else {\n                    var ordered = false // default\n                }\n\n                if(typeof(arguments[0]) === 'string') {\n                    var label = arguments[0]\n                }\n            }\n        }\n\n        if(ordered) {\n            var type = 'ol'\n        } else {\n            var type = 'ul'\n            this.defaultStyle = Style({\n                listStyleType: 'decimal'\n            })\n        }\n\n\n        this.domNode = document.createElement(type) // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n        this.label = label\n\n        if(listInit !== undefined) {\n            for(var n=0; n<listInit.length; n++) {\n                this.item(listInit[n])\n            }\n        }\n\t}\n\n\tthis.item = function() {\n\t\tvar item = Item.apply(this, arguments)\n        this.add(item)\n        return item\n\t}\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/List.js\n ** module id = 8\n ** module chunks = 0\n **/","var proto = require('proto')\nvar EventEmitter = require('events').EventEmitter\n\nvar Block = require('../Block')\n\nvar randomStart = getRandomInt(0,999999) // a random number used to start off the numbers given to radio button names (using a random number in case there are somehow two different instances of blocks.js on the page)\n\n// A group of radio buttons\nmodule.exports = proto(EventEmitter, function(superclass) {\n\n\t// static properties\n\n    this.name = 'Radio'\n\n\t// instance properties\n\n\n    // required - If true, a radio button must always be selected. Otherwise, radio buttons can be deselected by clicking on them.\n\tthis.init = function(required) {\n        //this.selected\n        this.required = required === true || required === undefined\n        this.buttons = {} // maps values to the buttons that have each value\n        this.randomStart = randomStart++\n\t}\n\n    // returns a new radio button\n    this.button = function(/*[label,] value*/) {\n        if(arguments.length >= 2) {\n            var label = arguments[0]\n            var value = arguments[1]\n        } else {\n            var value = arguments[0]\n        }\n\n        if(this.buttons[value] !== undefined) {\n            throw new Error(\"Can't give a RadioButton the same value as another in the group (value: '\"+value+\"')\")\n        }\n\n        var button = RadioButton(this, label, value, \"_radioblock\"+this.randomStart)\n        this.buttons[value] = button\n\n        if(this.required && this._selected === undefined) {\n            button.selected = true\n        }\n\n        return button\n    }\n\n    // returns the RadioButton in the group that's selected (or undefined if none are selected)\n    Object.defineProperty(this, 'selected', {\n        get: function() {\n            return this._selected\n        },\n        set: function() {\n            throw new Error(\"Can't set selected on a Radio object\")\n        }\n    })\n\n    Object.defineProperty(this, 'val', {\n        // returns the value of the selected radio button in the group (undefined if none are selected)\n        get: function() {\n            var selected = this._selected\n            if(selected === undefined) return undefined\n            // else\n            return selected.attr('value')\n        },\n\n        // sets the value of the checkbox to the passed value (true for checked)\n        // throws an exception if none of the radio buttons have that value\n        // throws an exception if an unset is attempted for a required Radio set\n        set: function(value) {\n            if(value === undefined) {\n                var selected = this._selected\n                if(selected !== undefined) {\n                    selected.selected = false\n                }\n            } else {\n                var button = this.buttons[value]\n                if(button === undefined) throw new Error(\"There is no RadioButton in the group with the value: '\"+value+\"'\")\n\n                button.selected = true\n            }\n        }\n    })\n\n\n    // arguments can be one of the following:\n        // RadioButton, RadioButton, RadioButton, ...\n        // value, value, value, ... - each value is the value of the RadioButton to remove\n        // arrayOfRadioButtons\n        // arrayOfValues\n    this.remove = function() {\n        if(arguments[0] instanceof Array) {\n            var removals = arguments[0]\n        } else {\n            var removals = arguments\n        }\n\n        for(var n=0; n<removals.length; n++) {\n            var r = removals[n]\n\n            if(r instanceof RadioButton) {\n                var button = r\n                var value = r.val\n\n                if(this.buttons[value] !== r) {\n                    throw new Error(\"The button passed at index \"+n+\" is not part of the group.\")\n                }\n            } else {\n                var button = this.buttons[r]\n                var value = r\n\n                if(button === undefined) {\n                    throw new Error(\"There is no RadioButton in the group with the value: '\"+value+\"'\")\n                }\n            }\n\n            var originalSelected = this.selected\n            if(this.selected === button) {\n                this._selected = undefined\n            }\n\n            this.buttons[value].group = undefined // fully remove it from the group\n            delete this.buttons[value]\n        }\n\n        if(this.required && this.selected === undefined) {\n            for(var v in this.buttons) {\n                this.buttons[v].selected = true // just select the first one\n                break; // yes this doesn't loop\n            }\n        } else if(originalSelected !== this.selected) {\n            this.emit('change')\n        }\n    }\n\n})\n\nvar RadioButton = proto(Block, function(superclass) {\n    this.name = 'RadioButton'\n\n    this.init = function(radioGroup, label, value, name) {\n        this.domNode = document.createElement(\"input\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n\n        this.label = label\n        this.group = radioGroup\n\n        this.attr('type', 'radio')\n        this.attr('name', name) // the name is needed so that using tab to move through page elements can tab between different radio groups\n        this.val = value\n\n        var that = this\n\t\tthis.on(\"mousedown\",function(event) {\n            event.preventDefault()           // this needs to be here otherwise the radio button can't be changed\n\n\t\t\tif(that.group.required) {\n                if(that.selected === false) {\n                    that.selected = true\n                }\n            } else {\n                that.selected = !that.selected // toggle\n            }\n\t\t})\n        this.on(\"click\",function(event) {\n            event.preventDefault()         // this needs to be here otherwise the radio button can't be *unset*\n        })\n        this.on(\"keydown\",function(event) {\n            if(event.keyCode === 40 || event.keyCode === 39) { // down or right\n                event.preventDefault()         // this needs to be here otherwise the radio button strangely calls the click handler which causes things to mess up\n                that.selectNext()\n            } else if(event.keyCode === 38 || event.keyCode === 37) { // up or left\n                event.preventDefault()         // this needs to be here otherwise the radio button strangely calls the click handler which causes things to mess up\n                that.selectPrevious()\n            }\n        })\n    }\n\n    Object.defineProperty(this, 'val', {\n        // returns the value attribute of the checkbox\n        get: function() {\n            return this.attr('value')\n        },\n\n        // sets the value attribute of the checkbox\n        set: function(value) {\n            if(this.group.buttons[value] !== undefined) {\n                throw new Error(\"Can't give a RadioButton the same value as another in the group (value: '\"+value+\"')\")\n            }\n\n            var oldValue = this.val\n            this.attr('value', value)\n            if(oldValue !== undefined) delete this.group.buttons[oldValue]\n            this.group.buttons[value] = this\n        }\n    })\n\n\n    Object.defineProperty(this, 'selected', {\n        // returns whether or not the checkbox is checked\n        get: function() {\n            return this.domNode.checked\n        },\n\n        // sets the selected state of the checkbox to the passed value (true for checked)\n        set: function(value) {\n            var booleanValue = value === true\n            if(this.selected === value) return; // ignore if there's no change\n\n            if(booleanValue) {\n                var previouslySelected = this.group.selected\n                setButtonInGroup(this.group, this)\n                if(previouslySelected !== undefined)\n                    previouslySelected.emit('change')\n            } else {\n                if(this.group.required) throw new Error(\"Can't unset this Radio set, a value is required.\")\n                this.domNode.checked = false\n                this.group._selected = undefined\n            }\n            this.emit('change') // the browser has no listenable event that is triggered on change of the 'checked' property\n            this.group.emit('change')\n        }\n    })\n\n    this.selectNext = function() {\n        selectSibling(this,1)\n    }\n    this.selectPrevious = function() {\n        selectSibling(this,-1)\n    }\n\n})\n\n// direction can be +1 or -1\nfunction selectSibling(button, direction) {\n    var buttons = button.group.buttons\n    var values = Object.keys(buttons)\n    var index = values.indexOf(button.attr('value'))\n    if(direction === 1 && index === values.length-1) {\n        var buttonToSelect = buttons[values[0]]\n    } else if(direction === -1 && index === 0) {\n        var buttonToSelect = buttons[values[values.length-1]]\n\n    } else {\n        var buttonToSelect = buttons[values[index+direction]]\n    }\n\n    buttonToSelect.selected = true\n    buttonToSelect.focus()\n}\n\nfunction setButtonInGroup(group, button) {\n    var selected = group._selected\n    if(selected !== undefined) selected.domNode.checked = false\n    button.domNode.checked = true\n    group._selected = button\n}\n\nfunction getRandomInt(min, max) {\n  return Math.floor(Math.random() * (max - min)) + min;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Radio.js\n ** module id = 9\n ** module chunks = 0\n **/","var Block = require('../Block')\nvar proto = require('proto')\n\nvar Option = require('Components/Option')\n\n// emits a 'change' event when its 'val' changes\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static variables\n\n    this.name = 'Select'\n\n    this.Option = Option\n\n\tthis.init = function(/*[label,] options*/) {\n        if(arguments[0] instanceof Object) {\n            var options = arguments[0]\n        } else {\n            var label = arguments[0]\n            var options = arguments[1]\n        }\n\n        this.domNode = document.createElement(\"select\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n        this.label = label\n\n        this.options = {}\n\n\t\tfor(var value in options) {\n\t\t\tthis.option(value, options[value])\n\t\t}\n\t}\n\n\n\t// instance methods\n\n    Object.defineProperty(this, 'val', {\n        // returns the value that is selected\n        get: function() {\n            for(var value in this.options) {\n                if(this.options[value].selected) {\n                    return value\n                }\n            }\n        },\n\n        set: function(value) {\n            var option = this.options[value]\n            if(option === undefined) throw new Error(\"There is no Option in the Select with the value: '\"+value+\"'\")\n            option.selected = true\n        }\n    })\n\t\n\tthis.option = function(/*[label,] value,text*/) {\n        if(arguments.length === 2) {\n            var value = arguments[0]\n            var text = arguments[1]\n        } else if(arguments.length === 3) {\n            var label = arguments[0]\n            var value = arguments[1]\n            var text = arguments[2]\n        } else {\n            throw new Error(\"Invalid number of arguments\")\n        }\n\n        var newOption = Option(label, value,text)\n        this.add(newOption)\n\n        return newOption\n\n\t}\n\n    // same interface as Block.addAt\n    /*override*/ this.addAt = function(index/*, nodes...*/) {\n        var that = this\n\n        var nodesToAdd = Block.normalizeAddAtArguments.apply(this, arguments)\n\n        // validation first\n        nodesToAdd.forEach(function(option) {\n            if(that.options[option.val] !== undefined) {\n                throw new Error(\"Can't give an Option the same value as another in the Select (value: '\"+option.val+\"')\")\n            }\n        })\n\n        superclass.addAt.call(this, index, nodesToAdd)\n\n        // Select specific state modifications - this must be done after the superclass call in case an error is thrown from it\n        var anyWereSelected = false\n        nodesToAdd.forEach(function(option) {\n            if(option.selected) anyWereSelected = true\n            that.options[option.val] = option\n\n            // set up Select events\n            // todo: remove events when the Option is removed\n\n            option.on(\"mousedown\",function(event) {\n                option.parent.val = option.val      // select this one\n            })\n        })\n\n        if(anyWereSelected) {\n            this.emit('change')\n        }\n    }\n\n    // same interface as Block.remove\n    /*override*/ this.remove = function() {\n        var that = this\n\n        var removalIndexes = Block.normalizeRemoveArguments.apply(this, arguments)\n        var removals = removalIndexes.map(function(index) {\n            return that.children[index]\n        })\n\n        superclass.remove.call(this, removalIndexes)\n\n        // Select specific state modifications - this must be done after the superclass call in case an error is thrown from it\n        var theSelectedWasRemoved = false\n        removals.forEach(function(option) {\n            if(option.selected) theSelectedWasRemoved = true\n            delete that.options[option.val]\n        })\n\n        if(theSelectedWasRemoved) {\n            //this.children[0].selected = true // I think the browser does this automatically??\n            this.emit('change')\n        }\n    }\n\n\n    // private\n\n    this.prepareForValueChange = function(values) {\n        var value = values[0]\n\n        for(var optionValue in this.options) {\n            if(optionValue !== value) {\n                var option = this.options[optionValue]\n                if(option.selected === true) {\n                    option.setSelectedQuiet(false)\n                }\n            }\n        }\n    }\n})\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Select.js\n ** module id = 10\n ** module chunks = 0\n **/","var proto = require('proto')\n\nvar Block = require('../Block')\nvar Style = require(\"Style\")\n\nvar Header = require(\"./Header\");\nvar Row = require(\"./Row\");\nvar Cell = require(\"./Cell\");\n\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static properties\n\n    this.name = 'Table'\n\n    this.defaultStyle = Style({\n        borderSpacing: 0\n    })\n\n    this.Row = Row\n\tthis.Header = Header\n    this.Cell = Cell\n\n\n\t// instance properties\n\n\tthis.init = function(/*[label,] tableInit*/) {\n\t\tif(arguments[0] instanceof Array) {\n            var tableInit = arguments[0]\n        } else {\n            var label = arguments[0]\n            var tableInit = arguments[1]\n        }\n\n        this.domNode = document.createElement(\"table\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n        this.label = label\n\n        if(tableInit !== undefined) {\n            for(var n=0; n<tableInit.length; n++) {\n                this.row(tableInit[n])\n            }\n        }\n\t}\n\t\n\tthis.header = function(/*[]label,] listOfBlocksOrText*/) {\n        return headerOrRegularRow(this, Header, arguments)\n\t}\n\n\tthis.row = function() {\n\t\treturn headerOrRegularRow(this, Row, arguments)\n\t}\n});\n\nfunction headerOrRegularRow(that, Prototype, args) {\n    var row = Prototype.apply(undefined, args)\n    that.add(row)\n    return row\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Table.js\n ** module id = 11\n ** module chunks = 0\n **/","var Block = require('../Block')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static variables\n\n    this.name = 'TextArea'\n\n\tthis.init = function(label) {\n        this.domNode = document.createElement(\"textarea\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n\t\tthis.label = label\n\t}\n\n\n\t// instance properties\n\n\n    Object.defineProperty(this, 'val', {\n        // returns the value of the Option\n        get: function() {\n            return this.domNode.value\n        },\n\n        // sets the value of the Option\n        set: function(value) {\n            if(this.val === value) return; // do nothing if there's no change\n\n            this.domNode.value = value\n            this.emit('change')\n        }\n    })\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/TextArea.js\n ** module id = 12\n ** module chunks = 0\n **/","var Block = require('../Block')\nvar proto = require('proto')\n\nvar domUtils = require(\"../domUtils\")\n\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static properties\n\n    this.name = 'TextField'\n\n\tthis.init = function(/*[label,] password*/) {\n        if(arguments.length === 1) {\n            var password = arguments[0]\n        } else if(arguments.length > 1) {\n            var label = arguments[0]\n            var password = arguments[1]\n        }\n\n        this.domNode = document.createElement(\"input\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n\n\t\tthis.label = label\n        this.domNode.className = 'field'\n\t\tdomUtils.setAttribute(this.domNode,'type','text');\n        if(password)\n            domUtils.setAttribute(this.domNode, 'type', 'password')\n\t}\n\n\n\t// instance properties\n\n    Object.defineProperty(this, 'val', {\n        // returns the value of the Option\n        get: function() {\n            return this.domNode.value\n        },\n\n        // sets the value of the Option\n        set: function(value) {\n            if(this.val === value) return; // do nothing if there's no change\n\n            this.domNode.value = value\n            this.emit('change')\n        }\n    })\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/TextField.js\n ** module id = 13\n ** module chunks = 0\n **/","var Block = require('../Block')\nvar proto = require('proto')\nvar Style = require(\"Style\")\n\nmodule.exports = proto(Block, function(superclass) {\n\n    //static properties\n\n    this.name = 'Text'\n\n    this.defaultStyle = Style({\n        whiteSpace: 'pre'\n    })\n\n    this.init = function(/*[label,] text*/) {\n        if(arguments.length === 1) {\n            var text = arguments[0]\n        } else {\n            var label = arguments[0]\n            var text = arguments[1]\n        }\n\n        if (text === undefined) text = '';\n\n        superclass.init.call(this) // superclass constructor\n\n        var that = this\n\n        this.label = label\n        this.text = text\n\n        this.on(\"input\",function(data) {\n            var eventData = {newText:data.srcElement.textContent,oldText:that.oldText};\n            that.oldText = eventData.newText;\n            //that.emit(\"input\",eventData);\n        });\n\n        this.on(\"blur\",function(data) {\n            var eventData = {newText:data.srcElement.textContent,oldText:that.lastFocus};\n            that.lastFocus = eventData.newText;\n            //that.emit(\"blur\",eventData);\n        });\n    }\n\n    // instance properties\n\n    Object.defineProperty(this, 'text', {\n        get: function() {\n            return this.domNode.textContent\n        }, set: function(v) {\n            this.domNode.innerText = v   // apparently textContent can't be set or something\n        }\n    })\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Text.js\n ** module id = 14\n ** module chunks = 0\n **/","/*\r\n * JSS v0.6 - JavaScript Stylesheets\r\n * https://github.com/Box9/jss\r\n *\r\n * Copyright (c) 2011, David Tang\r\n * MIT Licensed (http://www.opensource.org/licenses/mit-license.php)\r\n */\r\nvar jss = (function() {\r\n    var adjSelAttrRegex = /((?:\\.|#)[^\\.\\s#]+)((?:\\.|#)[^\\.\\s#]+)/g;\r\n    var doubleColonPseudoElRegex = /(::)(before|after|first-line|first-letter|selection)/;\r\n    var singleColonPseudoElRegex = /([^:])(:)(before|after|first-line|first-letter|selection)/;\r\n    var singleColonForPseudoElements; // flag for older browsers\r\n\r\n    function getSelectorsAndRules(sheet) {\r\n        var rules = sheet.cssRules || sheet.rules || [];\r\n        var results = {};\r\n        for (var i = 0; i < rules.length; i++) {\r\n            // Older browsers and FF report pseudo element selectors in an outdated format\r\n            var selectorText = toDoubleColonPseudoElements(rules[i].selectorText);\r\n            if (!results[selectorText]) {\r\n                results[selectorText] = [];\r\n            }\r\n            results[selectorText].push({\r\n                sheet: sheet,\r\n                index: i,\r\n                style: rules[i].style\r\n            });\r\n        }\r\n        return results;\r\n    }\r\n\r\n    function getRules(sheet, selector) {\r\n        var rules = sheet.cssRules || sheet.rules || [];\r\n        var results = [];\r\n        // Browsers report selectors in lowercase\r\n        selector = selector.toLowerCase();\r\n        for (var i = 0; i < rules.length; i++) {\r\n            var selectorText = rules[i].selectorText;\r\n            // Note - certain rules (e.g. @rules) don't have selectorText\r\n            if (selectorText && (selectorText == selector || selectorText == swapAdjSelAttr(selector) || selectorText == swapPseudoElSyntax(selector))) {\r\n                results.push({\r\n                    sheet: sheet,\r\n                    index: i,\r\n                    style: rules[i].style\r\n                });\r\n            }\r\n        }\r\n        return results;\r\n    }\r\n\r\n    function addRule(sheet, selector) {\r\n        var rules = sheet.cssRules || sheet.rules || [];\r\n        var index = rules.length;\r\n        var pseudoElementRule = addPseudoElementRule(sheet, selector, rules, index);\r\n\r\n        if (!pseudoElementRule) {\r\n            addRuleToSheet(sheet, selector, index);\r\n        }\r\n\r\n        return {\r\n            sheet: sheet,\r\n            index: index,\r\n            style: rules[index].style\r\n        };\r\n    };\r\n\r\n    function addRuleToSheet(sheet, selector, index) {\r\n        if (sheet.insertRule) {\r\n            sheet.insertRule(selector + ' { }', index);\r\n        } else {\r\n            sheet.addRule(selector, null, index);\r\n        }\r\n    }\r\n\r\n    // Handles single colon syntax for older browsers and bugzilla.mozilla.org/show_bug.cgi?id=949651\r\n    function addPseudoElementRule(sheet, selector, rules, index) {\r\n        var doubleColonSelector;\r\n        var singleColonSelector;\r\n\r\n        if (doubleColonPseudoElRegex.exec(selector)) {\r\n            doubleColonSelector = selector;\r\n            singleColonSelector = toSingleColonPseudoElements(selector);\r\n        } else if (singleColonPseudoElRegex.exec(selector)) {\r\n            doubleColonSelector = toDoubleColonPseudoElements(selector);\r\n            singleColonSelector = selector;\r\n        } else {\r\n            return false; // Not dealing with a pseudo element\r\n        }\r\n\r\n        if (!singleColonForPseudoElements) {\r\n            // Assume modern browser and then check if successful\r\n            addRuleToSheet(sheet, doubleColonSelector, index);\r\n            if (rules.length <= index) {\r\n                singleColonForPseudoElements = true;\r\n            }\r\n        }\r\n        if (singleColonForPseudoElements) {\r\n            addRuleToSheet(sheet, singleColonSelector, index);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function toDoubleColonPseudoElements(selector) {\r\n        return selector.replace(singleColonPseudoElRegex, function (match, submatch1, submatch2, submatch3) {\r\n            return submatch1 + '::' + submatch3;\r\n        });\r\n    }\r\n\r\n    function toSingleColonPseudoElements(selector) {\r\n        return selector.replace(doubleColonPseudoElRegex, function(match, submatch1, submatch2) {\r\n            return ':' + submatch2;\r\n        })\r\n    }\r\n\r\n    function removeRule(rule) {\r\n        var sheet = rule.sheet;\r\n        if (sheet.deleteRule) {\r\n            sheet.deleteRule(rule.index);\r\n        } else if (sheet.removeRule) {\r\n            sheet.removeRule(rule.index);\r\n        }\r\n    }\r\n\r\n    function extend(dest, src) {\r\n        for (var key in src) {\r\n            if (!src.hasOwnProperty(key))\r\n                continue;\r\n            dest[key] = src[key];\r\n        }\r\n        return dest;\r\n    }\r\n\r\n    function aggregateStyles(rules) {\r\n        var aggregate = {};\r\n        for (var i = 0; i < rules.length; i++) {\r\n            extend(aggregate, declaredProperties(rules[i].style));\r\n        }\r\n        return aggregate;\r\n    }\r\n\r\n    function declaredProperties(style) {\r\n        var declared = {};\r\n        for (var i = 0; i < style.length; i++) {\r\n            declared[style[i]] = style[toCamelCase(style[i])];\r\n        }\r\n        return declared;\r\n    }\r\n\r\n    // IE9 stores rules with attributes (classes or ID's) adjacent in the opposite order as defined\r\n    // causing them to not be found, so this method swaps [#|.]sel1[#|.]sel2 to become [#|.]sel2[#|.]sel1\r\n    function swapAdjSelAttr(selector) {\r\n        var swap = '';\r\n        var lastIndex = 0;\r\n\r\n        while ((match = adjSelAttrRegex.exec(selector)) != null) {\r\n            if (match[0] === '')\r\n                break;\r\n            swap += selector.substring(lastIndex, match.index);\r\n            swap += selector.substr(match.index + match[1].length, match[2].length);\r\n            swap += selector.substr(match.index, match[1].length);\r\n            lastIndex = match.index + match[0].length;\r\n        }\r\n        swap += selector.substr(lastIndex);\r\n\r\n        return swap;\r\n    };\r\n\r\n    // FF and older browsers store rules with pseudo elements using single-colon syntax\r\n    function swapPseudoElSyntax(selector) {\r\n        if (doubleColonPseudoElRegex.exec(selector)) {\r\n            return toSingleColonPseudoElements(selector);\r\n        }\r\n        return selector;\r\n    }\r\n\r\n    function setStyleProperties(rule, properties) {\r\n        for (var key in properties) {\r\n            var value = properties[key];\r\n            var importantIndex = value.indexOf(' !important');\r\n\r\n            // Modern browsers seem to handle overrides fine, but IE9 doesn't\r\n            rule.style.removeProperty(key);\r\n            if (importantIndex > 0) {\r\n                rule.style.setProperty(key, value.substr(0, importantIndex), 'important');\r\n            } else {\r\n                rule.style.setProperty(key, value);\r\n            }\r\n        }\r\n    }\r\n\r\n    function toCamelCase(str) {\r\n        return str.replace(/-([a-z])/g, function (match, submatch) {\r\n            return submatch.toUpperCase();\r\n        });\r\n    }\r\n\r\n    function transformCamelCasedPropertyNames(oldProps) {\r\n        var newProps = {};\r\n        for (var key in oldProps) {\r\n            newProps[unCamelCase(key)] = oldProps[key];\r\n        }\r\n        return newProps;\r\n    }\r\n\r\n    function unCamelCase(str) {\r\n        return str.replace(/([A-Z])/g, function(match, submatch) {\r\n            return '-' + submatch.toLowerCase();\r\n        });\r\n    }\r\n\r\n    var Jss = function(doc) {\r\n        this.doc = doc;\r\n        this.head = this.doc.head || this.doc.getElementsByTagName('head')[0];\r\n        this.sheets = this.doc.styleSheets || [];\r\n    };\r\n\r\n    Jss.prototype = {\r\n        // Returns JSS rules (selector is optional)\r\n        get: function(selector) {\r\n            if (!this.defaultSheet) {\r\n                return {};\r\n            }\r\n            if (selector) {\r\n                return aggregateStyles(getRules(this.defaultSheet, selector));\r\n            }\r\n            var rules = getSelectorsAndRules(this.defaultSheet);\r\n            for (selector in rules) {\r\n                rules[selector] = aggregateStyles(rules[selector]);\r\n            }\r\n            return rules;\r\n        },\r\n        // Returns all rules (selector is required)\r\n        getAll: function(selector) {\r\n            var properties = {};\r\n            for (var i = 0; i < this.sheets.length; i++) {\r\n                extend(properties, aggregateStyles(getRules(this.sheets[i], selector)));\r\n            }\r\n            return properties;\r\n        },\r\n        // Adds JSS rules for the selector based on the given properties\r\n        set: function(selector, properties) {\r\n            if (!this.defaultSheet) {\r\n                this.defaultSheet = this._createSheet();\r\n            }\r\n            properties = transformCamelCasedPropertyNames(properties);\r\n            var rules = getRules(this.defaultSheet, selector);\r\n            if (!rules.length) {\r\n                rules = [addRule(this.defaultSheet, selector)];\r\n            }\r\n            for (var i = 0; i < rules.length; i++) {\r\n                setStyleProperties(rules[i], properties);\r\n            }\r\n        },\r\n        // Removes JSS rules (selector is optional)\r\n        remove: function(selector) {\r\n            if (!this.defaultSheet)\r\n                return;\r\n            if (!selector) {\r\n                this._removeSheet(this.defaultSheet);\r\n                delete this.defaultSheet;\r\n                return;\r\n            }\r\n            var rules = getRules(this.defaultSheet, selector);\r\n            for (var i = 0; i < rules.length; i++) {\r\n                removeRule(rules[i]);\r\n            }\r\n            return rules.length;\r\n        },\r\n        _createSheet: function() {\r\n            var styleNode = this.doc.createElement('style');\r\n            styleNode.type = 'text/css';\r\n            styleNode.rel = 'stylesheet';\r\n            this.head.appendChild(styleNode);\r\n            return styleNode.sheet;\r\n        },\r\n        _removeSheet: function(sheet) {\r\n            var node = sheet.ownerNode;\r\n            node.parentNode.removeChild(node);\r\n        }\r\n    };\r\n\r\n    var exports = new Jss(document);\r\n    exports.forDocument = function(doc) {\r\n        return new Jss(doc);\r\n    };\r\n    return exports;\r\n})();\r\n\r\ntypeof module !== 'undefined' && module.exports && (module.exports = jss); // CommonJS support\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./external/jss.js\n ** module id = 15\n ** module chunks = 0\n **/","// utilities needed by the configuration (excludes dependencies the configs don't need so the webpack bundle is lean)\r\n\r\nvar path = require('path')\r\n\r\n\r\n// Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1\r\n// any number of objects can be passed into the function and will be merged into the first argument in order\r\n// returns obj1 (now mutated)\r\nvar merge = exports.merge = function(obj1, obj2/*, moreObjects...*/){\r\n    return mergeInternal(arrayify(arguments), false)\r\n}\r\n\r\n// like merge, but traverses the whole object tree\r\n// the result is undefined for objects with circular references\r\nvar deepMerge = exports.deepMerge = function(obj1, obj2/*, moreObjects...*/) {\r\n    return mergeInternal(arrayify(arguments), true)\r\n}\r\n\r\n// returns a new object where properties of b are merged onto a (a's properties may be overwritten)\r\nexports.objectConjunction = function(a, b) {\r\n    var objectCopy = {}\r\n    merge(objectCopy, a)\r\n    merge(objectCopy, b)\r\n    return objectCopy\r\n}\r\n\r\n// turns an array of values into a an object where those values are all keys that point to 'true'\r\nexports.arrayToMap = function(array) {\r\n    var result = {}\r\n    array.forEach(function(v) {\r\n        result[v] = true\r\n    })\r\n    return result\r\n}\r\n\r\nfunction mergeInternal(objects, deep) {\r\n    var obj1 = objects[0]\r\n    var obj2 = objects[1]\r\n\r\n    for(var key in obj2){\r\n       if(Object.hasOwnProperty.call(obj2, key)) {\r\n            if(deep && obj1[key] instanceof Object && obj2[key] instanceof Object) {\r\n                mergeInternal([obj1[key], obj2[key]], true)\r\n            } else {\r\n                obj1[key] = obj2[key]\r\n            }\r\n       }\r\n    }\r\n\r\n    if(objects.length > 2) {\r\n        var newObjects = [obj1].concat(objects.slice(2))\r\n        return mergeInternal(newObjects, deep)\r\n    } else {\r\n        return obj1\r\n    }\r\n}\r\n\r\nfunction arrayify(a) {\r\n    return Array.prototype.slice.call(a, 0)\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/utils.js\n ** module id = 16\n ** module chunks = 0\n **/","// some functionality that is needed by Block.js but is related to styling (some things are also needed by Style.js)\r\n\r\nvar HashMap = require(\"hashmap\")\r\n\r\nvar Style = require(\"./Style\")\r\nvar utils = require('./utils')\r\n\r\nexports.defaultStyleMap = new HashMap() // maps from a proto class to its computed default style\r\n\r\n// propogates a style-set change to a set of components\r\n    // styleMap should be a *copy* of a Style's componentStyleMap property (because it will be modified)\r\nvar propogateStyleSet = exports.propogateStyleSet = function (components, styleMap) {\r\n    for(var n=0; n<components.length; n++) {\r\n        var c = components[n]\r\n\r\n        // object inherits style if its in the styleSet and if it doesn't have an explicitly set style\r\n        if(c._style === undefined) {\r\n            if(styleMap === undefined) {\r\n                setCurrentStyle(c, undefined)\r\n            } else {\r\n                var styleFromMap = getStyleForComponent(styleMap, c)\r\n                if(styleFromMap !== undefined) {\r\n                    setCurrentStyle(c, styleFromMap)\r\n                }\r\n            }\r\n        }\r\n\r\n        // set the computed style set\r\n        var mainStyle; // the style directly given to a component, either its `style` property, or its inherited style\r\n        if(c._style !== undefined) {\r\n            mainStyle = c._style.get(c)\r\n        } else if(styleMap !== undefined) {\r\n            mainStyle = getStyleForComponent(styleMap, c)\r\n            if(mainStyle !== undefined) {\r\n                mainStyle = mainStyle.get(c) // get the specific style (taking into account any label)\r\n            }\r\n        }\r\n\r\n        if(mainStyle !== undefined) {\r\n            if(styleMap !== undefined) {\r\n                c.computedStyleMap = styleMapConjunction(styleMap, mainStyle.componentStyleMap)\r\n            } else {\r\n                c.computedStyleMap = mainStyle.componentStyleMap\r\n            }\r\n        } else {\r\n            c.computedStyleMap = styleMap\r\n        }\r\n\r\n        propogateStyleSet(c.children, c.computedStyleMap)\r\n    }\r\n}\r\n\r\n// gets the right style from the styleMap\r\n// takes the component's inheritance tree into account (relies on the block.constructor.parent property)\r\nvar getStyleForComponent = exports.getStyleForComponent = function (styleMap, block) {\r\n    var constructor = block.constructor\r\n    while(constructor !== undefined) {\r\n        var style = styleMap[constructor.name]\r\n        if(style !== undefined) {\r\n            return style\r\n        } else {\r\n            constructor = constructor.parent\r\n        }\r\n    }\r\n}\r\n\r\n// returns the conjunction of two style maps\r\n// gets it from the computedStyles cache if its already in there\r\nvar styleMapConjunction = exports.styleMapConjunction = function (secondaryStyleMap, primaryStyleMap) {\r\n    var cachedStyleMap = Style.computedStyles.get([secondaryStyleMap, primaryStyleMap])\r\n    if(cachedStyleMap === undefined) {\r\n        cachedStyleMap = utils.objectConjunction(secondaryStyleMap, primaryStyleMap)\r\n        Style.computedStyles.set([secondaryStyleMap, primaryStyleMap], cachedStyleMap)\r\n    }\r\n\r\n    return cachedStyleMap\r\n}\r\n\r\n// takes labels into account\r\nvar setCurrentStyle = exports.setCurrentStyle = function (component, style) {\r\n    if(style === component.currentStyle) return; // do nothing\r\n\r\n    if(style !== undefined)\r\n        var specificStyle = style.get(component)\r\n    else\r\n        var specificStyle = style\r\n\r\n    setStyleClass(component, specificStyle)\r\n    applyStyleKillFunction(component)\r\n    component.currentStyle = specificStyle\r\n    applyStyleSetupFunction(component, specificStyle)\r\n    applyStateHandler(component, specificStyle)\r\n}\r\n\r\n\r\nexports.createDefaultBlockStyle = function (that) {\r\n    if(that.defaultStyle !== undefined) {\r\n        validateDefaultStyle(that.defaultStyle)\r\n    }\r\n\r\n    // get list of default styles\r\n    var defaultStyles = []\r\n    var nextConstructor = that.constructor\r\n    while(nextConstructor !== undefined) {\r\n        if(nextConstructor.defaultStyle !== undefined) {\r\n            defaultStyles.push(nextConstructor.defaultStyle)\r\n        }\r\n        nextConstructor = nextConstructor.parent\r\n    }\r\n\r\n    // generate merged default style\r\n    var defaultStyleSet = {}\r\n    defaultStyles.reverse().forEach(function(style) {\r\n        for(var k in style.styleDefinitions) {\r\n            utils.merge(defaultStyleSet, style.styleDefinitions[k])\r\n            break; // just do first key (shouldn't be more than one key, because only simple stylings are allowed for default styles)\r\n        }\r\n\r\n    })\r\n\r\n    if(Object.keys(defaultStyleSet).length > 0)\r\n        var defaultBlockStyle = Style(defaultStyleSet, {default:true})\r\n    else\r\n        var defaultBlockStyle = false // no special default\r\n\r\n    exports.defaultStyleMap.set(that.constructor, defaultBlockStyle)\r\n    return defaultBlockStyle\r\n}\r\n\r\n\r\n// applies setup appropriately\r\nfunction applyStyleSetupFunction(component, style) {\r\n    if(style !== undefined && style.setup !== undefined) {\r\n        component._styleSetupObject = style.setup(component) // call setup on the component\r\n    } else {\r\n        component._styleSetupObject = undefined\r\n    }\r\n}\r\n// applies kill appropriately\r\nfunction applyStyleKillFunction(component) {\r\n    var currentStyle = component.currentStyle\r\n    if(currentStyle !== undefined && currentStyle.setup !== undefined) {\r\n        if(currentStyle.kill === undefined)\r\n            throw new Error('style has been unset but does not have a \"kill\" function to undo its \"setup\" function')\r\n\r\n        currentStyle.kill(component, component._styleSetupObject)\r\n    }\r\n}\r\n\r\n// initializes and sets up state-change handler\r\nfunction applyStateHandler(component, style) {\r\n    if(style !== undefined && style.stateHandler !== undefined) {\r\n        // todo: using setCurrentStyle is a stopgap until I can implement better style application for $state and pseudoclasses (which probably will require a rewrite of much of the style logic)\r\n        setCurrentStyle(component, style.stateHandler(component.state.subject))\r\n        component.state.on('change', function() {\r\n            setCurrentStyle(component, style.stateHandler(component.state.subject))\r\n        })\r\n    }\r\n}\r\n\r\n// sets the style, replacing one if one already exists\r\nfunction setStyleClass(component, style) {\r\n    var currentStyle = component.currentStyle\r\n    if(currentStyle !== undefined) {\r\n        component.domNode.className = component.domNode.className.replace(new RegExp(\" ?\\\\b\"+currentStyle.className+\"\\\\b\"),'') // remove the previous css class\r\n    }\r\n    if(style !== undefined) {\r\n        component.domNode.className = style.className+' '+component.domNode.className.trim() // note that the order of classes doesn't matter\r\n    }\r\n}\r\n\r\nfunction validateDefaultStyle(defaultStyle) {\r\n    if(!(defaultStyle instanceof Style)) {\r\n        throw new Error(\"defaultStyle property must be a Style object\")\r\n    } else if(\r\n        defaultStyle.setup !== undefined || defaultStyle.kill !== undefined || defaultStyle.stateHandler !== undefined ||\r\n        Object.keys(defaultStyle.componentStyleMap).length > 0 || Object.keys(defaultStyle.labelStyleMap).length > 0 /*||\r\n        Object.keys(defaultStyle.pseudoClassStyles).length > 0*/\r\n    ) {\r\n        throw new Error(\"A Block's defaultStyle can only contain basic css stylings, no Block, label, or pseudoclass stylings, nor run/kill javascript\")\r\n    }\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/blockStyleUtils.js\n ** module id = 17\n ** module chunks = 0\n **/","var EventEmitter = require('events').EventEmitter\r\nvar proto = require(\"proto\")\r\nvar utils = require(\"utils\")\r\n\r\nmodule.exports = proto(EventEmitter, function(superclass) {\r\n\r\n    this.init = function() {\r\n        superclass.apply(this, arguments)\r\n\r\n        this.ifonHandlers = {}\r\n        this.ifoffHandlers = {}\r\n        this.ifonAllHandlers = []\r\n        this.ifoffAllHandlers = []\r\n    }\r\n\r\n    // callback will be triggered immediately if there is already a listener attached, or\r\n    // callback will be triggered when the first listener for the event is added\r\n    // (regardless of whether its done through on or once)\r\n    // parameters can be:\r\n        // event, callback - attach an ifon handler for the passed event\r\n        // callback - attach an ifon handler for all events\r\n    this.ifon = function(event, callback) {\r\n        if(event instanceof Function) {     // event not passed, only a callback\r\n            callback = event // fix the argument\r\n            for(var eventName in this._events) {\r\n                if(this.listeners(eventName).length > 0) {\r\n                    callback(eventName)\r\n                }\r\n            }\r\n        } else if(this.listeners(event).length > 0) {\r\n            callback(event)\r\n        }\r\n\r\n        addHandlerToList(this, 'ifonHandlers', event, callback)\r\n    }\r\n\r\n    // removes either:\r\n        // removeIfon() - all ifon handlers (if no arguments are passed), or\r\n        // removeIfon(event) - all ifon handlers for the passed event, or\r\n        // removeIfon(callback) - the passed ifon-all handler (if the first parameter is the callback)\r\n        // removeIfon(event, callback) - the specific passed callback for the passed event\r\n    this.removeIfon = function(event, callback) {\r\n        removeFromHandlerList(this, 'ifonHandlers', event, callback)\r\n    }\r\n\r\n    // callback will be triggered when the last listener for the 'click' event is removed (will not trigger immediately if there is no event listeners on call of ifoff)\r\n    // (regardless of whether this is done through removeListener or as a result of 'once' being fulfilled)\r\n    // parameters can be:\r\n        // event, callback - attach an ifoff handler for the passed event\r\n        // callback - attach an ifoff handler for all events\r\n    this.ifoff = function(event, callback) {\r\n        addHandlerToList(this, 'ifoffHandlers', event, callback)\r\n    }\r\n\r\n    // removes either:\r\n        // removeIfoff() - all ifoff handlers (if no arguments are passed), or\r\n        // removeIfoff(event) - all ifoff handlers for the passed event, or\r\n        // removeIfoff(callback) - the passed ifoff-all handler (if the first parameter is the callback)\r\n        // removeIfoff(event, callback) - the specific passed callback for the passed event\r\n    this.removeIfoff = function(event, callback) {\r\n        removeFromHandlerList(this, 'ifoffHandlers', event, callback)\r\n    }\r\n\r\n    // emitter is the emitter to proxy handler binding to\r\n    // options can have one of the following properties:\r\n        // only - an array of events to proxy\r\n        // except - an array of events to *not* proxy\r\n    this.proxy = function(emitter, options) {\r\n        if(options === undefined) options = {}\r\n        if(options.except !== undefined) {\r\n            var except = utils.arrayToMap(options.except)\r\n            var handleIt = function(event){return !(event in except)}\r\n        } else if(options.only !== undefined) {\r\n            var only = utils.arrayToMap(options.only)\r\n            var handleIt = function(event){return event in only}\r\n        } else {\r\n            var handleIt = function(){return true}\r\n        }\r\n\r\n        var that = this, handler;\r\n        this.ifon(function(event) {\r\n            if(handleIt(event)) {\r\n                emitter.on(event, handler = function() {\r\n                    that.emit.apply(that, [event].concat(Array.prototype.slice.call(arguments)))\r\n                })\r\n            }\r\n        })\r\n        this.ifoff(function(event) {\r\n            if(handleIt(event))\r\n                emitter.off(event, handler)\r\n        })\r\n    }\r\n\r\n    /*override*/ this.on = this.addListener = function(event, callback) {\r\n        var triggerIfOn = this.listeners(event).length === 0\r\n        superclass.prototype.on.apply(this,arguments)\r\n        if(triggerIfOn) triggerIfHandlers(this, 'ifonHandlers', event)\r\n    }\r\n\r\n    /*override*/ this.off = this.removeListener = function(event, callback) {\r\n        var triggerIfOff = this.listeners(event).length === 1\r\n        superclass.prototype.removeListener.apply(this,arguments)\r\n        if(triggerIfOff) triggerIfHandlers(this, 'ifoffHandlers', event)\r\n    }\r\n    /*override*/ this.removeAllListeners = function(event) {\r\n        var triggerIfOffForEvents = []\r\n        if(event !== undefined) {\r\n            if(this.listeners(event).length > 0) {\r\n                triggerIfOffForEvents.push(event)\r\n            }\r\n        } else {\r\n            for(var event in this._events) {\r\n                if(this.listeners(event).length > 0) {\r\n                    triggerIfOffForEvents.push(event)\r\n                }\r\n            }\r\n        }\r\n\r\n        superclass.prototype.removeAllListeners.apply(this,arguments)\r\n\r\n        for(var n=0; n<triggerIfOffForEvents.length; n++) {\r\n            triggerIfHandlers(this, 'ifoffHandlers', triggerIfOffForEvents[n])\r\n        }\r\n    }\r\n\r\n})\r\n\r\n\r\n// triggers the if handlers from the normal list and the \"all\" list\r\nfunction triggerIfHandlers(that, handlerListName, event) {\r\n    triggerIfHandlerList(that[handlerListName][event], event)\r\n    triggerIfHandlerList(that[normalHandlerToAllHandlerProperty(handlerListName)], event)\r\n}\r\n\r\n\r\n// triggers the if handlers from a specific list\r\n// ya these names are confusing, sorry : (\r\nfunction triggerIfHandlerList(handlerList, event) {\r\n    if(handlerList !== undefined) {\r\n        for(var n=0; n<handlerList.length; n++) {\r\n            handlerList[n](event)\r\n        }\r\n    }\r\n}\r\n\r\nfunction addHandlerToList(that, handlerListName, event, callback) {\r\n    if(event instanceof Function) {\r\n        // correct arguments\r\n        callback = event\r\n        event = undefined\r\n    }\r\n\r\n    if(event !== undefined && callback !== undefined) {\r\n        var handlerList = that[handlerListName][event]\r\n        if(handlerList === undefined) {\r\n            handlerList = that[handlerListName][event] = []\r\n        }\r\n\r\n        handlerList.push(callback)\r\n    } else {\r\n        that[normalHandlerToAllHandlerProperty(handlerListName)].push(callback)\r\n    }\r\n}\r\n\r\nfunction removeFromHandlerList(that, handlerListName, event, callback) {\r\n    if(event instanceof Function) {\r\n        // correct arguments\r\n        callback = event\r\n        event = undefined\r\n    }\r\n\r\n    if(event !== undefined && callback !== undefined) {\r\n        removeCallbackFromList(that[handlerListName][event], callback)\r\n    } else if(event !== undefined) {\r\n        delete that[handlerListName][event]\r\n    } else if(callback !== undefined) {\r\n        var allHandlerListName = normalHandlerToAllHandlerProperty(handlerListName)\r\n        removeCallbackFromList(that[allHandlerListName], callback)\r\n    } else {\r\n        var allHandlerListName = normalHandlerToAllHandlerProperty(handlerListName)\r\n        that[handlerListName] = {}\r\n        that[allHandlerListName] = []\r\n    }\r\n}\r\n\r\nfunction normalHandlerToAllHandlerProperty(handlerListName) {\r\n    if(handlerListName === 'ifonHandlers')\r\n        return 'ifonAllHandlers'\r\n    if(handlerListName === 'ifoffHandlers')\r\n        return 'ifoffAllHandlers'\r\n}\r\n\r\nfunction removeCallbackFromList(list, callback) {\r\n    var index = list.indexOf(callback)\r\n    list.splice(index,1)\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/EventEmitterB.js\n ** module id = 18\n ** module chunks = 0\n **/","\r\n// creates a dom element optionally with a class and attributes\r\n var node = module.exports.node = function(type, className, options) {\r\n    var elem = document.createElement(type)\r\n\r\n    if(options !== undefined) {\r\n        if(options.attr !== undefined) {\r\n            for(var attribute in options.attr) {\r\n                createAttribute(elem, attribute, options.attr[attribute])\r\n            }\r\n        }\r\n        if(options.textContent !== undefined) {\r\n            elem.textContent = options.textContent\r\n        }\r\n    }\r\n\r\n    if(className !== undefined)\r\n        elem.className = className\r\n\r\n    return elem\r\n}\r\n\r\n// convenience function for creating a div\r\nmodule.exports.div = function(className, options) {\r\n    return node('div', className, options)\r\n}\r\n\r\n// adds an attribute to a domNode\r\nvar setAttribute = module.exports.setAttribute = function(/*[domNode,] type, value*/) {\r\n    if (arguments.length === 2) {\r\n        var domNode = this.domNode;\r\n        var type = arguments[0];\r\n        var value = arguments[1];\r\n    } else if (arguments.length === 3) {\r\n        var domNode = arguments[0];\r\n        var type = arguments[1];\r\n        var value = arguments[2];\r\n    } else {\r\n        throw new Error(\"This function expects arguments to be: [domNode,] type, value\");\r\n    }\r\n    var attr = document.createAttribute(type)\r\n    attr.value = value\r\n    domNode.setAttributeNode(attr)\r\n}\r\n\r\n\r\n// sets the selection\r\n//\r\n// works for contenteditable elements\r\nexports.setSelectionRange = function(containerEl, start, end) {\r\n\r\n    if(containerEl.nodeName === 'INPUT' || containerEl.nodeName === 'TEXTAREA') {\r\n        containerEl.setSelectionRange(start, end)\r\n    } else {\r\n        var charIndex = 0, range = document.createRange();\r\n        range.setStart(containerEl, 0);\r\n        range.collapse(true);\r\n        var foundStart = false;\r\n\r\n        iterateThroughLeafNodes(containerEl, function(node) {\r\n            var hiddenCharacters = findHiddenCharacters(node, node.length)\r\n            var nextCharIndex = charIndex + node.length - hiddenCharacters;\r\n\r\n            if (!foundStart && start >= charIndex && start <= nextCharIndex) {\r\n                var nodeIndex = start-charIndex\r\n                var hiddenCharactersBeforeStart = findHiddenCharacters(node, nodeIndex)\r\n                range.setStart(node, nodeIndex + hiddenCharactersBeforeStart);\r\n                foundStart = true;\r\n            }\r\n\r\n            if (foundStart && end >= charIndex && end <= nextCharIndex) {\r\n                var nodeIndex = end-charIndex\r\n                var hiddenCharactersBeforeEnd = findHiddenCharacters(node, nodeIndex)\r\n                range.setEnd(node, nodeIndex + hiddenCharactersBeforeEnd);\r\n                return true; // stop the iteration - we're done here\r\n            }\r\n\r\n            charIndex = nextCharIndex\r\n        })\r\n\r\n        var sel = window.getSelection();\r\n        sel.removeAllRanges();\r\n        sel.addRange(range);\r\n    }\r\n}\r\n\r\n// gets the character offsets of a selection within a particular dom node\r\n// returns undefined if there is no selection in the element\r\n// note: yes this code doesn't work in older versions of IE (or possibly any versions) - if you want it to work in IE, please use http://modernizr.com/ or a polyfill for ranges\r\nexports.getSelectionRange = function (element) {\r\n\r\n    var selection = window.getSelection()\r\n    var isInputOrArea = element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA'\r\n\r\n    for(var n=0; n<selection.rangeCount; n++) {\r\n        var range = selection.getRangeAt(0)\r\n        if(isInputOrArea) {\r\n            if(range.startOffset === range.endOffset && range.startContainer.children[range.startOffset] === element /*|| range.startContainer === element || */) { // I don't think the input or textarea itself will ever be the startContainer\r\n                return [element.selectionStart, element.selectionEnd]\r\n            }\r\n        } else {\r\n            var startsInElement = element.contains(range.startContainer)\r\n            if(startsInElement) {\r\n                var elementToIterateThrough = element\r\n                var startFound = true\r\n            } else {\r\n                var elementToIterateThrough = range.commonAncestorContainer\r\n                var startFound = false\r\n                var startContainerFound = false\r\n            }\r\n\r\n            var visibleCharacterOffset = 0, start, end;\r\n            iterateThroughLeafNodes(elementToIterateThrough, function(leaf) {\r\n                if(!startFound) {\r\n                    if(leaf === range.startContainer) {\r\n                        startContainerFound = true\r\n                    }\r\n\r\n                    if(!element.contains(leaf) || !startContainerFound)\r\n                        return; // continue\r\n                    else if(startContainerFound)\r\n                       startFound = true\r\n                } else if(!startsInElement && !element.contains(leaf)) {\r\n                    return true // done!\r\n                }\r\n\r\n                if(leaf === range.startContainer) {\r\n                    start = visibleCharacterOffset + range.startOffset - findHiddenCharacters(leaf, range.startOffset)\r\n                }\r\n                if(leaf === range.endContainer) {\r\n                    end = visibleCharacterOffset + range.endOffset - findHiddenCharacters(leaf, range.endOffset)\r\n                    return true // done!\r\n                }\r\n\r\n                visibleCharacterOffset += leaf.length - findHiddenCharacters(leaf, leaf.length)\r\n            })\r\n\r\n            if(start === undefined && !startFound) {\r\n                return undefined\r\n            } else {\r\n                if(start === undefined) {\r\n                    start = 0 // start is at the beginning\r\n                }\r\n                if(end === undefined) {\r\n                    end = visibleCharacterOffset // end is all the way at the end (the selection may continue in other elements)\r\n                }\r\n\r\n                return [start, end]\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// iterate through the leaf nodes inside element\r\n// callback(node) - a function called for each leaf node\r\n    // returning true from this ends the iteration\r\nfunction iterateThroughLeafNodes(element, callback) {\r\n    var nodeStack = [element], node;\r\n\r\n    while (node = nodeStack.pop()) {\r\n        if (node.nodeType == 3) {\r\n            if(callback(node) === true)\r\n                break;\r\n        } else {\r\n            var i = node.childNodes.length;\r\n            while (i--) {\r\n                nodeStack.push(node.childNodes[i]);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction findHiddenCharacters(node, beforeCaretIndex) {\r\n    var hiddenCharacters = 0\r\n    var lastCharWasWhiteSpace=true\r\n    for(var n=0; n-hiddenCharacters<beforeCaretIndex &&n<node.length; n++) {\r\n        if([' ','\\n','\\t','\\r'].indexOf(node.textContent[n]) !== -1) {\r\n            if(lastCharWasWhiteSpace)\r\n                hiddenCharacters++\r\n            else\r\n                lastCharWasWhiteSpace = true\r\n        } else {\r\n            lastCharWasWhiteSpace = false\r\n        }\r\n    }\r\n\r\n    return hiddenCharacters\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/domUtils.js\n ** module id = 19\n ** module chunks = 0\n **/","var Block = require('Block')\nvar proto = require('proto')\nvar Style = require(\"Style\")\n\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static properties\n\n\tthis.name = 'ListItem'\n\n    this.defaultStyle = Style({\n        display: 'list-item'\n    })\n\n\t// instance properties\n\n\tthis.init = function(/*[label,] contents*/) {\n        if(arguments.length <= 1) {\n            var contents = arguments[0]\n        } else {\n            var label = arguments[0]\n            var contents = arguments[1]\n        }\n\n        this.domNode = document.createElement(\"li\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t\tsuperclass.init.call(this) // superclass constructor\n\t\tthis.label = label\n\n        if(contents instanceof Block) {\n\t\t\tthis.add(contents)\n\t\t} else if(contents !== undefined) {\n            this.domNode.textContent = contents\n        }\n\t}\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Item.js\n ** module id = 20\n ** module chunks = 0\n **/","// note: this is  not intended to be used directly - only through Select and MultiSelect\r\n\r\nvar Block = require('Block')\r\nvar Style = require('Style')\r\nvar proto = require('proto')\r\n//var htmlEntities = require('he')\r\n\r\n// emits a 'change' event when its 'selected' value changes\r\nmodule.exports = proto(Block, function(superclass) {\r\n\r\n    // staic members\r\n\r\n    this.name = 'Option'\r\n\r\n    this.defaultStyle = Style({\r\n        display: 'block'\r\n    })\r\n\r\n\r\n    // instance members\r\n\r\n    this.init = function(label, value, text) {\r\n        this.domNode = document.createElement(\"option\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\r\n        superclass.init.call(this) // superclass constructor\r\n\r\n        this.label = label\r\n\r\n        this.text = text\r\n        this.val = value\r\n    }\r\n\r\n    Object.defineProperty(this, 'val', {\r\n        // returns the value of the Option\r\n        get: function() {\r\n            return this.attr('value')\r\n        },\r\n\r\n        // sets the value of the Option\r\n        set: function(value) {\r\n            if(this.parent !== undefined) {\r\n                if(this.parent.options[value] !== undefined) {\r\n                    throw new Error(\"Can't give an Option the same value as another in the Select or MultiSelect (value: '\"+value+\"')\")\r\n                }\r\n\r\n                if(this.val !== null) {\r\n                    delete this.parent.options[this.val]\r\n                }\r\n\r\n                this.parent.options[value] = this\r\n            }\r\n\r\n            this.attr('value', value)\r\n\r\n        }\r\n    })\r\n\r\n\r\n    Object.defineProperty(this, 'selected', {\r\n        // returns whether or not the option is selected\r\n        get: function() {\r\n            return this.domNode.selected\r\n        },\r\n\r\n        // sets the selected state of the option to the passed value (true for selected)\r\n        set: function(value) {\r\n            var booleanValue = value === true\r\n            if(this.selected === booleanValue) return false; // ignore if there's no change\r\n\r\n            if(this.parent !== undefined)\r\n                this.parent.prepareForValueChange([this.val])\r\n\r\n            this.setSelectedQuiet(booleanValue)\r\n\r\n            if(this.parent !== undefined)\r\n                this.parent.emit('change')\r\n        }\r\n    })\r\n\r\n    Object.defineProperty(this, 'text', {\r\n        get: function() {\r\n            return this.domNode.textContent\r\n        },\r\n\r\n        set: function(text) {\r\n            this.domNode.innerText = text // apparently textContent can't be set or something? unclear\r\n        }\r\n    })\r\n\r\n\r\n    // private\r\n\r\n    // does everything for setting the selected state except emit the parent's change event\r\n    this.setSelectedQuiet = function setOptionSelected(booleanValue) {\r\n        if(this.selected === booleanValue) return; // ignore if there's no change\r\n\r\n        this.domNode.selected = booleanValue\r\n        this.emit('change') // the browser has no listenable event that is triggered on change of the 'checked' property\r\n    }\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Option.js\n ** module id = 21\n ** module chunks = 0\n **/","\n\nvar RowlikeGenerator = require(\"./RowlikeGenerator\");\n\nmodule.exports = RowlikeGenerator('th', \"TableHeader\")\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Header.js\n ** module id = 22\n ** module chunks = 0\n **/","var RowlikeGenerator = require(\"./RowlikeGenerator\");\n\nmodule.exports = RowlikeGenerator('tr', \"TableRow\")\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Row.js\n ** module id = 23\n ** module chunks = 0\n **/","var Block = require('../Block')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static properties\n\n\tthis.name = 'TableCell'\n\t\n\n\t// instance properties\n\n\tthis.init = function(/*[label,] contents*/) {\n        if(arguments.length <= 1) {\n            var contents = arguments[0]\n        } else {\n            var label = arguments[0]\n            var contents = arguments[1]\n        }\n\n        this.domNode = document.createElement(\"td\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t\tsuperclass.init.call(this) // superclass constructor\n\t\tthis.label = label\n\n        if(contents instanceof Block) {\n\t\t\tthis.add(contents)\n\t\t} else if(contents !== undefined) {\n            this.domNode.textContent = contents\n        }\n\t}\n\n\tthis.colspan = function(cols) {\n\t\tthis.attr('colspan',cols);\n\t}\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Cell.js\n ** module id = 24\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/build-modules/~/webpack/~/node-libs-browser/~/events/events.js\n ** module id = 25\n ** module chunks = 0\n **/","\"use strict\";\r\n/* Copyright (c) 2013 Billy Tetrud - Free to use for any purpose: MIT License*/\r\n\r\nvar noop = function() {}\r\n\r\nvar prototypeName='prototype', undefined, protoUndefined='undefined', init='init', ownProperty=({}).hasOwnProperty; // minifiable variables\r\nfunction proto() {\r\n    var args = arguments // minifiable variables\r\n\r\n    if(args.length == 1) {\r\n        var parent = {init: noop}\r\n        var prototypeBuilder = args[0]\r\n\r\n    } else { // length == 2\r\n        var parent = args[0]\r\n        var prototypeBuilder = args[1]\r\n    }\r\n\r\n    // special handling for Error objects\r\n    var namePointer = {}    // name used only for Error Objects\r\n    if([Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError].indexOf(parent) !== -1) {\r\n        parent = normalizeErrorObject(parent, namePointer)\r\n    }\r\n\r\n    // set up the parent into the prototype chain if a parent is passed\r\n    var parentIsFunction = typeof(parent) === \"function\"\r\n    if(parentIsFunction) {\r\n        prototypeBuilder[prototypeName] = parent[prototypeName]\r\n    } else {\r\n        prototypeBuilder[prototypeName] = parent\r\n    }\r\n\r\n    // the prototype that will be used to make instances\r\n    var prototype = new prototypeBuilder(parent)\r\n    namePointer.name = prototype.name\r\n\r\n    // if there's no init, assume its inheriting a non-proto class, so default to applying the superclass's constructor.\r\n    if(!prototype[init] && parentIsFunction) {\r\n        prototype[init] = function() {\r\n            parent.apply(this, arguments)\r\n        }\r\n    }\r\n\r\n    // constructor for empty object which will be populated via the constructor\r\n    var F = function() {}\r\n        F[prototypeName] = prototype    // set the prototype for created instances\r\n\r\n    var constructorName = prototype.name?prototype.name:''\r\n    if(prototype[init] === undefined || prototype[init] === noop) {\r\n        var ProtoObjectFactory = new Function('F',\r\n            \"return function \" + constructorName + \"(){\" +\r\n                \"return new F()\" +\r\n            \"}\"\r\n        )(F)\r\n    } else {\r\n        // dynamically creating this function cause there's no other way to dynamically name a function\r\n        var ProtoObjectFactory = new Function('F','i','u','n', // shitty variables cause minifiers aren't gonna minify my function string here\r\n            \"return function \" + constructorName + \"(){ \" +\r\n                \"var x=new F(),r=i.apply(x,arguments)\\n\" +    // populate object via the constructor\r\n                \"if(r===n)\\n\" +\r\n                    \"return x\\n\" +\r\n                \"else if(r===u)\\n\" +\r\n                    \"return n\\n\" +\r\n                \"else\\n\" +\r\n                    \"return r\\n\" +\r\n            \"}\"\r\n        )(F, prototype[init], proto[protoUndefined]) // note that n is undefined\r\n    }\r\n\r\n    prototype.constructor = ProtoObjectFactory;    // set the constructor property on the prototype\r\n\r\n    // add all the prototype properties onto the static class as well (so you can access that class when you want to reference superclass properties)\r\n    for(var n in prototype) {\r\n        addProperty(ProtoObjectFactory, prototype, n)\r\n    }\r\n\r\n    // add properties from parent that don't exist in the static class object yet\r\n    for(var n in parent) {\r\n        if(ownProperty.call(parent, n) && ProtoObjectFactory[n] === undefined) {\r\n            addProperty(ProtoObjectFactory, parent, n)\r\n        }\r\n    }\r\n\r\n    ProtoObjectFactory.parent = parent;            // special parent property only available on the returned proto class\r\n    ProtoObjectFactory[prototypeName] = prototype  // set the prototype on the object factory\r\n\r\n    return ProtoObjectFactory;\r\n}\r\n\r\nproto[protoUndefined] = {} // a special marker for when you want to return undefined from a constructor\r\n\r\nmodule.exports = proto\r\n\r\nfunction normalizeErrorObject(ErrorObject, namePointer) {\r\n    function NormalizedError() {\r\n        var tmp = new ErrorObject(arguments[0])\r\n        tmp.name = namePointer.name\r\n\r\n        this.message = tmp.message\r\n        if(Object.defineProperty) {\r\n            /*this.stack = */Object.defineProperty(this, 'stack', { // getter for more optimizy goodness\r\n                get: function() {\r\n                    return tmp.stack\r\n                }\r\n            })\r\n        } else {\r\n            this.stack = tmp.stack\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    var IntermediateInheritor = function() {}\r\n        IntermediateInheritor.prototype = ErrorObject.prototype\r\n    NormalizedError.prototype = new IntermediateInheritor()\r\n\r\n    return NormalizedError\r\n}\r\n\r\nfunction addProperty(factoryObject, prototype, property) {\r\n    try {\r\n        var info = Object.getOwnPropertyDescriptor(prototype, property)\r\n        if(info.get !== undefined || info.get !== undefined && Object.defineProperty !== undefined) {\r\n            Object.defineProperty(factoryObject, property, info)\r\n        } else {\r\n            factoryObject[property] = prototype[property]\r\n        }\r\n    } catch(e) {\r\n        // do nothing, if a property (like `name`) can't be set, just ignore it\r\n    }\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/proto/proto.js\n ** module id = 26\n ** module chunks = 0\n **/","/**\r\n * HashMap - HashMap Class for JavaScript\r\n * @author Ariel Flesler <aflesler@gmail.com>\r\n * @version 2.0.1\r\n * Homepage: https://github.com/flesler/hashmap\r\n */\r\n\r\n(function(factory) {\r\n\tif (typeof define === 'function' && define.amd) {\r\n\t\t// AMD. Register as an anonymous module.\r\n\t\tdefine([], factory);\r\n\t} else if (typeof module === 'object') {\r\n\t\t// Node js environment\r\n\t\tvar HashMap = module.exports = factory();\r\n\t\t// Keep it backwards compatible\r\n\t\tHashMap.HashMap = HashMap;\r\n\t} else {\r\n\t\t// Browser globals (this is window)\r\n\t\tthis.HashMap = factory();\r\n\t}\r\n}(function() {\r\n\r\n\tfunction HashMap(other) {\r\n\t\tthis.clear();\r\n\t\tswitch (arguments.length) {\r\n\t\t\tcase 0: break;\r\n\t\t\tcase 1: this.copy(other); break;\r\n\t\t\tdefault: multi(this, arguments); break;\r\n\t\t}\r\n\t}\r\n\r\n\tvar proto = HashMap.prototype = {\r\n\t\tconstructor:HashMap,\r\n\r\n\t\tget:function(key) {\r\n\t\t\tvar data = this._data[this.hash(key)];\r\n\t\t\treturn data && data[1];\r\n\t\t},\r\n\r\n\t\tset:function(key, value) {\r\n\t\t\t// Store original key as well (for iteration)\r\n\t\t\tthis._data[this.hash(key)] = [key, value];\r\n\t\t},\r\n\r\n\t\tmulti:function() {\r\n\t\t\tmulti(this, arguments);\r\n\t\t},\r\n\r\n\t\tcopy:function(other) {\r\n\t\t\tfor (var key in other._data) {\r\n\t\t\t\tthis._data[key] = other._data[key];\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\thas:function(key) {\r\n\t\t\treturn this.hash(key) in this._data;\r\n\t\t},\r\n\r\n\t\tsearch:function(value) {\r\n\t\t\tfor (var key in this._data) {\r\n\t\t\t\tif (this._data[key][1] === value) {\r\n\t\t\t\t\treturn this._data[key][0];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\t\t},\r\n\r\n\t\tremove:function(key) {\r\n\t\t\tdelete this._data[this.hash(key)];\r\n\t\t},\r\n\r\n\t\ttype:function(key) {\r\n\t\t\tvar str = Object.prototype.toString.call(key);\r\n\t\t\tvar type = str.slice(8, -1).toLowerCase();\r\n\t\t\t// Some browsers yield DOMWindow for null and undefined, works fine on Node\r\n\t\t\tif (type === 'domwindow' && !key) {\r\n\t\t\t\treturn key + '';\r\n\t\t\t}\r\n\t\t\treturn type;\r\n\t\t},\r\n\r\n\t\tkeys:function() {\r\n\t\t\tvar keys = [];\r\n\t\t\tthis.forEach(function(value, key) { keys.push(key); });\r\n\t\t\treturn keys;\r\n\t\t},\r\n\r\n\t\tvalues:function() {\r\n\t\t\tvar values = [];\r\n\t\t\tthis.forEach(function(value) { values.push(value); });\r\n\t\t\treturn values;\r\n\t\t},\r\n\r\n\t\tcount:function() {\r\n\t\t\treturn this.keys().length;\r\n\t\t},\r\n\r\n\t\tclear:function() {\r\n\t\t\t// TODO: Would Object.create(null) make any difference\r\n\t\t\tthis._data = {};\r\n\t\t},\r\n\r\n\t\tclone:function() {\r\n\t\t\treturn new HashMap(this);\r\n\t\t},\r\n\r\n\t\thash:function(key) {\r\n\t\t\tswitch (this.type(key)) {\r\n\t\t\t\tcase 'undefined':\r\n\t\t\t\tcase 'null':\r\n\t\t\t\tcase 'boolean':\r\n\t\t\t\tcase 'number':\r\n\t\t\t\tcase 'regexp':\r\n\t\t\t\t\treturn key + '';\r\n\r\n\t\t\t\tcase 'date':\r\n\t\t\t\t\treturn ':' + key.getTime();\r\n\r\n\t\t\t\tcase 'string':\r\n\t\t\t\t\treturn '\"' + key;\r\n\r\n\t\t\t\tcase 'array':\r\n\t\t\t\t\tvar hashes = [];\r\n\t\t\t\t\tfor (var i = 0; i < key.length; i++) {\r\n\t\t\t\t\t\thashes[i] = this.hash(key[i]);\r\n\t\t\t\t\t}\r\n\t\t\t\t\treturn '[' + hashes.join('|');\r\n\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t// TODO: Don't use expandos when Object.defineProperty is not available?\r\n\t\t\t\t\tif (!key._hmuid_) {\r\n\t\t\t\t\t\tkey._hmuid_ = ++HashMap.uid;\r\n\t\t\t\t\t\thide(key, '_hmuid_');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn '{' + key._hmuid_;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tforEach:function(func) {\r\n\t\t\tfor (var key in this._data) {\r\n\t\t\t\tvar data = this._data[key];\r\n\t\t\t\tfunc.call(this, data[1], data[0]);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tHashMap.uid = 0;\r\n\r\n\t//- Automatically add chaining to some methods\r\n\r\n\tfor (var method in proto) {\r\n\t\t// Skip constructor, valueOf, toString and any other built-in method\r\n\t\tif (method === 'constructor' || !proto.hasOwnProperty(method)) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tvar fn = proto[method];\r\n\t\tif (fn.toString().indexOf('return ') === -1) {\r\n\t\t\tproto[method] = chain(fn);\r\n\t\t}\r\n\t}\r\n\r\n\t//- Utils\r\n\r\n\tfunction multi(map, args) {\r\n\t\tfor (var i = 0; i < args.length; i += 2) {\r\n\t\t\tmap.set(args[i], args[i+1]);\r\n\t\t}\r\n\t}\r\n\r\n\tfunction chain(fn) {\r\n\t\treturn function() {\r\n\t\t\tfn.apply(this, arguments);\r\n\t\t\treturn this;\r\n\t\t};\r\n\t}\r\n\r\n\tfunction hide(obj, prop) {\r\n\t\t// Make non iterable if supported\r\n\t\tif (Object.defineProperty) {\r\n\t\t\tObject.defineProperty(obj, prop, {enumerable:false});\r\n\t\t}\r\n\t}\r\n\r\n\treturn HashMap;\r\n}));\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/hashmap/hashmap.js\n ** module id = 27\n ** module chunks = 0\n **/","// resolves varargs variable into more usable form\n// args - should be a function arguments variable\n// returns a javascript Array object of arguments that doesn't count trailing undefined values in the length\nmodule.exports = function(theArguments) {\n    var args = Array.prototype.slice.call(theArguments, 0)\n\n    var count = 0;\n    for(var n=args.length-1; n>=0; n--) {\n        if(args[n] === undefined)\n            count++\n        else\n            break\n    }\n    args.splice(args.length-count, count)\n    return args\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/trimArguments/trimArguments.js\n ** module id = 28\n ** module chunks = 0\n **/","var proto = require(\"proto\")\r\nvar EventEmitter = require(\"events\").EventEmitter\r\nvar utils = require(\"./utils\")\r\n\r\n\r\n// emits the event:\r\n    // change - the event data is an object of one of the following forms:\r\n        // {id:_, type: 'set', property: propertyList}\r\n        // {id:_, type: 'added', property: propertyList, index:_, count: numberOfElementsAdded}\r\n        // {id:_, type: 'removed', property: propertyList, index:_, values: removedValues}\r\nvar Observe = module.exports = proto(EventEmitter, function() {\r\n\r\n    // static members\r\n\r\n    this.init = function(obj) {\r\n        this.subject = obj\r\n\r\n        this.setMaxListeners(1000)\r\n    }\r\n\r\n    // instance members\r\n\r\n    // gets an element or member of the subject and returns another Observee\r\n    // changes to the returned Observee will be emitted by its parent as well\r\n    this.get = function(property) {\r\n        return ObserveeChild(this, parsePropertyList(property))\r\n    }\r\n\r\n    // sets a value on the subject\r\n    // property - either an array of members to select, or a string where properties to select are separated by dots\r\n    // value - the value to set\r\n    this.set = function(property, value) {\r\n        setInternal(this, parsePropertyList(property), value, {})\r\n    }\r\n\r\n    // pushes a value onto a list\r\n    this.push = function(/*value...*/) {\r\n        pushInternal(this, [], arguments, {})\r\n    }\r\n\r\n\r\n    // index is the index to remove/insert at\r\n    // countToRemove is the number to remove\r\n    // elementsToAdd is a list of elements to add\r\n    this.splice = function(/*index, countToRemove[, elementsToAdd]*/) {\r\n        return spliceInternal(this, [], arguments, {})\r\n    }\r\n\r\n    // use this instead of concat for mutation behavior\r\n    this.append = function(arrayToAppend) {\r\n        appendInternal(this, [], arguments, {})\r\n    }\r\n\r\n    this.id = function(id) {\r\n        return ObserveeChild(this, [], {id: id})\r\n        //return idFunction(this, [], id)\r\n    }\r\n\r\n    // For the returned object, any property added via set, push, splice, or append joins an internal observee together with this observee, so that\r\n    //      the internal observee and the containing observee will both send 'change' events appropriately\r\n    // collapse - (default: false) if true, any property added will be set to the subject of the value added (so that value won't be an observee anymore\r\n        // note: only use collapse:true if the observees you're unioning isn't actually an object that inherits from an observee - any instance methods on the observee that come from child classes won't be accessible anymore\r\n        // e.g. var x = observe({a:5})\r\n        //      var b = observe({})\r\n        //      x.subject.a === 5    ;; true\r\n        //      b.union(true).set('x', x)\r\n        //      b.subject.x.a === 5            ;; true\r\n        //      b.subject.x.subject.a === 5    ;; false\r\n    this.union = function(collapse) {\r\n        if(collapse === undefined) collapse = false\r\n        return ObserveeChild(this, [], {union: collapse})\r\n    }\r\n\r\n\r\n    /* pause and unpause may cause weird affects in certain cases (e.g. if you remove an element at index 4 and *then* add an element at index 2)\r\n    // pause sending events (for when you want to do a lot of things to an object)\r\n    this.pause = function() {\r\n        this.paused = true\r\n    }\r\n    this.unpause = function() {\r\n        this.paused = undefined\r\n        sendEvent(this)\r\n    }*/\r\n})\r\n\r\n\r\nfunction parsePropertyList(property) {\r\n    if(!(property instanceof Array)) {\r\n        property = property.toString().split('.')\r\n    }\r\n\r\n    return property\r\n}\r\n\r\nfunction getPropertyPointer(subject, propertyList) {\r\n    var current = subject\r\n    for(var n=0; n<propertyList.length-1; n++) {\r\n        current = current[propertyList[n]]\r\n    }\r\n\r\n    return {obj: current, key:propertyList[n]}\r\n}\r\n\r\nvar getPropertyValue = module.exports.getPropertyValue = function(subject, property) {\r\n    var pointer = getPropertyPointer(subject, property)\r\n    if(pointer.key !== undefined) {\r\n        return pointer.obj[pointer.key]\r\n    } else {\r\n        return pointer.obj\r\n    }\r\n}\r\n\r\n// private\r\n\r\n// options can have the properties:\r\n    // union - if true, any value set, pushed, appended, or spliced onto the observee is unioned\r\nvar ObserveeChild = proto(EventEmitter, function() {\r\n\r\n    this.init = function(parent, propertyList, options) {\r\n        if(options === undefined) this.options = {}\r\n        else                      this.options = options\r\n\r\n        if(parent._observeeParent !== undefined)\r\n            this._observeeParent = parent._observeeParent\r\n        else\r\n            this._observeeParent = parent\r\n\r\n        this.property = propertyList\r\n        this.subject = getPropertyValue(parent.subject, propertyList)\r\n\r\n        var that = this\r\n        parent.on('change', function(change) {\r\n            var answers = changeQuestions(that.property, change)\r\n\r\n            if(answers.isWithin ) {\r\n                that.emit('change', {type:change.type, property: change.property.slice(that.property.length), index:change.index, count:change.count, removed: change.removed})\r\n            } else if(answers.couldRelocate) {\r\n                if(change.type === 'removed') {\r\n                    var relevantIndex = that.property[change.property.length]\r\n                    var removedIndexesAreBeforeIndexOfObserveeChild = change.index + change.removed.length - 1 < relevantIndex\r\n\r\n                    if(removedIndexesAreBeforeIndexOfObserveeChild) {\r\n                        that.property[change.property.length] = relevantIndex - change.removed.length // change the propertyList to match the new index\r\n                    }\r\n                } else if(change.type === 'added') {\r\n                    var relevantIndex = that.property[change.property.length]\r\n                    if(change.index < relevantIndex) {\r\n                        that.property[change.property.length] = relevantIndex + change.count // change the propertyList to match the new index\r\n                    }\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    this.get = function(property) {\r\n        return this._observeeParent.get(this.property.concat(parsePropertyList(property)))\r\n    }\r\n\r\n    this.set = function(property, value) {\r\n        setInternal(this._observeeParent, this.property.concat(parsePropertyList(property)), value, this.options)\r\n    }\r\n\r\n    this.push = function(/*values...*/) {\r\n        pushInternal(this._observeeParent, this.property, arguments, this.options)\r\n    }\r\n\r\n    this.splice = function(index, countToRemove/*[, elementsToAdd....]*/) {\r\n        spliceInternal(this._observeeParent, this.property, arguments, this.options)\r\n    }\r\n\r\n    this.append = function(/*[property,] arrayToAppend*/) {\r\n        appendInternal(this._observeeParent, this.property, arguments, this.options)\r\n    }\r\n\r\n    this.id = function(id) {\r\n        return ObserveeChild(this, this.property, utils.merge({}, this.options, {id: id}))\r\n        //return idFunction(this._observeeParent, this.property, id)\r\n    }\r\n\r\n    this.union = function(collapse) {\r\n        if(collapse === undefined) collapse = false\r\n        return ObserveeChild(this, [], utils.merge({}, this.options, {union: collapse}))\r\n    }\r\n\r\n})\r\n\r\n     /*\r\nfunction idFunction(that, propertyList, id) {\r\n    var result = {\r\n        set: function(property, value) {\r\n            var fullPropertyList = propertyList.concat(parsePropertyList(property))\r\n            setInternal(that, fullPropertyList, value, id)\r\n        },\r\n        push: function() {\r\n            pushInternal(that, propertyList, arguments, id)\r\n        },\r\n        splice: function() {\r\n            spliceInternal(that, propertyList, arguments, id)\r\n        },\r\n        append: function() {\r\n            appendInternal(that, propertyList, arguments, id)\r\n        },\r\n        get: function() {\r\n\r\n        }\r\n    }\r\n}\r\n*/\r\n\r\n// that - the Observee object\r\nfunction setInternal(that, propertyList, value, options) {\r\n    var pointer = getPropertyPointer(that.subject, propertyList)\r\n\r\n    var internalObservee = value\r\n    if(options.union === true) {\r\n        value = value.subject\r\n    }\r\n\r\n    pointer.obj[pointer.key] = value\r\n\r\n    var event = {type: 'set', property: propertyList}\r\n    if(options.id !== undefined) event.id = options.id\r\n    that.emit('change',event)\r\n\r\n    if(options.union !== undefined)\r\n        unionizeEvents(that, internalObservee, propertyList, options.union)\r\n}\r\n\r\nfunction pushInternal(that, propertyList, args, options) {\r\n    var array = getPropertyValue(that.subject, propertyList)\r\n    var originalLength = array.length\r\n    array.push.apply(array, args)\r\n\r\n    var internalObservees = unionizeList(array, originalLength, args.length, options.union)\r\n\r\n    var event = {type: 'added', property: propertyList, index: originalLength, count: 1}\r\n    if(options.id !== undefined) event.id = options.id\r\n    that.emit('change', event)\r\n\r\n    unionizeListEvents(that, internalObservees, propertyList, options.union)\r\n}\r\n\r\nfunction spliceInternal(that, propertyList, args, options) {\r\n    var index = args[0]\r\n    var countToRemove = args[1]\r\n\r\n    var array = getPropertyValue(that.subject, propertyList)\r\n    var result = array.splice.apply(array, args)\r\n\r\n    if(countToRemove > 0) {\r\n        var event = {type: 'removed', property: propertyList, index: index, removed: result}\r\n        if(options.id !== undefined) event.id = options.id\r\n        that.emit('change', event)\r\n    }\r\n    if(args.length > 2) {\r\n        var event = {type: 'added', property: propertyList, index: index, count: args.length-2}\r\n\r\n        var internalObservees = unionizeList(array, index, event.count, options.union)\r\n\r\n        if(options.id !== undefined) event.id = options.id\r\n        that.emit('change', event)\r\n\r\n        unionizeListEvents(that, internalObservees, propertyList, options.union)\r\n    }\r\n\r\n    return result\r\n}\r\n\r\n// note: I'm not using splice to do this as an optimization (because otherwise the property list would have to be parsed twice and the value gotten twice) - maybe this optimization wasn't worth it but its already done\r\nfunction appendInternal(that, propertyList, args, options) {\r\n    var arrayToAppend = args[0]\r\n    if(arrayToAppend.length === 0) return; //nothing to do\r\n\r\n    var array = getPropertyValue(that.subject, propertyList)\r\n    var originalLength = array.length\r\n\r\n    var spliceArgs = [originalLength, 0]\r\n    spliceArgs = spliceArgs.concat(arrayToAppend)\r\n    var oldLength = array.length\r\n    array.splice.apply(array, spliceArgs)\r\n\r\n    var internalObservees = unionizeList(array, oldLength, array.length, options.union)\r\n\r\n    var event = {type: 'added', property: propertyList, index: originalLength, count: arrayToAppend.length}\r\n    if(options.id !== undefined) event.id = options.id\r\n    that.emit('change', event)\r\n\r\n    unionizeListEvents(that, internalObservees, propertyList, options.union)\r\n}\r\n\r\n// sets a slice of elements to their subjects and\r\n// returns the original observee objects along with their indexes\r\nfunction unionizeList(array, start, count, union) {\r\n    var internalObservees = [] // list of observees and their property path\r\n    if(union !== undefined) {\r\n        var afterEnd = start+count\r\n        for(var n=start; n<afterEnd; n++) {\r\n            internalObservees.push({obj: array[n], index: n})\r\n            if(union === true)\r\n                array[n] = array[n].subject\r\n        }\r\n    }\r\n\r\n    return internalObservees\r\n}\r\n\r\n// runs unionizeEvents for elements in a list\r\n// internalObservees should be the result from `unionizeList`\r\nfunction unionizeListEvents(that, internalObservees, propertyList, collapse) {\r\n    for(var n=0; n<internalObservees.length; n++) {\r\n        unionizeEvents(that, internalObservees[n].obj, propertyList.concat(internalObservees[n].index), collapse)\r\n    }\r\n}\r\n\r\n\r\n// sets up the union change events for an observee with one of its inner properties\r\n// parameters:\r\n    // that - the container observee\r\n    // innerObservee - the contained observee\r\n    // propertyList - the propertyList to unionize\r\n    // collapse - the union option (true for collapse)\r\nfunction unionizeEvents(that, innerObservee, propertyList, collapse) {\r\n    var propertyListDepth = propertyList.length\r\n\r\n    if(innerObservee.on === undefined || innerObservee.emit === undefined || innerObservee.removeListener === undefined || innerObservee.set === undefined) {\r\n        throw new Error(\"Attempting to union a value that isn't an observee\")\r\n    }\r\n\r\n    var innerChangeHandler, containerChangeHandler\r\n    var ignorableContainerEvents = [], ignorableInnerEvents = []\r\n    innerObservee.on('change', innerChangeHandler = function(change) {\r\n        if(ignorableInnerEvents.indexOf(change) === -1) {        // don't run this for events generated by the union event handlers\r\n            if(collapse) {\r\n                var property = propertyList.concat(change.property)\r\n            } else {\r\n                var property = propertyList.concat(['subject']).concat(change.property)\r\n            }\r\n\r\n            var containerChange = utils.merge({}, change, {property: property})\r\n            ignorableContainerEvents.push(containerChange)\r\n            that.emit('change', containerChange)\r\n        }\r\n    })\r\n    that.on('change', containerChangeHandler = function(change) {\r\n        var changedPropertyDepth = change.property.length\r\n\r\n        var answers = changeQuestions(propertyList, change)\r\n        var changeIsWithinInnerProperty = answers.isWithin\r\n        var changeCouldRelocateInnerProperty = answers.couldRelocate\r\n\r\n        if(changeIsWithinInnerProperty && ignorableContainerEvents.indexOf(change) === -1) {   // don't run this for events generated by the union event handlers\r\n            if(collapse) {\r\n                var property = change.property.slice(propertyListDepth)\r\n            } else {\r\n                var property = change.property.slice(propertyListDepth+1) // +1 for the 'subject'\r\n            }\r\n\r\n            var innerObserveeEvent = utils.merge({}, change, {property: property})\r\n            ignorableInnerEvents.push(innerObserveeEvent)\r\n            innerObservee.emit('change', innerObserveeEvent)\r\n        } else if(changeCouldRelocateInnerProperty) {\r\n            if(change.type === 'set' /*&& changedPropertyDepth <= propertyListDepth  - this part already done above*/) {\r\n                removeUnion()\r\n            } else if(change.type === 'removed') {\r\n                var relevantIndex = propertyList[change.property.length]\r\n                var removedIndexesContainsIndexOfInnerObservee = change.index <= relevantIndex && relevantIndex <= change.index + change.removed.length - 1\r\n                var removedIndexesAreBeforeIndexOfInnerObservee = change.index + change.removed.length - 1 < relevantIndex && relevantIndex\r\n\r\n                if(removedIndexesContainsIndexOfInnerObservee && changedPropertyDepth <= propertyListDepth+1) {\r\n                    removeUnion()\r\n                } else if(removedIndexesAreBeforeIndexOfInnerObservee) {\r\n                    propertyList[change.property.length] = relevantIndex - change.removed.length // change the propertyList to match the new index\r\n                }\r\n            } else if(change.type === 'added') {\r\n                var relevantIndex = propertyList[change.property.length]\r\n                if(change.index < relevantIndex) {\r\n                    propertyList[change.property.length] = relevantIndex + change.count // change the propertyList to match the new index\r\n                }\r\n            }\r\n        }\r\n    })\r\n\r\n    var removeUnion = function() {\r\n        innerObservee.removeListener('change', innerChangeHandler)\r\n        that.removeListener('change', containerChangeHandler)\r\n    }\r\n}\r\n\r\n\r\n// answers certain questions about a change compared to a property list\r\n// returns an object like: {\r\n    // isWithin: _,           // true if changeIsWithinInnerProperty\r\n    // couldRelocate: _       // true if changeCouldRelocateInnerProperty or if innerProperty might be removed\r\n// }\r\nfunction changeQuestions(propertyList, change) {\r\n    var propertyListDepth = propertyList.length\r\n\r\n    var changeIsWithinInnerProperty = true // assume true until proven otherwise\r\n    var changeCouldRelocateInnerProperty = true // assume true until prove otherwise\r\n    for(var n=0; n<propertyListDepth; n++) {\r\n        if(change.property[n] !== propertyList[n]) {\r\n            changeIsWithinInnerProperty = false\r\n            if(n<change.property.length) {\r\n                changeCouldRelocateInnerProperty = false\r\n            }\r\n        }\r\n    }\r\n\r\n    if(change.property.length <= propertyListDepth) {\r\n        changeIsWithinInnerProperty = false\r\n    } else {\r\n        changeCouldRelocateInnerProperty = false\r\n    }\r\n\r\n    return {couldRelocate: changeCouldRelocateInnerProperty, isWithin: changeIsWithinInnerProperty}\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/observe/observe.js\n ** module id = 29\n ** module chunks = 0\n **/","var proto = require('proto')\r\n\r\nvar Block = require('Block')\r\nvar Style = require(\"Style\")\r\nvar Cell = require(\"./Cell\");\r\n\r\n// generates either a Header or a Row, depending on what you pass in\r\n// elementType should either be \"tr\" or \"th\r\n// name should either be \"Header\" or \"Row\r\nmodule.exports = function(elementType, name) {\r\n    return proto(Block, function(superclass) {\r\n\r\n        // static properties\r\n\r\n        this.name = name\r\n\r\n        this.defaultStyle = Style({\r\n            display: 'table-row'\r\n        })\r\n\r\n\r\n        // instance properties\r\n\r\n        this.init = function(/*[label,] rowInit*/) {\r\n            if(arguments[0] instanceof Array) {\r\n                var rowInit = arguments[0]\r\n            } else {\r\n                var label = arguments[0]\r\n                var rowInit = arguments[1]\r\n            }\r\n\r\n            this.domNode = document.createElement(elementType) // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\r\n            superclass.init.call(this) // superclass constructor\r\n            this.label = label\r\n\r\n            if(rowInit !== undefined) {\r\n                for(var n=0; n<rowInit.length; n++) {\r\n                    this.cell(rowInit[n])\r\n                }\r\n            }\r\n        }\r\n\r\n        this.cell = function(/*[label,] contents*/) {\r\n            var cell = Cell.apply(undefined, arguments);\r\n            this.add(cell);\r\n            return cell;\r\n        }\r\n    })\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/RowlikeGenerator.js\n ** module id = 30\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/build-modules/~/webpack/~/node-libs-browser/~/path-browserify/index.js\n ** module id = 31\n ** module chunks = 0\n **/","// utilities needed by the configuration (excludes dependencies the configs don't need so the webpack bundle is lean)\r\n\r\nvar path = require('path')\r\n\r\n\r\n// Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1\r\n// any number of objects can be passed into the function and will be merged into the first argument in order\r\n// returns obj1 (now mutated)\r\nvar merge = exports.merge = function(obj1, obj2/*, moreObjects...*/){\r\n    return mergeInternal(arrayify(arguments), false)\r\n}\r\n\r\n// like merge, but traverses the whole object tree\r\n// the result is undefined for objects with circular references\r\nvar deepMerge = exports.deepMerge = function(obj1, obj2/*, moreObjects...*/) {\r\n    return mergeInternal(arrayify(arguments), true)\r\n}\r\n\r\nfunction mergeInternal(objects, deep) {\r\n    var obj1 = objects[0]\r\n    var obj2 = objects[1]\r\n\r\n    for(var key in obj2){\r\n       if(Object.hasOwnProperty.call(obj2, key)) {\r\n            if(deep && obj1[key] instanceof Object && obj2[key] instanceof Object) {\r\n                mergeInternal([obj1[key], obj2[key]], true)\r\n            } else {\r\n                obj1[key] = obj2[key]\r\n            }\r\n       }\r\n    }\r\n\r\n    if(objects.length > 2) {\r\n        var newObjects = [obj1].concat(objects.slice(2))\r\n        return mergeInternal(newObjects, deep)\r\n    } else {\r\n        return obj1\r\n    }\r\n}\r\n\r\nfunction arrayify(a) {\r\n    return Array.prototype.slice.call(a, 0)\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/observe/utils.js\n ** module id = 32\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canMutationObserver = typeof window !== 'undefined'\n    && window.MutationObserver;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    var queue = [];\n\n    if (canMutationObserver) {\n        var hiddenDiv = document.createElement(\"div\");\n        var observer = new MutationObserver(function () {\n            var queueList = queue.slice();\n            queue.length = 0;\n            queueList.forEach(function (fn) {\n                fn();\n            });\n        });\n\n        observer.observe(hiddenDiv, { attributes: true });\n\n        return function nextTick(fn) {\n            if (!queue.length) {\n                hiddenDiv.setAttribute('yes', 'no');\n            }\n            queue.push(fn);\n        };\n    }\n\n    if (canPost) {\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/build-modules/~/webpack/~/node-libs-browser/~/process/browser.js\n ** module id = 33\n ** module chunks = 0\n **/"],"sourceRoot":""}