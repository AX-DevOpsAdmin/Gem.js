{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///blocks.umd.js","webpack:///webpack/bootstrap 94739a056a0c696fb684","webpack:///./blocks.browser.js","webpack:///./~/Block.js","webpack:///./~/Style.js","webpack:///./~/Components/Canvas.js","webpack:///./~/Components/Container.js","webpack:///./~/Components/Button.js","webpack:///./~/Components/CheckBox.js","webpack:///./~/Components/Image.js","webpack:///./~/Components/List.js","webpack:///./~/Components/Radio.js","webpack:///./~/Components/Select.js","webpack:///./~/Components/Table.js","webpack:///./~/Components/TextArea.js","webpack:///./~/Components/TextField.js","webpack:///./~/Components/Text.js","webpack:///./~/EventEmitterB.js","webpack:///./~/utils.js","webpack:///./~/domUtils.js","webpack:///./external/jss.js","webpack:///./~/Components/Item.js","webpack:///./~/Components/Option.js","webpack:///./~/Components/Header.js","webpack:///./~/Components/Row.js","webpack:///./~/Components/Cell.js","webpack:///../~/build-modules/~/webpack/~/node-libs-browser/~/events/events.js","webpack:///../~/proto/proto.js","webpack:///../~/trimArguments/trimArguments.js","webpack:///../~/observe/observe.js","webpack:///../~/hashmap/hashmap.js","webpack:///./~/Components/RowlikeGenerator.js","webpack:///../~/build-modules/~/webpack/~/node-libs-browser/~/path-browserify/index.js","webpack:///../~/observe/utils.js","webpack:///../~/build-modules/~/webpack/~/node-libs-browser/~/process/browser.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Block","Style","Canvas","Container","Button","CheckBox","Image","List","Radio","Select","Table","TextArea","TextField","Text","Object","defineProperty","get","dev","set","v","attach","apply","arguments","detach","createBody","propogateStyleSet","components","styleMap","n","length","undefined","_style","setCurrentStyle","styleFromMap","getStyleForComponent","mainStyle","computedStyleMap","styleMapConjunction","componentStyleMap","children","block","constructor","style","name","parent","secondaryStyleMap","primaryStyleMap","cachedStyleMap","computedStyles","utils","objectConjunction","component","currentStyle","specificStyle","setStyleClass","applyStyleKillFunction","applyStyleSetupFunction","applyStateHandler","setup","kill","Error","stateHandler","state","domNode","on","subject","className","replace","RegExp","trim","validateDefaultStyle","defaultStyle","keys","labelStyleMap","createDefaultBlockStyle","that","defaultStyles","nextConstructor","push","defaultStyleSet","reverse","forEach","k","styleDefinitions","merge","defaultBlockStyle","default","defaultStyleMap","isBlock","add","Array","EventEmitterB","proto","trimArguments","domUtils","observe","HashMap","isDev","setOfBrowserEvents","arrayToMap","superclass","init","div","build","attr","classList","defaultClassName","join","ifonHandlers","ifon","event","excludeDomEvents","addEventListener","emit","concat","prototype","slice","ifoff","removeEventListener","label","_label","addAt","index","nodes","normalizeAddAtArguments","i","node","splice","beforeChild","appendChild","insertBefore","getParentStyleMap","addBefore","addBeforeNode","indexOf","remove","removals","normalizeRemoveArguments","sort","a","b","r","removeChild","childNodes","attribute","getAttribute","attributes","setAttribute","value","removeAttribute","display","setToVisible","_displayStyle","document","activeElement","setToInFocus","focus","blur","styleObject","getSelectionRange","selection","setSelectionRange","_styleSetupStates","body","callback","dom","implementation","createDocument","createElement","documentElement","setTimeout","map","removal","parameterIndex","createTieredPseudoClasses","pseudoClassStyles","tieredPseudoClasses","key","pseudoClassList","split","emulatablePseudoClasses","nonEmulatablePseudoClasses","pseudoClass","pseudoClassParts","getPseudoClassParts","emulatedPseudoClasses","validatePurePseudoClassStyles","createPseudoClassRules","emulatablePseudoClassKey","nonEmulatablePsuedoClassKey","secondTier","pseudoclassCombinations","tieredPseudoClassesKeys","parts","keyA","j","result","combinePseudoclasses","nthChildCheck","testFn","parentNode","nthLastChildCheck","parameter","parseInt","nthChildParameterFn","match","nthChildParameter","constant","variable","cssValue","cssStyleName","cssNumber","toString","selector","pseudoClassStyle","pseudoClassCss","cssStyle","mapCamelCase","defaultJss","isStyleObject","fullPsuedoClass","x","pseudoClassRegex","class","flattenPseudoClassStyles","nonPseudoClassStyles","subpseudoClasses","subPseudoClass","substr","flattenedStyles","o","ascii","charCodeAt","asciiA","asciiZ","String","fromCharCode","difference","jssModule","baseClassName","nextClassNumber","forDocument","defaultSheet","_createSheet","jss","styleDefinition","privateOptions","inLabel","labelStyles","cssProperties","Function","jssSheet","baseStyle","mergedStyle","pseudoClasesToEmulate","preSplitPseudoClasses","pseudoClassesToEmulationInfo","newStyle","fns","info","processParameter","initializeState","pseudoClassEmulationInfo","check","changeStyleIfNecessary","longestMatchingLength","mostSpecificMatchingStyle","wrapSetupAndKill","originalSetup","emulationInfo","originalKill","labelStyle","pseudoclasses","resultKeyParts","resultValue","part","hover","querySelectorAll","startCallback","endCallback","start","end","off","checked","selected","setupState","listener","removeListener","required","observer","MutationObserver","disconnect","last-child","console","log","textContent","setupObserver","childList","nth-child","parameterCheck","checkAndCallCallbacks","addPseudoClass","column-count","fill-opacity","flex-grow","flex-shrink","font-weight","line-height","opacity","order","orphans","widows","z-index","zoom","defaultStyleValues","azimuth","border-collapse","border-spacing","caption-side","direction","elevation","empty-cells","letter-spacing","list-style-image","list-style-position","list-style-type","pitch-range","pitch","position","quotes","richness","speak-header","speak-numeral","speak-punctuation","speak","speak-rate","stress","text-align","text-indent","text-transform","voice-family","volume","white-space","word-spacing","cursor","height","width","context","getContext","toImg","toDataURL","contentArgs","text","newValue","curValue","imageSource","src","Item","listInit","ordered","type","listStyleType","item","selectSibling","button","buttons","group","values","buttonToSelect","setButtonInGroup","_selected","getRandomInt","min","max","Math","floor","random","EventEmitter","randomStart","RadioButton","val","originalSelected","radioGroup","preventDefault","keyCode","selectNext","selectPrevious","oldValue","booleanValue","previouslySelected","Option","options","option","newOption","nodesToAdd","anyWereSelected","removalIndexes","theSelectedWasRemoved","prepareForValueChange","optionValue","setSelectedQuiet","headerOrRegularRow","Prototype","args","row","Header","Row","Cell","borderSpacing","tableInit","header","password","whiteSpace","data","eventData","newText","srcElement","oldText","lastFocus","innerText","triggerIfHandlers","handlerListName","triggerIfHandlerList","normalHandlerToAllHandlerProperty","handlerList","addHandlerToList","removeFromHandlerList","removeCallbackFromList","allHandlerListName","list","ifoffHandlers","ifonAllHandlers","ifoffAllHandlers","eventName","_events","listeners","removeIfon","removeIfoff","proxy","emitter","except","handleIt","only","handler","addListener","triggerIfOn","triggerIfOff","removeAllListeners","triggerIfOffForEvents","mergeInternal","objects","deep","obj1","obj2","hasOwnProperty","newObjects","arrayify","deepMerge","objectCopy","array","iterateThroughLeafNodes","element","nodeStack","pop","nodeType","findHiddenCharacters","beforeCaretIndex","hiddenCharacters","lastCharWasWhiteSpace","elem","createAttribute","setAttributeNode","containerEl","nodeName","charIndex","range","createRange","setStart","collapse","foundStart","nextCharIndex","nodeIndex","hiddenCharactersBeforeStart","hiddenCharactersBeforeEnd","setEnd","sel","window","getSelection","removeAllRanges","addRange","isInputOrArea","rangeCount","getRangeAt","startsInElement","contains","startContainer","elementToIterateThrough","startFound","commonAncestorContainer","startContainerFound","visibleCharacterOffset","leaf","startOffset","endContainer","endOffset","selectionStart","selectionEnd","getSelectorsAndRules","sheet","rules","cssRules","results","selectorText","toDoubleColonPseudoElements","getRules","toLowerCase","swapAdjSelAttr","swapPseudoElSyntax","addRule","pseudoElementRule","addPseudoElementRule","addRuleToSheet","insertRule","doubleColonSelector","singleColonSelector","doubleColonPseudoElRegex","exec","toSingleColonPseudoElements","singleColonPseudoElRegex","singleColonForPseudoElements","submatch1","submatch2","submatch3","removeRule","rule","deleteRule","extend","dest","aggregateStyles","aggregate","declaredProperties","declared","toCamelCase","swap","lastIndex","adjSelAttrRegex","substring","setStyleProperties","properties","importantIndex","removeProperty","setProperty","str","submatch","toUpperCase","transformCamelCasedPropertyNames","oldProps","newProps","unCamelCase","Jss","doc","head","getElementsByTagName","sheets","styleSheets","getAll","_removeSheet","styleNode","rel","ownerNode","contents","RowlikeGenerator","colspan","cols","_maxListeners","isFunction","arg","isNumber","isObject","isUndefined","defaultMaxListeners","setMaxListeners","isNaN","TypeError","er","len","error","newListener","warned","trace","once","g","fired","ret","listenerCount","noop","prototypeBuilder","namePointer","EvalError","RangeError","ReferenceError","SyntaxError","URIError","normalizeErrorObject","parentIsFunction","prototypeName","ProtoObjectFactory","namedFunction","F","protoUndefined","addProperty","ErrorObject","NormalizedError","tmp","message","stack","IntermediateInheritor","factoryObject","property","getOwnPropertyDescriptor","e","fn","theArguments","count","parsePropertyList","getPropertyPointer","propertyList","current","obj","setInternal","pointer","internalObservee","union","unionizeEvents","pushInternal","getPropertyValue","originalLength","internalObservees","unionizeList","unionizeListEvents","spliceInternal","countToRemove","removed","appendInternal","arrayToAppend","spliceArgs","oldLength","afterEnd","innerObservee","propertyListDepth","innerChangeHandler","containerChangeHandler","ignorableContainerEvents","ignorableInnerEvents","change","containerChange","changedPropertyDepth","answers","changeQuestions","changeIsWithinInnerProperty","isWithin","changeCouldRelocateInnerProperty","couldRelocate","innerObserveeEvent","removeUnion","relevantIndex","removedIndexesContainsIndexOfInnerObservee","removedIndexesAreBeforeIndexOfInnerObservee","ObserveeChild","append","_observeeParent","removedIndexesAreBeforeIndexOfObserveeChild","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","other","clear","copy","multi","chain","hide","prop","enumerable","_data","hash","has","search","clone","getTime","hashes","_hmuid_","uid","func","method","elementType","rowInit","cell","process","normalizeArray","allowAboveRoot","up","last","unshift","filter","xs","f","res","splitPathRe","splitPath","filename","resolve","resolvedPath","resolvedAbsolute","path","cwd","charAt","normalize","isAbsolute","trailingSlash","paths","relative","from","to","arr","fromParts","toParts","samePartsLength","outputParts","sep","delimiter","dirname","dir","basename","ext","extname","nextTick","canSetImmediate","setImmediate","canMutationObserver","canPost","postMessage","queue","hiddenDiv","queueList","ev","source","stopPropagation","shift","title","browser","env","argv","binding","chdir"],"mappings":"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","file":"blocks.umd.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"blocks\"] = factory();\n\telse\n\t\troot[\"blocks\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"blocks\"] = factory();\n\telse\n\t\troot[\"blocks\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports.Block = __webpack_require__(1)\r\n\texports.Style = __webpack_require__(2)\r\n\t\r\n\texports.Canvas = __webpack_require__(3)\r\n\texports.Container = __webpack_require__(4)\r\n\texports.Button = __webpack_require__(5)\r\n\texports.CheckBox = __webpack_require__(6)\r\n\texports.Image = __webpack_require__(7)\r\n\texports.List = __webpack_require__(8)\r\n\t//exports.MultiSelect = require(\"Components/MultiSelect\") // not ready yet\r\n\texports.Radio = __webpack_require__(9)\r\n\texports.Select = __webpack_require__(10)\r\n\texports.Table = __webpack_require__(11)\r\n\texports.TextArea = __webpack_require__(12)\r\n\texports.TextField = __webpack_require__(13)\r\n\texports.Text = __webpack_require__(14)\r\n\t\r\n\t\r\n\t\r\n\tObject.defineProperty(exports, 'dev', {\r\n\t    get: function() {\r\n\t        return exports.Block.dev\r\n\t    }, set: function(v) {\r\n\t        exports.Block.dev = v\r\n\t    }\r\n\t})\r\n\t\r\n\texports.attach = function(/*component,component,.. or components*/) {\r\n\t    exports.Block.attach.apply(this,arguments)\r\n\t}\r\n\texports.detach = function(/*component,component,.. or components*/) {\r\n\t    exports.Block.detach.apply(this,arguments)\r\n\t}\r\n\t\r\n\texports.createBody = function(callback) {\r\n\t    exports.Block.detach.apply(this,arguments)\r\n\t}\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar EventEmitterB = __webpack_require__(15)\n\tvar proto = __webpack_require__(25);\n\tvar trimArguments = __webpack_require__(26)\n\tvar utils = __webpack_require__(16)\n\tvar domUtils = __webpack_require__(17)\n\tvar observe = __webpack_require__(27)\n\tvar HashMap = __webpack_require__(28)\n\t\n\tvar Style = __webpack_require__(2)\n\tStyle.isDev = function() {return module.exports.dev}\n\t\n\tvar defaultStyleMap = new HashMap() // maps from a proto class to its computed default style\n\tvar components = {};\n\t\n\tvar setOfBrowserEvents = utils.arrayToMap([\n\t    'abort','afterprint','animationend','animationiteration','animationstart','audioprocess','beforeprint','beforeunload',\n\t    'beginEvent','blocked','blur','cached','canplay','canplaythrough','change','chargingchange','chargingtimechange',\n\t    'checking','click','close','compassneedscalibration','complete','compositionend','compositionstart','compositionupdate','contextmenu',\n\t    'copy','cut','dblclick','decivelight','devicemotion','deviceorientation','deviceproximity','dischargingtimechange','DOMContentLoaded',\n\t    'downloading','drag','dragend','dragenter','dragleave','dragover','dragstart','drop','durationchange','emptied','ended','endEvent',\n\t    'error','focus','focusin','focusout','fullscreenchange','fullscreenerror','gamepadconnected','gamepaddisconnected','hashchange',\n\t    'input','invalid','keydown','keypress','keyup','languagechange','levelchange','load','loadeddata','loadedmetadata','loadend',\n\t    'loadstart','message','mousedown','mouseenter','mouseleave','mousemove','mouseout','mouseover','mouseup','noupdate','obsolete',\n\t    'offline','online','open','orientationchange','pagehide','pageshow','paste','pause','pointerlockchange','pointerlockerror','play',\n\t    'playing','popstate','progress','ratechange','readystatechange','repeatEvent','reset','resize','scroll','seeked','seeking','select',\n\t    'show','stalled','storage','submit','success','suspend','SVGAbort','SVGError','SVGLoad','SVGResize','SVGScroll','SVGUnload','SVGZoom',\n\t    'timeout','timeupdate','touchcancel','touchend','touchenter','touchleave','touchmove','touchstart','transitionend','unload',\n\t    'updateready','upgradeneeded','userproximity','versionchange','visibilitychange','volumechange','waiting','wheel'\n\t])\n\t\n\t// events:\n\t    // newParent - emits this when a component gets a new parent\n\t    // parentRemoved - emits this when a component is detached from its parent\n\tvar Block = module.exports = proto(EventEmitterB,function(superclass) {\n\t\n\t    // static properties\n\t\n\t    // constructor\n\t\tthis.init = function() {\n\t        var that = this\n\t\n\t        if(this.name === undefined) {\n\t            throw new Error(\"The 'name' property is required for Blocks\")\n\t        }\n\t\n\t        var defaultBlockStyle = defaultStyleMap.get(this.constructor)\n\t        if(defaultBlockStyle === undefined) {\n\t            defaultBlockStyle = createDefaultBlockStyle(this)\n\t        }\n\t\n\t        superclass.init.call(this)\n\t\n\t        this.children = []\n\t        this.state = observe({})\n\t        this.parent = undefined;\n\t\n\t\t\tif (this.id !== undefined) {\n\t\t\t\tcomponents[this.id] = this;\n\t\t\t}\n\t\n\t        if(this.domNode === undefined) {\n\t            this.domNode = domUtils.div()\n\t        }\n\t\n\t        this.build.apply(this, arguments)\n\t\n\t        //if(module.exports.dev) {\n\t            this.attr('blkName', this.name)\n\t        //}\n\t\n\t        var classList = [this.domNode.className]\n\t        if(defaultBlockStyle !== false) classList.push(defaultBlockStyle.className)\n\t        classList.push(Style.defaultClassName)\n\t        this.domNode.className = classList.join(' ') // note that the order of classes doesn't matter\n\t\n\t        // set up dom event handlers\n\t        var ifonHandlers={}\n\t        that.ifon(function(event) {\n\t            if(event in setOfBrowserEvents && (that.excludeDomEvents === undefined || !(event in that.excludeDomEvents))) {\n\t                that.domNode.addEventListener(event, ifonHandlers[event]=function() {\n\t                    that.emit.apply(that, [event].concat(Array.prototype.slice.call(arguments)))\n\t                })\n\t            }\n\t        })\n\t        that.ifoff(function(event) {\n\t            if(event in setOfBrowserEvents && (that.excludeDomEvents === undefined || !(event in that.excludeDomEvents))) {\n\t                that.domNode.removeEventListener(event,ifonHandlers[event])\n\t            }\n\t        })\n\t\t}\n\t\n\t    // sub-constructor - called by the constructor\n\t    // parameters:\n\t        // label - (Optional) A label that can be used to style a component differently.\n\t                   // Intended to be some string describing what the component is being used for.\n\t                   // Note, tho, that labels are not dynamic - changing the label won't affect styling until a new style is applied to the component)\n\t        // domNode - (Optional) A domNode to be used as the container domNode instead of the default (a div)\n\t    this.build = function(/*[label,] domNode*/) {\n\t        if(arguments.length === 1) {\n\t            this.domNode = arguments[0]\n\t        } else if(arguments.length >= 2) {\n\t            this.label = arguments[0]\n\t            this.domNode = arguments[1]\n\t        }\n\t    }\n\t\t\n\t\n\t\t// instance properties\n\t\n\t\t\n\t\tthis.domNode;\n\t    this.label;\n\t    this.excludeDomEvents;\n\t    this.children;     // a list of child components that are a part of a Block object (these are used so Styles can be propogated down to child components)\n\t\n\t\n\t    Object.defineProperty(this, 'label', {\n\t        get: function() {\n\t            return this._label\n\t        }, set: function(v) {\n\t            if(this._label === undefined) {\n\t                this._label = v\n\t\n\t                if(module.exports.dev) {\n\t                    this.attr('label', this._label)\n\t                }\n\t            } else {\n\t                throw new Error(\"A Block's label can only be set once (was already set to: \"+this._label+\")\")\n\t            }\n\t        }\n\t    })\n\t\n\t    // adds elements to the components main domNode\n\t    // arguments can be one of the following:\n\t        // component, component, component, ...\n\t        // listOfBlocks\n\t    this.add = function() {\n\t        this.addAt.apply(this, [this.domNode.children.length].concat(trimArguments(arguments)))\n\t\t}\n\t\n\t    // adds nodes at a particular index\n\t    // nodes can be one of the following:\n\t        // component, component, component, ...\n\t        // listOfBlocks\n\t    this.addAt = function(index/*, nodes...*/) {\n\t        var nodes = normalizeAddAtArguments.apply(this, arguments)\n\t\n\t        for (var i=0;i<nodes.length;i++) {\n\t\t\t\tvar node = nodes[i];\n\t            this.children.splice(index+i, 0, node)\n\t\n\t            if(!isBlock(node)) {\n\t                throw new Error(\"node is not a Block\")\n\t            }\n\t\n\t            node.parent = undefined\n\t            node.emit('parentRemoved')\n\t\n\t            var beforeChild = this.children[1+i+index]\n\t            if(beforeChild === undefined) {\n\t                this.domNode.appendChild(node.domNode)\n\t            } else {\n\t                this.domNode.insertBefore(node.domNode, beforeChild.domNode)\n\t            }\n\t\n\t            node.parent = this;\n\t            node.emit('newParent')\n\t\n\t            // apply styles\n\t            //if(itsaBlock) { // its always a component now\n\t                var that = this\n\t                node.getParentStyleMap = function() {return that.computedStyleMap}\n\t                propogateStyleSet([node], this.computedStyleMap)\n\t            //}\n\t\t\t}\n\t    }\n\t\n\t\t// add a list of nodes before a particular node\n\t    // if beforeChild is undefined, this will append the given nodes\n\t    // arguments can be one of the following:\n\t        // component, component, component, ...\n\t        // listOfBlocks\n\t    this.addBefore = this.addBeforeNode = function(beforeChild) {\n\t        var nodes = trimArguments(arguments).slice(1)\n\t        if(beforeChild === undefined) {\n\t            this.add.apply(this, nodes)\n\t        } else {\n\t            var index = this.children.indexOf(beforeChild)\n\t            this.addAt.apply(this, [index].concat(nodes))\n\t        }\n\t    }\n\t\n\t\n\t    // arguments can be one of the following:\n\t        // component, component, component, ...\n\t        // index, index, index, ... - each index is the numerical index to remove\n\t        // arrayOfComponents\n\t        // arrayOfIndexes\n\t    this.remove = function() {\n\t        var removals = normalizeRemoveArguments.apply(this, arguments)\n\t        removals = removals.sort(function(a,b) {\n\t            return b-a // reverse sort (so that removing multiple indexes doesn't mess up)\n\t        })\n\t\n\t        for(var n=0; n<removals.length; n++) {\n\t            var r = removals[n]\n\t            var c = this.children[r]\n\t\n\t            if(c === undefined) {\n\t                throw new Error(\"There is no child at index \"+r)\n\t            }\n\t\n\t            c.parent = undefined\n\t            this.children.splice(r, 1)\n\t            this.domNode.removeChild(this.domNode.childNodes[r])\n\t\n\t            c.emit('parentRemoved')\n\t        }\n\t    }\n\t\n\t    // sets or gets an attribute on the components domNode\n\t    // parameter sets:\n\t    // if one argument is passed, the attribute's value is returned (if there is no attribute, undefined is returned)\n\t    // if there are two arguments passed, the attribute is set\n\t        // if 'value' is undefined, the attribute is removed\n\t    this.attr = function(/*attribute, value OR attributeObject*/) {\n\t        if(arguments.length === 1) {\n\t            if(arguments[0] instanceof Object) {\n\t                var attributes = arguments[0]\n\t                for(var attribute in attributes) {\n\t                    domUtils.setAttribute(this.domNode, attribute, arguments[0][attribute])\n\t                }\n\t            } else {\n\t                var attribute = this.domNode.getAttribute(arguments[0])\n\t                if(attribute === null) {\n\t                    return undefined // screw null\n\t                } else {\n\t                    return attribute\n\t                }\n\t            }\n\t        } else {\n\t            var attribute = arguments[0]\n\t            if(arguments[1] !== undefined) {\n\t                var value = arguments[1]\n\t                domUtils.setAttribute(this.domNode, arguments[0], value)\n\t            } else {\n\t                this.domNode.removeAttribute(attribute)\n\t            }\n\t        }\n\t    }\n\t\n\t    Object.defineProperty(this, 'visible', {\n\t        // returns true if the element is visible\n\t        get: function() {\n\t            return this.domNode.style.display !== 'none';\n\t\n\t        // sets whether or not the element is visible\n\t        }, set: function(setToVisible) {\n\t            if(setToVisible) {\n\t                if (this._displayStyle !== undefined) {\n\t                    this.domNode.style.display = this._displayStyle // set back to its previous inline style\n\t                    this._displayStyle = undefined\n\t                } else {\n\t                    this.domNode.style.display = ''\n\t                }\n\t            } else {\n\t                if(this.domNode.style.display !== '' && this.domNode.style.display !== 'none') { // domNode has inline style\n\t                    this._displayStyle = this.domNode.style.display\n\t                }\n\t\n\t                this.domNode.style.display = 'none'\n\t            }\n\t        }\n\t    })\n\t\n\t\n\t    Object.defineProperty(this, 'focus', {\n\t        // returns true if the element is in focus\n\t        get: function() {\n\t            return document.activeElement === this.domNode\n\t\n\t        // sets whether or not the element is in focus (setting it to true gives it focus, setting it to false blurs it)\n\t        }, set: function(setToInFocus) {\n\t            if(setToInFocus) {\n\t                this.domNode.focus()\n\t            } else {\n\t                this.domNode.blur()\n\t            }\n\t        }\n\t    })\n\t\n\t    Object.defineProperty(this, 'style', {\n\t        get: function() {\n\t            return this._style\n\t\n\t        // sets the style, replacing one if one already exists\n\t        }, set: function(styleObject) {\n\t            if(styleObject === undefined) {\n\t                var styleMap = this.getParentStyleMap()\n\t                if(styleMap !== undefined) {\n\t                    setCurrentStyle(this, getStyleForComponent(styleMap, this))\n\t                } else {\n\t                    setCurrentStyle(this, undefined)\n\t                }\n\t\n\t                this.computedStyleMap = styleMap\n\t\n\t            } else {\n\t                setCurrentStyle(this, styleObject)\n\t                var specificStyle = styleObject.get(this)\n\t                if(this.getParentStyleMap() !== undefined) {\n\t                    this.computedStyleMap = styleMapConjunction(this.getParentStyleMap(), specificStyle.componentStyleMap)\n\t                } else {\n\t                    this.computedStyleMap = specificStyle.componentStyleMap\n\t                }\n\t            }\n\t\n\t            this._style = styleObject\n\t            propogateStyleSet(this.children, this.computedStyleMap) // propogate styles to children\n\t        }\n\t    })\n\t\n\t    Object.defineProperty(this, 'selectionRange', {\n\t        // returns the visible character selection range inside the element\n\t        // returns an array like [offsetStart, offsetEnd]\n\t        get: function() {\n\t            return domUtils.getSelectionRange(this.domNode)\n\t\n\t        // sets the visible character selection range\n\t        }, set: function(selection) {\n\t            domUtils.setSelectionRange(this.domNode, selection[0], selection[1])\n\t        }\n\t    })\n\t\n\t    this.attach = function() {\n\t        attach(this)\n\t    }\n\t    this.detach = function() {\n\t        detach(this)\n\t    }\n\t\n\t\n\t\t// private instance variables/functions\n\t\n\t    this.getParentStyleMap = function() {/*default returns undefined*/}  // should be set to a function that returns the computedStyleMap of the component containing this one (so Styles objects can be inherited)\n\t    this.computedStyleMap;  // a map of style objects computed from the Styles set on a given component and its parent components\n\t\n\t\tthis._style;              // the object's explicit Style object (undefined if it inherits a style)\n\t    this.currentStyle;       // the object's current Style (inherited or explicit)\n\t    this._displayStyle;      // temporariliy stores an inline display style while the element is hidden (for use when 'show' is called)\n\t    this._styleSetupStates   // place to put states for setup functions (used for css pseudoclass emulation)\n\t});\n\t\n\t\n\tmodule.exports.dev = false // set to true to enable dom element naming (so you can see boundaries of components when inspecting the dom)\n\t\n\t\n\t// appends components to the body\n\tvar attach = module.exports.attach = function(/*component,component,.. or components*/) {\n\t    if(arguments[0] instanceof Array) {\n\t        var components = arguments[0]\n\t    } else {\n\t        var components = arguments\n\t    }\n\t\n\t    if(document.body === null) throw new Error(\"Your document does not have a body.\")\n\t\n\t    for(var n=0; n<components.length; n++) {\n\t        document.body.appendChild(components[n].domNode)\n\t    }\n\t}\n\t// removes components from the body\n\tvar detach = module.exports.detach = function(/*component,component,.. or components*/) {\n\t    if(arguments[0] instanceof Array) {\n\t        var components = arguments[0]\n\t    } else {\n\t        var components = arguments\n\t    }\n\t\n\t    for(var n=0; n<components.length; n++) {\n\t        document.body.removeChild(components[n].domNode)\n\t    }\n\t}\n\t\n\t// creates a body tag (only call this if document.body is null)\n\t\n\tmodule.exports.createBody = function(callback) {\n\t    var dom = document.implementation.createDocument('http://www.w3.org/1999/xhtml', 'html', null);\n\t    var body = dom.createElement(\"body\")\n\t    dom.documentElement.appendChild(body)\n\t    setTimeout(function() {  // set timeout is needed because the body tag is only added after javascript goes back to the scheduler\n\t        callback()\n\t    },0)\n\t}\n\t\n\t\n\t\n\t\n\t// returns a list of indexes to remove from Block.remove's arguments\n\t/*private*/ var normalizeRemoveArguments = module.exports.normalizeRemoveArguments = function() {\n\t    var that = this\n\t\n\t    if(arguments[0] instanceof Array) {\n\t        var removals = arguments[0]\n\t    } else {\n\t        var removals = Array.prototype.slice.call(arguments)\n\t    }\n\t\n\t    return removals.map(function(removal, parameterIndex) {\n\t        if(isBlock(removal)) {\n\t            var index = that.children.indexOf(removal)\n\t            if(index === -1) {\n\t                throw new Error(\"The Block passed at index \"+parameterIndex+\" is not a child of this Block.\")\n\t            }\n\t            return index\n\t        } else {\n\t            return removal\n\t        }\n\t\n\t    })\n\t}\n\t\n\t// returns a list of nodes to add\n\t/*private*/ var normalizeAddAtArguments = module.exports.normalizeAddAtArguments = function() {\n\t    if(arguments.length === 2) {\n\t        if(arguments[1] instanceof Array) {\n\t            return arguments[1]\n\t        } else {\n\t            return [arguments[1]]\n\t        }\n\t    } else { // > 2\n\t        return trimArguments(arguments).slice(1)\n\t    }\n\t}\n\t\n\t\n\t// propogates a style-set change to a set of components\n\t    // styleMap should be a *copy* of a Style's componentStyleMap property (because it will be modified)\n\tfunction propogateStyleSet(components, styleMap) {\n\t    for(var n=0; n<components.length; n++) {\n\t        var c = components[n]\n\t        //if(isBlock(c)) {   //\n\t            // object inherits style if its in the styleSet and if it doesn't have an explicitly set style\n\t            if(c._style === undefined) {\n\t                if(styleMap === undefined) {\n\t                    setCurrentStyle(c, undefined)\n\t                } else {\n\t                    var styleFromMap = getStyleForComponent(styleMap, c)\n\t                    if(styleFromMap !== undefined) {\n\t                        setCurrentStyle(c, styleFromMap)\n\t                    }\n\t                }\n\t            }\n\t\n\t            // set the computed style set\n\t            var mainStyle; // the style directly given to a component, either its `style` property, or its inherited style\n\t            if(c._style !== undefined) {\n\t                mainStyle = c._style.get(c)\n\t            } else if(styleMap !== undefined) {\n\t                mainStyle = getStyleForComponent(styleMap, c)\n\t                if(mainStyle !== undefined) {\n\t                    mainStyle = mainStyle.get(c) // get the specific style (taking into account any label)\n\t                }\n\t            }\n\t\n\t            if(mainStyle !== undefined) {\n\t                if(styleMap !== undefined) {\n\t                    c.computedStyleMap = styleMapConjunction(styleMap, mainStyle.componentStyleMap)\n\t                } else {\n\t                    c.computedStyleMap = mainStyle.componentStyleMap\n\t                }\n\t            } else {\n\t                c.computedStyleMap = styleMap\n\t            }\n\t\n\t            propogateStyleSet(c.children, c.computedStyleMap)\n\t        //}\n\t    }\n\t}\n\t\n\t// gets the right style from the styleMap\n\t// takes the component's inheritance tree into account (relies on the block.constructor.parent property)\n\tfunction getStyleForComponent(styleMap, block) {\n\t    var constructor = block.constructor\n\t    while(constructor !== undefined) {\n\t        var style = styleMap[constructor.name]\n\t        if(style !== undefined) {\n\t            return style\n\t        } else {\n\t            constructor = constructor.parent\n\t        }\n\t    }\n\t}\n\t\n\t// returns the conjunction of two style maps\n\t// gets it from the computedStyles cache if its already in there\n\tfunction styleMapConjunction(secondaryStyleMap, primaryStyleMap) {\n\t    var cachedStyleMap = Style.computedStyles.get([secondaryStyleMap, primaryStyleMap])\n\t    if(cachedStyleMap === undefined) {\n\t        cachedStyleMap = utils.objectConjunction(secondaryStyleMap, primaryStyleMap)\n\t        Style.computedStyles.set([secondaryStyleMap, primaryStyleMap], cachedStyleMap)\n\t    }\n\t\n\t    return cachedStyleMap\n\t}\n\t\n\t// takes lables into account\n\tfunction setCurrentStyle(component, style) {\n\t    if(style === component.currentStyle) return; // do nothing\n\t\n\t    if(style !== undefined)\n\t        var specificStyle = style.get(component)\n\t    else\n\t        var specificStyle = style\n\t\n\t    setStyleClass(component, specificStyle)\n\t    applyStyleKillFunction(component)\n\t    component.currentStyle = specificStyle\n\t    applyStyleSetupFunction(component, specificStyle)\n\t    applyStateHandler(component, specificStyle)\n\t}\n\t\n\t// applies kill appropriately\n\tfunction applyStyleKillFunction(component) {\n\t    var currentStyle = component.currentStyle\n\t    if(currentStyle !== undefined && currentStyle.setup !== undefined) {\n\t        if(currentStyle.kill === undefined)\n\t            throw new Error('style has been unset but does not have a \"kill\" function to undo its \"setup\" function')\n\t\n\t        currentStyle.kill(component)\n\t    }\n\t}\n\t// applies setup appropriately\n\tfunction applyStyleSetupFunction(component, style) {\n\t    if(style !== undefined && style.setup !== undefined) {\n\t        style.setup(component) // call setup on the component\n\t    }\n\t}\n\t// initializes and sets up state-change handler\n\tfunction applyStateHandler(component, style) {\n\t    if(style !== undefined && style.stateHandler !== undefined) {\n\t        style.stateHandler(component.state, component.domNode.style)\n\t        component.state.on('change', function() {\n\t            style.stateHandler(component.state.subject, component.domNode.style)\n\t        })\n\t    }\n\t}\n\t\n\t// sets the style, replacing one if one already exists\n\tfunction setStyleClass(component, style) {\n\t    var currentStyle = component.currentStyle\n\t    if(currentStyle !== undefined) {\n\t        component.domNode.className = component.domNode.className.replace(new RegExp(\" ?\\\\b\"+currentStyle.className+\"\\\\b\"),'') // remove the previous css class\n\t    }\n\t    if(style !== undefined) {\n\t        component.domNode.className = style.className+' '+component.domNode.className.trim() // note that the order of classes doesn't matter\n\t    }\n\t}\n\t\n\tfunction validateDefaultStyle(defaultStyle) {\n\t    if(!(defaultStyle instanceof Style)) {\n\t        throw new Error(\"defaultStyle property must be a Style object\")\n\t    } else if(\n\t        defaultStyle.setup !== undefined || defaultStyle.kill !== undefined || defaultStyle.stateHandler !== undefined ||\n\t        Object.keys(defaultStyle.componentStyleMap).length > 0 || Object.keys(defaultStyle.labelStyleMap).length > 0 /*||\n\t        Object.keys(defaultStyle.pseudoClassStyles).length > 0*/\n\t    ) {\n\t        throw new Error(\"A Block's defaultStyle can only contain basic css stylings, no Block, label, or pseudoclass stylings, nor run/kill javascript\")\n\t    }\n\t}\n\t\n\tfunction createDefaultBlockStyle(that) {\n\t    if(that.defaultStyle !== undefined) {\n\t        validateDefaultStyle(that.defaultStyle)\n\t    }\n\t\n\t    // get list of default styles\n\t    var defaultStyles = []\n\t    var nextConstructor = that.constructor\n\t    while(nextConstructor !== undefined) {\n\t        if(nextConstructor.defaultStyle !== undefined) {\n\t            defaultStyles.push(nextConstructor.defaultStyle)\n\t        }\n\t        nextConstructor = nextConstructor.parent\n\t    }\n\t\n\t    // generate merged default style\n\t    var defaultStyleSet = {}\n\t    defaultStyles.reverse().forEach(function(style) {\n\t        for(var k in style.styleDefinitions) {\n\t            utils.merge(defaultStyleSet, style.styleDefinitions[k])\n\t            break; // just do first key (shouldn't be more than one key, because only simple stylings are allowed for default styles)\n\t        }\n\t\n\t    })\n\t\n\t    if(Object.keys(defaultStyleSet).length > 0)\n\t        var defaultBlockStyle = Style(defaultStyleSet, {default:true})\n\t    else\n\t        var defaultBlockStyle = false // no special default\n\t\n\t    defaultStyleMap.set(that.constructor, defaultBlockStyle)\n\t    return defaultBlockStyle\n\t}\n\t\n\tfunction isBlock(c) {\n\t    return c.add !== undefined && c.children instanceof Array && c.domNode !== undefined\n\t}\n\tfunction isDomNode(node) {\n\t    return node.nodeName !== undefined\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar jssModule = __webpack_require__(18)\n\tvar proto = __webpack_require__(25)\n\tvar HashMap = __webpack_require__(28) // .HashMap // weirdly, it looks like this is being treated like an AMD module\n\t\n\tvar utils = __webpack_require__(16)\n\t\n\tvar baseClassName = '_ComponentStyle_' // the base name for generated class names\n\tvar nextClassNumber = 0\n\t\n\tvar defaultJss = jssModule.forDocument(document) // must be created before the jss object (so that the styles there override the styles in the default sheet)\n\tdefaultJss.defaultSheet = defaultJss._createSheet() // create its sheet first (before the regular jss sheet)\n\tvar jss = jssModule.forDocument(document)\n\tjss.defaultSheet = jss._createSheet()\n\t\n\t// creates a style object\n\tvar Style = module.exports = proto(function() {\n\t\n\t    this.defaultClassName = '_default_'     // the name of the default class (used to prevent style inheritance)\n\t\n\t    // styleDefinition is an object where key-value pairs can be any of the following:\n\t    // <cssPropertyName>: the value should be a valid css value for that style attribute\n\t    // <ComponentName>: the value can either be a Style object or a nested styleDefinition object\n\t    // $setup: the value is a function to be run on a component when the style is applied to it\n\t    // $kill: the value is a function to be run on a component when a style is removed from it\n\t    // $state: the value should be a state handler function\n\t    // $<label>: the value should be a nested styleDefinition object that does not contain any label styles.\n\t    this.init = function(styleDefinition, privateOptions) {\n\t        if(privateOptions === undefined) privateOptions = {}\n\t        if(privateOptions.inLabel===undefined) inLabel = false\n\t\n\t        this.className = baseClassName+nextClassNumber\n\t        nextClassNumber++\n\t\n\t        this.componentStyleMap = {}\n\t        this.labelStyleMap = {}\n\t\n\t        var labelStyles = {}\n\t        var pseudoClassStyles = {}\n\t        var cssProperties = {}\n\t        for(var key in styleDefinition) {\n\t            var value = styleDefinition[key]\n\t\n\t            if(key === '$setup') {\n\t                if(!(value instanceof Function)) throw new Error(\"$setup key must be a function ('setup' can't be used as a label)\")\n\t                this.setup = value\n\t\n\t            } else if(key === '$kill') {\n\t                if(!(value instanceof Function)) throw new Error(\"$kill key must be a function ('kill' can't be used as a label)\")\n\t                this.kill = value\n\t\n\t            } else if(key === '$state') {\n\t                if(!(value instanceof Function)) throw new Error(\"$state key must be a function ('$state' can't be used as a label)\")\n\t                this.stateHandler = value\n\t\n\t            } else if(key.indexOf('$$') === 0) { // pseudo-class style\n\t                var pseudoClass = mapCamelCase(key.substr(2))\n\t                if(pseudoClass === '') {\n\t                    throw new Error(\"Empty pseudo-class name not valid (style key '$$')\")\n\t                }\n\t\n\t                utils.merge(pseudoClassStyles, flattenPseudoClassStyles(pseudoClass, value))\n\t\n\t            } else if(key.indexOf('$') === 0) {   // label style\n\t                if(privateOptions.inLabel)\n\t                    throw new Error(\"Can't create nested label style \"+key+\" because components can only have one label\")\n\t\n\t                var label = key.substr(1)\n\t                if(label === '') {\n\t                    throw new Error(\"Empty label name not valid (style key '$')\")\n\t                }\n\t\n\t                labelStyles[label] = value\n\t\n\t            } else if(isStyleObject(value)) {\n\t                this.componentStyleMap[key] = value\n\t\n\t            } else if(value instanceof Object) {\n\t                this.componentStyleMap[key] = Style(value)  // turn the object description into a full fledged style object\n\t            } else {\n\t                var cssStyle = key\n\t                var cssStyleName = mapCamelCase(cssStyle)\n\t                cssProperties[cssStyleName] = cssValue(cssStyleName, value)\n\t            }\n\t        }\n\t\n\t        // create the css class\n\t        if(privateOptions.default) {\n\t            var jssSheet = defaultJss\n\t        } else {\n\t            var jssSheet = jss\n\t        }\n\t\n\t        jssSheet.set('.'+this.className, cssProperties)\n\t\n\t        //if(module.exports.isDev) {\n\t            this.styleDefinitions = {}\n\t            this.styleDefinitions['.'+this.className] = cssProperties\n\t        //}\n\t\n\t        // create label styles\n\t        if(Object.keys(labelStyles).length > 0) {\n\t            var baseStyle = utils.merge({}, cssProperties, this.componentStyleMap)\n\t\n\t            for(var label in labelStyles) {\n\t                if(isStyleObject(labelStyles[label])) {\n\t                    this.labelStyleMap[label] = labelStyles[label]\n\t                } else {\n\t                    var mergedStyle = utils.merge({}, baseStyle, labelStyles[label])\n\t                    this.labelStyleMap[label] = Style(mergedStyle, {inLabel:true})\n\t                }\n\t            }\n\t        }\n\t\n\t        // create pseudoclass styles\n\t        if(Object.keys(pseudoClassStyles).length > 0) {\n\t\n\t            var tieredPseudoClasses = createTieredPseudoClasses(this, pseudoClassStyles)\n\t            pseudoclassCombinations(tieredPseudoClasses) // mutates tieredPseudoClasses\n\t\n\t            // turn the emulatable pseudo classes into Style objects\n\t            // also build up the set of psuedoclasses that will be emulated\n\t            // also build up a map of pseudoclasses-to-emulate to the emulation functions for those pseudoclasses\n\t            var pseudoClasesToEmulate = []\n\t            var preSplitPseudoClasses = [] // a list where each element looks like: [pseudoClassList, styleObject]  (this is primarily for performance - so we don't have to split the key every time we check for state changes)\n\t            var pseudoClassesToEmulationInfo = {}\n\t            for(var key in tieredPseudoClasses) {\n\t                if(isStyleObject(tieredPseudoClasses[key])) {\n\t                    tieredPseudoClasses[key] = tieredPseudoClasses[key]\n\t                } else {\n\t                    var newStyle = Style(utils.merge({}, cssProperties, tieredPseudoClasses[key])) // pseudoClassStyles merged with parent css styles\n\t\n\t                    // merge in componentStyleMap and labelStyleMap\n\t                    for(var k in this.componentStyleMap) {\n\t                        if(newStyle.componentStyleMap[k] === undefined)\n\t                            newStyle.componentStyleMap[k] = this.componentStyleMap[k]\n\t                    }\n\t                    for(var k in this.labelStyleMap) {\n\t                        if(newStyle.labelStyleMap[k] === undefined)\n\t                            newStyle.labelStyleMap[k] = this.labelStyleMap[k]\n\t                    }\n\t\n\t                    tieredPseudoClasses[key] = newStyle\n\t                }\n\t\n\t\n\t                var pseudoClassList = key.split(\":\")\n\t                for(var n=0; n<pseudoClassList.length; n++) {\n\t                    var pseudoClass = pseudoClassList[n]\n\t                    if(pseudoClasesToEmulate.indexOf(pseudoClass) === -1) {\n\t                        pseudoClasesToEmulate.push(pseudoClass)\n\t\n\t                        var pseudoClassParts = getPseudoClassParts(pseudoClass)\n\t                        var fns = emulatedPseudoClasses[pseudoClassParts.class]\n\t                        var info = {fns: fns}\n\t                        if(fns.processParameter !== undefined) {\n\t                            info.parameter = fns.processParameter(pseudoClassParts.parameter)\n\t                        }\n\t                        pseudoClassesToEmulationInfo[pseudoClass] = info\n\t                    }\n\t                }\n\t\n\t                preSplitPseudoClasses.push([pseudoClassList, tieredPseudoClasses[key]])\n\t            }\n\t\n\t            // create functions that initialize and keep track of state\n\t            var initializeState = function(component) {\n\t                var state = {}\n\t                for(var n=0; n<pseudoClasesToEmulate.length; n++) {\n\t                    var pseudoClass = pseudoClasesToEmulate[n]\n\t                    var pseudoClassEmulationInfo = pseudoClassesToEmulationInfo[pseudoClass]\n\t                    state[pseudoClass] = pseudoClassEmulationInfo.fns.check(component, pseudoClassEmulationInfo.parameter)\n\t                }\n\t\n\t                return state\n\t            }\n\t\n\t            var that = this\n\t            var changeStyleIfNecessary = function(currentStyle, component, state) {\n\t                var longestMatchingLength = 0;\n\t                var mostSpecificMatchingStyle = that; // if nothing else matches, change back to the base style object\n\t                for(var n=0; n<preSplitPseudoClasses.length; n++) {\n\t                    var pseudoClassList = preSplitPseudoClasses[n][0]\n\t                    for(var j=0; j<pseudoClassList.length; j++) {\n\t                        if(!state[pseudoClassList[j]]) {\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    if(j === pseudoClassList.length && j > longestMatchingLength) {\n\t                        longestMatchingLength = j\n\t                        mostSpecificMatchingStyle = preSplitPseudoClasses[n][1]\n\t                    }\n\t                }\n\t\n\t                if(mostSpecificMatchingStyle !== currentStyle) {\n\t                    component.style = mostSpecificMatchingStyle\n\t                }\n\t            }\n\t\n\t            // setup pseudoclass emulation with $setup and $kill handlers\n\t\n\t            var wrapSetupAndKill = function(style) {\n\t                var originalSetup = style.setup\n\t                style.setup = function(component) {\n\t                    var that = this\n\t\n\t                    this._styleSetupStates = {} // maps pseudoClass to setupState\n\t                    var state = initializeState(component)\n\t                    for(var pseudoClass in pseudoClassesToEmulationInfo) {\n\t                        ;(function(pseudoClass, emulationInfo){   // close over those variables (so they keep the value they had when the function was setup)\n\t                            that._styleSetupStates[pseudoClass] = emulationInfo.fns.setup(component, function() { // start\n\t                                state[pseudoClass] = true\n\t                                changeStyleIfNecessary(that, component, state)\n\t                            }, function() { // end\n\t                                state[pseudoClass] = false\n\t                                changeStyleIfNecessary(that, component, state)\n\t                            }, emulationInfo.parameter)\n\t\n\t                        })(pseudoClass, pseudoClassesToEmulationInfo[pseudoClass])\n\t                    }\n\t\n\t                    changeStyleIfNecessary(that, component, state)\n\t\n\t                    if(originalSetup !== undefined) {\n\t                        originalSetup.apply(this, arguments)\n\t                    }\n\t                }\n\t\n\t                var originalKill = style.kill\n\t                style.kill = function(component) {\n\t                    for(var pseudoClass in pseudoClassesToEmulationInfo) {\n\t                        var emulationInfo = pseudoClassesToEmulationInfo[pseudoClass]\n\t                        emulationInfo.fns.kill(component, this._styleSetupStates[pseudoClass])\n\t                    }\n\t\n\t                    if(originalKill !== undefined) {\n\t                        originalKill.apply(this, arguments)\n\t                    }\n\t                }\n\t            }\n\t\n\t            // wrap all the setup and kill functions\n\t\n\t            for(var key in tieredPseudoClasses) {\n\t                var style = tieredPseudoClasses[key]\n\t                wrapSetupAndKill(style)\n\t            }\n\t\n\t            wrapSetupAndKill(this)\n\t        }\n\t    }\n\t\n\t    // instance properties\n\t\n\t    this.className          // the css classname for this style\n\t    this.componentStyleMap; // maps a Component name to a Style object for that component\n\t    this.labelStyleMap;     // maps a label name to a Style object for that label\n\t    this.setup;             // run some javascript on any element this class is applied to\n\t    this.kill;              // a function to run on removal of the style (should reverse setup)\n\t\n\t    // gets the style object for a component based on the current style object (takes into account whether the component has a label\n\t    this.get = function(component) {\n\t        if(component.label !== undefined) {\n\t            var labelStyle = this.labelStyleMap[component.label]\n\t            if(labelStyle !==  undefined) {\n\t                return labelStyle\n\t            }\n\t        }\n\t        // else\n\t        return this\n\t    }\n\t})\n\t\n\t\n\t// private\n\t\n\t\n\t// returns a two-level map where the top-level keys are emulatable psuedo classes, and non-emulatable pseudo classes are at the second level\n\t// the classes will also be sorted and deduped\n\t// Example return value: {\"hover:lastChild\": {color:'red', \"$$visited:disabled\": {fontWeight: 'bold'}}, }\n\t// parameters:\n\t    // style - the style object being created\n\t    // pseudoClassStyles - a flat object where each key is a list of pseudoclasses separated by colons (e.g. \"hover\" or \"hover:focus\") and the value is an object of styles that don't contain pseudoclasses\n\tfunction createTieredPseudoClasses(style, pseudoClassStyles) {\n\t    var tieredPseudoClasses = {} // the two-level map\n\t    for(var key in pseudoClassStyles) {\n\t        var value = pseudoClassStyles[key]\n\t\n\t        // split key into pseudoclass list\n\t        var pseudoClassList = key.split(\":\")\n\t        var emulatablePseudoClasses = []\n\t        var nonEmulatablePseudoClasses = []\n\t        for(var n in pseudoClassList) {\n\t            var pseudoClass = pseudoClassList[n]\n\t            var pseudoClassParts = getPseudoClassParts(pseudoClass)\n\t            if(pseudoClassParts.class in emulatedPseudoClasses) {\n\t                emulatablePseudoClasses.push(pseudoClass)\n\t            } else {\n\t                nonEmulatablePseudoClasses.push(pseudoClass)\n\t            }\n\t        }\n\t\n\t        if(emulatablePseudoClasses.length === 0) { // if none of the pseudoclasses can be emulated using javascript\n\t            validatePurePseudoClassStyles(key, value)                        // then validate the value and\n\t            createPseudoClassRules(style, key, '.'+style.className+\":\"+key, value)   // create pseudoClassRules\n\t\n\t        } else { // if some of the pseudoclasses can be emulated using javascript\n\t\n\t            emulatablePseudoClasses.sort()\n\t            var emulatablePseudoClassKey = emulatablePseudoClasses.join(':')\n\t            if(tieredPseudoClasses[emulatablePseudoClassKey] === undefined)\n\t                tieredPseudoClasses[emulatablePseudoClassKey] = {}\n\t\n\t            if(nonEmulatablePseudoClasses.length === 0) {\n\t                utils.merge(tieredPseudoClasses[emulatablePseudoClassKey], value)\n\t            } else {\n\t                nonEmulatablePseudoClasses.sort()\n\t                var nonEmulatablePsuedoClassKey = nonEmulatablePseudoClasses.join(':')\n\t\n\t                var secondTier = {}\n\t                secondTier['$$'+nonEmulatablePsuedoClassKey] = value\n\t\n\t                utils.merge(tieredPseudoClasses[emulatablePseudoClassKey], secondTier)\n\t            }\n\t        }\n\t    }\n\t\n\t    return tieredPseudoClasses\n\t}\n\t\n\t\n\t\n\t// make combinations of the emulatable pseudoclasses, so that they combine like the non-emulated ones do\n\t// info about mathematical combination: https://en.wikipedia.org/wiki/Combination\n\t// mutates tieredPseudoClasses\n\tfunction pseudoclassCombinations(tieredPseudoClasses) {\n\t    var tieredPseudoClassesKeys = Object.keys(tieredPseudoClasses).reverse().map(function(v) {    // reverse first so that more specific pseudoclasses go first\n\t        return {key: v, parts: v.split(':')} // so it doesn't have to split every time\n\t    })\n\t\n\t    for(var n=0; n<tieredPseudoClassesKeys.length; n++) {\n\t        var keyA = tieredPseudoClassesKeys[n]\n\t        for(var k=2; k <= tieredPseudoClassesKeys.length; k++) { // k is the number of psuedoclasses to combine\n\t            for(var j=n+1; j<tieredPseudoClassesKeys.length-(k-2); j++) {\n\t                var result = combinePseudoclasses(tieredPseudoClasses, [keyA].concat(tieredPseudoClassesKeys.slice(j, k)))\n\t                if(result.key in tieredPseudoClasses) {\n\t                    utils.merge(tieredPseudoClasses[result.key], result.value)\n\t                } else { // new key\n\t                    tieredPseudoClasses[result.key] = result.value\n\t                }\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\t\n\t\n\t// keys is a list of objects where each object has the members:\n\t    // key - the original string key\n\t    // parts - the key split by \":\"\n\t// returns an object with the following members:\n\t    // key - the new combined key\n\t    // value - the new merged value\n\tvar combinePseudoclasses = function(pseudoclasses, keys) {\n\t    var resultKeyParts = keys[0].parts\n\t    var resultValue = utils.merge({}, pseudoclasses[keys[0].key]) // make a copy\n\t    for(var n=1; n<keys.length; n++) {\n\t        var key = keys[n]\n\t        // merge all psuedoclasses that don't already exist into the resultKey\n\t        for(var j=0; j<key.parts.length; j++) {\n\t            var part = key.parts[j]\n\t            if(resultKeyParts.indexOf(part) === -1) {\n\t                resultKeyParts.push(part)\n\t            }\n\t        }\n\t\n\t        // merge the value into resultValue\n\t        utils.merge(resultValue, pseudoclasses[key.key])\n\t    }\n\t\n\t    return {key: resultKeyParts.join(':'), value: resultValue}\n\t}\n\t\n\t// a map of pseudoclass names and how they are emulated with javascript\n\t// each pseudoclass sets up the following functions:\n\t    // check - a function that checks if that pseudoclass currently applies to the component when its called\n\t    // setup - calls a callback when the pseudoClass starts and stops applying\n\t        // should return an object that will be passed to the kill function (as its 'state' parameter)\n\t    // kill - cleans up anything set up in the 'setup' function\n\t    // processParameter - takes the pseudoclass parameter and returns some object representing it that will be used by the setup and check functions\n\tvar emulatedPseudoClasses = {\n\t    hover: {\n\t        check: function(component) {\n\t            var nodes = document.querySelectorAll( \":hover\" )\n\t            for(var n=0; n<nodes.length; n++) {\n\t                if(nodes[n] === component.domNode) {\n\t                    return true\n\t                }\n\t            }\n\t            return false\n\t        },\n\t        setup: function(component, startCallback, endCallback) {\n\t            component.on(\"mouseover\", function() {\n\t                startCallback()\n\t            })\n\t            component.on(\"mouseout\", endCallback)\n\t\n\t            return {start: startCallback, end: endCallback}\n\t        },\n\t        kill: function(component, state) {\n\t            component.off(\"mouseover\", state.start)\n\t            component.off(\"mouseout\", state.end)\n\t        }\n\t    },\n\t    checked: {\n\t        check: function(component) {\n\t            return component.selected\n\t        },\n\t        setup: function(component, startCallback, endCallback) {\n\t            var setupState = {}\n\t            component.on(\"change\", setupState.listener = function() {\n\t                if(component.selected) {\n\t                    startCallback()\n\t                } else {\n\t                    endCallback()\n\t                }\n\t            })\n\t\n\t            return setupState\n\t        },\n\t        kill: function(component, state) {\n\t            component.removeListener(\"change\", state.listener)\n\t        }\n\t    },\n\t    required: {\n\t        check: function(component) {\n\t            return component.attr('required') !== undefined\n\t        },\n\t        setup: function(component, startCallback, endCallback) {\n\t            var observer = new MutationObserver(function() {\n\t                if(component.attr('required') !== undefined) {\n\t                    startCallback()\n\t                } else {\n\t                    endCallback()\n\t                }\n\t            })\n\t\n\t            observer.observe(component.domNode, {attributes: true})\n\t\n\t            return {observer: observer}\n\t        },\n\t        kill: function(component, state) {\n\t            state.observer.disconnect()\n\t        }\n\t    },\n\t    'last-child': {\n\t        check: function(component) {\n\t            console.log(\"Checking: \"+component.domNode.textContent+\" and its \"+nthLastChildCheck(component, '1'))\n\t            return nthLastChildCheck(component, '1')\n\t        },\n\t        setup: function(component, startCallback, endCallback) {\n\t            console.log(\"Setup: \"+component.domNode.textContent)\n\t\n\t            var observer = new MutationObserver(function() {\n\t                if(nthLastChildCheck(component, '1')) {\n\t                    startCallback()\n\t                } else {\n\t                    endCallback()\n\t                }\n\t            })\n\t\n\t            var setupObserver = function() {\n\t                // note that since this uses the component parent rather than domNode.parentNode, this won't work for components added to non-component nodes (and there's no good way to do it, because you would have to poll for parent changes)\n\t                observer.observe(component.parent.domNode, {childList: true})\n\t            }\n\t\n\t            if(component.parent !== undefined) {\n\t                setupObserver()\n\t            }\n\t\n\t            component.on('newParent', function() {\n\t                setupObserver()\n\t            })\n\t            component.on('parentRemoved', function() {\n\t                observer.disconnect()\n\t            })\n\t\n\t            return {observer: observer}\n\t        },\n\t        kill: function(component, state) {\n\t            console.log(\"Kill: \"+component.domNode.textContent)\n\t            state.observer.disconnect()\n\t        }\n\t    },\n\t    'nth-child': {\n\t        // todo: support full an+b parameters for nth-child https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-child\n\t        check: function(component, parameterCheck) {\n\t            return nthChildCheck(component, parameterCheck)\n\t        },\n\t        setup: function(component, startCallback, endCallback, parameterCheck) {\n\t\n\t            var checkAndCallCallbacks = function() {\n\t                if(nthChildCheck(component, parameterCheck)) {\n\t                    startCallback()\n\t                } else {\n\t                    endCallback()\n\t                }\n\t            }\n\t\n\t            var observer = new MutationObserver(function() {\n\t                checkAndCallCallbacks()\n\t            })\n\t\n\t            var setupObserver = function() {\n\t                // note that since this uses the component parent rather than domNode.parentNode, this won't work for components added to non-component nodes (and there's no good way to do it, because you would have to poll for parent changes)\n\t                observer.observe(component.parent.domNode, {childList: true})\n\t            }\n\t\n\t            if(component.parent !== undefined) {\n\t                setupObserver()\n\t            }\n\t\n\t            component.on('newParent', function() {\n\t                setupObserver()\n\t                checkAndCallCallbacks()\n\t            })\n\t            component.on('parentRemoved', function() {\n\t                observer.disconnect()\n\t                checkAndCallCallbacks()\n\t            })\n\t\n\t            return {observer: observer}\n\t        },\n\t        kill: function(component, state) {\n\t            state.observer.disconnect()\n\t        },\n\t        processParameter: function(parameter) {\n\t            return nthChildParameterFn(parameter)\n\t        }\n\t    },\n\t\n\t    // not's parameter is a statement consisting of pseudoclasses separated either by & or ,\n\t    // $$not(pseudoclass1&pseudoclass2,psuedoclass3) translates to the css :not(:pseudoclass1:pseudoclass2,:psuedoclass3)\n\t    /*not: {\n\t        check: function() {\n\t\n\t        },\n\t    }*/\n\t}\n\t\n\t// name is the name of the new pseudoclass\n\t// fns is an object with the members:\n\t    // check(component) - returns true if the pseudoclass applies to the component\n\t    // setup(component, startCallback, endCallback, parameter) - a function that should call startCallback when the pseudoclass starts applying, and endCallback when it stops applying\n\t        // parameter - the parameter passed to the pseudoclass (e.g. in :not(:first-child), \":first-child\" is the parameter)\n\t    // kill - a function that cleans up any event listeners or anything else set up in the 'setup' function\n\tmodule.exports.addPseudoClass = function(name, fns) {\n\t    if(emulatedPseudoClasses[name] !== undefined) throw new Error(\"The pseudoclass '\"+name+\"' is already defined.\")\n\t    // else\n\t    emulatedPseudoClasses[name] = fns\n\t}\n\t\n\t\n\tfunction nthChildCheck(component, testFn) {\n\t    if(component.domNode.parentNode === null)\n\t        return false\n\t\n\t    var children = component.domNode.parentNode.children                    // must be domNode.parentNode, because child nodes may not be Components\n\t    var index = Array.prototype.indexOf.call(children, component.domNode)\n\t    return testFn(index)\n\t}\n\t\n\tfunction nthLastChildCheck(component, parameter) {\n\t    if(component.domNode.parentNode === null)\n\t        return false\n\t\n\t    var children = component.domNode.parentNode.children                    // must be domNode.parentNode, because child nodes may not be Components\n\t    var index = children.length - parseInt(parameter)\n\t    return children[index] === component.domNode\n\t}\n\t\n\t// returns a function that takes an index and tell you if that index applies to the nthChildParameter\n\tvar nthChildParameter = /^(((-?\\d*)(([+-]\\d*)n?)?)|((-?\\d)*n?([+-]\\d*)?))$/\n\tfunction nthChildParameterFn(parameter) {\n\t    var parts = parameter.match(nthChildParameter)\n\t    if(parts === null)\n\t        throw new Error(\"nth-child parameter '\"+parameter+\"' isn't valid\")\n\t\n\t    if(parts[2] !== undefined) {\n\t        var constant = parts[3]\n\t        var variable = parts[5]\n\t    } else {\n\t        var constant = parts[8]\n\t        var variable = parts[7]\n\t    }\n\t\n\t    if(constant === undefined) constant = 0\n\t    else                       constant = parseInt(constant)\n\t    if(variable === undefined) variable = 0\n\t    else                       variable = parseInt(variable)\n\t\n\t    if(variable === 0) {\n\t        return function(index) {\n\t            return index+1 === constant\n\t        }\n\t    } else {\n\t        return function(index) {\n\t            return ((index+1-constant)/variable) % 1 === 0\n\t        }\n\t    }\n\t\n\t}\n\t\n\t// maps a style value to a css value\n\t// style values that are numbers are mapped to strings, usually with px postfix\n\tfunction cssValue(cssStyleName, value) {\n\t    // If a number was passed in, add 'px' to the (except for certain CSS properties) [also taken from jquery's code]\n\t    if(typeof(value) === \"number\" && cssNumber[cssStyleName] === undefined) {\n\t        return value+\"px\"\n\t    } else {\n\t        return value.toString()\n\t    }\n\t}\n\t\n\tfunction createPseudoClassRules(that, pseudoClass, selector, pseudoClassStyle) {\n\t\n\t    var pseudoClassCss = {}\n\t    for(var key in pseudoClassStyle) {\n\t        var value = pseudoClassStyle[key]\n\t\n\t        if(!(value instanceof Object)) {\n\t            var cssStyle = key\n\t            var cssStyleName = mapCamelCase(cssStyle)\n\t            pseudoClassCss[cssStyleName] = cssValue(cssStyleName, value)\n\t        } else {\n\t            throw new Error(\"All properties within the pseudoclasses '\"+pseudoClass+\"' must be css styles\")\n\t        }\n\t    }\n\t\n\t    // create immediate pseudo class style\n\t    defaultJss.set(selector, pseudoClassCss) // create the css class with the pseudoClass\n\t\n\t    //if(module.exports.isDev) {\n\t        that.styleDefinitions = {}\n\t        that.styleDefinitions[selector] = pseudoClassCss\n\t    //}\n\t}\n\t\n\t// throws exceptions for various style configurations that are unsupported by pure pseudo classes (ones that can't be emulated usuing javascript)\n\tfunction validatePurePseudoClassStyles(pseudoClass, pseudoClassStyles) {\n\t    for(var key in pseudoClassStyles) {\n\t        var value = pseudoClassStyles[key]\n\t\n\t        if(isStyleObject(value)) {\n\t            throw new Error(\"Can't set the pseudoclasses '\"+pseudoClass+\"' to a Style object\")\n\t        } else if(key === '$setup') {\n\t            throw new Error(\"$setup can't be used within the pseudoclasses '\"+pseudoClass+\"'\")\n\t        } else if(key === '$kill') {\n\t            throw new Error(\"$kill can't be used within the pseudoclasses '\"+pseudoClass+\"'\")\n\t        } else if(key.indexOf('$') === 0) {   // label style\n\t            throw new Error(\"Block labels can't be used within the pseudoclasses '\"+pseudoClass+\"'\")\n\t        }\n\t    }\n\t}\n\t\n\t// e.g. pulls out 'nth-child' and '2+3n' from 'nth-child(2+3n)'\n\tvar pseudoClassRegex = /^([^(]*)(\\((.*)\\))?$/\n\tfunction getPseudoClassParts(fullPsuedoClass) {\n\t    var x = fullPsuedoClass.match(pseudoClassRegex)\n\t    if(x === null) throw new Error(\"Pseudoclass '\"+fullPsuedoClass+\"' is invalid\")\n\t    return {class: x[1], parameter: x[3]}\n\t}\n\t\n\t\n\t// takes in a list of pseudoClassRules and changes any nesting like {hover: {focus: {}}} into something like {hover: {}, \"hover:focus\": {}}\n\t// also does some validation\n\tfunction flattenPseudoClassStyles(pseudoClass, pseudoClassStyle) {\n\t    var nonPseudoClassStyles = {}\n\t    var subpseudoClasses = {}\n\t    for(var key in pseudoClassStyle) {\n\t        var value = pseudoClassStyle[key]\n\t\n\t        if(key.indexOf('$$') === 0) { // pseudo-class style\n\t            var subPseudoClass = key.substr(2)\n\t            if(subPseudoClass === '') {\n\t                throw new Error(\"Empty pseudo-class name not valid (style key '$$')\")\n\t            }\n\t\n\t            subpseudoClasses[subPseudoClass] = value\n\t        } else {\n\t            nonPseudoClassStyles[key] = value\n\t        }\n\t    }\n\t\n\t    // create flattened styles (with merged in styles from its parent pseudoclass\n\t    var flattenedStyles = {}\n\t    for(var subPseudoClass in subpseudoClasses) {\n\t        var value = subpseudoClasses[subPseudoClass]\n\t\n\t        if(isStyleObject(value)) {\n\t            flattenedStyles[pseudoClass+\":\"+subPseudoClass] =  value\n\t        } else {\n\t            utils.merge(flattenedStyles, flattenPseudoClassStyles(pseudoClass+\":\"+subPseudoClass, utils.merge({}, nonPseudoClassStyles, value)))\n\t        }\n\t    }\n\t\n\t    // write the top-level pseudoClass\n\t    flattenedStyles[pseudoClass] = nonPseudoClassStyles\n\t\n\t    return flattenedStyles\n\t}\n\t\n\t\n\t// taken from jquery's code\n\tvar cssNumber = {\n\t    \"column-count\": 1,\n\t    \"fill-opacity\": 1,\n\t    \"flex-grow\": 1,\n\t    \"flex-shrink\": 1,\n\t    \"font-weight\": 1,\n\t    \"line-height\": 1,\n\t    \"opacity\": 1,\n\t    \"order\": 1,\n\t    \"orphans\": 1,\n\t    \"widows\": 1,\n\t    \"z-index\": 1,\n\t    \"zoom\": 1\n\t}\n\t\n\tfunction isStyleObject(o) {\n\t    return o.componentStyleMap !== undefined\n\t}\n\t\n\t\n\tvar asciiA = 'A'.charCodeAt(0), asciiZ = 'Z'.charCodeAt(0), difference = 'a'.charCodeAt(0) - asciiA\n\tfunction mapCamelCase(cssStyleName) {\n\t    for(var n=0; n<cssStyleName.length; n++) {\n\t        var ascii = cssStyleName.charCodeAt(n)\n\t        if(asciiA <= ascii && ascii <= asciiZ) { // found capital letter\n\t            cssStyleName = cssStyleName.slice(0, n) + '-'+String.fromCharCode(ascii+difference) + cssStyleName.slice(n+1)\n\t            n++ // increment a second time for the dash\n\t        }\n\t    }\n\t\n\t    return cssStyleName\n\t}\n\t\n\t// maps all the styles that are inherited by descendant nodes to their default values\n\t// source: http://stackoverflow.com/questions/5612302/which-css-styles-are-inherited\n\tvar defaultStyleValues = {\n\t    'azimuth': 'center',\n\t    'border-collapse': 'separate',\n\t    'border-spacing': '0',\n\t    'caption-side': 'top',\n\t    //'color': 'black',         // let this inherit\n\t    //'cursor': 'auto',         // let this one inherit - its weird otherwise\n\t    'direction': 'ltr',\n\t     display: 'inline-block', // changes the default display to inline-block\n\t    'elevation': '',\n\t    'empty-cells': 'show',\n\t    // 'font-family': '',       // let this inherit\n\t    // 'font-size': 'medium',   // let this inherit\n\t    //'font-style': 'normal',   // let this inherit\n\t    //'font-variant': 'normal', // let this inherit\n\t    //'font-weight': 'normal',  // let this inherit\n\t    'letter-spacing': 'normal',\n\t    'line-height': 'normal',\n\t    'list-style-image': 'none',\n\t    'list-style-position': 'outside',\n\t    'list-style-type': 'disc',\n\t    'orphans': '2',\n\t    'pitch-range': '',\n\t    'pitch': '',\n\t     position: 'relative', // changes the default positioning so that absolute is relative to its parent by default\n\t    'quotes': '',\n\t    'richness': '',\n\t    'speak-header': '',\n\t    'speak-numeral': '',\n\t    'speak-punctuation': '',\n\t    'speak': '',\n\t    'speak-rate': '',\n\t    'stress': '',\n\t    'text-align': 'left',\n\t    'text-indent': '0',\n\t    'text-transform': 'none',\n\t    //'visibility': 'visible',    // let this inherit - otherwise you just hide the container and not the contents\n\t    'voice-family': '',\n\t    'volume': '',\n\t    'white-space': 'normal',\n\t    'widows': '2',\n\t    'word-spacing': 'normal'\n\t}\n\t\n\tdefaultJss.set('.'+Style.defaultClassName, defaultStyleValues) // creates default css class in order to prevent inheritance\n\t\n\tdefaultJss.set('input', { // chrome and firefox user agent stylesheets mess with this otherwise\n\t    cursor: 'inherit'\n\t})\n\t\n\t/*private*/ module.exports.isDev; // should be set by Block\n\t\n\tvar computedStyles = module.exports.computedStyles = new HashMap() // stores a map from styleMap components, to the combined style map\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(25)\n\tvar Style = __webpack_require__(2)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t    //static properties\n\t\n\t    this.name = 'Canvas'\n\t\n\t    this.init = function(/*[label,] height, width*/) {\n\t        if(arguments.length === 2) {\n\t            var height = arguments[0]\n\t            var width = arguments[1]\n\t        } else {\n\t            var label = arguments[0]\n\t            var height = arguments[1]\n\t            var width = arguments[2]\n\t        }\n\t\n\t        this.domNode = document.createElement('canvas') // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t\n\t        this.label = label\n\t        this.height = height\n\t        this.width = width\n\t    }\n\t\n\t    // instance properties\n\t\n\t    Object.defineProperty(this, 'width', {\n\t        get: function() {\n\t            return this.domNode.width\n\t        }, set: function(v) {\n\t            this.domNode.width = v\n\t        }\n\t    })\n\t    Object.defineProperty(this, 'height', {\n\t        get: function() {\n\t            return this.domNode.height\n\t        }, set: function(v) {\n\t            this.domNode.height = v\n\t        }\n\t    })\n\t\n\t    this.context = function() {\n\t        return this.domNode.getContext.apply(this.domNode, arguments)\n\t    }\n\t\n\t    this.toImg = this.toDataURL = function() {\n\t        return this.domNode.toDataURL()\n\t    }\n\t});\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(25)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t\t// static properties\n\t\n\t    this.name = 'Container'\n\t\n\t\n\t\t// instance properties\n\t\n\t\tthis.init = function (/*[label,] content*/) {\n\t        if(arguments.length === 1) {\n\t            var contentArgs = [arguments[0]]\n\t        } else if(arguments.length > 1) {\n\t            if(typeof(arguments[0]) === 'string') {\n\t                var label = arguments[0]\n\t                var contentArgs = Array.prototype.slice.call(arguments, 1)\n\t            } else {\n\t                var contentArgs = arguments\n\t            }\n\t        }\n\t\n\t\t\tvar that = this\n\t        superclass.init.call(this) // superclass constructor\n\t\n\t        this.label = label\n\t\n\t\t\tif(contentArgs !== undefined)\n\t            this.add.apply(this,contentArgs)\n\t\t}\n\t})\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(25)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t    // static variables\n\t\n\t    this.name = 'Button'\n\t\n\t\n\t    // instance properties\n\t\n\t\tthis.init = function(/*[label,] text*/) {\n\t        if(arguments.length >= 2) {\n\t            var label = arguments[0]\n\t            var text = arguments[1]\n\t        } else {\n\t            var text = arguments[0]\n\t        }\n\t\n\t        this.domNode = document.createElement(\"input\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t\n\t        this.label = label\n\t\t\tthis.attr('type','button');\n\t\t\tthis.text = text\n\t\t}\n\t\n\t    Object.defineProperty(this, 'text', {\n\t        get: function() {\n\t            return this.attr('value')\n\t        },\n\t        set: function(text) {\n\t            this.attr('value', text)\n\t        }\n\t    })\n\t\n\t})\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(25)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\t// static variables\n\t    this.name = 'CheckBox'\n\t\n\t\t// instance methods\n\t\tthis.init = function(label) {\n\t        var that = this\n\t\n\t        this.domNode = document.createElement(\"input\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t\n\t        this.label = label\n\t\t\tthis.attr('type','checkbox')\n\t\t}\n\t\n\t    Object.defineProperty(this, 'selected', {\n\t        // returns whether or not the checkbox is checked\n\t        get: function() {\n\t            return this.domNode.checked\n\t        },\n\t        // sets the value of the checkbox to the passed value (true for checked)\n\t        set: function(checked) {\n\t            var newValue = checked === true\n\t            var curValue = this.domNode.checked\n\t            if(curValue === newValue) return;  // do nothing if nothing's changing\n\t\n\t            this.domNode.checked = newValue\n\t            this.emit('change') // the browser has no listenable event that is triggered on change of the 'checked' property\n\t        }\n\t    })\n\t})\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(25)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t    //static properties\n\t\n\t    this.name = 'Image'\n\t\n\t    this.init = function(/*[label,] imageSource*/) {\n\t        if(arguments.length === 1) {\n\t            var imageSource = arguments[0]\n\t        } else {\n\t            var label = arguments[0]\n\t            var imageSource = arguments[1]\n\t        }\n\t\n\t        this.domNode = document.createElement('img') // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t\n\t        var that = this\n\t\n\t        this.label = label\n\t        if(imageSource !==  undefined) this.src = imageSource\n\t    }\n\t\n\t    // instance properties\n\t\n\t    Object.defineProperty(this, 'src', {\n\t        get: function() {\n\t            return this.domNode.src\n\t        }, set: function(v) {\n\t            this.domNode.src = v\n\t        }\n\t    })\n\t});\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar proto = __webpack_require__(25)\n\t\n\tvar Block = __webpack_require__(1)\n\tvar Style = __webpack_require__(2)\n\t\n\tvar Item = __webpack_require__(19);\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t\t// static properties\n\t\n\t\tthis.Item = Item\n\t\n\t    this.name = 'List'\n\t\n\t\t// instance properties\n\t\n\t\tthis.init = function(/*[label,] [ordered,] listInit*/) {\n\t\t\tif(arguments[0] instanceof Array) {\n\t            var listInit = arguments[0]\n\t        } else {\n\t            if(arguments[1] instanceof Array) {\n\t                var listInit = arguments[1]\n\t            } else if(arguments[2] instanceof Array) {\n\t                var listInit = arguments[2]\n\t            }\n\t\n\t            if(typeof(arguments[0]) === 'boolean') {\n\t                var ordered = arguments[0]\n\t            } else {\n\t                if(typeof(arguments[1]) === 'boolean') {\n\t                    var ordered = arguments[1]\n\t                } else {\n\t                    var ordered = false // default\n\t                }\n\t\n\t                if(typeof(arguments[0]) === 'string') {\n\t                    var label = arguments[0]\n\t                }\n\t            }\n\t        }\n\t\n\t        if(ordered) {\n\t            var type = 'ol'\n\t        } else {\n\t            var type = 'ul'\n\t            this.defaultStyle = Style({\n\t                listStyleType: 'decimal'\n\t            })\n\t        }\n\t\n\t\n\t        this.domNode = document.createElement(type) // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t        this.label = label\n\t\n\t        if(listInit !== undefined) {\n\t            for(var n=0; n<listInit.length; n++) {\n\t                this.item(listInit[n])\n\t            }\n\t        }\n\t\t}\n\t\n\t\tthis.item = function() {\n\t\t\tvar item = Item.apply(this, arguments)\n\t        this.add(item)\n\t        return item\n\t\t}\n\t});\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar proto = __webpack_require__(25)\n\tvar EventEmitter = __webpack_require__(24).EventEmitter\n\t\n\tvar Block = __webpack_require__(1)\n\t\n\tvar randomStart = getRandomInt(0,999999) // a random number used to start off the numbers given to radio button names (using a random number in case there are somehow two different instances of blocks.js on the page)\n\t\n\t// A group of radio buttons\n\tmodule.exports = proto(EventEmitter, function(superclass) {\n\t\n\t\t// static properties\n\t\n\t    this.name = 'Radio'\n\t\n\t\t// instance properties\n\t\n\t\n\t    // required - If true, a radio button must always be selected. Otherwise, radio buttons can be deselected by clicking on them.\n\t\tthis.init = function(required) {\n\t        //this.selected\n\t        this.required = required === true || required === undefined\n\t        this.buttons = {} // maps values to the buttons that have each value\n\t        this.randomStart = randomStart++\n\t\t}\n\t\n\t    // returns a new radio button\n\t    this.button = function(/*[label,] value*/) {\n\t        if(arguments.length >= 2) {\n\t            var label = arguments[0]\n\t            var value = arguments[1]\n\t        } else {\n\t            var value = arguments[0]\n\t        }\n\t\n\t        if(this.buttons[value] !== undefined) {\n\t            throw new Error(\"Can't give a RadioButton the same value as another in the group (value: '\"+value+\"')\")\n\t        }\n\t\n\t        var button = RadioButton(this, label, value, \"_radioblock\"+this.randomStart)\n\t        this.buttons[value] = button\n\t\n\t        if(this.required && this._selected === undefined) {\n\t            button.selected = true\n\t        }\n\t\n\t        return button\n\t    }\n\t\n\t    // returns the RadioButton in the group that's selected (or undefined if none are selected)\n\t    Object.defineProperty(this, 'selected', {\n\t        get: function() {\n\t            return this._selected\n\t        },\n\t        set: function() {\n\t            throw new Error(\"Can't set selected on a Radio object\")\n\t        }\n\t    })\n\t\n\t    Object.defineProperty(this, 'val', {\n\t        // returns the value of the selected radio button in the group (undefined if none are selected)\n\t        get: function() {\n\t            var selected = this._selected\n\t            if(selected === undefined) return undefined\n\t            // else\n\t            return selected.attr('value')\n\t        },\n\t\n\t        // sets the value of the checkbox to the passed value (true for checked)\n\t        // throws an exception if none of the radio buttons have that value\n\t        // throws an exception if an unset is attempted for a required Radio set\n\t        set: function(value) {\n\t            if(value === undefined) {\n\t                var selected = this._selected\n\t                if(selected !== undefined) {\n\t                    selected.selected = false\n\t                }\n\t            } else {\n\t                var button = this.buttons[value]\n\t                if(button === undefined) throw new Error(\"There is no RadioButton in the group with the value: '\"+value+\"'\")\n\t\n\t                button.selected = true\n\t            }\n\t        }\n\t    })\n\t\n\t\n\t    // arguments can be one of the following:\n\t        // RadioButton, RadioButton, RadioButton, ...\n\t        // value, value, value, ... - each value is the value of the RadioButton to remove\n\t        // arrayOfRadioButtons\n\t        // arrayOfValues\n\t    this.remove = function() {\n\t        if(arguments[0] instanceof Array) {\n\t            var removals = arguments[0]\n\t        } else {\n\t            var removals = arguments\n\t        }\n\t\n\t        for(var n=0; n<removals.length; n++) {\n\t            var r = removals[n]\n\t\n\t            if(r instanceof RadioButton) {\n\t                var button = r\n\t                var value = r.val\n\t\n\t                if(this.buttons[value] !== r) {\n\t                    throw new Error(\"The button passed at index \"+n+\" is not part of the group.\")\n\t                }\n\t            } else {\n\t                var button = this.buttons[r]\n\t                var value = r\n\t\n\t                if(button === undefined) {\n\t                    throw new Error(\"There is no RadioButton in the group with the value: '\"+value+\"'\")\n\t                }\n\t            }\n\t\n\t            var originalSelected = this.selected\n\t            if(this.selected === button) {\n\t                this._selected = undefined\n\t            }\n\t\n\t            this.buttons[value].group = undefined // fully remove it from the group\n\t            delete this.buttons[value]\n\t        }\n\t\n\t        if(this.required && this.selected === undefined) {\n\t            for(var v in this.buttons) {\n\t                this.buttons[v].selected = true // just select the first one\n\t                break; // yes this doesn't loop\n\t            }\n\t        } else if(originalSelected !== this.selected) {\n\t            this.emit('change')\n\t        }\n\t    }\n\t\n\t})\n\t\n\tvar RadioButton = proto(Block, function(superclass) {\n\t    this.name = 'RadioButton'\n\t\n\t    this.init = function(radioGroup, label, value, name) {\n\t        this.domNode = document.createElement(\"input\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t\n\t        this.label = label\n\t        this.group = radioGroup\n\t\n\t        this.attr('type', 'radio')\n\t        this.attr('name', name) // the name is needed so that using tab to move through page elements can tab between different radio groups\n\t        this.val = value\n\t\n\t        var that = this\n\t\t\tthis.on(\"mousedown\",function(event) {\n\t            event.preventDefault()           // this needs to be here otherwise the radio button can't be changed\n\t\n\t\t\t\tif(that.group.required) {\n\t                if(that.selected === false) {\n\t                    that.selected = true\n\t                }\n\t            } else {\n\t                that.selected = !that.selected // toggle\n\t            }\n\t\t\t})\n\t        this.on(\"click\",function(event) {\n\t            event.preventDefault()         // this needs to be here otherwise the radio button can't be *unset*\n\t        })\n\t        this.on(\"keydown\",function(event) {\n\t            if(event.keyCode === 40 || event.keyCode === 39) { // down or right\n\t                event.preventDefault()         // this needs to be here otherwise the radio button strangely calls the click handler which causes things to mess up\n\t                that.selectNext()\n\t            } else if(event.keyCode === 38 || event.keyCode === 37) { // up or left\n\t                event.preventDefault()         // this needs to be here otherwise the radio button strangely calls the click handler which causes things to mess up\n\t                that.selectPrevious()\n\t            }\n\t        })\n\t    }\n\t\n\t    Object.defineProperty(this, 'val', {\n\t        // returns the value attribute of the checkbox\n\t        get: function() {\n\t            return this.attr('value')\n\t        },\n\t\n\t        // sets the value attribute of the checkbox\n\t        set: function(value) {\n\t            if(this.group.buttons[value] !== undefined) {\n\t                throw new Error(\"Can't give a RadioButton the same value as another in the group (value: '\"+value+\"')\")\n\t            }\n\t\n\t            var oldValue = this.val\n\t            this.attr('value', value)\n\t            if(oldValue !== undefined) delete this.group.buttons[oldValue]\n\t            this.group.buttons[value] = this\n\t        }\n\t    })\n\t\n\t\n\t    Object.defineProperty(this, 'selected', {\n\t        // returns whether or not the checkbox is checked\n\t        get: function() {\n\t            return this.domNode.checked\n\t        },\n\t\n\t        // sets the selected state of the checkbox to the passed value (true for checked)\n\t        set: function(value) {\n\t            var booleanValue = value === true\n\t            if(this.selected === value) return; // ignore if there's no change\n\t\n\t            if(booleanValue) {\n\t                var previouslySelected = this.group.selected\n\t                setButtonInGroup(this.group, this)\n\t                if(previouslySelected !== undefined)\n\t                    previouslySelected.emit('change')\n\t            } else {\n\t                if(this.group.required) throw new Error(\"Can't unset this Radio set, a value is required.\")\n\t                this.domNode.checked = false\n\t                this.group._selected = undefined\n\t            }\n\t            this.emit('change') // the browser has no listenable event that is triggered on change of the 'checked' property\n\t            this.group.emit('change')\n\t        }\n\t    })\n\t\n\t    this.selectNext = function() {\n\t        selectSibling(this,1)\n\t    }\n\t    this.selectPrevious = function() {\n\t        selectSibling(this,-1)\n\t    }\n\t\n\t})\n\t\n\t// direction can be +1 or -1\n\tfunction selectSibling(button, direction) {\n\t    var buttons = button.group.buttons\n\t    var values = Object.keys(buttons)\n\t    var index = values.indexOf(button.attr('value'))\n\t    if(direction === 1 && index === values.length-1) {\n\t        var buttonToSelect = buttons[values[0]]\n\t    } else if(direction === -1 && index === 0) {\n\t        var buttonToSelect = buttons[values[values.length-1]]\n\t\n\t    } else {\n\t        var buttonToSelect = buttons[values[index+direction]]\n\t    }\n\t\n\t    buttonToSelect.selected = true\n\t    buttonToSelect.focus()\n\t}\n\t\n\tfunction setButtonInGroup(group, button) {\n\t    var selected = group._selected\n\t    if(selected !== undefined) selected.domNode.checked = false\n\t    button.domNode.checked = true\n\t    group._selected = button\n\t}\n\t\n\tfunction getRandomInt(min, max) {\n\t  return Math.floor(Math.random() * (max - min)) + min;\n\t}\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(25)\n\t\n\tvar Option = __webpack_require__(20)\n\t\n\t// emits a 'change' event when its 'val' changes\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t\t// static variables\n\t\n\t    this.name = 'Select'\n\t\n\t    this.Option = Option\n\t\n\t\tthis.init = function(/*[label,] options*/) {\n\t        if(arguments[0] instanceof Object) {\n\t            var options = arguments[0]\n\t        } else {\n\t            var label = arguments[0]\n\t            var options = arguments[1]\n\t        }\n\t\n\t        this.domNode = document.createElement(\"select\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t        this.label = label\n\t\n\t        this.options = {}\n\t\n\t\t\tfor(var value in options) {\n\t\t\t\tthis.option(value, options[value])\n\t\t\t}\n\t\t}\n\t\n\t\n\t\t// instance methods\n\t\n\t    Object.defineProperty(this, 'val', {\n\t        // returns the value that is selected\n\t        get: function() {\n\t            for(var value in this.options) {\n\t                if(this.options[value].selected) {\n\t                    return value\n\t                }\n\t            }\n\t        },\n\t\n\t        set: function(value) {\n\t            var option = this.options[value]\n\t            if(option === undefined) throw new Error(\"There is no Option in the Select with the value: '\"+value+\"'\")\n\t            option.selected = true\n\t        }\n\t    })\n\t\t\n\t\tthis.option = function(/*[label,] value,text*/) {\n\t        if(arguments.length === 2) {\n\t            var value = arguments[0]\n\t            var text = arguments[1]\n\t        } else if(arguments.length === 3) {\n\t            var label = arguments[0]\n\t            var value = arguments[1]\n\t            var text = arguments[2]\n\t        } else {\n\t            throw new Error(\"Invalid number of arguments\")\n\t        }\n\t\n\t        var newOption = Option(label, value,text)\n\t        this.add(newOption)\n\t\n\t        return newOption\n\t\n\t\t}\n\t\n\t    // same interface as Block.addAt\n\t    /*override*/ this.addAt = function(index/*, nodes...*/) {\n\t        var that = this\n\t\n\t        var nodesToAdd = Block.normalizeAddAtArguments.apply(this, arguments)\n\t\n\t        // validation first\n\t        nodesToAdd.forEach(function(option) {\n\t            if(that.options[option.val] !== undefined) {\n\t                throw new Error(\"Can't give an Option the same value as another in the Select (value: '\"+option.val+\"')\")\n\t            }\n\t        })\n\t\n\t        superclass.addAt.call(this, index, nodesToAdd)\n\t\n\t        // Select specific state modifications - this must be done after the superclass call in case an error is thrown from it\n\t        var anyWereSelected = false\n\t        nodesToAdd.forEach(function(option) {\n\t            if(option.selected) anyWereSelected = true\n\t            that.options[option.val] = option\n\t\n\t            // set up Select events\n\t            // todo: remove events when the Option is removed\n\t\n\t            option.on(\"mousedown\",function(event) {\n\t                option.parent.val = option.val      // select this one\n\t            })\n\t        })\n\t\n\t        if(anyWereSelected) {\n\t            this.emit('change')\n\t        }\n\t    }\n\t\n\t    // same interface as Block.remove\n\t    /*override*/ this.remove = function() {\n\t        var that = this\n\t\n\t        var removalIndexes = Block.normalizeRemoveArguments.apply(this, arguments)\n\t        var removals = removalIndexes.map(function(index) {\n\t            return that.children[index]\n\t        })\n\t\n\t        superclass.remove.call(this, removalIndexes)\n\t\n\t        // Select specific state modifications - this must be done after the superclass call in case an error is thrown from it\n\t        var theSelectedWasRemoved = false\n\t        removals.forEach(function(option) {\n\t            if(option.selected) theSelectedWasRemoved = true\n\t            delete that.options[option.val]\n\t        })\n\t\n\t        if(theSelectedWasRemoved) {\n\t            //this.children[0].selected = true // I think the browser does this automatically??\n\t            this.emit('change')\n\t        }\n\t    }\n\t\n\t\n\t    // private\n\t\n\t    this.prepareForValueChange = function(values) {\n\t        var value = values[0]\n\t\n\t        for(var optionValue in this.options) {\n\t            if(optionValue !== value) {\n\t                var option = this.options[optionValue]\n\t                if(option.selected === true) {\n\t                    option.setSelectedQuiet(false)\n\t                }\n\t            }\n\t        }\n\t    }\n\t})\n\t\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar proto = __webpack_require__(25)\n\t\n\tvar Block = __webpack_require__(1)\n\tvar Style = __webpack_require__(2)\n\t\n\tvar Header = __webpack_require__(21);\n\tvar Row = __webpack_require__(22);\n\tvar Cell = __webpack_require__(23);\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t\t// static properties\n\t\n\t    this.name = 'Table'\n\t\n\t    this.defaultStyle = Style({\n\t        borderSpacing: 0\n\t    })\n\t\n\t    this.Row = Row\n\t\tthis.Header = Header\n\t    this.Cell = Cell\n\t\n\t\n\t\t// instance properties\n\t\n\t\tthis.init = function(/*[label,] tableInit*/) {\n\t\t\tif(arguments[0] instanceof Array) {\n\t            var tableInit = arguments[0]\n\t        } else {\n\t            var label = arguments[0]\n\t            var tableInit = arguments[1]\n\t        }\n\t\n\t        this.domNode = document.createElement(\"table\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t        this.label = label\n\t\n\t        if(tableInit !== undefined) {\n\t            for(var n=0; n<tableInit.length; n++) {\n\t                this.row(tableInit[n])\n\t            }\n\t        }\n\t\t}\n\t\t\n\t\tthis.header = function(/*[]label,] listOfBlocksOrText*/) {\n\t        return headerOrRegularRow(this, Header, arguments)\n\t\t}\n\t\n\t\tthis.row = function() {\n\t\t\treturn headerOrRegularRow(this, Row, arguments)\n\t\t}\n\t});\n\t\n\tfunction headerOrRegularRow(that, Prototype, args) {\n\t    var row = Prototype.apply(undefined, args)\n\t    that.add(row)\n\t    return row\n\t}\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(25)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t\t// static variables\n\t\n\t    this.name = 'TextArea'\n\t\n\t\tthis.init = function(label) {\n\t        this.domNode = document.createElement(\"textarea\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t\t\tthis.label = label\n\t\t}\n\t\n\t\n\t\t// instance properties\n\t\n\t\n\t    Object.defineProperty(this, 'val', {\n\t        // returns the value of the Option\n\t        get: function() {\n\t            return this.domNode.value\n\t        },\n\t\n\t        // sets the value of the Option\n\t        set: function(value) {\n\t            if(this.val === value) return; // do nothing if there's no change\n\t\n\t            this.domNode.value = value\n\t            this.emit('change')\n\t        }\n\t    })\n\t});\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(25)\n\t\n\tvar domUtils = __webpack_require__(17)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t\t// static properties\n\t\n\t    this.name = 'TextField'\n\t\n\t\tthis.init = function(/*[label,] password*/) {\n\t        if(arguments.length === 1) {\n\t            var password = arguments[0]\n\t        } else if(arguments.length > 1) {\n\t            var label = arguments[0]\n\t            var password = arguments[1]\n\t        }\n\t\n\t        this.domNode = document.createElement(\"input\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t\n\t\t\tthis.label = label\n\t        this.domNode.className = 'field'\n\t\t\tdomUtils.setAttribute(this.domNode,'type','text');\n\t        if(password)\n\t            domUtils.setAttribute(this.domNode, 'type', 'password')\n\t\t}\n\t\n\t\n\t\t// instance properties\n\t\n\t    Object.defineProperty(this, 'val', {\n\t        // returns the value of the Option\n\t        get: function() {\n\t            return this.domNode.value\n\t        },\n\t\n\t        // sets the value of the Option\n\t        set: function(value) {\n\t            if(this.val === value) return; // do nothing if there's no change\n\t\n\t            this.domNode.value = value\n\t            this.emit('change')\n\t        }\n\t    })\n\t\n\t});\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(25)\n\tvar Style = __webpack_require__(2)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t    //static properties\n\t\n\t    this.name = 'Text'\n\t\n\t    this.defaultStyle = Style({\n\t        whiteSpace: 'pre'\n\t    })\n\t\n\t    this.init = function(/*[label,] text*/) {\n\t        if(arguments.length === 1) {\n\t            var text = arguments[0]\n\t        } else {\n\t            var label = arguments[0]\n\t            var text = arguments[1]\n\t        }\n\t\n\t        if (text === undefined) text = '';\n\t\n\t        superclass.init.call(this) // superclass constructor\n\t\n\t        var that = this\n\t\n\t        this.label = label\n\t        this.text = text\n\t\n\t        this.on(\"input\",function(data) {\n\t            var eventData = {newText:data.srcElement.textContent,oldText:that.oldText};\n\t            that.oldText = eventData.newText;\n\t            //that.emit(\"input\",eventData);\n\t        });\n\t\n\t        this.on(\"blur\",function(data) {\n\t            var eventData = {newText:data.srcElement.textContent,oldText:that.lastFocus};\n\t            that.lastFocus = eventData.newText;\n\t            //that.emit(\"blur\",eventData);\n\t        });\n\t    }\n\t\n\t    // instance properties\n\t\n\t    Object.defineProperty(this, 'text', {\n\t        get: function() {\n\t            return this.domNode.textContent\n\t        }, set: function(v) {\n\t            this.domNode.innerText = v   // apparently textContent can't be set or something\n\t        }\n\t    })\n\t});\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar EventEmitter = __webpack_require__(24).EventEmitter\r\n\tvar proto = __webpack_require__(25)\r\n\tvar utils = __webpack_require__(16)\r\n\t\r\n\tmodule.exports = proto(EventEmitter, function(superclass) {\r\n\t\r\n\t    this.init = function() {\r\n\t        superclass.apply(this, arguments)\r\n\t\r\n\t        this.ifonHandlers = {}\r\n\t        this.ifoffHandlers = {}\r\n\t        this.ifonAllHandlers = []\r\n\t        this.ifoffAllHandlers = []\r\n\t    }\r\n\t\r\n\t    // callback will be triggered immediately if there is already a listener attached, or\r\n\t    // callback will be triggered when the first listener for the event is added\r\n\t    // (regardless of whether its done through on or once)\r\n\t    // parameters can be:\r\n\t        // event, callback - attach an ifon handler for the passed event\r\n\t        // callback - attach an ifon handler for all events\r\n\t    this.ifon = function(event, callback) {\r\n\t        if(event instanceof Function) {     // event not passed, only a callback\r\n\t            callback = event // fix the argument\r\n\t            for(var eventName in this._events) {\r\n\t                if(this.listeners(eventName).length > 0) {\r\n\t                    callback(eventName)\r\n\t                }\r\n\t            }\r\n\t        } else if(this.listeners(event).length > 0) {\r\n\t            callback(event)\r\n\t        }\r\n\t\r\n\t        addHandlerToList(this, 'ifonHandlers', event, callback)\r\n\t    }\r\n\t\r\n\t    // removes either:\r\n\t        // removeIfon() - all ifon handlers (if no arguments are passed), or\r\n\t        // removeIfon(event) - all ifon handlers for the passed event, or\r\n\t        // removeIfon(callback) - the passed ifon-all handler (if the first parameter is the callback)\r\n\t        // removeIfon(event, callback) - the specific passed callback for the passed event\r\n\t    this.removeIfon = function(event, callback) {\r\n\t        removeFromHandlerList(this, 'ifonHandlers', event, callback)\r\n\t    }\r\n\t\r\n\t    // callback will be triggered when the last listener for the 'click' event is removed (will not trigger immediately if there is no event listeners on call of ifoff)\r\n\t    // (regardless of whether this is done through removeListener or as a result of 'once' being fulfilled)\r\n\t    // parameters can be:\r\n\t        // event, callback - attach an ifoff handler for the passed event\r\n\t        // callback - attach an ifoff handler for all events\r\n\t    this.ifoff = function(event, callback) {\r\n\t        addHandlerToList(this, 'ifoffHandlers', event, callback)\r\n\t    }\r\n\t\r\n\t    // removes either:\r\n\t        // removeIfoff() - all ifoff handlers (if no arguments are passed), or\r\n\t        // removeIfoff(event) - all ifoff handlers for the passed event, or\r\n\t        // removeIfoff(callback) - the passed ifoff-all handler (if the first parameter is the callback)\r\n\t        // removeIfoff(event, callback) - the specific passed callback for the passed event\r\n\t    this.removeIfoff = function(event, callback) {\r\n\t        removeFromHandlerList(this, 'ifoffHandlers', event, callback)\r\n\t    }\r\n\t\r\n\t    // emitter is the emitter to proxy handler binding to\r\n\t    // options can have one of the following properties:\r\n\t        // only - an array of events to proxy\r\n\t        // except - an array of events to *not* proxy\r\n\t    this.proxy = function(emitter, options) {\r\n\t        if(options === undefined) options = {}\r\n\t        if(options.except !== undefined) {\r\n\t            var except = utils.arrayToMap(options.except)\r\n\t            var handleIt = function(event){return !(event in except)}\r\n\t        } else if(options.only !== undefined) {\r\n\t            var only = utils.arrayToMap(options.only)\r\n\t            var handleIt = function(event){return event in only}\r\n\t        } else {\r\n\t            var handleIt = function(){return true}\r\n\t        }\r\n\t\r\n\t        var that = this, handler;\r\n\t        this.ifon(function(event) {\r\n\t            if(handleIt(event)) {\r\n\t                emitter.on(event, handler = function() {\r\n\t                    that.emit.apply(that, [event].concat(Array.prototype.slice.call(arguments)))\r\n\t                })\r\n\t            }\r\n\t        })\r\n\t        this.ifoff(function(event) {\r\n\t            if(handleIt(event))\r\n\t                emitter.off(event, handler)\r\n\t        })\r\n\t    }\r\n\t\r\n\t    /*override*/ this.on = this.addListener = function(event, callback) {\r\n\t        var triggerIfOn = this.listeners(event).length === 0\r\n\t        superclass.prototype.on.apply(this,arguments)\r\n\t        if(triggerIfOn) triggerIfHandlers(this, 'ifonHandlers', event)\r\n\t    }\r\n\t\r\n\t    /*override*/ this.off = this.removeListener = function(event, callback) {\r\n\t        var triggerIfOff = this.listeners(event).length === 1\r\n\t        superclass.prototype.removeListener.apply(this,arguments)\r\n\t        if(triggerIfOff) triggerIfHandlers(this, 'ifoffHandlers', event)\r\n\t    }\r\n\t    /*override*/ this.removeAllListeners = function(event) {\r\n\t        var triggerIfOffForEvents = []\r\n\t        if(event !== undefined) {\r\n\t            if(this.listeners(event).length > 0) {\r\n\t                triggerIfOffForEvents.push(event)\r\n\t            }\r\n\t        } else {\r\n\t            for(var event in this._events) {\r\n\t                if(this.listeners(event).length > 0) {\r\n\t                    triggerIfOffForEvents.push(event)\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        superclass.prototype.removeAllListeners.apply(this,arguments)\r\n\t\r\n\t        for(var n=0; n<triggerIfOffForEvents.length; n++) {\r\n\t            triggerIfHandlers(this, 'ifoffHandlers', triggerIfOffForEvents[n])\r\n\t        }\r\n\t    }\r\n\t\r\n\t})\r\n\t\r\n\t\r\n\t// triggers the if handlers from the normal list and the \"all\" list\r\n\tfunction triggerIfHandlers(that, handlerListName, event) {\r\n\t    triggerIfHandlerList(that[handlerListName][event], event)\r\n\t    triggerIfHandlerList(that[normalHandlerToAllHandlerProperty(handlerListName)], event)\r\n\t}\r\n\t\r\n\t\r\n\t// triggers the if handlers from a specific list\r\n\t// ya these names are confusing, sorry : (\r\n\tfunction triggerIfHandlerList(handlerList, event) {\r\n\t    if(handlerList !== undefined) {\r\n\t        for(var n=0; n<handlerList.length; n++) {\r\n\t            handlerList[n](event)\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction addHandlerToList(that, handlerListName, event, callback) {\r\n\t    if(event instanceof Function) {\r\n\t        // correct arguments\r\n\t        callback = event\r\n\t        event = undefined\r\n\t    }\r\n\t\r\n\t    if(event !== undefined && callback !== undefined) {\r\n\t        var handlerList = that[handlerListName][event]\r\n\t        if(handlerList === undefined) {\r\n\t            handlerList = that[handlerListName][event] = []\r\n\t        }\r\n\t\r\n\t        handlerList.push(callback)\r\n\t    } else {\r\n\t        that[normalHandlerToAllHandlerProperty(handlerListName)].push(callback)\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction removeFromHandlerList(that, handlerListName, event, callback) {\r\n\t    if(event instanceof Function) {\r\n\t        // correct arguments\r\n\t        callback = event\r\n\t        event = undefined\r\n\t    }\r\n\t\r\n\t    if(event !== undefined && callback !== undefined) {\r\n\t        removeCallbackFromList(that[handlerListName][event], callback)\r\n\t    } else if(event !== undefined) {\r\n\t        delete that[handlerListName][event]\r\n\t    } else if(callback !== undefined) {\r\n\t        var allHandlerListName = normalHandlerToAllHandlerProperty(handlerListName)\r\n\t        removeCallbackFromList(that[allHandlerListName], callback)\r\n\t    } else {\r\n\t        var allHandlerListName = normalHandlerToAllHandlerProperty(handlerListName)\r\n\t        that[handlerListName] = {}\r\n\t        that[allHandlerListName] = []\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction normalHandlerToAllHandlerProperty(handlerListName) {\r\n\t    if(handlerListName === 'ifonHandlers')\r\n\t        return 'ifonAllHandlers'\r\n\t    if(handlerListName === 'ifoffHandlers')\r\n\t        return 'ifoffAllHandlers'\r\n\t}\r\n\t\r\n\tfunction removeCallbackFromList(list, callback) {\r\n\t    var index = list.indexOf(callback)\r\n\t    list.splice(index,1)\r\n\t}\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// utilities needed by the configuration (excludes dependencies the configs don't need so the webpack bundle is lean)\r\n\t\r\n\tvar path = __webpack_require__(30)\r\n\t\r\n\t\r\n\t// Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1\r\n\t// any number of objects can be passed into the function and will be merged into the first argument in order\r\n\t// returns obj1 (now mutated)\r\n\tvar merge = exports.merge = function(obj1, obj2/*, moreObjects...*/){\r\n\t    return mergeInternal(arrayify(arguments), false)\r\n\t}\r\n\t\r\n\t// like merge, but traverses the whole object tree\r\n\t// the result is undefined for objects with circular references\r\n\tvar deepMerge = exports.deepMerge = function(obj1, obj2/*, moreObjects...*/) {\r\n\t    return mergeInternal(arrayify(arguments), true)\r\n\t}\r\n\t\r\n\t// returns a new object where properties of b are merged onto a (a's properties may be overwritten)\r\n\texports.objectConjunction = function(a, b) {\r\n\t    var objectCopy = {}\r\n\t    merge(objectCopy, a)\r\n\t    merge(objectCopy, b)\r\n\t    return objectCopy\r\n\t}\r\n\t\r\n\t// turns an array of values into a an object where those values are all keys that point to 'true'\r\n\texports.arrayToMap = function(array) {\r\n\t    var result = {}\r\n\t    array.forEach(function(v) {\r\n\t        result[v] = true\r\n\t    })\r\n\t    return result\r\n\t}\r\n\t\r\n\tfunction mergeInternal(objects, deep) {\r\n\t    var obj1 = objects[0]\r\n\t    var obj2 = objects[1]\r\n\t\r\n\t    for(var key in obj2){\r\n\t       if(Object.hasOwnProperty.call(obj2, key)) {\r\n\t            if(deep && obj1[key] instanceof Object && obj2[key] instanceof Object) {\r\n\t                mergeInternal([obj1[key], obj2[key]], true)\r\n\t            } else {\r\n\t                obj1[key] = obj2[key]\r\n\t            }\r\n\t       }\r\n\t    }\r\n\t\r\n\t    if(objects.length > 2) {\r\n\t        var newObjects = [obj1].concat(objects.slice(2))\r\n\t        return mergeInternal(newObjects, deep)\r\n\t    } else {\r\n\t        return obj1\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction arrayify(a) {\r\n\t    return Array.prototype.slice.call(a, 0)\r\n\t}\r\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t// creates a dom element optionally with a class and attributes\r\n\t var node = module.exports.node = function(type, className, options) {\r\n\t    var elem = document.createElement(type)\r\n\t\r\n\t    if(options !== undefined) {\r\n\t        if(options.attr !== undefined) {\r\n\t            for(var attribute in options.attr) {\r\n\t                createAttribute(elem, attribute, options.attr[attribute])\r\n\t            }\r\n\t        }\r\n\t        if(options.textContent !== undefined) {\r\n\t            elem.textContent = options.textContent\r\n\t        }\r\n\t    }\r\n\t\r\n\t    if(className !== undefined)\r\n\t        elem.className = className\r\n\t\r\n\t    return elem\r\n\t}\r\n\t\r\n\t// convenience function for creating a div\r\n\tmodule.exports.div = function(className, options) {\r\n\t    return node('div', className, options)\r\n\t}\r\n\t\r\n\t// adds an attribute to a domNode\r\n\tvar setAttribute = module.exports.setAttribute = function(/*[domNode,] type, value*/) {\r\n\t    if (arguments.length === 2) {\r\n\t        var domNode = this.domNode;\r\n\t        var type = arguments[0];\r\n\t        var value = arguments[1];\r\n\t    } else if (arguments.length === 3) {\r\n\t        var domNode = arguments[0];\r\n\t        var type = arguments[1];\r\n\t        var value = arguments[2];\r\n\t    } else {\r\n\t        throw new Error(\"This function expects arguments to be: [domNode,] type, value\");\r\n\t    }\r\n\t    var attr = document.createAttribute(type)\r\n\t    attr.value = value\r\n\t    domNode.setAttributeNode(attr)\r\n\t}\r\n\t\r\n\t\r\n\t// sets the selection\r\n\t//\r\n\t// works for contenteditable elements\r\n\texports.setSelectionRange = function(containerEl, start, end) {\r\n\t\r\n\t    if(containerEl.nodeName === 'INPUT' || containerEl.nodeName === 'TEXTAREA') {\r\n\t        containerEl.setSelectionRange(start, end)\r\n\t    } else {\r\n\t        var charIndex = 0, range = document.createRange();\r\n\t        range.setStart(containerEl, 0);\r\n\t        range.collapse(true);\r\n\t        var foundStart = false;\r\n\t\r\n\t        iterateThroughLeafNodes(containerEl, function(node) {\r\n\t            var hiddenCharacters = findHiddenCharacters(node, node.length)\r\n\t            var nextCharIndex = charIndex + node.length - hiddenCharacters;\r\n\t\r\n\t            if (!foundStart && start >= charIndex && start <= nextCharIndex) {\r\n\t                var nodeIndex = start-charIndex\r\n\t                var hiddenCharactersBeforeStart = findHiddenCharacters(node, nodeIndex)\r\n\t                range.setStart(node, nodeIndex + hiddenCharactersBeforeStart);\r\n\t                foundStart = true;\r\n\t            }\r\n\t\r\n\t            if (foundStart && end >= charIndex && end <= nextCharIndex) {\r\n\t                var nodeIndex = end-charIndex\r\n\t                var hiddenCharactersBeforeEnd = findHiddenCharacters(node, nodeIndex)\r\n\t                range.setEnd(node, nodeIndex + hiddenCharactersBeforeEnd);\r\n\t                return true; // stop the iteration - we're done here\r\n\t            }\r\n\t\r\n\t            charIndex = nextCharIndex\r\n\t        })\r\n\t\r\n\t        var sel = window.getSelection();\r\n\t        sel.removeAllRanges();\r\n\t        sel.addRange(range);\r\n\t    }\r\n\t}\r\n\t\r\n\t// gets the character offsets of a selection within a particular dom node\r\n\t// returns undefined if there is no selection in the element\r\n\t// note: yes this code doesn't work in older versions of IE (or possibly any versions) - if you want it to work in IE, please use http://modernizr.com/ or a polyfill for ranges\r\n\texports.getSelectionRange = function (element) {\r\n\t\r\n\t    var selection = window.getSelection()\r\n\t    var isInputOrArea = element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA'\r\n\t\r\n\t    for(var n=0; n<selection.rangeCount; n++) {\r\n\t        var range = selection.getRangeAt(0)\r\n\t        if(isInputOrArea) {\r\n\t            if(range.startOffset === range.endOffset && range.startContainer.children[range.startOffset] === element /*|| range.startContainer === element || */) { // I don't think the input or textarea itself will ever be the startContainer\r\n\t                return [element.selectionStart, element.selectionEnd]\r\n\t            }\r\n\t        } else {\r\n\t            var startsInElement = element.contains(range.startContainer)\r\n\t            if(startsInElement) {\r\n\t                var elementToIterateThrough = element\r\n\t                var startFound = true\r\n\t            } else {\r\n\t                var elementToIterateThrough = range.commonAncestorContainer\r\n\t                var startFound = false\r\n\t                var startContainerFound = false\r\n\t            }\r\n\t\r\n\t            var visibleCharacterOffset = 0, start, end;\r\n\t            iterateThroughLeafNodes(elementToIterateThrough, function(leaf) {\r\n\t                if(!startFound) {\r\n\t                    if(leaf === range.startContainer) {\r\n\t                        startContainerFound = true\r\n\t                    }\r\n\t\r\n\t                    if(!element.contains(leaf) || !startContainerFound)\r\n\t                        return; // continue\r\n\t                    else if(startContainerFound)\r\n\t                       startFound = true\r\n\t                } else if(!startsInElement && !element.contains(leaf)) {\r\n\t                    return true // done!\r\n\t                }\r\n\t\r\n\t                if(leaf === range.startContainer) {\r\n\t                    start = visibleCharacterOffset + range.startOffset - findHiddenCharacters(leaf, range.startOffset)\r\n\t                }\r\n\t                if(leaf === range.endContainer) {\r\n\t                    end = visibleCharacterOffset + range.endOffset - findHiddenCharacters(leaf, range.endOffset)\r\n\t                    return true // done!\r\n\t                }\r\n\t\r\n\t                visibleCharacterOffset += leaf.length - findHiddenCharacters(leaf, leaf.length)\r\n\t            })\r\n\t\r\n\t            if(start === undefined && !startFound) {\r\n\t                return undefined\r\n\t            } else {\r\n\t                if(start === undefined) {\r\n\t                    start = 0 // start is at the beginning\r\n\t                }\r\n\t                if(end === undefined) {\r\n\t                    end = visibleCharacterOffset // end is all the way at the end (the selection may continue in other elements)\r\n\t                }\r\n\t\r\n\t                return [start, end]\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\t\r\n\t// iterate through the leaf nodes inside element\r\n\t// callback(node) - a function called for each leaf node\r\n\t    // returning true from this ends the iteration\r\n\tfunction iterateThroughLeafNodes(element, callback) {\r\n\t    var nodeStack = [element], node;\r\n\t\r\n\t    while (node = nodeStack.pop()) {\r\n\t        if (node.nodeType == 3) {\r\n\t            if(callback(node) === true)\r\n\t                break;\r\n\t        } else {\r\n\t            var i = node.childNodes.length;\r\n\t            while (i--) {\r\n\t                nodeStack.push(node.childNodes[i]);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction findHiddenCharacters(node, beforeCaretIndex) {\r\n\t    var hiddenCharacters = 0\r\n\t    var lastCharWasWhiteSpace=true\r\n\t    for(var n=0; n-hiddenCharacters<beforeCaretIndex &&n<node.length; n++) {\r\n\t        if([' ','\\n','\\t','\\r'].indexOf(node.textContent[n]) !== -1) {\r\n\t            if(lastCharWasWhiteSpace)\r\n\t                hiddenCharacters++\r\n\t            else\r\n\t                lastCharWasWhiteSpace = true\r\n\t        } else {\r\n\t            lastCharWasWhiteSpace = false\r\n\t        }\r\n\t    }\r\n\t\r\n\t    return hiddenCharacters\r\n\t}\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t * JSS v0.6 - JavaScript Stylesheets\r\n\t * https://github.com/Box9/jss\r\n\t *\r\n\t * Copyright (c) 2011, David Tang\r\n\t * MIT Licensed (http://www.opensource.org/licenses/mit-license.php)\r\n\t */\r\n\tvar jss = (function() {\r\n\t    var adjSelAttrRegex = /((?:\\.|#)[^\\.\\s#]+)((?:\\.|#)[^\\.\\s#]+)/g;\r\n\t    var doubleColonPseudoElRegex = /(::)(before|after|first-line|first-letter|selection)/;\r\n\t    var singleColonPseudoElRegex = /([^:])(:)(before|after|first-line|first-letter|selection)/;\r\n\t    var singleColonForPseudoElements; // flag for older browsers\r\n\t\r\n\t    function getSelectorsAndRules(sheet) {\r\n\t        var rules = sheet.cssRules || sheet.rules || [];\r\n\t        var results = {};\r\n\t        for (var i = 0; i < rules.length; i++) {\r\n\t            // Older browsers and FF report pseudo element selectors in an outdated format\r\n\t            var selectorText = toDoubleColonPseudoElements(rules[i].selectorText);\r\n\t            if (!results[selectorText]) {\r\n\t                results[selectorText] = [];\r\n\t            }\r\n\t            results[selectorText].push({\r\n\t                sheet: sheet,\r\n\t                index: i,\r\n\t                style: rules[i].style\r\n\t            });\r\n\t        }\r\n\t        return results;\r\n\t    }\r\n\t\r\n\t    function getRules(sheet, selector) {\r\n\t        var rules = sheet.cssRules || sheet.rules || [];\r\n\t        var results = [];\r\n\t        // Browsers report selectors in lowercase\r\n\t        selector = selector.toLowerCase();\r\n\t        for (var i = 0; i < rules.length; i++) {\r\n\t            var selectorText = rules[i].selectorText;\r\n\t            // Note - certain rules (e.g. @rules) don't have selectorText\r\n\t            if (selectorText && (selectorText == selector || selectorText == swapAdjSelAttr(selector) || selectorText == swapPseudoElSyntax(selector))) {\r\n\t                results.push({\r\n\t                    sheet: sheet,\r\n\t                    index: i,\r\n\t                    style: rules[i].style\r\n\t                });\r\n\t            }\r\n\t        }\r\n\t        return results;\r\n\t    }\r\n\t\r\n\t    function addRule(sheet, selector) {\r\n\t        var rules = sheet.cssRules || sheet.rules || [];\r\n\t        var index = rules.length;\r\n\t        var pseudoElementRule = addPseudoElementRule(sheet, selector, rules, index);\r\n\t\r\n\t        if (!pseudoElementRule) {\r\n\t            addRuleToSheet(sheet, selector, index);\r\n\t        }\r\n\t\r\n\t        return {\r\n\t            sheet: sheet,\r\n\t            index: index,\r\n\t            style: rules[index].style\r\n\t        };\r\n\t    };\r\n\t\r\n\t    function addRuleToSheet(sheet, selector, index) {\r\n\t        if (sheet.insertRule) {\r\n\t            sheet.insertRule(selector + ' { }', index);\r\n\t        } else {\r\n\t            sheet.addRule(selector, null, index);\r\n\t        }\r\n\t    }\r\n\t\r\n\t    // Handles single colon syntax for older browsers and bugzilla.mozilla.org/show_bug.cgi?id=949651\r\n\t    function addPseudoElementRule(sheet, selector, rules, index) {\r\n\t        var doubleColonSelector;\r\n\t        var singleColonSelector;\r\n\t\r\n\t        if (doubleColonPseudoElRegex.exec(selector)) {\r\n\t            doubleColonSelector = selector;\r\n\t            singleColonSelector = toSingleColonPseudoElements(selector);\r\n\t        } else if (singleColonPseudoElRegex.exec(selector)) {\r\n\t            doubleColonSelector = toDoubleColonPseudoElements(selector);\r\n\t            singleColonSelector = selector;\r\n\t        } else {\r\n\t            return false; // Not dealing with a pseudo element\r\n\t        }\r\n\t\r\n\t        if (!singleColonForPseudoElements) {\r\n\t            // Assume modern browser and then check if successful\r\n\t            addRuleToSheet(sheet, doubleColonSelector, index);\r\n\t            if (rules.length <= index) {\r\n\t                singleColonForPseudoElements = true;\r\n\t            }\r\n\t        }\r\n\t        if (singleColonForPseudoElements) {\r\n\t            addRuleToSheet(sheet, singleColonSelector, index);\r\n\t        }\r\n\t\r\n\t        return true;\r\n\t    }\r\n\t\r\n\t    function toDoubleColonPseudoElements(selector) {\r\n\t        return selector.replace(singleColonPseudoElRegex, function (match, submatch1, submatch2, submatch3) {\r\n\t            return submatch1 + '::' + submatch3;\r\n\t        });\r\n\t    }\r\n\t\r\n\t    function toSingleColonPseudoElements(selector) {\r\n\t        return selector.replace(doubleColonPseudoElRegex, function(match, submatch1, submatch2) {\r\n\t            return ':' + submatch2;\r\n\t        })\r\n\t    }\r\n\t\r\n\t    function removeRule(rule) {\r\n\t        var sheet = rule.sheet;\r\n\t        if (sheet.deleteRule) {\r\n\t            sheet.deleteRule(rule.index);\r\n\t        } else if (sheet.removeRule) {\r\n\t            sheet.removeRule(rule.index);\r\n\t        }\r\n\t    }\r\n\t\r\n\t    function extend(dest, src) {\r\n\t        for (var key in src) {\r\n\t            if (!src.hasOwnProperty(key))\r\n\t                continue;\r\n\t            dest[key] = src[key];\r\n\t        }\r\n\t        return dest;\r\n\t    }\r\n\t\r\n\t    function aggregateStyles(rules) {\r\n\t        var aggregate = {};\r\n\t        for (var i = 0; i < rules.length; i++) {\r\n\t            extend(aggregate, declaredProperties(rules[i].style));\r\n\t        }\r\n\t        return aggregate;\r\n\t    }\r\n\t\r\n\t    function declaredProperties(style) {\r\n\t        var declared = {};\r\n\t        for (var i = 0; i < style.length; i++) {\r\n\t            declared[style[i]] = style[toCamelCase(style[i])];\r\n\t        }\r\n\t        return declared;\r\n\t    }\r\n\t\r\n\t    // IE9 stores rules with attributes (classes or ID's) adjacent in the opposite order as defined\r\n\t    // causing them to not be found, so this method swaps [#|.]sel1[#|.]sel2 to become [#|.]sel2[#|.]sel1\r\n\t    function swapAdjSelAttr(selector) {\r\n\t        var swap = '';\r\n\t        var lastIndex = 0;\r\n\t\r\n\t        while ((match = adjSelAttrRegex.exec(selector)) != null) {\r\n\t            if (match[0] === '')\r\n\t                break;\r\n\t            swap += selector.substring(lastIndex, match.index);\r\n\t            swap += selector.substr(match.index + match[1].length, match[2].length);\r\n\t            swap += selector.substr(match.index, match[1].length);\r\n\t            lastIndex = match.index + match[0].length;\r\n\t        }\r\n\t        swap += selector.substr(lastIndex);\r\n\t\r\n\t        return swap;\r\n\t    };\r\n\t\r\n\t    // FF and older browsers store rules with pseudo elements using single-colon syntax\r\n\t    function swapPseudoElSyntax(selector) {\r\n\t        if (doubleColonPseudoElRegex.exec(selector)) {\r\n\t            return toSingleColonPseudoElements(selector);\r\n\t        }\r\n\t        return selector;\r\n\t    }\r\n\t\r\n\t    function setStyleProperties(rule, properties) {\r\n\t        for (var key in properties) {\r\n\t            var value = properties[key];\r\n\t            var importantIndex = value.indexOf(' !important');\r\n\t\r\n\t            // Modern browsers seem to handle overrides fine, but IE9 doesn't\r\n\t            rule.style.removeProperty(key);\r\n\t            if (importantIndex > 0) {\r\n\t                rule.style.setProperty(key, value.substr(0, importantIndex), 'important');\r\n\t            } else {\r\n\t                rule.style.setProperty(key, value);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    function toCamelCase(str) {\r\n\t        return str.replace(/-([a-z])/g, function (match, submatch) {\r\n\t            return submatch.toUpperCase();\r\n\t        });\r\n\t    }\r\n\t\r\n\t    function transformCamelCasedPropertyNames(oldProps) {\r\n\t        var newProps = {};\r\n\t        for (var key in oldProps) {\r\n\t            newProps[unCamelCase(key)] = oldProps[key];\r\n\t        }\r\n\t        return newProps;\r\n\t    }\r\n\t\r\n\t    function unCamelCase(str) {\r\n\t        return str.replace(/([A-Z])/g, function(match, submatch) {\r\n\t            return '-' + submatch.toLowerCase();\r\n\t        });\r\n\t    }\r\n\t\r\n\t    var Jss = function(doc) {\r\n\t        this.doc = doc;\r\n\t        this.head = this.doc.head || this.doc.getElementsByTagName('head')[0];\r\n\t        this.sheets = this.doc.styleSheets || [];\r\n\t    };\r\n\t\r\n\t    Jss.prototype = {\r\n\t        // Returns JSS rules (selector is optional)\r\n\t        get: function(selector) {\r\n\t            if (!this.defaultSheet) {\r\n\t                return {};\r\n\t            }\r\n\t            if (selector) {\r\n\t                return aggregateStyles(getRules(this.defaultSheet, selector));\r\n\t            }\r\n\t            var rules = getSelectorsAndRules(this.defaultSheet);\r\n\t            for (selector in rules) {\r\n\t                rules[selector] = aggregateStyles(rules[selector]);\r\n\t            }\r\n\t            return rules;\r\n\t        },\r\n\t        // Returns all rules (selector is required)\r\n\t        getAll: function(selector) {\r\n\t            var properties = {};\r\n\t            for (var i = 0; i < this.sheets.length; i++) {\r\n\t                extend(properties, aggregateStyles(getRules(this.sheets[i], selector)));\r\n\t            }\r\n\t            return properties;\r\n\t        },\r\n\t        // Adds JSS rules for the selector based on the given properties\r\n\t        set: function(selector, properties) {\r\n\t            if (!this.defaultSheet) {\r\n\t                this.defaultSheet = this._createSheet();\r\n\t            }\r\n\t            properties = transformCamelCasedPropertyNames(properties);\r\n\t            var rules = getRules(this.defaultSheet, selector);\r\n\t            if (!rules.length) {\r\n\t                rules = [addRule(this.defaultSheet, selector)];\r\n\t            }\r\n\t            for (var i = 0; i < rules.length; i++) {\r\n\t                setStyleProperties(rules[i], properties);\r\n\t            }\r\n\t        },\r\n\t        // Removes JSS rules (selector is optional)\r\n\t        remove: function(selector) {\r\n\t            if (!this.defaultSheet)\r\n\t                return;\r\n\t            if (!selector) {\r\n\t                this._removeSheet(this.defaultSheet);\r\n\t                delete this.defaultSheet;\r\n\t                return;\r\n\t            }\r\n\t            var rules = getRules(this.defaultSheet, selector);\r\n\t            for (var i = 0; i < rules.length; i++) {\r\n\t                removeRule(rules[i]);\r\n\t            }\r\n\t            return rules.length;\r\n\t        },\r\n\t        _createSheet: function() {\r\n\t            var styleNode = this.doc.createElement('style');\r\n\t            styleNode.type = 'text/css';\r\n\t            styleNode.rel = 'stylesheet';\r\n\t            this.head.appendChild(styleNode);\r\n\t            return styleNode.sheet;\r\n\t        },\r\n\t        _removeSheet: function(sheet) {\r\n\t            var node = sheet.ownerNode;\r\n\t            node.parentNode.removeChild(node);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    var exports = new Jss(document);\r\n\t    exports.forDocument = function(doc) {\r\n\t        return new Jss(doc);\r\n\t    };\r\n\t    return exports;\r\n\t})();\r\n\t\r\n\ttypeof module !== 'undefined' && module.exports && (module.exports = jss); // CommonJS support\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(25)\n\tvar Style = __webpack_require__(2)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t\t// static properties\n\t\n\t\tthis.name = 'ListItem'\n\t\n\t    this.defaultStyle = Style({\n\t        display: 'list-item'\n\t    })\n\t\n\t\t// instance properties\n\t\n\t\tthis.init = function(/*[label,] contents*/) {\n\t        if(arguments.length <= 1) {\n\t            var contents = arguments[0]\n\t        } else {\n\t            var label = arguments[0]\n\t            var contents = arguments[1]\n\t        }\n\t\n\t        this.domNode = document.createElement(\"li\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t\t\tsuperclass.init.call(this) // superclass constructor\n\t\t\tthis.label = label\n\t\n\t        if(contents instanceof Block) {\n\t\t\t\tthis.add(contents)\n\t\t\t} else if(contents !== undefined) {\n\t            this.domNode.textContent = contents\n\t        }\n\t\t}\n\t});\n\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// note: this is  not intended to be used directly - only through Select and MultiSelect\r\n\t\r\n\tvar Block = __webpack_require__(1)\r\n\tvar Style = __webpack_require__(2)\r\n\tvar proto = __webpack_require__(25)\r\n\t//var htmlEntities = require('he')\r\n\t\r\n\t// emits a 'change' event when its 'selected' value changes\r\n\tmodule.exports = proto(Block, function(superclass) {\r\n\t\r\n\t    // staic members\r\n\t\r\n\t    this.name = 'Option'\r\n\t\r\n\t    this.defaultStyle = Style({\r\n\t        display: 'block'\r\n\t    })\r\n\t\r\n\t\r\n\t    // instance members\r\n\t\r\n\t    this.init = function(label, value, text) {\r\n\t        this.domNode = document.createElement(\"option\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\r\n\t        superclass.init.call(this) // superclass constructor\r\n\t\r\n\t        this.label = label\r\n\t\r\n\t        this.text = text\r\n\t        this.val = value\r\n\t    }\r\n\t\r\n\t    Object.defineProperty(this, 'val', {\r\n\t        // returns the value of the Option\r\n\t        get: function() {\r\n\t            return this.attr('value')\r\n\t        },\r\n\t\r\n\t        // sets the value of the Option\r\n\t        set: function(value) {\r\n\t            if(this.parent !== undefined) {\r\n\t                if(this.parent.options[value] !== undefined) {\r\n\t                    throw new Error(\"Can't give an Option the same value as another in the Select or MultiSelect (value: '\"+value+\"')\")\r\n\t                }\r\n\t\r\n\t                if(this.val !== null) {\r\n\t                    delete this.parent.options[this.val]\r\n\t                }\r\n\t\r\n\t                this.parent.options[value] = this\r\n\t            }\r\n\t\r\n\t            this.attr('value', value)\r\n\t\r\n\t        }\r\n\t    })\r\n\t\r\n\t\r\n\t    Object.defineProperty(this, 'selected', {\r\n\t        // returns whether or not the option is selected\r\n\t        get: function() {\r\n\t            return this.domNode.selected\r\n\t        },\r\n\t\r\n\t        // sets the selected state of the option to the passed value (true for selected)\r\n\t        set: function(value) {\r\n\t            var booleanValue = value === true\r\n\t            if(this.selected === booleanValue) return false; // ignore if there's no change\r\n\t\r\n\t            if(this.parent !== undefined)\r\n\t                this.parent.prepareForValueChange([this.val])\r\n\t\r\n\t            this.setSelectedQuiet(booleanValue)\r\n\t\r\n\t            if(this.parent !== undefined)\r\n\t                this.parent.emit('change')\r\n\t        }\r\n\t    })\r\n\t\r\n\t    Object.defineProperty(this, 'text', {\r\n\t        get: function() {\r\n\t            return this.domNode.textContent\r\n\t        },\r\n\t\r\n\t        set: function(text) {\r\n\t            this.domNode.innerText = text // apparently textContent can't be set or something? unclear\r\n\t        }\r\n\t    })\r\n\t\r\n\t\r\n\t    // private\r\n\t\r\n\t    // does everything for setting the selected state except emit the parent's change event\r\n\t    this.setSelectedQuiet = function setOptionSelected(booleanValue) {\r\n\t        if(this.selected === booleanValue) return; // ignore if there's no change\r\n\t\r\n\t        this.domNode.selected = booleanValue\r\n\t        this.emit('change') // the browser has no listenable event that is triggered on change of the 'checked' property\r\n\t    }\r\n\t})\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\tvar RowlikeGenerator = __webpack_require__(29);\n\t\n\tmodule.exports = RowlikeGenerator('th', \"TableHeader\")\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar RowlikeGenerator = __webpack_require__(29);\n\t\n\tmodule.exports = RowlikeGenerator('tr', \"TableRow\")\n\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(25)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t\t// static properties\n\t\n\t\tthis.name = 'TableCell'\n\t\t\n\t\n\t\t// instance properties\n\t\n\t\tthis.init = function(/*[label,] contents*/) {\n\t        if(arguments.length <= 1) {\n\t            var contents = arguments[0]\n\t        } else {\n\t            var label = arguments[0]\n\t            var contents = arguments[1]\n\t        }\n\t\n\t        this.domNode = document.createElement(\"td\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t\t\tsuperclass.init.call(this) // superclass constructor\n\t\t\tthis.label = label\n\t\n\t        if(contents instanceof Block) {\n\t\t\t\tthis.add(contents)\n\t\t\t} else if(contents !== undefined) {\n\t            this.domNode.textContent = contents\n\t        }\n\t\t}\n\t\n\t\tthis.colspan = function(cols) {\n\t\t\tthis.attr('colspan',cols);\n\t\t}\n\t});\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tfunction EventEmitter() {\n\t  this._events = this._events || {};\n\t  this._maxListeners = this._maxListeners || undefined;\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!isNumber(n) || n < 0 || isNaN(n))\n\t    throw TypeError('n must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var er, handler, len, args, i, listeners;\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error') {\n\t    if (!this._events.error ||\n\t        (isObject(this._events.error) && !this._events.error.length)) {\n\t      er = arguments[1];\n\t      if (er instanceof Error) {\n\t        throw er; // Unhandled 'error' event\n\t      }\n\t      throw TypeError('Uncaught, unspecified \"error\" event.');\n\t    }\n\t  }\n\t\n\t  handler = this._events[type];\n\t\n\t  if (isUndefined(handler))\n\t    return false;\n\t\n\t  if (isFunction(handler)) {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        len = arguments.length;\n\t        args = new Array(len - 1);\n\t        for (i = 1; i < len; i++)\n\t          args[i - 1] = arguments[i];\n\t        handler.apply(this, args);\n\t    }\n\t  } else if (isObject(handler)) {\n\t    len = arguments.length;\n\t    args = new Array(len - 1);\n\t    for (i = 1; i < len; i++)\n\t      args[i - 1] = arguments[i];\n\t\n\t    listeners = handler.slice();\n\t    len = listeners.length;\n\t    for (i = 0; i < len; i++)\n\t      listeners[i].apply(this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  var m;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // To avoid recursion in the case that type === \"newListener\"! Before\n\t  // adding it to the listeners, first emit \"newListener\".\n\t  if (this._events.newListener)\n\t    this.emit('newListener', type,\n\t              isFunction(listener.listener) ?\n\t              listener.listener : listener);\n\t\n\t  if (!this._events[type])\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  else if (isObject(this._events[type]))\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t  else\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t\n\t  // Check for listener leak\n\t  if (isObject(this._events[type]) && !this._events[type].warned) {\n\t    var m;\n\t    if (!isUndefined(this._maxListeners)) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = EventEmitter.defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t      console.error('(node) warning: possible EventEmitter memory ' +\n\t                    'leak detected. %d listeners added. ' +\n\t                    'Use emitter.setMaxListeners() to increase limit.',\n\t                    this._events[type].length);\n\t      if (typeof console.trace === 'function') {\n\t        // not supported in IE 10\n\t        console.trace();\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  var list, position, length, i;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events || !this._events[type])\n\t    return this;\n\t\n\t  list = this._events[type];\n\t  length = list.length;\n\t  position = -1;\n\t\n\t  if (list === listener ||\n\t      (isFunction(list.listener) && list.listener === listener)) {\n\t    delete this._events[type];\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t\n\t  } else if (isObject(list)) {\n\t    for (i = length; i-- > 0;) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener)) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0)\n\t      return this;\n\t\n\t    if (list.length === 1) {\n\t      list.length = 0;\n\t      delete this._events[type];\n\t    } else {\n\t      list.splice(position, 1);\n\t    }\n\t\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  var key, listeners;\n\t\n\t  if (!this._events)\n\t    return this;\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!this._events.removeListener) {\n\t    if (arguments.length === 0)\n\t      this._events = {};\n\t    else if (this._events[type])\n\t      delete this._events[type];\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    for (key in this._events) {\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  listeners = this._events[type];\n\t\n\t  if (isFunction(listeners)) {\n\t    this.removeListener(type, listeners);\n\t  } else {\n\t    // LIFO order\n\t    while (listeners.length)\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t  }\n\t  delete this._events[type];\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  var ret;\n\t  if (!this._events || !this._events[type])\n\t    ret = [];\n\t  else if (isFunction(this._events[type]))\n\t    ret = [this._events[type]];\n\t  else\n\t    ret = this._events[type].slice();\n\t  return ret;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  var ret;\n\t  if (!emitter._events || !emitter._events[type])\n\t    ret = 0;\n\t  else if (isFunction(emitter._events[type]))\n\t    ret = 1;\n\t  else\n\t    ret = emitter._events[type].length;\n\t  return ret;\n\t};\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t/* Copyright (c) 2013 Billy Tetrud - Free to use for any purpose: MIT License*/\r\n\t\r\n\tvar noop = function() {}\r\n\t\r\n\tvar prototypeName='prototype', undefined, protoUndefined='undefined', init='init', ownProperty=({}).hasOwnProperty; // minifiable variables\r\n\tfunction proto() {\r\n\t    var args = arguments // minifiable variables\r\n\t\r\n\t    if(args.length == 1) {\r\n\t        var parent = {init: noop}   // set noop init so that every parent has an init\r\n\t        var prototypeBuilder = args[0]\r\n\t\r\n\t    } else { // length == 2\r\n\t        var parent = args[0]\r\n\t        var prototypeBuilder = args[1]\r\n\t    }\r\n\t\r\n\t    // special handling for Error objects\r\n\t    var namePointer = {}    // name used only for Error Objects\r\n\t    if([Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError].indexOf(parent) !== -1) {\r\n\t        parent = normalizeErrorObject(parent, namePointer)\r\n\t    }\r\n\t\r\n\t    // set up the parent into the prototype chain if a parent is passed\r\n\t    var parentIsFunction = typeof(parent) === \"function\"\r\n\t    if(parentIsFunction) {\r\n\t        prototypeBuilder[prototypeName] = parent[prototypeName]\r\n\t    } else {\r\n\t        prototypeBuilder[prototypeName] = parent\r\n\t    }\r\n\t\r\n\t    // the prototype that will be used to make instances\r\n\t    var prototype = new prototypeBuilder(parent)\r\n\t    namePointer.name = prototype.name\r\n\t\r\n\t    var ProtoObjectFactory = namedFunction(prototype.name, function() {     // result object factory\r\n\t        var x = new F()          // empty object\r\n\t\r\n\t        if(prototype[init]) {\r\n\t            var result = prototype[init].apply(x, arguments)    // populate object via the constructor\r\n\t            if(result === proto[protoUndefined])\r\n\t                return undefined\r\n\t            else if(result !== undefined)\r\n\t                return result\r\n\t            else\r\n\t                return x\r\n\t        } else {\r\n\t            return x\r\n\t        }\r\n\t    })\r\n\t\r\n\t    prototype.constructor = ProtoObjectFactory;    // set the constructor property on the prototype\r\n\t\r\n\t\r\n\t    // if there's no init, assume its inheriting a non-proto class, so default to applying the superclass's constructor.\r\n\t    if(!prototype[init] && parentIsFunction) {\r\n\t        prototype[init] = function() {\r\n\t            parent.apply(this, arguments)\r\n\t        }\r\n\t    }\r\n\t\r\n\t    // constructor for empty object which will be populated via the constructor\r\n\t    var F = function() {}\r\n\t        F[prototypeName] = prototype    // set the prototype for created instances\r\n\t\r\n\t    // add all the prototype properties onto the static class as well (so you can access that class when you want to reference superclass properties)\r\n\t    for(var n in prototype) {\r\n\t        addProperty(ProtoObjectFactory, prototype, n)\r\n\t    }\r\n\t\r\n\t    // add properties from parent that don't exist in the static class object yet\r\n\t    for(var n in parent) {\r\n\t        if(Object.hasOwnProperty.call(parent, n) && ProtoObjectFactory[n] === undefined) {\r\n\t            addProperty(ProtoObjectFactory, parent, n)\r\n\t        }\r\n\t    }\r\n\t\r\n\t    ProtoObjectFactory.parent = parent;            // special parent property only available on the returned proto class\r\n\t    ProtoObjectFactory[prototypeName] = prototype  // set the prototype on the object factory\r\n\t\r\n\t    return ProtoObjectFactory;\r\n\t}\r\n\t\r\n\tproto[protoUndefined] = {} // a special marker for when you want to return undefined from a constructor\r\n\t\r\n\tmodule.exports = proto\r\n\t\r\n\tfunction normalizeErrorObject(ErrorObject, namePointer) {\r\n\t    function NormalizedError() {\r\n\t        var tmp = new ErrorObject(arguments[0])\r\n\t        tmp.name = namePointer.name\r\n\t\r\n\t        this.message = tmp.message\r\n\t        if(Object.defineProperty) {\r\n\t            /*this.stack = */Object.defineProperty(this, 'stack', { // getter for more optimizy goodness\r\n\t                get: function() {\r\n\t                    return tmp.stack\r\n\t                }\r\n\t            })\r\n\t        } else {\r\n\t            this.stack = tmp.stack\r\n\t        }\r\n\t\r\n\t        return this\r\n\t    }\r\n\t\r\n\t    var IntermediateInheritor = function() {}\r\n\t        IntermediateInheritor.prototype = ErrorObject.prototype\r\n\t    NormalizedError.prototype = new IntermediateInheritor()\r\n\t\r\n\t    return NormalizedError\r\n\t}\r\n\t\r\n\tfunction addProperty(factoryObject, prototype, property) {\r\n\t    try {\r\n\t        var info = Object.getOwnPropertyDescriptor(prototype, property)\r\n\t        if(info.get !== undefined || info.get !== undefined && Object.defineProperty !== undefined) {\r\n\t            Object.defineProperty(factoryObject, property, info)\r\n\t        } else {\r\n\t            factoryObject[property] = prototype[property]\r\n\t        }\r\n\t    } catch(e) {\r\n\t        // do nothing, if a property (like `name`) can't be set, just ignore it\r\n\t    }\r\n\t}\r\n\t\r\n\t// returns the function named with the passed name\r\n\tfunction namedFunction(name, fn) {\r\n\t    if(name !== undefined) {\r\n\t        return new Function('fn',\r\n\t            \"return function \" + name + \"(){ return fn.apply(this,arguments)}\"\r\n\t        )(fn)\r\n\t    } else {\r\n\t        return fn\r\n\t    }\r\n\t\r\n\t}\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// resolves varargs variable into more usable form\n\t// args - should be a function arguments variable\n\t// returns a javascript Array object of arguments that doesn't count trailing undefined values in the length\n\tmodule.exports = function(theArguments) {\n\t    var args = Array.prototype.slice.call(theArguments, 0)\n\t\n\t    var count = 0;\n\t    for(var n=args.length-1; n>=0; n--) {\n\t        if(args[n] === undefined)\n\t            count++\n\t        else\n\t            break\n\t    }\n\t    args.splice(args.length-count, count)\n\t    return args\n\t}\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar proto = __webpack_require__(25)\r\n\tvar EventEmitter = __webpack_require__(24).EventEmitter\r\n\tvar utils = __webpack_require__(31)\r\n\t\r\n\t\r\n\t// emits the event:\r\n\t    // change - the event data is an object of one of the following forms:\r\n\t        // {id:_, type: 'set', property: propertyList}\r\n\t        // {id:_, type: 'added', property: propertyList, index:_, count: numberOfElementsAdded}\r\n\t        // {id:_, type: 'removed', property: propertyList, index:_, values: removedValues}\r\n\tvar Observe = module.exports = proto(EventEmitter, function() {\r\n\t\r\n\t    // static members\r\n\t\r\n\t    this.init = function(obj) {\r\n\t        this.subject = obj\r\n\t\r\n\t        this.setMaxListeners(1000)\r\n\t    }\r\n\t\r\n\t    // instance members\r\n\t\r\n\t    // gets an element or member of the subject and returns another Observee\r\n\t    // changes to the returned Observee will be emitted by its parent as well\r\n\t    this.get = function(property) {\r\n\t        return ObserveeChild(this, parsePropertyList(property))\r\n\t    }\r\n\t\r\n\t    // sets a value on the subject\r\n\t    // property - either an array of members to select, or a string where properties to select are separated by dots\r\n\t    // value - the value to set\r\n\t    this.set = function(property, value) {\r\n\t        setInternal(this, parsePropertyList(property), value, {})\r\n\t    }\r\n\t\r\n\t    // pushes a value onto a list\r\n\t    this.push = function(/*value...*/) {\r\n\t        pushInternal(this, [], arguments, {})\r\n\t    }\r\n\t\r\n\t\r\n\t    // index is the index to remove/insert at\r\n\t    // countToRemove is the number to remove\r\n\t    // elementsToAdd is a list of elements to add\r\n\t    this.splice = function(/*index, countToRemove[, elementsToAdd]*/) {\r\n\t        return spliceInternal(this, [], arguments, {})\r\n\t    }\r\n\t\r\n\t    // use this instead of concat for mutation behavior\r\n\t    this.append = function(arrayToAppend) {\r\n\t        appendInternal(this, [], arguments, {})\r\n\t    }\r\n\t\r\n\t    this.id = function(id) {\r\n\t        return ObserveeChild(this, [], {id: id})\r\n\t        //return idFunction(this, [], id)\r\n\t    }\r\n\t\r\n\t    // For the returned object, any property added via set, push, splice, or append joins an internal observee together with this observee, so that\r\n\t    //      the internal observee and the containing observee will both send 'change' events appropriately\r\n\t    // collapse - (default: false) if true, any property added will be set to the subject of the value added (so that value won't be an observee anymore\r\n\t        // note: only use collapse:true if the observees you're unioning isn't actually an object that inherits from an observee - any instance methods on the observee that come from child classes won't be accessible anymore\r\n\t        // e.g. var x = observe({a:5})\r\n\t        //      var b = observe({})\r\n\t        //      x.subject.a === 5    ;; true\r\n\t        //      b.union(true).set('x', x)\r\n\t        //      b.subject.x.a === 5            ;; true\r\n\t        //      b.subject.x.subject.a === 5    ;; false\r\n\t    this.union = function(collapse) {\r\n\t        if(collapse === undefined) collapse = false\r\n\t        return ObserveeChild(this, [], {union: collapse})\r\n\t    }\r\n\t\r\n\t\r\n\t    /* pause and unpause may cause weird affects in certain cases (e.g. if you remove an element at index 4 and *then* add an element at index 2)\r\n\t    // pause sending events (for when you want to do a lot of things to an object)\r\n\t    this.pause = function() {\r\n\t        this.paused = true\r\n\t    }\r\n\t    this.unpause = function() {\r\n\t        this.paused = undefined\r\n\t        sendEvent(this)\r\n\t    }*/\r\n\t})\r\n\t\r\n\t\r\n\tfunction parsePropertyList(property) {\r\n\t    if(!(property instanceof Array)) {\r\n\t        property = property.toString().split('.')\r\n\t    }\r\n\t\r\n\t    return property\r\n\t}\r\n\t\r\n\tfunction getPropertyPointer(subject, propertyList) {\r\n\t    var current = subject\r\n\t    for(var n=0; n<propertyList.length-1; n++) {\r\n\t        current = current[propertyList[n]]\r\n\t    }\r\n\t\r\n\t    return {obj: current, key:propertyList[n]}\r\n\t}\r\n\t\r\n\tvar getPropertyValue = module.exports.getPropertyValue = function(subject, property) {\r\n\t    var pointer = getPropertyPointer(subject, property)\r\n\t    if(pointer.key !== undefined) {\r\n\t        return pointer.obj[pointer.key]\r\n\t    } else {\r\n\t        return pointer.obj\r\n\t    }\r\n\t}\r\n\t\r\n\t// private\r\n\t\r\n\t// options can have the properties:\r\n\t    // union - if true, any value set, pushed, appended, or spliced onto the observee is unioned\r\n\tvar ObserveeChild = proto(EventEmitter, function() {\r\n\t\r\n\t    this.init = function(parent, propertyList, options) {\r\n\t        if(options === undefined) this.options = {}\r\n\t        else                      this.options = options\r\n\t\r\n\t        if(parent._observeeParent !== undefined)\r\n\t            this._observeeParent = parent._observeeParent\r\n\t        else\r\n\t            this._observeeParent = parent\r\n\t\r\n\t        this.property = propertyList\r\n\t        this.subject = getPropertyValue(parent.subject, propertyList)\r\n\t\r\n\t        var that = this\r\n\t        parent.on('change', function(change) {\r\n\t            var answers = changeQuestions(that.property, change)\r\n\t\r\n\t            if(answers.isWithin ) {\r\n\t                that.emit('change', {type:change.type, property: change.property.slice(that.property.length), index:change.index, count:change.count, removed: change.removed})\r\n\t            } else if(answers.couldRelocate) {\r\n\t                if(change.type === 'removed') {\r\n\t                    var relevantIndex = that.property[change.property.length]\r\n\t                    var removedIndexesAreBeforeIndexOfObserveeChild = change.index + change.removed.length - 1 < relevantIndex\r\n\t\r\n\t                    if(removedIndexesAreBeforeIndexOfObserveeChild) {\r\n\t                        that.property[change.property.length] = relevantIndex - change.removed.length // change the propertyList to match the new index\r\n\t                    }\r\n\t                } else if(change.type === 'added') {\r\n\t                    var relevantIndex = that.property[change.property.length]\r\n\t                    if(change.index < relevantIndex) {\r\n\t                        that.property[change.property.length] = relevantIndex + change.count // change the propertyList to match the new index\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        })\r\n\t    }\r\n\t\r\n\t    this.get = function(property) {\r\n\t        return this._observeeParent.get(this.property.concat(parsePropertyList(property)))\r\n\t    }\r\n\t\r\n\t    this.set = function(property, value) {\r\n\t        setInternal(this._observeeParent, this.property.concat(parsePropertyList(property)), value, this.options)\r\n\t    }\r\n\t\r\n\t    this.push = function(/*values...*/) {\r\n\t        pushInternal(this._observeeParent, this.property, arguments, this.options)\r\n\t    }\r\n\t\r\n\t    this.splice = function(index, countToRemove/*[, elementsToAdd....]*/) {\r\n\t        spliceInternal(this._observeeParent, this.property, arguments, this.options)\r\n\t    }\r\n\t\r\n\t    this.append = function(/*[property,] arrayToAppend*/) {\r\n\t        appendInternal(this._observeeParent, this.property, arguments, this.options)\r\n\t    }\r\n\t\r\n\t    this.id = function(id) {\r\n\t        return ObserveeChild(this, this.property, utils.merge({}, this.options, {id: id}))\r\n\t        //return idFunction(this._observeeParent, this.property, id)\r\n\t    }\r\n\t\r\n\t    this.union = function(collapse) {\r\n\t        if(collapse === undefined) collapse = false\r\n\t        return ObserveeChild(this, [], utils.merge({}, this.options, {union: collapse}))\r\n\t    }\r\n\t\r\n\t})\r\n\t\r\n\t     /*\r\n\tfunction idFunction(that, propertyList, id) {\r\n\t    var result = {\r\n\t        set: function(property, value) {\r\n\t            var fullPropertyList = propertyList.concat(parsePropertyList(property))\r\n\t            setInternal(that, fullPropertyList, value, id)\r\n\t        },\r\n\t        push: function() {\r\n\t            pushInternal(that, propertyList, arguments, id)\r\n\t        },\r\n\t        splice: function() {\r\n\t            spliceInternal(that, propertyList, arguments, id)\r\n\t        },\r\n\t        append: function() {\r\n\t            appendInternal(that, propertyList, arguments, id)\r\n\t        },\r\n\t        get: function() {\r\n\t\r\n\t        }\r\n\t    }\r\n\t}\r\n\t*/\r\n\t\r\n\t// that - the Observee object\r\n\tfunction setInternal(that, propertyList, value, options) {\r\n\t    var pointer = getPropertyPointer(that.subject, propertyList)\r\n\t\r\n\t    var internalObservee = value\r\n\t    if(options.union === true) {\r\n\t        value = value.subject\r\n\t    }\r\n\t\r\n\t    pointer.obj[pointer.key] = value\r\n\t\r\n\t    var event = {type: 'set', property: propertyList}\r\n\t    if(options.id !== undefined) event.id = options.id\r\n\t    that.emit('change',event)\r\n\t\r\n\t    if(options.union !== undefined)\r\n\t        unionizeEvents(that, internalObservee, propertyList, options.union)\r\n\t}\r\n\t\r\n\tfunction pushInternal(that, propertyList, args, options) {\r\n\t    var array = getPropertyValue(that.subject, propertyList)\r\n\t    var originalLength = array.length\r\n\t    array.push.apply(array, args)\r\n\t\r\n\t    var internalObservees = unionizeList(array, originalLength, args.length, options.union)\r\n\t\r\n\t    var event = {type: 'added', property: propertyList, index: originalLength, count: 1}\r\n\t    if(options.id !== undefined) event.id = options.id\r\n\t    that.emit('change', event)\r\n\t\r\n\t    unionizeListEvents(that, internalObservees, propertyList, options.union)\r\n\t}\r\n\t\r\n\tfunction spliceInternal(that, propertyList, args, options) {\r\n\t    var index = args[0]\r\n\t    var countToRemove = args[1]\r\n\t\r\n\t    var array = getPropertyValue(that.subject, propertyList)\r\n\t    var result = array.splice.apply(array, args)\r\n\t\r\n\t    if(countToRemove > 0) {\r\n\t        var event = {type: 'removed', property: propertyList, index: index, removed: result}\r\n\t        if(options.id !== undefined) event.id = options.id\r\n\t        that.emit('change', event)\r\n\t    }\r\n\t    if(args.length > 2) {\r\n\t        var event = {type: 'added', property: propertyList, index: index, count: args.length-2}\r\n\t\r\n\t        var internalObservees = unionizeList(array, index, event.count, options.union)\r\n\t\r\n\t        if(options.id !== undefined) event.id = options.id\r\n\t        that.emit('change', event)\r\n\t\r\n\t        unionizeListEvents(that, internalObservees, propertyList, options.union)\r\n\t    }\r\n\t\r\n\t    return result\r\n\t}\r\n\t\r\n\t// note: I'm not using splice to do this as an optimization (because otherwise the property list would have to be parsed twice and the value gotten twice) - maybe this optimization wasn't worth it but its already done\r\n\tfunction appendInternal(that, propertyList, args, options) {\r\n\t    var arrayToAppend = args[0]\r\n\t    if(arrayToAppend.length === 0) return; //nothing to do\r\n\t\r\n\t    var array = getPropertyValue(that.subject, propertyList)\r\n\t    var originalLength = array.length\r\n\t\r\n\t    var spliceArgs = [originalLength, 0]\r\n\t    spliceArgs = spliceArgs.concat(arrayToAppend)\r\n\t    var oldLength = array.length\r\n\t    array.splice.apply(array, spliceArgs)\r\n\t\r\n\t    var internalObservees = unionizeList(array, oldLength, array.length, options.union)\r\n\t\r\n\t    var event = {type: 'added', property: propertyList, index: originalLength, count: arrayToAppend.length}\r\n\t    if(options.id !== undefined) event.id = options.id\r\n\t    that.emit('change', event)\r\n\t\r\n\t    unionizeListEvents(that, internalObservees, propertyList, options.union)\r\n\t}\r\n\t\r\n\t// sets a slice of elements to their subjects and\r\n\t// returns the original observee objects along with their indexes\r\n\tfunction unionizeList(array, start, count, union) {\r\n\t    var internalObservees = [] // list of observees and their property path\r\n\t    if(union !== undefined) {\r\n\t        var afterEnd = start+count\r\n\t        for(var n=start; n<afterEnd; n++) {\r\n\t            internalObservees.push({obj: array[n], index: n})\r\n\t            if(union === true)\r\n\t                array[n] = array[n].subject\r\n\t        }\r\n\t    }\r\n\t\r\n\t    return internalObservees\r\n\t}\r\n\t\r\n\t// runs unionizeEvents for elements in a list\r\n\t// internalObservees should be the result from `unionizeList`\r\n\tfunction unionizeListEvents(that, internalObservees, propertyList, collapse) {\r\n\t    for(var n=0; n<internalObservees.length; n++) {\r\n\t        unionizeEvents(that, internalObservees[n].obj, propertyList.concat(internalObservees[n].index), collapse)\r\n\t    }\r\n\t}\r\n\t\r\n\t\r\n\t// sets up the union change events for an observee with one of its inner properties\r\n\t// parameters:\r\n\t    // that - the container observee\r\n\t    // innerObservee - the contained observee\r\n\t    // propertyList - the propertyList to unionize\r\n\t    // collapse - the union option (true for collapse)\r\n\tfunction unionizeEvents(that, innerObservee, propertyList, collapse) {\r\n\t    var propertyListDepth = propertyList.length\r\n\t\r\n\t    if(innerObservee.on === undefined || innerObservee.emit === undefined || innerObservee.removeListener === undefined || innerObservee.set === undefined) {\r\n\t        throw new Error(\"Attempting to union a value that isn't an observee\")\r\n\t    }\r\n\t\r\n\t    var innerChangeHandler, containerChangeHandler\r\n\t    var ignorableContainerEvents = [], ignorableInnerEvents = []\r\n\t    innerObservee.on('change', innerChangeHandler = function(change) {\r\n\t        if(ignorableInnerEvents.indexOf(change) === -1) {        // don't run this for events generated by the union event handlers\r\n\t            if(collapse) {\r\n\t                var property = propertyList.concat(change.property)\r\n\t            } else {\r\n\t                var property = propertyList.concat(['subject']).concat(change.property)\r\n\t            }\r\n\t\r\n\t            var containerChange = utils.merge({}, change, {property: property})\r\n\t            ignorableContainerEvents.push(containerChange)\r\n\t            that.emit('change', containerChange)\r\n\t        }\r\n\t    })\r\n\t    that.on('change', containerChangeHandler = function(change) {\r\n\t        var changedPropertyDepth = change.property.length\r\n\t\r\n\t        var answers = changeQuestions(propertyList, change)\r\n\t        var changeIsWithinInnerProperty = answers.isWithin\r\n\t        var changeCouldRelocateInnerProperty = answers.couldRelocate\r\n\t\r\n\t        if(changeIsWithinInnerProperty && ignorableContainerEvents.indexOf(change) === -1) {   // don't run this for events generated by the union event handlers\r\n\t            if(collapse) {\r\n\t                var property = change.property.slice(propertyListDepth)\r\n\t            } else {\r\n\t                var property = change.property.slice(propertyListDepth+1) // +1 for the 'subject'\r\n\t            }\r\n\t\r\n\t            var innerObserveeEvent = utils.merge({}, change, {property: property})\r\n\t            ignorableInnerEvents.push(innerObserveeEvent)\r\n\t            innerObservee.emit('change', innerObserveeEvent)\r\n\t        } else if(changeCouldRelocateInnerProperty) {\r\n\t            if(change.type === 'set' /*&& changedPropertyDepth <= propertyListDepth  - this part already done above*/) {\r\n\t                removeUnion()\r\n\t            } else if(change.type === 'removed') {\r\n\t                var relevantIndex = propertyList[change.property.length]\r\n\t                var removedIndexesContainsIndexOfInnerObservee = change.index <= relevantIndex && relevantIndex <= change.index + change.removed.length - 1\r\n\t                var removedIndexesAreBeforeIndexOfInnerObservee = change.index + change.removed.length - 1 < relevantIndex && relevantIndex\r\n\t\r\n\t                if(removedIndexesContainsIndexOfInnerObservee && changedPropertyDepth <= propertyListDepth+1) {\r\n\t                    removeUnion()\r\n\t                } else if(removedIndexesAreBeforeIndexOfInnerObservee) {\r\n\t                    propertyList[change.property.length] = relevantIndex - change.removed.length // change the propertyList to match the new index\r\n\t                }\r\n\t            } else if(change.type === 'added') {\r\n\t                var relevantIndex = propertyList[change.property.length]\r\n\t                if(change.index < relevantIndex) {\r\n\t                    propertyList[change.property.length] = relevantIndex + change.count // change the propertyList to match the new index\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    })\r\n\t\r\n\t    var removeUnion = function() {\r\n\t        innerObservee.removeListener('change', innerChangeHandler)\r\n\t        that.removeListener('change', containerChangeHandler)\r\n\t    }\r\n\t}\r\n\t\r\n\t\r\n\t// answers certain questions about a change compared to a property list\r\n\t// returns an object like: {\r\n\t    // isWithin: _,           // true if changeIsWithinInnerProperty\r\n\t    // couldRelocate: _       // true if changeCouldRelocateInnerProperty or if innerProperty might be removed\r\n\t// }\r\n\tfunction changeQuestions(propertyList, change) {\r\n\t    var propertyListDepth = propertyList.length\r\n\t\r\n\t    var changeIsWithinInnerProperty = true // assume true until proven otherwise\r\n\t    var changeCouldRelocateInnerProperty = true // assume true until prove otherwise\r\n\t    for(var n=0; n<propertyListDepth; n++) {\r\n\t        if(change.property[n] !== propertyList[n]) {\r\n\t            changeIsWithinInnerProperty = false\r\n\t            if(n<change.property.length) {\r\n\t                changeCouldRelocateInnerProperty = false\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    if(change.property.length <= propertyListDepth) {\r\n\t        changeIsWithinInnerProperty = false\r\n\t    } else {\r\n\t        changeCouldRelocateInnerProperty = false\r\n\t    }\r\n\t\r\n\t    return {couldRelocate: changeCouldRelocateInnerProperty, isWithin: changeIsWithinInnerProperty}\r\n\t}\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\r\n\t * HashMap - HashMap Class for JavaScript\r\n\t * @author Ariel Flesler <aflesler@gmail.com>\r\n\t * @version 2.0.0\r\n\t * Homepage: https://github.com/flesler/hashmap\r\n\t */\r\n\t\r\n\t(function (factory) {\r\n\t\tif (true) {\r\n\t\t\t// AMD. Register as an anonymous module.\r\n\t\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t\t} else if (typeof exports === 'object') {\r\n\t\t\t// Node js environment\r\n\t\t\texports.HashMap = factory();\r\n\t\t} else {\r\n\t\t\t// Browser globals (this is window)\r\n\t\t\tthis.HashMap = factory();\r\n\t\t}\r\n\t}(function () {\r\n\t\t\r\n\t\tfunction HashMap(other) {\r\n\t\t\tthis.clear();\r\n\t\t\tswitch (arguments.length) {\r\n\t\t\t\tcase 0: break;\r\n\t\t\t\tcase 1: this.copy(other); break;\r\n\t\t\t\tdefault: multi(this, arguments); break;\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar proto = HashMap.prototype = {\r\n\t\t\tconstructor:HashMap,\r\n\t\r\n\t\t\tget:function(key) {\r\n\t\t\t\tvar data = this._data[this.hash(key)];\r\n\t\t\t\treturn data && data[1];\r\n\t\t\t},\r\n\t\t\t\r\n\t\t\tset:function(key, value) {\r\n\t\t\t\t// Store original key as well (for iteration)\r\n\t\t\t\tthis._data[this.hash(key)] = [key, value];\r\n\t\t\t},\r\n\t\r\n\t\t\tmulti:function() {\r\n\t\t\t\tmulti(this, arguments);\r\n\t\t\t},\r\n\t\r\n\t\t\tcopy:function(other) {\r\n\t\t\t\tfor (var key in other._data) {\r\n\t\t\t\t\tthis._data[key] = other._data[key];\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t\r\n\t\t\thas:function(key) {\r\n\t\t\t\treturn this.hash(key) in this._data;\r\n\t\t\t},\r\n\t\t\t\r\n\t\t\tsearch:function(value) {\r\n\t\t\t\tfor (var key in this._data) {\r\n\t\t\t\t\tif (this._data[key][1] === value) {\r\n\t\t\t\t\t\treturn this._data[key][0];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn null;\r\n\t\t\t},\r\n\t\t\t\r\n\t\t\tremove:function(key) {\r\n\t\t\t\tdelete this._data[this.hash(key)];\r\n\t\t\t},\r\n\t\r\n\t\t\ttype:function(key) {\r\n\t\t\t\tvar str = Object.prototype.toString.call(key);\r\n\t\t\t\tvar type = str.slice(8, -1).toLowerCase();\r\n\t\t\t\t// Some browsers yield DOMWindow for null and undefined, works fine on Node\r\n\t\t\t\tif (type === 'domwindow' && !key) {\r\n\t\t\t\t\treturn key + '';\r\n\t\t\t\t}\r\n\t\t\t\treturn type;\r\n\t\t\t},\r\n\t\r\n\t\t\tkeys:function() {\r\n\t\t\t\tvar keys = [];\r\n\t\t\t\tthis.forEach(function(value, key) { keys.push(key); });\r\n\t\t\t\treturn keys;\r\n\t\t\t},\r\n\t\r\n\t\t\tvalues:function() {\r\n\t\t\t\tvar values = [];\r\n\t\t\t\tthis.forEach(function(value) { values.push(value); });\r\n\t\t\t\treturn values;\r\n\t\t\t},\r\n\t\r\n\t\t\tcount:function() {\r\n\t\t\t\treturn this.keys().length;\r\n\t\t\t},\r\n\t\r\n\t\t\tclear:function() {\r\n\t\t\t\t// TODO: Would Object.create(null) make any difference\r\n\t\t\t\tthis._data = {};\r\n\t\t\t},\r\n\t\r\n\t\t\tclone:function() {\r\n\t\t\t\treturn new HashMap(this);\r\n\t\t\t},\r\n\t\r\n\t\t\thash:function(key) {\r\n\t\t\t\tswitch (this.type(key)) {\r\n\t\t\t\t\tcase 'undefined':\r\n\t\t\t\t\tcase 'null':\r\n\t\t\t\t\tcase 'boolean':\r\n\t\t\t\t\tcase 'number':\r\n\t\t\t\t\tcase 'regexp':\r\n\t\t\t\t\t\treturn key + '';\r\n\t\r\n\t\t\t\t\tcase 'date':\r\n\t\t\t\t\t\treturn ':' + key.getTime();\r\n\t\r\n\t\t\t\t\tcase 'string':\r\n\t\t\t\t\t\treturn '\"' + key;\r\n\t\r\n\t\t\t\t\tcase 'array':\r\n\t\t\t\t\t\tvar hashes = [];\r\n\t\t\t\t\t\tfor (var i = 0; i < key.length; i++)\r\n\t\t\t\t\t\t\thashes[i] = this.hash(key[i]);\r\n\t\t\t\t\t\treturn '[' + hashes.join('|');\r\n\t\r\n\t\t\t\t\tcase 'object':\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t// TODO: Don't use expandos when Object.defineProperty is not available?\r\n\t\t\t\t\t\tif (!key._hmuid_) {\r\n\t\t\t\t\t\t\tkey._hmuid_ = ++HashMap.uid;\r\n\t\t\t\t\t\t\thide(key, '_hmuid_');\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\treturn '{' + key._hmuid_;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tforEach:function(func) {\r\n\t\t\t\tfor (var key in this._data) {\r\n\t\t\t\t\tvar data = this._data[key];\r\n\t\t\t\t\tfunc.call(this, data[1], data[0]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\tHashMap.uid = 0;\r\n\t\r\n\t\t//- Automatically add chaining to some methods\r\n\t\r\n\t\tfor (var method in proto) {\r\n\t\t\t// Skip constructor, valueOf, toString and any other built-in method\r\n\t\t\tif (method === 'constructor' || !proto.hasOwnProperty(method)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tvar fn = proto[method];\r\n\t\t\tif (fn.toString().indexOf('return ') === -1) {\r\n\t\t\t\tproto[method] = chain(fn);\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\t//- Utils\r\n\t\r\n\t\tfunction multi(map, args) {\r\n\t\t\tfor (var i = 0; i < args.length; i += 2) {\r\n\t\t\t\tmap.set(args[i], args[i+1])\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction chain(fn) {\r\n\t\t\treturn function() {\r\n\t\t\t\tfn.apply(this, arguments);\r\n\t\t\t\treturn this;\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\tfunction hide(obj, prop) {\r\n\t\t\t// Make non iterable if supported\r\n\t\t\tif (Object.defineProperty) {\r\n\t\t\t\tObject.defineProperty(obj, prop, {enumerable:false});\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\treturn HashMap;\r\n\t\r\n\t}));\r\n\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar proto = __webpack_require__(25)\r\n\t\r\n\tvar Block = __webpack_require__(1)\r\n\tvar Style = __webpack_require__(2)\r\n\tvar Cell = __webpack_require__(23);\r\n\t\r\n\t// generates either a Header or a Row, depending on what you pass in\r\n\t// elementType should either be \"tr\" or \"th\r\n\t// name should either be \"Header\" or \"Row\r\n\tmodule.exports = function(elementType, name) {\r\n\t    return proto(Block, function(superclass) {\r\n\t\r\n\t        // static properties\r\n\t\r\n\t        this.name = name\r\n\t\r\n\t        this.defaultStyle = Style({\r\n\t            display: 'table-row'\r\n\t        })\r\n\t\r\n\t\r\n\t        // instance properties\r\n\t\r\n\t        this.init = function(/*[label,] rowInit*/) {\r\n\t            if(arguments[0] instanceof Array) {\r\n\t                var rowInit = arguments[0]\r\n\t            } else {\r\n\t                var label = arguments[0]\r\n\t                var rowInit = arguments[1]\r\n\t            }\r\n\t\r\n\t            this.domNode = document.createElement(elementType) // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\r\n\t            superclass.init.call(this) // superclass constructor\r\n\t            this.label = label\r\n\t\r\n\t            if(rowInit !== undefined) {\r\n\t                for(var n=0; n<rowInit.length; n++) {\r\n\t                    this.cell(rowInit[n])\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        this.cell = function(/*[label,] contents*/) {\r\n\t            var cell = Cell.apply(undefined, arguments);\r\n\t            this.add(cell);\r\n\t            return cell;\r\n\t        }\r\n\t    })\r\n\t}\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t// resolves . and .. elements in a path array with directory names there\n\t// must be no slashes, empty elements, or device names (c:\\) in the array\n\t// (so also no leading and trailing slashes - it does not distinguish\n\t// relative and absolute paths)\n\tfunction normalizeArray(parts, allowAboveRoot) {\n\t  // if the path tries to go above the root, `up` ends up > 0\n\t  var up = 0;\n\t  for (var i = parts.length - 1; i >= 0; i--) {\n\t    var last = parts[i];\n\t    if (last === '.') {\n\t      parts.splice(i, 1);\n\t    } else if (last === '..') {\n\t      parts.splice(i, 1);\n\t      up++;\n\t    } else if (up) {\n\t      parts.splice(i, 1);\n\t      up--;\n\t    }\n\t  }\n\t\n\t  // if the path is allowed to go above the root, restore leading ..s\n\t  if (allowAboveRoot) {\n\t    for (; up--; up) {\n\t      parts.unshift('..');\n\t    }\n\t  }\n\t\n\t  return parts;\n\t}\n\t\n\t// Split a filename into [root, dir, basename, ext], unix version\n\t// 'root' is just a slash, or nothing.\n\tvar splitPathRe =\n\t    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n\tvar splitPath = function(filename) {\n\t  return splitPathRe.exec(filename).slice(1);\n\t};\n\t\n\t// path.resolve([from ...], to)\n\t// posix version\n\texports.resolve = function() {\n\t  var resolvedPath = '',\n\t      resolvedAbsolute = false;\n\t\n\t  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n\t    var path = (i >= 0) ? arguments[i] : process.cwd();\n\t\n\t    // Skip empty and invalid entries\n\t    if (typeof path !== 'string') {\n\t      throw new TypeError('Arguments to path.resolve must be strings');\n\t    } else if (!path) {\n\t      continue;\n\t    }\n\t\n\t    resolvedPath = path + '/' + resolvedPath;\n\t    resolvedAbsolute = path.charAt(0) === '/';\n\t  }\n\t\n\t  // At this point the path should be resolved to a full absolute path, but\n\t  // handle relative paths to be safe (might happen when process.cwd() fails)\n\t\n\t  // Normalize the path\n\t  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n\t    return !!p;\n\t  }), !resolvedAbsolute).join('/');\n\t\n\t  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n\t};\n\t\n\t// path.normalize(path)\n\t// posix version\n\texports.normalize = function(path) {\n\t  var isAbsolute = exports.isAbsolute(path),\n\t      trailingSlash = substr(path, -1) === '/';\n\t\n\t  // Normalize the path\n\t  path = normalizeArray(filter(path.split('/'), function(p) {\n\t    return !!p;\n\t  }), !isAbsolute).join('/');\n\t\n\t  if (!path && !isAbsolute) {\n\t    path = '.';\n\t  }\n\t  if (path && trailingSlash) {\n\t    path += '/';\n\t  }\n\t\n\t  return (isAbsolute ? '/' : '') + path;\n\t};\n\t\n\t// posix version\n\texports.isAbsolute = function(path) {\n\t  return path.charAt(0) === '/';\n\t};\n\t\n\t// posix version\n\texports.join = function() {\n\t  var paths = Array.prototype.slice.call(arguments, 0);\n\t  return exports.normalize(filter(paths, function(p, index) {\n\t    if (typeof p !== 'string') {\n\t      throw new TypeError('Arguments to path.join must be strings');\n\t    }\n\t    return p;\n\t  }).join('/'));\n\t};\n\t\n\t\n\t// path.relative(from, to)\n\t// posix version\n\texports.relative = function(from, to) {\n\t  from = exports.resolve(from).substr(1);\n\t  to = exports.resolve(to).substr(1);\n\t\n\t  function trim(arr) {\n\t    var start = 0;\n\t    for (; start < arr.length; start++) {\n\t      if (arr[start] !== '') break;\n\t    }\n\t\n\t    var end = arr.length - 1;\n\t    for (; end >= 0; end--) {\n\t      if (arr[end] !== '') break;\n\t    }\n\t\n\t    if (start > end) return [];\n\t    return arr.slice(start, end - start + 1);\n\t  }\n\t\n\t  var fromParts = trim(from.split('/'));\n\t  var toParts = trim(to.split('/'));\n\t\n\t  var length = Math.min(fromParts.length, toParts.length);\n\t  var samePartsLength = length;\n\t  for (var i = 0; i < length; i++) {\n\t    if (fromParts[i] !== toParts[i]) {\n\t      samePartsLength = i;\n\t      break;\n\t    }\n\t  }\n\t\n\t  var outputParts = [];\n\t  for (var i = samePartsLength; i < fromParts.length; i++) {\n\t    outputParts.push('..');\n\t  }\n\t\n\t  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\t\n\t  return outputParts.join('/');\n\t};\n\t\n\texports.sep = '/';\n\texports.delimiter = ':';\n\t\n\texports.dirname = function(path) {\n\t  var result = splitPath(path),\n\t      root = result[0],\n\t      dir = result[1];\n\t\n\t  if (!root && !dir) {\n\t    // No dirname whatsoever\n\t    return '.';\n\t  }\n\t\n\t  if (dir) {\n\t    // It has a dirname, strip trailing slash\n\t    dir = dir.substr(0, dir.length - 1);\n\t  }\n\t\n\t  return root + dir;\n\t};\n\t\n\t\n\texports.basename = function(path, ext) {\n\t  var f = splitPath(path)[2];\n\t  // TODO: make this comparison case-insensitive on windows?\n\t  if (ext && f.substr(-1 * ext.length) === ext) {\n\t    f = f.substr(0, f.length - ext.length);\n\t  }\n\t  return f;\n\t};\n\t\n\t\n\texports.extname = function(path) {\n\t  return splitPath(path)[3];\n\t};\n\t\n\tfunction filter (xs, f) {\n\t    if (xs.filter) return xs.filter(f);\n\t    var res = [];\n\t    for (var i = 0; i < xs.length; i++) {\n\t        if (f(xs[i], i, xs)) res.push(xs[i]);\n\t    }\n\t    return res;\n\t}\n\t\n\t// String.prototype.substr - negative index don't work in IE8\n\tvar substr = 'ab'.substr(-1) === 'b'\n\t    ? function (str, start, len) { return str.substr(start, len) }\n\t    : function (str, start, len) {\n\t        if (start < 0) start = str.length + start;\n\t        return str.substr(start, len);\n\t    }\n\t;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(32)))\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// utilities needed by the configuration (excludes dependencies the configs don't need so the webpack bundle is lean)\r\n\t\r\n\tvar path = __webpack_require__(30)\r\n\t\r\n\t\r\n\t// Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1\r\n\t// any number of objects can be passed into the function and will be merged into the first argument in order\r\n\t// returns obj1 (now mutated)\r\n\tvar merge = exports.merge = function(obj1, obj2/*, moreObjects...*/){\r\n\t    return mergeInternal(arrayify(arguments), false)\r\n\t}\r\n\t\r\n\t// like merge, but traverses the whole object tree\r\n\t// the result is undefined for objects with circular references\r\n\tvar deepMerge = exports.deepMerge = function(obj1, obj2/*, moreObjects...*/) {\r\n\t    return mergeInternal(arrayify(arguments), true)\r\n\t}\r\n\t\r\n\tfunction mergeInternal(objects, deep) {\r\n\t    var obj1 = objects[0]\r\n\t    var obj2 = objects[1]\r\n\t\r\n\t    for(var key in obj2){\r\n\t       if(Object.hasOwnProperty.call(obj2, key)) {\r\n\t            if(deep && obj1[key] instanceof Object && obj2[key] instanceof Object) {\r\n\t                mergeInternal([obj1[key], obj2[key]], true)\r\n\t            } else {\r\n\t                obj1[key] = obj2[key]\r\n\t            }\r\n\t       }\r\n\t    }\r\n\t\r\n\t    if(objects.length > 2) {\r\n\t        var newObjects = [obj1].concat(objects.slice(2))\r\n\t        return mergeInternal(newObjects, deep)\r\n\t    } else {\r\n\t        return obj1\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction arrayify(a) {\r\n\t    return Array.prototype.slice.call(a, 0)\r\n\t}\r\n\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\t\n\tprocess.nextTick = (function () {\n\t    var canSetImmediate = typeof window !== 'undefined'\n\t    && window.setImmediate;\n\t    var canMutationObserver = typeof window !== 'undefined'\n\t    && window.MutationObserver;\n\t    var canPost = typeof window !== 'undefined'\n\t    && window.postMessage && window.addEventListener\n\t    ;\n\t\n\t    if (canSetImmediate) {\n\t        return function (f) { return window.setImmediate(f) };\n\t    }\n\t\n\t    var queue = [];\n\t\n\t    if (canMutationObserver) {\n\t        var hiddenDiv = document.createElement(\"div\");\n\t        var observer = new MutationObserver(function () {\n\t            var queueList = queue.slice();\n\t            queue.length = 0;\n\t            queueList.forEach(function (fn) {\n\t                fn();\n\t            });\n\t        });\n\t\n\t        observer.observe(hiddenDiv, { attributes: true });\n\t\n\t        return function nextTick(fn) {\n\t            if (!queue.length) {\n\t                hiddenDiv.setAttribute('yes', 'no');\n\t            }\n\t            queue.push(fn);\n\t        };\n\t    }\n\t\n\t    if (canPost) {\n\t        window.addEventListener('message', function (ev) {\n\t            var source = ev.source;\n\t            if ((source === window || source === null) && ev.data === 'process-tick') {\n\t                ev.stopPropagation();\n\t                if (queue.length > 0) {\n\t                    var fn = queue.shift();\n\t                    fn();\n\t                }\n\t            }\n\t        }, true);\n\t\n\t        return function nextTick(fn) {\n\t            queue.push(fn);\n\t            window.postMessage('process-tick', '*');\n\t        };\n\t    }\n\t\n\t    return function nextTick(fn) {\n\t        setTimeout(fn, 0);\n\t    };\n\t})();\n\t\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\t// TODO(shtylman)\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\n\n/***/ }\n/******/ ])\n});\n\n\n\n/** WEBPACK FOOTER **\n ** blocks.umd.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 94739a056a0c696fb684\n **/","exports.Block = require('Block')\r\nexports.Style = require('Style')\r\n\r\nexports.Canvas = require('Components/Canvas')\r\nexports.Container = require(\"Components/Container\")\r\nexports.Button = require(\"Components/Button\")\r\nexports.CheckBox = require(\"Components/CheckBox\")\r\nexports.Image = require('Components/Image')\r\nexports.List = require('Components/List')\r\n//exports.MultiSelect = require(\"Components/MultiSelect\") // not ready yet\r\nexports.Radio = require(\"Components/Radio\")\r\nexports.Select = require(\"Components/Select\")\r\nexports.Table = require(\"Components/Table\")\r\nexports.TextArea = require(\"Components/TextArea\")\r\nexports.TextField = require(\"Components/TextField\")\r\nexports.Text = require(\"Components/Text\")\r\n\r\n\r\n\r\nObject.defineProperty(exports, 'dev', {\r\n    get: function() {\r\n        return exports.Block.dev\r\n    }, set: function(v) {\r\n        exports.Block.dev = v\r\n    }\r\n})\r\n\r\nexports.attach = function(/*component,component,.. or components*/) {\r\n    exports.Block.attach.apply(this,arguments)\r\n}\r\nexports.detach = function(/*component,component,.. or components*/) {\r\n    exports.Block.detach.apply(this,arguments)\r\n}\r\n\r\nexports.createBody = function(callback) {\r\n    exports.Block.detach.apply(this,arguments)\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./blocks.browser.js\n ** module id = 0\n ** module chunks = 0\n **/","var EventEmitterB = require('EventEmitterB')\nvar proto = require(\"proto\");\nvar trimArguments = require(\"trimArguments\")\nvar utils = require('./utils')\nvar domUtils = require('./domUtils')\nvar observe = require('observe')\nvar HashMap = require(\"hashmap\")\n\nvar Style = require(\"./Style\")\nStyle.isDev = function() {return module.exports.dev}\n\nvar defaultStyleMap = new HashMap() // maps from a proto class to its computed default style\nvar components = {};\n\nvar setOfBrowserEvents = utils.arrayToMap([\n    'abort','afterprint','animationend','animationiteration','animationstart','audioprocess','beforeprint','beforeunload',\n    'beginEvent','blocked','blur','cached','canplay','canplaythrough','change','chargingchange','chargingtimechange',\n    'checking','click','close','compassneedscalibration','complete','compositionend','compositionstart','compositionupdate','contextmenu',\n    'copy','cut','dblclick','decivelight','devicemotion','deviceorientation','deviceproximity','dischargingtimechange','DOMContentLoaded',\n    'downloading','drag','dragend','dragenter','dragleave','dragover','dragstart','drop','durationchange','emptied','ended','endEvent',\n    'error','focus','focusin','focusout','fullscreenchange','fullscreenerror','gamepadconnected','gamepaddisconnected','hashchange',\n    'input','invalid','keydown','keypress','keyup','languagechange','levelchange','load','loadeddata','loadedmetadata','loadend',\n    'loadstart','message','mousedown','mouseenter','mouseleave','mousemove','mouseout','mouseover','mouseup','noupdate','obsolete',\n    'offline','online','open','orientationchange','pagehide','pageshow','paste','pause','pointerlockchange','pointerlockerror','play',\n    'playing','popstate','progress','ratechange','readystatechange','repeatEvent','reset','resize','scroll','seeked','seeking','select',\n    'show','stalled','storage','submit','success','suspend','SVGAbort','SVGError','SVGLoad','SVGResize','SVGScroll','SVGUnload','SVGZoom',\n    'timeout','timeupdate','touchcancel','touchend','touchenter','touchleave','touchmove','touchstart','transitionend','unload',\n    'updateready','upgradeneeded','userproximity','versionchange','visibilitychange','volumechange','waiting','wheel'\n])\n\n// events:\n    // newParent - emits this when a component gets a new parent\n    // parentRemoved - emits this when a component is detached from its parent\nvar Block = module.exports = proto(EventEmitterB,function(superclass) {\n\n    // static properties\n\n    // constructor\n\tthis.init = function() {\n        var that = this\n\n        if(this.name === undefined) {\n            throw new Error(\"The 'name' property is required for Blocks\")\n        }\n\n        var defaultBlockStyle = defaultStyleMap.get(this.constructor)\n        if(defaultBlockStyle === undefined) {\n            defaultBlockStyle = createDefaultBlockStyle(this)\n        }\n\n        superclass.init.call(this)\n\n        this.children = []\n        this.state = observe({})\n        this.parent = undefined;\n\n\t\tif (this.id !== undefined) {\n\t\t\tcomponents[this.id] = this;\n\t\t}\n\n        if(this.domNode === undefined) {\n            this.domNode = domUtils.div()\n        }\n\n        this.build.apply(this, arguments)\n\n        //if(module.exports.dev) {\n            this.attr('blkName', this.name)\n        //}\n\n        var classList = [this.domNode.className]\n        if(defaultBlockStyle !== false) classList.push(defaultBlockStyle.className)\n        classList.push(Style.defaultClassName)\n        this.domNode.className = classList.join(' ') // note that the order of classes doesn't matter\n\n        // set up dom event handlers\n        var ifonHandlers={}\n        that.ifon(function(event) {\n            if(event in setOfBrowserEvents && (that.excludeDomEvents === undefined || !(event in that.excludeDomEvents))) {\n                that.domNode.addEventListener(event, ifonHandlers[event]=function() {\n                    that.emit.apply(that, [event].concat(Array.prototype.slice.call(arguments)))\n                })\n            }\n        })\n        that.ifoff(function(event) {\n            if(event in setOfBrowserEvents && (that.excludeDomEvents === undefined || !(event in that.excludeDomEvents))) {\n                that.domNode.removeEventListener(event,ifonHandlers[event])\n            }\n        })\n\t}\n\n    // sub-constructor - called by the constructor\n    // parameters:\n        // label - (Optional) A label that can be used to style a component differently.\n                   // Intended to be some string describing what the component is being used for.\n                   // Note, tho, that labels are not dynamic - changing the label won't affect styling until a new style is applied to the component)\n        // domNode - (Optional) A domNode to be used as the container domNode instead of the default (a div)\n    this.build = function(/*[label,] domNode*/) {\n        if(arguments.length === 1) {\n            this.domNode = arguments[0]\n        } else if(arguments.length >= 2) {\n            this.label = arguments[0]\n            this.domNode = arguments[1]\n        }\n    }\n\t\n\n\t// instance properties\n\n\t\n\tthis.domNode;\n    this.label;\n    this.excludeDomEvents;\n    this.children;     // a list of child components that are a part of a Block object (these are used so Styles can be propogated down to child components)\n\n\n    Object.defineProperty(this, 'label', {\n        get: function() {\n            return this._label\n        }, set: function(v) {\n            if(this._label === undefined) {\n                this._label = v\n\n                if(module.exports.dev) {\n                    this.attr('label', this._label)\n                }\n            } else {\n                throw new Error(\"A Block's label can only be set once (was already set to: \"+this._label+\")\")\n            }\n        }\n    })\n\n    // adds elements to the components main domNode\n    // arguments can be one of the following:\n        // component, component, component, ...\n        // listOfBlocks\n    this.add = function() {\n        this.addAt.apply(this, [this.domNode.children.length].concat(trimArguments(arguments)))\n\t}\n\n    // adds nodes at a particular index\n    // nodes can be one of the following:\n        // component, component, component, ...\n        // listOfBlocks\n    this.addAt = function(index/*, nodes...*/) {\n        var nodes = normalizeAddAtArguments.apply(this, arguments)\n\n        for (var i=0;i<nodes.length;i++) {\n\t\t\tvar node = nodes[i];\n            this.children.splice(index+i, 0, node)\n\n            if(!isBlock(node)) {\n                throw new Error(\"node is not a Block\")\n            }\n\n            node.parent = undefined\n            node.emit('parentRemoved')\n\n            var beforeChild = this.children[1+i+index]\n            if(beforeChild === undefined) {\n                this.domNode.appendChild(node.domNode)\n            } else {\n                this.domNode.insertBefore(node.domNode, beforeChild.domNode)\n            }\n\n            node.parent = this;\n            node.emit('newParent')\n\n            // apply styles\n            //if(itsaBlock) { // its always a component now\n                var that = this\n                node.getParentStyleMap = function() {return that.computedStyleMap}\n                propogateStyleSet([node], this.computedStyleMap)\n            //}\n\t\t}\n    }\n\n\t// add a list of nodes before a particular node\n    // if beforeChild is undefined, this will append the given nodes\n    // arguments can be one of the following:\n        // component, component, component, ...\n        // listOfBlocks\n    this.addBefore = this.addBeforeNode = function(beforeChild) {\n        var nodes = trimArguments(arguments).slice(1)\n        if(beforeChild === undefined) {\n            this.add.apply(this, nodes)\n        } else {\n            var index = this.children.indexOf(beforeChild)\n            this.addAt.apply(this, [index].concat(nodes))\n        }\n    }\n\n\n    // arguments can be one of the following:\n        // component, component, component, ...\n        // index, index, index, ... - each index is the numerical index to remove\n        // arrayOfComponents\n        // arrayOfIndexes\n    this.remove = function() {\n        var removals = normalizeRemoveArguments.apply(this, arguments)\n        removals = removals.sort(function(a,b) {\n            return b-a // reverse sort (so that removing multiple indexes doesn't mess up)\n        })\n\n        for(var n=0; n<removals.length; n++) {\n            var r = removals[n]\n            var c = this.children[r]\n\n            if(c === undefined) {\n                throw new Error(\"There is no child at index \"+r)\n            }\n\n            c.parent = undefined\n            this.children.splice(r, 1)\n            this.domNode.removeChild(this.domNode.childNodes[r])\n\n            c.emit('parentRemoved')\n        }\n    }\n\n    // sets or gets an attribute on the components domNode\n    // parameter sets:\n    // if one argument is passed, the attribute's value is returned (if there is no attribute, undefined is returned)\n    // if there are two arguments passed, the attribute is set\n        // if 'value' is undefined, the attribute is removed\n    this.attr = function(/*attribute, value OR attributeObject*/) {\n        if(arguments.length === 1) {\n            if(arguments[0] instanceof Object) {\n                var attributes = arguments[0]\n                for(var attribute in attributes) {\n                    domUtils.setAttribute(this.domNode, attribute, arguments[0][attribute])\n                }\n            } else {\n                var attribute = this.domNode.getAttribute(arguments[0])\n                if(attribute === null) {\n                    return undefined // screw null\n                } else {\n                    return attribute\n                }\n            }\n        } else {\n            var attribute = arguments[0]\n            if(arguments[1] !== undefined) {\n                var value = arguments[1]\n                domUtils.setAttribute(this.domNode, arguments[0], value)\n            } else {\n                this.domNode.removeAttribute(attribute)\n            }\n        }\n    }\n\n    Object.defineProperty(this, 'visible', {\n        // returns true if the element is visible\n        get: function() {\n            return this.domNode.style.display !== 'none';\n\n        // sets whether or not the element is visible\n        }, set: function(setToVisible) {\n            if(setToVisible) {\n                if (this._displayStyle !== undefined) {\n                    this.domNode.style.display = this._displayStyle // set back to its previous inline style\n                    this._displayStyle = undefined\n                } else {\n                    this.domNode.style.display = ''\n                }\n            } else {\n                if(this.domNode.style.display !== '' && this.domNode.style.display !== 'none') { // domNode has inline style\n                    this._displayStyle = this.domNode.style.display\n                }\n\n                this.domNode.style.display = 'none'\n            }\n        }\n    })\n\n\n    Object.defineProperty(this, 'focus', {\n        // returns true if the element is in focus\n        get: function() {\n            return document.activeElement === this.domNode\n\n        // sets whether or not the element is in focus (setting it to true gives it focus, setting it to false blurs it)\n        }, set: function(setToInFocus) {\n            if(setToInFocus) {\n                this.domNode.focus()\n            } else {\n                this.domNode.blur()\n            }\n        }\n    })\n\n    Object.defineProperty(this, 'style', {\n        get: function() {\n            return this._style\n\n        // sets the style, replacing one if one already exists\n        }, set: function(styleObject) {\n            if(styleObject === undefined) {\n                var styleMap = this.getParentStyleMap()\n                if(styleMap !== undefined) {\n                    setCurrentStyle(this, getStyleForComponent(styleMap, this))\n                } else {\n                    setCurrentStyle(this, undefined)\n                }\n\n                this.computedStyleMap = styleMap\n\n            } else {\n                setCurrentStyle(this, styleObject)\n                var specificStyle = styleObject.get(this)\n                if(this.getParentStyleMap() !== undefined) {\n                    this.computedStyleMap = styleMapConjunction(this.getParentStyleMap(), specificStyle.componentStyleMap)\n                } else {\n                    this.computedStyleMap = specificStyle.componentStyleMap\n                }\n            }\n\n            this._style = styleObject\n            propogateStyleSet(this.children, this.computedStyleMap) // propogate styles to children\n        }\n    })\n\n    Object.defineProperty(this, 'selectionRange', {\n        // returns the visible character selection range inside the element\n        // returns an array like [offsetStart, offsetEnd]\n        get: function() {\n            return domUtils.getSelectionRange(this.domNode)\n\n        // sets the visible character selection range\n        }, set: function(selection) {\n            domUtils.setSelectionRange(this.domNode, selection[0], selection[1])\n        }\n    })\n\n    this.attach = function() {\n        attach(this)\n    }\n    this.detach = function() {\n        detach(this)\n    }\n\n\n\t// private instance variables/functions\n\n    this.getParentStyleMap = function() {/*default returns undefined*/}  // should be set to a function that returns the computedStyleMap of the component containing this one (so Styles objects can be inherited)\n    this.computedStyleMap;  // a map of style objects computed from the Styles set on a given component and its parent components\n\n\tthis._style;              // the object's explicit Style object (undefined if it inherits a style)\n    this.currentStyle;       // the object's current Style (inherited or explicit)\n    this._displayStyle;      // temporariliy stores an inline display style while the element is hidden (for use when 'show' is called)\n    this._styleSetupStates   // place to put states for setup functions (used for css pseudoclass emulation)\n});\n\n\nmodule.exports.dev = false // set to true to enable dom element naming (so you can see boundaries of components when inspecting the dom)\n\n\n// appends components to the body\nvar attach = module.exports.attach = function(/*component,component,.. or components*/) {\n    if(arguments[0] instanceof Array) {\n        var components = arguments[0]\n    } else {\n        var components = arguments\n    }\n\n    if(document.body === null) throw new Error(\"Your document does not have a body.\")\n\n    for(var n=0; n<components.length; n++) {\n        document.body.appendChild(components[n].domNode)\n    }\n}\n// removes components from the body\nvar detach = module.exports.detach = function(/*component,component,.. or components*/) {\n    if(arguments[0] instanceof Array) {\n        var components = arguments[0]\n    } else {\n        var components = arguments\n    }\n\n    for(var n=0; n<components.length; n++) {\n        document.body.removeChild(components[n].domNode)\n    }\n}\n\n// creates a body tag (only call this if document.body is null)\n\nmodule.exports.createBody = function(callback) {\n    var dom = document.implementation.createDocument('http://www.w3.org/1999/xhtml', 'html', null);\n    var body = dom.createElement(\"body\")\n    dom.documentElement.appendChild(body)\n    setTimeout(function() {  // set timeout is needed because the body tag is only added after javascript goes back to the scheduler\n        callback()\n    },0)\n}\n\n\n\n\n// returns a list of indexes to remove from Block.remove's arguments\n/*private*/ var normalizeRemoveArguments = module.exports.normalizeRemoveArguments = function() {\n    var that = this\n\n    if(arguments[0] instanceof Array) {\n        var removals = arguments[0]\n    } else {\n        var removals = Array.prototype.slice.call(arguments)\n    }\n\n    return removals.map(function(removal, parameterIndex) {\n        if(isBlock(removal)) {\n            var index = that.children.indexOf(removal)\n            if(index === -1) {\n                throw new Error(\"The Block passed at index \"+parameterIndex+\" is not a child of this Block.\")\n            }\n            return index\n        } else {\n            return removal\n        }\n\n    })\n}\n\n// returns a list of nodes to add\n/*private*/ var normalizeAddAtArguments = module.exports.normalizeAddAtArguments = function() {\n    if(arguments.length === 2) {\n        if(arguments[1] instanceof Array) {\n            return arguments[1]\n        } else {\n            return [arguments[1]]\n        }\n    } else { // > 2\n        return trimArguments(arguments).slice(1)\n    }\n}\n\n\n// propogates a style-set change to a set of components\n    // styleMap should be a *copy* of a Style's componentStyleMap property (because it will be modified)\nfunction propogateStyleSet(components, styleMap) {\n    for(var n=0; n<components.length; n++) {\n        var c = components[n]\n        //if(isBlock(c)) {   //\n            // object inherits style if its in the styleSet and if it doesn't have an explicitly set style\n            if(c._style === undefined) {\n                if(styleMap === undefined) {\n                    setCurrentStyle(c, undefined)\n                } else {\n                    var styleFromMap = getStyleForComponent(styleMap, c)\n                    if(styleFromMap !== undefined) {\n                        setCurrentStyle(c, styleFromMap)\n                    }\n                }\n            }\n\n            // set the computed style set\n            var mainStyle; // the style directly given to a component, either its `style` property, or its inherited style\n            if(c._style !== undefined) {\n                mainStyle = c._style.get(c)\n            } else if(styleMap !== undefined) {\n                mainStyle = getStyleForComponent(styleMap, c)\n                if(mainStyle !== undefined) {\n                    mainStyle = mainStyle.get(c) // get the specific style (taking into account any label)\n                }\n            }\n\n            if(mainStyle !== undefined) {\n                if(styleMap !== undefined) {\n                    c.computedStyleMap = styleMapConjunction(styleMap, mainStyle.componentStyleMap)\n                } else {\n                    c.computedStyleMap = mainStyle.componentStyleMap\n                }\n            } else {\n                c.computedStyleMap = styleMap\n            }\n\n            propogateStyleSet(c.children, c.computedStyleMap)\n        //}\n    }\n}\n\n// gets the right style from the styleMap\n// takes the component's inheritance tree into account (relies on the block.constructor.parent property)\nfunction getStyleForComponent(styleMap, block) {\n    var constructor = block.constructor\n    while(constructor !== undefined) {\n        var style = styleMap[constructor.name]\n        if(style !== undefined) {\n            return style\n        } else {\n            constructor = constructor.parent\n        }\n    }\n}\n\n// returns the conjunction of two style maps\n// gets it from the computedStyles cache if its already in there\nfunction styleMapConjunction(secondaryStyleMap, primaryStyleMap) {\n    var cachedStyleMap = Style.computedStyles.get([secondaryStyleMap, primaryStyleMap])\n    if(cachedStyleMap === undefined) {\n        cachedStyleMap = utils.objectConjunction(secondaryStyleMap, primaryStyleMap)\n        Style.computedStyles.set([secondaryStyleMap, primaryStyleMap], cachedStyleMap)\n    }\n\n    return cachedStyleMap\n}\n\n// takes lables into account\nfunction setCurrentStyle(component, style) {\n    if(style === component.currentStyle) return; // do nothing\n\n    if(style !== undefined)\n        var specificStyle = style.get(component)\n    else\n        var specificStyle = style\n\n    setStyleClass(component, specificStyle)\n    applyStyleKillFunction(component)\n    component.currentStyle = specificStyle\n    applyStyleSetupFunction(component, specificStyle)\n    applyStateHandler(component, specificStyle)\n}\n\n// applies kill appropriately\nfunction applyStyleKillFunction(component) {\n    var currentStyle = component.currentStyle\n    if(currentStyle !== undefined && currentStyle.setup !== undefined) {\n        if(currentStyle.kill === undefined)\n            throw new Error('style has been unset but does not have a \"kill\" function to undo its \"setup\" function')\n\n        currentStyle.kill(component)\n    }\n}\n// applies setup appropriately\nfunction applyStyleSetupFunction(component, style) {\n    if(style !== undefined && style.setup !== undefined) {\n        style.setup(component) // call setup on the component\n    }\n}\n// initializes and sets up state-change handler\nfunction applyStateHandler(component, style) {\n    if(style !== undefined && style.stateHandler !== undefined) {\n        style.stateHandler(component.state, component.domNode.style)\n        component.state.on('change', function() {\n            style.stateHandler(component.state.subject, component.domNode.style)\n        })\n    }\n}\n\n// sets the style, replacing one if one already exists\nfunction setStyleClass(component, style) {\n    var currentStyle = component.currentStyle\n    if(currentStyle !== undefined) {\n        component.domNode.className = component.domNode.className.replace(new RegExp(\" ?\\\\b\"+currentStyle.className+\"\\\\b\"),'') // remove the previous css class\n    }\n    if(style !== undefined) {\n        component.domNode.className = style.className+' '+component.domNode.className.trim() // note that the order of classes doesn't matter\n    }\n}\n\nfunction validateDefaultStyle(defaultStyle) {\n    if(!(defaultStyle instanceof Style)) {\n        throw new Error(\"defaultStyle property must be a Style object\")\n    } else if(\n        defaultStyle.setup !== undefined || defaultStyle.kill !== undefined || defaultStyle.stateHandler !== undefined ||\n        Object.keys(defaultStyle.componentStyleMap).length > 0 || Object.keys(defaultStyle.labelStyleMap).length > 0 /*||\n        Object.keys(defaultStyle.pseudoClassStyles).length > 0*/\n    ) {\n        throw new Error(\"A Block's defaultStyle can only contain basic css stylings, no Block, label, or pseudoclass stylings, nor run/kill javascript\")\n    }\n}\n\nfunction createDefaultBlockStyle(that) {\n    if(that.defaultStyle !== undefined) {\n        validateDefaultStyle(that.defaultStyle)\n    }\n\n    // get list of default styles\n    var defaultStyles = []\n    var nextConstructor = that.constructor\n    while(nextConstructor !== undefined) {\n        if(nextConstructor.defaultStyle !== undefined) {\n            defaultStyles.push(nextConstructor.defaultStyle)\n        }\n        nextConstructor = nextConstructor.parent\n    }\n\n    // generate merged default style\n    var defaultStyleSet = {}\n    defaultStyles.reverse().forEach(function(style) {\n        for(var k in style.styleDefinitions) {\n            utils.merge(defaultStyleSet, style.styleDefinitions[k])\n            break; // just do first key (shouldn't be more than one key, because only simple stylings are allowed for default styles)\n        }\n\n    })\n\n    if(Object.keys(defaultStyleSet).length > 0)\n        var defaultBlockStyle = Style(defaultStyleSet, {default:true})\n    else\n        var defaultBlockStyle = false // no special default\n\n    defaultStyleMap.set(that.constructor, defaultBlockStyle)\n    return defaultBlockStyle\n}\n\nfunction isBlock(c) {\n    return c.add !== undefined && c.children instanceof Array && c.domNode !== undefined\n}\nfunction isDomNode(node) {\n    return node.nodeName !== undefined\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Block.js\n ** module id = 1\n ** module chunks = 0\n **/","var jssModule = require(\"../external/jss\")\nvar proto = require('proto')\nvar HashMap = require('hashmap') // .HashMap // weirdly, it looks like this is being treated like an AMD module\n\nvar utils = require(\"./utils\")\n\nvar baseClassName = '_ComponentStyle_' // the base name for generated class names\nvar nextClassNumber = 0\n\nvar defaultJss = jssModule.forDocument(document) // must be created before the jss object (so that the styles there override the styles in the default sheet)\ndefaultJss.defaultSheet = defaultJss._createSheet() // create its sheet first (before the regular jss sheet)\nvar jss = jssModule.forDocument(document)\njss.defaultSheet = jss._createSheet()\n\n// creates a style object\nvar Style = module.exports = proto(function() {\n\n    this.defaultClassName = '_default_'     // the name of the default class (used to prevent style inheritance)\n\n    // styleDefinition is an object where key-value pairs can be any of the following:\n    // <cssPropertyName>: the value should be a valid css value for that style attribute\n    // <ComponentName>: the value can either be a Style object or a nested styleDefinition object\n    // $setup: the value is a function to be run on a component when the style is applied to it\n    // $kill: the value is a function to be run on a component when a style is removed from it\n    // $state: the value should be a state handler function\n    // $<label>: the value should be a nested styleDefinition object that does not contain any label styles.\n    this.init = function(styleDefinition, privateOptions) {\n        if(privateOptions === undefined) privateOptions = {}\n        if(privateOptions.inLabel===undefined) inLabel = false\n\n        this.className = baseClassName+nextClassNumber\n        nextClassNumber++\n\n        this.componentStyleMap = {}\n        this.labelStyleMap = {}\n\n        var labelStyles = {}\n        var pseudoClassStyles = {}\n        var cssProperties = {}\n        for(var key in styleDefinition) {\n            var value = styleDefinition[key]\n\n            if(key === '$setup') {\n                if(!(value instanceof Function)) throw new Error(\"$setup key must be a function ('setup' can't be used as a label)\")\n                this.setup = value\n\n            } else if(key === '$kill') {\n                if(!(value instanceof Function)) throw new Error(\"$kill key must be a function ('kill' can't be used as a label)\")\n                this.kill = value\n\n            } else if(key === '$state') {\n                if(!(value instanceof Function)) throw new Error(\"$state key must be a function ('$state' can't be used as a label)\")\n                this.stateHandler = value\n\n            } else if(key.indexOf('$$') === 0) { // pseudo-class style\n                var pseudoClass = mapCamelCase(key.substr(2))\n                if(pseudoClass === '') {\n                    throw new Error(\"Empty pseudo-class name not valid (style key '$$')\")\n                }\n\n                utils.merge(pseudoClassStyles, flattenPseudoClassStyles(pseudoClass, value))\n\n            } else if(key.indexOf('$') === 0) {   // label style\n                if(privateOptions.inLabel)\n                    throw new Error(\"Can't create nested label style \"+key+\" because components can only have one label\")\n\n                var label = key.substr(1)\n                if(label === '') {\n                    throw new Error(\"Empty label name not valid (style key '$')\")\n                }\n\n                labelStyles[label] = value\n\n            } else if(isStyleObject(value)) {\n                this.componentStyleMap[key] = value\n\n            } else if(value instanceof Object) {\n                this.componentStyleMap[key] = Style(value)  // turn the object description into a full fledged style object\n            } else {\n                var cssStyle = key\n                var cssStyleName = mapCamelCase(cssStyle)\n                cssProperties[cssStyleName] = cssValue(cssStyleName, value)\n            }\n        }\n\n        // create the css class\n        if(privateOptions.default) {\n            var jssSheet = defaultJss\n        } else {\n            var jssSheet = jss\n        }\n\n        jssSheet.set('.'+this.className, cssProperties)\n\n        //if(module.exports.isDev) {\n            this.styleDefinitions = {}\n            this.styleDefinitions['.'+this.className] = cssProperties\n        //}\n\n        // create label styles\n        if(Object.keys(labelStyles).length > 0) {\n            var baseStyle = utils.merge({}, cssProperties, this.componentStyleMap)\n\n            for(var label in labelStyles) {\n                if(isStyleObject(labelStyles[label])) {\n                    this.labelStyleMap[label] = labelStyles[label]\n                } else {\n                    var mergedStyle = utils.merge({}, baseStyle, labelStyles[label])\n                    this.labelStyleMap[label] = Style(mergedStyle, {inLabel:true})\n                }\n            }\n        }\n\n        // create pseudoclass styles\n        if(Object.keys(pseudoClassStyles).length > 0) {\n\n            var tieredPseudoClasses = createTieredPseudoClasses(this, pseudoClassStyles)\n            pseudoclassCombinations(tieredPseudoClasses) // mutates tieredPseudoClasses\n\n            // turn the emulatable pseudo classes into Style objects\n            // also build up the set of psuedoclasses that will be emulated\n            // also build up a map of pseudoclasses-to-emulate to the emulation functions for those pseudoclasses\n            var pseudoClasesToEmulate = []\n            var preSplitPseudoClasses = [] // a list where each element looks like: [pseudoClassList, styleObject]  (this is primarily for performance - so we don't have to split the key every time we check for state changes)\n            var pseudoClassesToEmulationInfo = {}\n            for(var key in tieredPseudoClasses) {\n                if(isStyleObject(tieredPseudoClasses[key])) {\n                    tieredPseudoClasses[key] = tieredPseudoClasses[key]\n                } else {\n                    var newStyle = Style(utils.merge({}, cssProperties, tieredPseudoClasses[key])) // pseudoClassStyles merged with parent css styles\n\n                    // merge in componentStyleMap and labelStyleMap\n                    for(var k in this.componentStyleMap) {\n                        if(newStyle.componentStyleMap[k] === undefined)\n                            newStyle.componentStyleMap[k] = this.componentStyleMap[k]\n                    }\n                    for(var k in this.labelStyleMap) {\n                        if(newStyle.labelStyleMap[k] === undefined)\n                            newStyle.labelStyleMap[k] = this.labelStyleMap[k]\n                    }\n\n                    tieredPseudoClasses[key] = newStyle\n                }\n\n\n                var pseudoClassList = key.split(\":\")\n                for(var n=0; n<pseudoClassList.length; n++) {\n                    var pseudoClass = pseudoClassList[n]\n                    if(pseudoClasesToEmulate.indexOf(pseudoClass) === -1) {\n                        pseudoClasesToEmulate.push(pseudoClass)\n\n                        var pseudoClassParts = getPseudoClassParts(pseudoClass)\n                        var fns = emulatedPseudoClasses[pseudoClassParts.class]\n                        var info = {fns: fns}\n                        if(fns.processParameter !== undefined) {\n                            info.parameter = fns.processParameter(pseudoClassParts.parameter)\n                        }\n                        pseudoClassesToEmulationInfo[pseudoClass] = info\n                    }\n                }\n\n                preSplitPseudoClasses.push([pseudoClassList, tieredPseudoClasses[key]])\n            }\n\n            // create functions that initialize and keep track of state\n            var initializeState = function(component) {\n                var state = {}\n                for(var n=0; n<pseudoClasesToEmulate.length; n++) {\n                    var pseudoClass = pseudoClasesToEmulate[n]\n                    var pseudoClassEmulationInfo = pseudoClassesToEmulationInfo[pseudoClass]\n                    state[pseudoClass] = pseudoClassEmulationInfo.fns.check(component, pseudoClassEmulationInfo.parameter)\n                }\n\n                return state\n            }\n\n            var that = this\n            var changeStyleIfNecessary = function(currentStyle, component, state) {\n                var longestMatchingLength = 0;\n                var mostSpecificMatchingStyle = that; // if nothing else matches, change back to the base style object\n                for(var n=0; n<preSplitPseudoClasses.length; n++) {\n                    var pseudoClassList = preSplitPseudoClasses[n][0]\n                    for(var j=0; j<pseudoClassList.length; j++) {\n                        if(!state[pseudoClassList[j]]) {\n                            break;\n                        }\n                    }\n\n                    if(j === pseudoClassList.length && j > longestMatchingLength) {\n                        longestMatchingLength = j\n                        mostSpecificMatchingStyle = preSplitPseudoClasses[n][1]\n                    }\n                }\n\n                if(mostSpecificMatchingStyle !== currentStyle) {\n                    component.style = mostSpecificMatchingStyle\n                }\n            }\n\n            // setup pseudoclass emulation with $setup and $kill handlers\n\n            var wrapSetupAndKill = function(style) {\n                var originalSetup = style.setup\n                style.setup = function(component) {\n                    var that = this\n\n                    this._styleSetupStates = {} // maps pseudoClass to setupState\n                    var state = initializeState(component)\n                    for(var pseudoClass in pseudoClassesToEmulationInfo) {\n                        ;(function(pseudoClass, emulationInfo){   // close over those variables (so they keep the value they had when the function was setup)\n                            that._styleSetupStates[pseudoClass] = emulationInfo.fns.setup(component, function() { // start\n                                state[pseudoClass] = true\n                                changeStyleIfNecessary(that, component, state)\n                            }, function() { // end\n                                state[pseudoClass] = false\n                                changeStyleIfNecessary(that, component, state)\n                            }, emulationInfo.parameter)\n\n                        })(pseudoClass, pseudoClassesToEmulationInfo[pseudoClass])\n                    }\n\n                    changeStyleIfNecessary(that, component, state)\n\n                    if(originalSetup !== undefined) {\n                        originalSetup.apply(this, arguments)\n                    }\n                }\n\n                var originalKill = style.kill\n                style.kill = function(component) {\n                    for(var pseudoClass in pseudoClassesToEmulationInfo) {\n                        var emulationInfo = pseudoClassesToEmulationInfo[pseudoClass]\n                        emulationInfo.fns.kill(component, this._styleSetupStates[pseudoClass])\n                    }\n\n                    if(originalKill !== undefined) {\n                        originalKill.apply(this, arguments)\n                    }\n                }\n            }\n\n            // wrap all the setup and kill functions\n\n            for(var key in tieredPseudoClasses) {\n                var style = tieredPseudoClasses[key]\n                wrapSetupAndKill(style)\n            }\n\n            wrapSetupAndKill(this)\n        }\n    }\n\n    // instance properties\n\n    this.className          // the css classname for this style\n    this.componentStyleMap; // maps a Component name to a Style object for that component\n    this.labelStyleMap;     // maps a label name to a Style object for that label\n    this.setup;             // run some javascript on any element this class is applied to\n    this.kill;              // a function to run on removal of the style (should reverse setup)\n\n    // gets the style object for a component based on the current style object (takes into account whether the component has a label\n    this.get = function(component) {\n        if(component.label !== undefined) {\n            var labelStyle = this.labelStyleMap[component.label]\n            if(labelStyle !==  undefined) {\n                return labelStyle\n            }\n        }\n        // else\n        return this\n    }\n})\n\n\n// private\n\n\n// returns a two-level map where the top-level keys are emulatable psuedo classes, and non-emulatable pseudo classes are at the second level\n// the classes will also be sorted and deduped\n// Example return value: {\"hover:lastChild\": {color:'red', \"$$visited:disabled\": {fontWeight: 'bold'}}, }\n// parameters:\n    // style - the style object being created\n    // pseudoClassStyles - a flat object where each key is a list of pseudoclasses separated by colons (e.g. \"hover\" or \"hover:focus\") and the value is an object of styles that don't contain pseudoclasses\nfunction createTieredPseudoClasses(style, pseudoClassStyles) {\n    var tieredPseudoClasses = {} // the two-level map\n    for(var key in pseudoClassStyles) {\n        var value = pseudoClassStyles[key]\n\n        // split key into pseudoclass list\n        var pseudoClassList = key.split(\":\")\n        var emulatablePseudoClasses = []\n        var nonEmulatablePseudoClasses = []\n        for(var n in pseudoClassList) {\n            var pseudoClass = pseudoClassList[n]\n            var pseudoClassParts = getPseudoClassParts(pseudoClass)\n            if(pseudoClassParts.class in emulatedPseudoClasses) {\n                emulatablePseudoClasses.push(pseudoClass)\n            } else {\n                nonEmulatablePseudoClasses.push(pseudoClass)\n            }\n        }\n\n        if(emulatablePseudoClasses.length === 0) { // if none of the pseudoclasses can be emulated using javascript\n            validatePurePseudoClassStyles(key, value)                        // then validate the value and\n            createPseudoClassRules(style, key, '.'+style.className+\":\"+key, value)   // create pseudoClassRules\n\n        } else { // if some of the pseudoclasses can be emulated using javascript\n\n            emulatablePseudoClasses.sort()\n            var emulatablePseudoClassKey = emulatablePseudoClasses.join(':')\n            if(tieredPseudoClasses[emulatablePseudoClassKey] === undefined)\n                tieredPseudoClasses[emulatablePseudoClassKey] = {}\n\n            if(nonEmulatablePseudoClasses.length === 0) {\n                utils.merge(tieredPseudoClasses[emulatablePseudoClassKey], value)\n            } else {\n                nonEmulatablePseudoClasses.sort()\n                var nonEmulatablePsuedoClassKey = nonEmulatablePseudoClasses.join(':')\n\n                var secondTier = {}\n                secondTier['$$'+nonEmulatablePsuedoClassKey] = value\n\n                utils.merge(tieredPseudoClasses[emulatablePseudoClassKey], secondTier)\n            }\n        }\n    }\n\n    return tieredPseudoClasses\n}\n\n\n\n// make combinations of the emulatable pseudoclasses, so that they combine like the non-emulated ones do\n// info about mathematical combination: https://en.wikipedia.org/wiki/Combination\n// mutates tieredPseudoClasses\nfunction pseudoclassCombinations(tieredPseudoClasses) {\n    var tieredPseudoClassesKeys = Object.keys(tieredPseudoClasses).reverse().map(function(v) {    // reverse first so that more specific pseudoclasses go first\n        return {key: v, parts: v.split(':')} // so it doesn't have to split every time\n    })\n\n    for(var n=0; n<tieredPseudoClassesKeys.length; n++) {\n        var keyA = tieredPseudoClassesKeys[n]\n        for(var k=2; k <= tieredPseudoClassesKeys.length; k++) { // k is the number of psuedoclasses to combine\n            for(var j=n+1; j<tieredPseudoClassesKeys.length-(k-2); j++) {\n                var result = combinePseudoclasses(tieredPseudoClasses, [keyA].concat(tieredPseudoClassesKeys.slice(j, k)))\n                if(result.key in tieredPseudoClasses) {\n                    utils.merge(tieredPseudoClasses[result.key], result.value)\n                } else { // new key\n                    tieredPseudoClasses[result.key] = result.value\n                }\n            }\n        }\n    }\n}\n\n\n\n// keys is a list of objects where each object has the members:\n    // key - the original string key\n    // parts - the key split by \":\"\n// returns an object with the following members:\n    // key - the new combined key\n    // value - the new merged value\nvar combinePseudoclasses = function(pseudoclasses, keys) {\n    var resultKeyParts = keys[0].parts\n    var resultValue = utils.merge({}, pseudoclasses[keys[0].key]) // make a copy\n    for(var n=1; n<keys.length; n++) {\n        var key = keys[n]\n        // merge all psuedoclasses that don't already exist into the resultKey\n        for(var j=0; j<key.parts.length; j++) {\n            var part = key.parts[j]\n            if(resultKeyParts.indexOf(part) === -1) {\n                resultKeyParts.push(part)\n            }\n        }\n\n        // merge the value into resultValue\n        utils.merge(resultValue, pseudoclasses[key.key])\n    }\n\n    return {key: resultKeyParts.join(':'), value: resultValue}\n}\n\n// a map of pseudoclass names and how they are emulated with javascript\n// each pseudoclass sets up the following functions:\n    // check - a function that checks if that pseudoclass currently applies to the component when its called\n    // setup - calls a callback when the pseudoClass starts and stops applying\n        // should return an object that will be passed to the kill function (as its 'state' parameter)\n    // kill - cleans up anything set up in the 'setup' function\n    // processParameter - takes the pseudoclass parameter and returns some object representing it that will be used by the setup and check functions\nvar emulatedPseudoClasses = {\n    hover: {\n        check: function(component) {\n            var nodes = document.querySelectorAll( \":hover\" )\n            for(var n=0; n<nodes.length; n++) {\n                if(nodes[n] === component.domNode) {\n                    return true\n                }\n            }\n            return false\n        },\n        setup: function(component, startCallback, endCallback) {\n            component.on(\"mouseover\", function() {\n                startCallback()\n            })\n            component.on(\"mouseout\", endCallback)\n\n            return {start: startCallback, end: endCallback}\n        },\n        kill: function(component, state) {\n            component.off(\"mouseover\", state.start)\n            component.off(\"mouseout\", state.end)\n        }\n    },\n    checked: {\n        check: function(component) {\n            return component.selected\n        },\n        setup: function(component, startCallback, endCallback) {\n            var setupState = {}\n            component.on(\"change\", setupState.listener = function() {\n                if(component.selected) {\n                    startCallback()\n                } else {\n                    endCallback()\n                }\n            })\n\n            return setupState\n        },\n        kill: function(component, state) {\n            component.removeListener(\"change\", state.listener)\n        }\n    },\n    required: {\n        check: function(component) {\n            return component.attr('required') !== undefined\n        },\n        setup: function(component, startCallback, endCallback) {\n            var observer = new MutationObserver(function() {\n                if(component.attr('required') !== undefined) {\n                    startCallback()\n                } else {\n                    endCallback()\n                }\n            })\n\n            observer.observe(component.domNode, {attributes: true})\n\n            return {observer: observer}\n        },\n        kill: function(component, state) {\n            state.observer.disconnect()\n        }\n    },\n    'last-child': {\n        check: function(component) {\n            console.log(\"Checking: \"+component.domNode.textContent+\" and its \"+nthLastChildCheck(component, '1'))\n            return nthLastChildCheck(component, '1')\n        },\n        setup: function(component, startCallback, endCallback) {\n            console.log(\"Setup: \"+component.domNode.textContent)\n\n            var observer = new MutationObserver(function() {\n                if(nthLastChildCheck(component, '1')) {\n                    startCallback()\n                } else {\n                    endCallback()\n                }\n            })\n\n            var setupObserver = function() {\n                // note that since this uses the component parent rather than domNode.parentNode, this won't work for components added to non-component nodes (and there's no good way to do it, because you would have to poll for parent changes)\n                observer.observe(component.parent.domNode, {childList: true})\n            }\n\n            if(component.parent !== undefined) {\n                setupObserver()\n            }\n\n            component.on('newParent', function() {\n                setupObserver()\n            })\n            component.on('parentRemoved', function() {\n                observer.disconnect()\n            })\n\n            return {observer: observer}\n        },\n        kill: function(component, state) {\n            console.log(\"Kill: \"+component.domNode.textContent)\n            state.observer.disconnect()\n        }\n    },\n    'nth-child': {\n        // todo: support full an+b parameters for nth-child https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-child\n        check: function(component, parameterCheck) {\n            return nthChildCheck(component, parameterCheck)\n        },\n        setup: function(component, startCallback, endCallback, parameterCheck) {\n\n            var checkAndCallCallbacks = function() {\n                if(nthChildCheck(component, parameterCheck)) {\n                    startCallback()\n                } else {\n                    endCallback()\n                }\n            }\n\n            var observer = new MutationObserver(function() {\n                checkAndCallCallbacks()\n            })\n\n            var setupObserver = function() {\n                // note that since this uses the component parent rather than domNode.parentNode, this won't work for components added to non-component nodes (and there's no good way to do it, because you would have to poll for parent changes)\n                observer.observe(component.parent.domNode, {childList: true})\n            }\n\n            if(component.parent !== undefined) {\n                setupObserver()\n            }\n\n            component.on('newParent', function() {\n                setupObserver()\n                checkAndCallCallbacks()\n            })\n            component.on('parentRemoved', function() {\n                observer.disconnect()\n                checkAndCallCallbacks()\n            })\n\n            return {observer: observer}\n        },\n        kill: function(component, state) {\n            state.observer.disconnect()\n        },\n        processParameter: function(parameter) {\n            return nthChildParameterFn(parameter)\n        }\n    },\n\n    // not's parameter is a statement consisting of pseudoclasses separated either by & or ,\n    // $$not(pseudoclass1&pseudoclass2,psuedoclass3) translates to the css :not(:pseudoclass1:pseudoclass2,:psuedoclass3)\n    /*not: {\n        check: function() {\n\n        },\n    }*/\n}\n\n// name is the name of the new pseudoclass\n// fns is an object with the members:\n    // check(component) - returns true if the pseudoclass applies to the component\n    // setup(component, startCallback, endCallback, parameter) - a function that should call startCallback when the pseudoclass starts applying, and endCallback when it stops applying\n        // parameter - the parameter passed to the pseudoclass (e.g. in :not(:first-child), \":first-child\" is the parameter)\n    // kill - a function that cleans up any event listeners or anything else set up in the 'setup' function\nmodule.exports.addPseudoClass = function(name, fns) {\n    if(emulatedPseudoClasses[name] !== undefined) throw new Error(\"The pseudoclass '\"+name+\"' is already defined.\")\n    // else\n    emulatedPseudoClasses[name] = fns\n}\n\n\nfunction nthChildCheck(component, testFn) {\n    if(component.domNode.parentNode === null)\n        return false\n\n    var children = component.domNode.parentNode.children                    // must be domNode.parentNode, because child nodes may not be Components\n    var index = Array.prototype.indexOf.call(children, component.domNode)\n    return testFn(index)\n}\n\nfunction nthLastChildCheck(component, parameter) {\n    if(component.domNode.parentNode === null)\n        return false\n\n    var children = component.domNode.parentNode.children                    // must be domNode.parentNode, because child nodes may not be Components\n    var index = children.length - parseInt(parameter)\n    return children[index] === component.domNode\n}\n\n// returns a function that takes an index and tell you if that index applies to the nthChildParameter\nvar nthChildParameter = /^(((-?\\d*)(([+-]\\d*)n?)?)|((-?\\d)*n?([+-]\\d*)?))$/\nfunction nthChildParameterFn(parameter) {\n    var parts = parameter.match(nthChildParameter)\n    if(parts === null)\n        throw new Error(\"nth-child parameter '\"+parameter+\"' isn't valid\")\n\n    if(parts[2] !== undefined) {\n        var constant = parts[3]\n        var variable = parts[5]\n    } else {\n        var constant = parts[8]\n        var variable = parts[7]\n    }\n\n    if(constant === undefined) constant = 0\n    else                       constant = parseInt(constant)\n    if(variable === undefined) variable = 0\n    else                       variable = parseInt(variable)\n\n    if(variable === 0) {\n        return function(index) {\n            return index+1 === constant\n        }\n    } else {\n        return function(index) {\n            return ((index+1-constant)/variable) % 1 === 0\n        }\n    }\n\n}\n\n// maps a style value to a css value\n// style values that are numbers are mapped to strings, usually with px postfix\nfunction cssValue(cssStyleName, value) {\n    // If a number was passed in, add 'px' to the (except for certain CSS properties) [also taken from jquery's code]\n    if(typeof(value) === \"number\" && cssNumber[cssStyleName] === undefined) {\n        return value+\"px\"\n    } else {\n        return value.toString()\n    }\n}\n\nfunction createPseudoClassRules(that, pseudoClass, selector, pseudoClassStyle) {\n\n    var pseudoClassCss = {}\n    for(var key in pseudoClassStyle) {\n        var value = pseudoClassStyle[key]\n\n        if(!(value instanceof Object)) {\n            var cssStyle = key\n            var cssStyleName = mapCamelCase(cssStyle)\n            pseudoClassCss[cssStyleName] = cssValue(cssStyleName, value)\n        } else {\n            throw new Error(\"All properties within the pseudoclasses '\"+pseudoClass+\"' must be css styles\")\n        }\n    }\n\n    // create immediate pseudo class style\n    defaultJss.set(selector, pseudoClassCss) // create the css class with the pseudoClass\n\n    //if(module.exports.isDev) {\n        that.styleDefinitions = {}\n        that.styleDefinitions[selector] = pseudoClassCss\n    //}\n}\n\n// throws exceptions for various style configurations that are unsupported by pure pseudo classes (ones that can't be emulated usuing javascript)\nfunction validatePurePseudoClassStyles(pseudoClass, pseudoClassStyles) {\n    for(var key in pseudoClassStyles) {\n        var value = pseudoClassStyles[key]\n\n        if(isStyleObject(value)) {\n            throw new Error(\"Can't set the pseudoclasses '\"+pseudoClass+\"' to a Style object\")\n        } else if(key === '$setup') {\n            throw new Error(\"$setup can't be used within the pseudoclasses '\"+pseudoClass+\"'\")\n        } else if(key === '$kill') {\n            throw new Error(\"$kill can't be used within the pseudoclasses '\"+pseudoClass+\"'\")\n        } else if(key.indexOf('$') === 0) {   // label style\n            throw new Error(\"Block labels can't be used within the pseudoclasses '\"+pseudoClass+\"'\")\n        }\n    }\n}\n\n// e.g. pulls out 'nth-child' and '2+3n' from 'nth-child(2+3n)'\nvar pseudoClassRegex = /^([^(]*)(\\((.*)\\))?$/\nfunction getPseudoClassParts(fullPsuedoClass) {\n    var x = fullPsuedoClass.match(pseudoClassRegex)\n    if(x === null) throw new Error(\"Pseudoclass '\"+fullPsuedoClass+\"' is invalid\")\n    return {class: x[1], parameter: x[3]}\n}\n\n\n// takes in a list of pseudoClassRules and changes any nesting like {hover: {focus: {}}} into something like {hover: {}, \"hover:focus\": {}}\n// also does some validation\nfunction flattenPseudoClassStyles(pseudoClass, pseudoClassStyle) {\n    var nonPseudoClassStyles = {}\n    var subpseudoClasses = {}\n    for(var key in pseudoClassStyle) {\n        var value = pseudoClassStyle[key]\n\n        if(key.indexOf('$$') === 0) { // pseudo-class style\n            var subPseudoClass = key.substr(2)\n            if(subPseudoClass === '') {\n                throw new Error(\"Empty pseudo-class name not valid (style key '$$')\")\n            }\n\n            subpseudoClasses[subPseudoClass] = value\n        } else {\n            nonPseudoClassStyles[key] = value\n        }\n    }\n\n    // create flattened styles (with merged in styles from its parent pseudoclass\n    var flattenedStyles = {}\n    for(var subPseudoClass in subpseudoClasses) {\n        var value = subpseudoClasses[subPseudoClass]\n\n        if(isStyleObject(value)) {\n            flattenedStyles[pseudoClass+\":\"+subPseudoClass] =  value\n        } else {\n            utils.merge(flattenedStyles, flattenPseudoClassStyles(pseudoClass+\":\"+subPseudoClass, utils.merge({}, nonPseudoClassStyles, value)))\n        }\n    }\n\n    // write the top-level pseudoClass\n    flattenedStyles[pseudoClass] = nonPseudoClassStyles\n\n    return flattenedStyles\n}\n\n\n// taken from jquery's code\nvar cssNumber = {\n    \"column-count\": 1,\n    \"fill-opacity\": 1,\n    \"flex-grow\": 1,\n    \"flex-shrink\": 1,\n    \"font-weight\": 1,\n    \"line-height\": 1,\n    \"opacity\": 1,\n    \"order\": 1,\n    \"orphans\": 1,\n    \"widows\": 1,\n    \"z-index\": 1,\n    \"zoom\": 1\n}\n\nfunction isStyleObject(o) {\n    return o.componentStyleMap !== undefined\n}\n\n\nvar asciiA = 'A'.charCodeAt(0), asciiZ = 'Z'.charCodeAt(0), difference = 'a'.charCodeAt(0) - asciiA\nfunction mapCamelCase(cssStyleName) {\n    for(var n=0; n<cssStyleName.length; n++) {\n        var ascii = cssStyleName.charCodeAt(n)\n        if(asciiA <= ascii && ascii <= asciiZ) { // found capital letter\n            cssStyleName = cssStyleName.slice(0, n) + '-'+String.fromCharCode(ascii+difference) + cssStyleName.slice(n+1)\n            n++ // increment a second time for the dash\n        }\n    }\n\n    return cssStyleName\n}\n\n// maps all the styles that are inherited by descendant nodes to their default values\n// source: http://stackoverflow.com/questions/5612302/which-css-styles-are-inherited\nvar defaultStyleValues = {\n    'azimuth': 'center',\n    'border-collapse': 'separate',\n    'border-spacing': '0',\n    'caption-side': 'top',\n    //'color': 'black',         // let this inherit\n    //'cursor': 'auto',         // let this one inherit - its weird otherwise\n    'direction': 'ltr',\n     display: 'inline-block', // changes the default display to inline-block\n    'elevation': '',\n    'empty-cells': 'show',\n    // 'font-family': '',       // let this inherit\n    // 'font-size': 'medium',   // let this inherit\n    //'font-style': 'normal',   // let this inherit\n    //'font-variant': 'normal', // let this inherit\n    //'font-weight': 'normal',  // let this inherit\n    'letter-spacing': 'normal',\n    'line-height': 'normal',\n    'list-style-image': 'none',\n    'list-style-position': 'outside',\n    'list-style-type': 'disc',\n    'orphans': '2',\n    'pitch-range': '',\n    'pitch': '',\n     position: 'relative', // changes the default positioning so that absolute is relative to its parent by default\n    'quotes': '',\n    'richness': '',\n    'speak-header': '',\n    'speak-numeral': '',\n    'speak-punctuation': '',\n    'speak': '',\n    'speak-rate': '',\n    'stress': '',\n    'text-align': 'left',\n    'text-indent': '0',\n    'text-transform': 'none',\n    //'visibility': 'visible',    // let this inherit - otherwise you just hide the container and not the contents\n    'voice-family': '',\n    'volume': '',\n    'white-space': 'normal',\n    'widows': '2',\n    'word-spacing': 'normal'\n}\n\ndefaultJss.set('.'+Style.defaultClassName, defaultStyleValues) // creates default css class in order to prevent inheritance\n\ndefaultJss.set('input', { // chrome and firefox user agent stylesheets mess with this otherwise\n    cursor: 'inherit'\n})\n\n/*private*/ module.exports.isDev; // should be set by Block\n\nvar computedStyles = module.exports.computedStyles = new HashMap() // stores a map from styleMap components, to the combined style map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Style.js\n ** module id = 2\n ** module chunks = 0\n **/","var Block = require('Block')\nvar proto = require('proto')\nvar Style = require(\"Style\")\n\nmodule.exports = proto(Block, function(superclass) {\n\n    //static properties\n\n    this.name = 'Canvas'\n\n    this.init = function(/*[label,] height, width*/) {\n        if(arguments.length === 2) {\n            var height = arguments[0]\n            var width = arguments[1]\n        } else {\n            var label = arguments[0]\n            var height = arguments[1]\n            var width = arguments[2]\n        }\n\n        this.domNode = document.createElement('canvas') // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n\n        this.label = label\n        this.height = height\n        this.width = width\n    }\n\n    // instance properties\n\n    Object.defineProperty(this, 'width', {\n        get: function() {\n            return this.domNode.width\n        }, set: function(v) {\n            this.domNode.width = v\n        }\n    })\n    Object.defineProperty(this, 'height', {\n        get: function() {\n            return this.domNode.height\n        }, set: function(v) {\n            this.domNode.height = v\n        }\n    })\n\n    this.context = function() {\n        return this.domNode.getContext.apply(this.domNode, arguments)\n    }\n\n    this.toImg = this.toDataURL = function() {\n        return this.domNode.toDataURL()\n    }\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Canvas.js\n ** module id = 3\n ** module chunks = 0\n **/","var Block = require('../Block')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static properties\n\n    this.name = 'Container'\n\n\n\t// instance properties\n\n\tthis.init = function (/*[label,] content*/) {\n        if(arguments.length === 1) {\n            var contentArgs = [arguments[0]]\n        } else if(arguments.length > 1) {\n            if(typeof(arguments[0]) === 'string') {\n                var label = arguments[0]\n                var contentArgs = Array.prototype.slice.call(arguments, 1)\n            } else {\n                var contentArgs = arguments\n            }\n        }\n\n\t\tvar that = this\n        superclass.init.call(this) // superclass constructor\n\n        this.label = label\n\n\t\tif(contentArgs !== undefined)\n            this.add.apply(this,contentArgs)\n\t}\n})\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Container.js\n ** module id = 4\n ** module chunks = 0\n **/","var Block = require('Block')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\n    // static variables\n\n    this.name = 'Button'\n\n\n    // instance properties\n\n\tthis.init = function(/*[label,] text*/) {\n        if(arguments.length >= 2) {\n            var label = arguments[0]\n            var text = arguments[1]\n        } else {\n            var text = arguments[0]\n        }\n\n        this.domNode = document.createElement(\"input\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n\n        this.label = label\n\t\tthis.attr('type','button');\n\t\tthis.text = text\n\t}\n\n    Object.defineProperty(this, 'text', {\n        get: function() {\n            return this.attr('value')\n        },\n        set: function(text) {\n            this.attr('value', text)\n        }\n    })\n\n})\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Button.js\n ** module id = 5\n ** module chunks = 0\n **/","var Block = require('Block')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\t// static variables\n    this.name = 'CheckBox'\n\n\t// instance methods\n\tthis.init = function(label) {\n        var that = this\n\n        this.domNode = document.createElement(\"input\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n\n        this.label = label\n\t\tthis.attr('type','checkbox')\n\t}\n\n    Object.defineProperty(this, 'selected', {\n        // returns whether or not the checkbox is checked\n        get: function() {\n            return this.domNode.checked\n        },\n        // sets the value of the checkbox to the passed value (true for checked)\n        set: function(checked) {\n            var newValue = checked === true\n            var curValue = this.domNode.checked\n            if(curValue === newValue) return;  // do nothing if nothing's changing\n\n            this.domNode.checked = newValue\n            this.emit('change') // the browser has no listenable event that is triggered on change of the 'checked' property\n        }\n    })\n})\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/CheckBox.js\n ** module id = 6\n ** module chunks = 0\n **/","var Block = require('Block')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\n    //static properties\n\n    this.name = 'Image'\n\n    this.init = function(/*[label,] imageSource*/) {\n        if(arguments.length === 1) {\n            var imageSource = arguments[0]\n        } else {\n            var label = arguments[0]\n            var imageSource = arguments[1]\n        }\n\n        this.domNode = document.createElement('img') // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n\n        var that = this\n\n        this.label = label\n        if(imageSource !==  undefined) this.src = imageSource\n    }\n\n    // instance properties\n\n    Object.defineProperty(this, 'src', {\n        get: function() {\n            return this.domNode.src\n        }, set: function(v) {\n            this.domNode.src = v\n        }\n    })\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Image.js\n ** module id = 7\n ** module chunks = 0\n **/","var proto = require('proto')\n\nvar Block = require('Block')\nvar Style = require(\"Style\")\n\nvar Item = require(\"./Item\");\n\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static properties\n\n\tthis.Item = Item\n\n    this.name = 'List'\n\n\t// instance properties\n\n\tthis.init = function(/*[label,] [ordered,] listInit*/) {\n\t\tif(arguments[0] instanceof Array) {\n            var listInit = arguments[0]\n        } else {\n            if(arguments[1] instanceof Array) {\n                var listInit = arguments[1]\n            } else if(arguments[2] instanceof Array) {\n                var listInit = arguments[2]\n            }\n\n            if(typeof(arguments[0]) === 'boolean') {\n                var ordered = arguments[0]\n            } else {\n                if(typeof(arguments[1]) === 'boolean') {\n                    var ordered = arguments[1]\n                } else {\n                    var ordered = false // default\n                }\n\n                if(typeof(arguments[0]) === 'string') {\n                    var label = arguments[0]\n                }\n            }\n        }\n\n        if(ordered) {\n            var type = 'ol'\n        } else {\n            var type = 'ul'\n            this.defaultStyle = Style({\n                listStyleType: 'decimal'\n            })\n        }\n\n\n        this.domNode = document.createElement(type) // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n        this.label = label\n\n        if(listInit !== undefined) {\n            for(var n=0; n<listInit.length; n++) {\n                this.item(listInit[n])\n            }\n        }\n\t}\n\n\tthis.item = function() {\n\t\tvar item = Item.apply(this, arguments)\n        this.add(item)\n        return item\n\t}\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/List.js\n ** module id = 8\n ** module chunks = 0\n **/","var proto = require('proto')\nvar EventEmitter = require('events').EventEmitter\n\nvar Block = require('../Block')\n\nvar randomStart = getRandomInt(0,999999) // a random number used to start off the numbers given to radio button names (using a random number in case there are somehow two different instances of blocks.js on the page)\n\n// A group of radio buttons\nmodule.exports = proto(EventEmitter, function(superclass) {\n\n\t// static properties\n\n    this.name = 'Radio'\n\n\t// instance properties\n\n\n    // required - If true, a radio button must always be selected. Otherwise, radio buttons can be deselected by clicking on them.\n\tthis.init = function(required) {\n        //this.selected\n        this.required = required === true || required === undefined\n        this.buttons = {} // maps values to the buttons that have each value\n        this.randomStart = randomStart++\n\t}\n\n    // returns a new radio button\n    this.button = function(/*[label,] value*/) {\n        if(arguments.length >= 2) {\n            var label = arguments[0]\n            var value = arguments[1]\n        } else {\n            var value = arguments[0]\n        }\n\n        if(this.buttons[value] !== undefined) {\n            throw new Error(\"Can't give a RadioButton the same value as another in the group (value: '\"+value+\"')\")\n        }\n\n        var button = RadioButton(this, label, value, \"_radioblock\"+this.randomStart)\n        this.buttons[value] = button\n\n        if(this.required && this._selected === undefined) {\n            button.selected = true\n        }\n\n        return button\n    }\n\n    // returns the RadioButton in the group that's selected (or undefined if none are selected)\n    Object.defineProperty(this, 'selected', {\n        get: function() {\n            return this._selected\n        },\n        set: function() {\n            throw new Error(\"Can't set selected on a Radio object\")\n        }\n    })\n\n    Object.defineProperty(this, 'val', {\n        // returns the value of the selected radio button in the group (undefined if none are selected)\n        get: function() {\n            var selected = this._selected\n            if(selected === undefined) return undefined\n            // else\n            return selected.attr('value')\n        },\n\n        // sets the value of the checkbox to the passed value (true for checked)\n        // throws an exception if none of the radio buttons have that value\n        // throws an exception if an unset is attempted for a required Radio set\n        set: function(value) {\n            if(value === undefined) {\n                var selected = this._selected\n                if(selected !== undefined) {\n                    selected.selected = false\n                }\n            } else {\n                var button = this.buttons[value]\n                if(button === undefined) throw new Error(\"There is no RadioButton in the group with the value: '\"+value+\"'\")\n\n                button.selected = true\n            }\n        }\n    })\n\n\n    // arguments can be one of the following:\n        // RadioButton, RadioButton, RadioButton, ...\n        // value, value, value, ... - each value is the value of the RadioButton to remove\n        // arrayOfRadioButtons\n        // arrayOfValues\n    this.remove = function() {\n        if(arguments[0] instanceof Array) {\n            var removals = arguments[0]\n        } else {\n            var removals = arguments\n        }\n\n        for(var n=0; n<removals.length; n++) {\n            var r = removals[n]\n\n            if(r instanceof RadioButton) {\n                var button = r\n                var value = r.val\n\n                if(this.buttons[value] !== r) {\n                    throw new Error(\"The button passed at index \"+n+\" is not part of the group.\")\n                }\n            } else {\n                var button = this.buttons[r]\n                var value = r\n\n                if(button === undefined) {\n                    throw new Error(\"There is no RadioButton in the group with the value: '\"+value+\"'\")\n                }\n            }\n\n            var originalSelected = this.selected\n            if(this.selected === button) {\n                this._selected = undefined\n            }\n\n            this.buttons[value].group = undefined // fully remove it from the group\n            delete this.buttons[value]\n        }\n\n        if(this.required && this.selected === undefined) {\n            for(var v in this.buttons) {\n                this.buttons[v].selected = true // just select the first one\n                break; // yes this doesn't loop\n            }\n        } else if(originalSelected !== this.selected) {\n            this.emit('change')\n        }\n    }\n\n})\n\nvar RadioButton = proto(Block, function(superclass) {\n    this.name = 'RadioButton'\n\n    this.init = function(radioGroup, label, value, name) {\n        this.domNode = document.createElement(\"input\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n\n        this.label = label\n        this.group = radioGroup\n\n        this.attr('type', 'radio')\n        this.attr('name', name) // the name is needed so that using tab to move through page elements can tab between different radio groups\n        this.val = value\n\n        var that = this\n\t\tthis.on(\"mousedown\",function(event) {\n            event.preventDefault()           // this needs to be here otherwise the radio button can't be changed\n\n\t\t\tif(that.group.required) {\n                if(that.selected === false) {\n                    that.selected = true\n                }\n            } else {\n                that.selected = !that.selected // toggle\n            }\n\t\t})\n        this.on(\"click\",function(event) {\n            event.preventDefault()         // this needs to be here otherwise the radio button can't be *unset*\n        })\n        this.on(\"keydown\",function(event) {\n            if(event.keyCode === 40 || event.keyCode === 39) { // down or right\n                event.preventDefault()         // this needs to be here otherwise the radio button strangely calls the click handler which causes things to mess up\n                that.selectNext()\n            } else if(event.keyCode === 38 || event.keyCode === 37) { // up or left\n                event.preventDefault()         // this needs to be here otherwise the radio button strangely calls the click handler which causes things to mess up\n                that.selectPrevious()\n            }\n        })\n    }\n\n    Object.defineProperty(this, 'val', {\n        // returns the value attribute of the checkbox\n        get: function() {\n            return this.attr('value')\n        },\n\n        // sets the value attribute of the checkbox\n        set: function(value) {\n            if(this.group.buttons[value] !== undefined) {\n                throw new Error(\"Can't give a RadioButton the same value as another in the group (value: '\"+value+\"')\")\n            }\n\n            var oldValue = this.val\n            this.attr('value', value)\n            if(oldValue !== undefined) delete this.group.buttons[oldValue]\n            this.group.buttons[value] = this\n        }\n    })\n\n\n    Object.defineProperty(this, 'selected', {\n        // returns whether or not the checkbox is checked\n        get: function() {\n            return this.domNode.checked\n        },\n\n        // sets the selected state of the checkbox to the passed value (true for checked)\n        set: function(value) {\n            var booleanValue = value === true\n            if(this.selected === value) return; // ignore if there's no change\n\n            if(booleanValue) {\n                var previouslySelected = this.group.selected\n                setButtonInGroup(this.group, this)\n                if(previouslySelected !== undefined)\n                    previouslySelected.emit('change')\n            } else {\n                if(this.group.required) throw new Error(\"Can't unset this Radio set, a value is required.\")\n                this.domNode.checked = false\n                this.group._selected = undefined\n            }\n            this.emit('change') // the browser has no listenable event that is triggered on change of the 'checked' property\n            this.group.emit('change')\n        }\n    })\n\n    this.selectNext = function() {\n        selectSibling(this,1)\n    }\n    this.selectPrevious = function() {\n        selectSibling(this,-1)\n    }\n\n})\n\n// direction can be +1 or -1\nfunction selectSibling(button, direction) {\n    var buttons = button.group.buttons\n    var values = Object.keys(buttons)\n    var index = values.indexOf(button.attr('value'))\n    if(direction === 1 && index === values.length-1) {\n        var buttonToSelect = buttons[values[0]]\n    } else if(direction === -1 && index === 0) {\n        var buttonToSelect = buttons[values[values.length-1]]\n\n    } else {\n        var buttonToSelect = buttons[values[index+direction]]\n    }\n\n    buttonToSelect.selected = true\n    buttonToSelect.focus()\n}\n\nfunction setButtonInGroup(group, button) {\n    var selected = group._selected\n    if(selected !== undefined) selected.domNode.checked = false\n    button.domNode.checked = true\n    group._selected = button\n}\n\nfunction getRandomInt(min, max) {\n  return Math.floor(Math.random() * (max - min)) + min;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Radio.js\n ** module id = 9\n ** module chunks = 0\n **/","var Block = require('../Block')\nvar proto = require('proto')\n\nvar Option = require('Components/Option')\n\n// emits a 'change' event when its 'val' changes\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static variables\n\n    this.name = 'Select'\n\n    this.Option = Option\n\n\tthis.init = function(/*[label,] options*/) {\n        if(arguments[0] instanceof Object) {\n            var options = arguments[0]\n        } else {\n            var label = arguments[0]\n            var options = arguments[1]\n        }\n\n        this.domNode = document.createElement(\"select\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n        this.label = label\n\n        this.options = {}\n\n\t\tfor(var value in options) {\n\t\t\tthis.option(value, options[value])\n\t\t}\n\t}\n\n\n\t// instance methods\n\n    Object.defineProperty(this, 'val', {\n        // returns the value that is selected\n        get: function() {\n            for(var value in this.options) {\n                if(this.options[value].selected) {\n                    return value\n                }\n            }\n        },\n\n        set: function(value) {\n            var option = this.options[value]\n            if(option === undefined) throw new Error(\"There is no Option in the Select with the value: '\"+value+\"'\")\n            option.selected = true\n        }\n    })\n\t\n\tthis.option = function(/*[label,] value,text*/) {\n        if(arguments.length === 2) {\n            var value = arguments[0]\n            var text = arguments[1]\n        } else if(arguments.length === 3) {\n            var label = arguments[0]\n            var value = arguments[1]\n            var text = arguments[2]\n        } else {\n            throw new Error(\"Invalid number of arguments\")\n        }\n\n        var newOption = Option(label, value,text)\n        this.add(newOption)\n\n        return newOption\n\n\t}\n\n    // same interface as Block.addAt\n    /*override*/ this.addAt = function(index/*, nodes...*/) {\n        var that = this\n\n        var nodesToAdd = Block.normalizeAddAtArguments.apply(this, arguments)\n\n        // validation first\n        nodesToAdd.forEach(function(option) {\n            if(that.options[option.val] !== undefined) {\n                throw new Error(\"Can't give an Option the same value as another in the Select (value: '\"+option.val+\"')\")\n            }\n        })\n\n        superclass.addAt.call(this, index, nodesToAdd)\n\n        // Select specific state modifications - this must be done after the superclass call in case an error is thrown from it\n        var anyWereSelected = false\n        nodesToAdd.forEach(function(option) {\n            if(option.selected) anyWereSelected = true\n            that.options[option.val] = option\n\n            // set up Select events\n            // todo: remove events when the Option is removed\n\n            option.on(\"mousedown\",function(event) {\n                option.parent.val = option.val      // select this one\n            })\n        })\n\n        if(anyWereSelected) {\n            this.emit('change')\n        }\n    }\n\n    // same interface as Block.remove\n    /*override*/ this.remove = function() {\n        var that = this\n\n        var removalIndexes = Block.normalizeRemoveArguments.apply(this, arguments)\n        var removals = removalIndexes.map(function(index) {\n            return that.children[index]\n        })\n\n        superclass.remove.call(this, removalIndexes)\n\n        // Select specific state modifications - this must be done after the superclass call in case an error is thrown from it\n        var theSelectedWasRemoved = false\n        removals.forEach(function(option) {\n            if(option.selected) theSelectedWasRemoved = true\n            delete that.options[option.val]\n        })\n\n        if(theSelectedWasRemoved) {\n            //this.children[0].selected = true // I think the browser does this automatically??\n            this.emit('change')\n        }\n    }\n\n\n    // private\n\n    this.prepareForValueChange = function(values) {\n        var value = values[0]\n\n        for(var optionValue in this.options) {\n            if(optionValue !== value) {\n                var option = this.options[optionValue]\n                if(option.selected === true) {\n                    option.setSelectedQuiet(false)\n                }\n            }\n        }\n    }\n})\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Select.js\n ** module id = 10\n ** module chunks = 0\n **/","var proto = require('proto')\n\nvar Block = require('../Block')\nvar Style = require(\"Style\")\n\nvar Header = require(\"./Header\");\nvar Row = require(\"./Row\");\nvar Cell = require(\"./Cell\");\n\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static properties\n\n    this.name = 'Table'\n\n    this.defaultStyle = Style({\n        borderSpacing: 0\n    })\n\n    this.Row = Row\n\tthis.Header = Header\n    this.Cell = Cell\n\n\n\t// instance properties\n\n\tthis.init = function(/*[label,] tableInit*/) {\n\t\tif(arguments[0] instanceof Array) {\n            var tableInit = arguments[0]\n        } else {\n            var label = arguments[0]\n            var tableInit = arguments[1]\n        }\n\n        this.domNode = document.createElement(\"table\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n        this.label = label\n\n        if(tableInit !== undefined) {\n            for(var n=0; n<tableInit.length; n++) {\n                this.row(tableInit[n])\n            }\n        }\n\t}\n\t\n\tthis.header = function(/*[]label,] listOfBlocksOrText*/) {\n        return headerOrRegularRow(this, Header, arguments)\n\t}\n\n\tthis.row = function() {\n\t\treturn headerOrRegularRow(this, Row, arguments)\n\t}\n});\n\nfunction headerOrRegularRow(that, Prototype, args) {\n    var row = Prototype.apply(undefined, args)\n    that.add(row)\n    return row\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Table.js\n ** module id = 11\n ** module chunks = 0\n **/","var Block = require('../Block')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static variables\n\n    this.name = 'TextArea'\n\n\tthis.init = function(label) {\n        this.domNode = document.createElement(\"textarea\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n\t\tthis.label = label\n\t}\n\n\n\t// instance properties\n\n\n    Object.defineProperty(this, 'val', {\n        // returns the value of the Option\n        get: function() {\n            return this.domNode.value\n        },\n\n        // sets the value of the Option\n        set: function(value) {\n            if(this.val === value) return; // do nothing if there's no change\n\n            this.domNode.value = value\n            this.emit('change')\n        }\n    })\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/TextArea.js\n ** module id = 12\n ** module chunks = 0\n **/","var Block = require('../Block')\nvar proto = require('proto')\n\nvar domUtils = require(\"../domUtils\")\n\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static properties\n\n    this.name = 'TextField'\n\n\tthis.init = function(/*[label,] password*/) {\n        if(arguments.length === 1) {\n            var password = arguments[0]\n        } else if(arguments.length > 1) {\n            var label = arguments[0]\n            var password = arguments[1]\n        }\n\n        this.domNode = document.createElement(\"input\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n\n\t\tthis.label = label\n        this.domNode.className = 'field'\n\t\tdomUtils.setAttribute(this.domNode,'type','text');\n        if(password)\n            domUtils.setAttribute(this.domNode, 'type', 'password')\n\t}\n\n\n\t// instance properties\n\n    Object.defineProperty(this, 'val', {\n        // returns the value of the Option\n        get: function() {\n            return this.domNode.value\n        },\n\n        // sets the value of the Option\n        set: function(value) {\n            if(this.val === value) return; // do nothing if there's no change\n\n            this.domNode.value = value\n            this.emit('change')\n        }\n    })\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/TextField.js\n ** module id = 13\n ** module chunks = 0\n **/","var Block = require('../Block')\nvar proto = require('proto')\nvar Style = require(\"Style\")\n\nmodule.exports = proto(Block, function(superclass) {\n\n    //static properties\n\n    this.name = 'Text'\n\n    this.defaultStyle = Style({\n        whiteSpace: 'pre'\n    })\n\n    this.init = function(/*[label,] text*/) {\n        if(arguments.length === 1) {\n            var text = arguments[0]\n        } else {\n            var label = arguments[0]\n            var text = arguments[1]\n        }\n\n        if (text === undefined) text = '';\n\n        superclass.init.call(this) // superclass constructor\n\n        var that = this\n\n        this.label = label\n        this.text = text\n\n        this.on(\"input\",function(data) {\n            var eventData = {newText:data.srcElement.textContent,oldText:that.oldText};\n            that.oldText = eventData.newText;\n            //that.emit(\"input\",eventData);\n        });\n\n        this.on(\"blur\",function(data) {\n            var eventData = {newText:data.srcElement.textContent,oldText:that.lastFocus};\n            that.lastFocus = eventData.newText;\n            //that.emit(\"blur\",eventData);\n        });\n    }\n\n    // instance properties\n\n    Object.defineProperty(this, 'text', {\n        get: function() {\n            return this.domNode.textContent\n        }, set: function(v) {\n            this.domNode.innerText = v   // apparently textContent can't be set or something\n        }\n    })\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Text.js\n ** module id = 14\n ** module chunks = 0\n **/","var EventEmitter = require('events').EventEmitter\r\nvar proto = require(\"proto\")\r\nvar utils = require(\"utils\")\r\n\r\nmodule.exports = proto(EventEmitter, function(superclass) {\r\n\r\n    this.init = function() {\r\n        superclass.apply(this, arguments)\r\n\r\n        this.ifonHandlers = {}\r\n        this.ifoffHandlers = {}\r\n        this.ifonAllHandlers = []\r\n        this.ifoffAllHandlers = []\r\n    }\r\n\r\n    // callback will be triggered immediately if there is already a listener attached, or\r\n    // callback will be triggered when the first listener for the event is added\r\n    // (regardless of whether its done through on or once)\r\n    // parameters can be:\r\n        // event, callback - attach an ifon handler for the passed event\r\n        // callback - attach an ifon handler for all events\r\n    this.ifon = function(event, callback) {\r\n        if(event instanceof Function) {     // event not passed, only a callback\r\n            callback = event // fix the argument\r\n            for(var eventName in this._events) {\r\n                if(this.listeners(eventName).length > 0) {\r\n                    callback(eventName)\r\n                }\r\n            }\r\n        } else if(this.listeners(event).length > 0) {\r\n            callback(event)\r\n        }\r\n\r\n        addHandlerToList(this, 'ifonHandlers', event, callback)\r\n    }\r\n\r\n    // removes either:\r\n        // removeIfon() - all ifon handlers (if no arguments are passed), or\r\n        // removeIfon(event) - all ifon handlers for the passed event, or\r\n        // removeIfon(callback) - the passed ifon-all handler (if the first parameter is the callback)\r\n        // removeIfon(event, callback) - the specific passed callback for the passed event\r\n    this.removeIfon = function(event, callback) {\r\n        removeFromHandlerList(this, 'ifonHandlers', event, callback)\r\n    }\r\n\r\n    // callback will be triggered when the last listener for the 'click' event is removed (will not trigger immediately if there is no event listeners on call of ifoff)\r\n    // (regardless of whether this is done through removeListener or as a result of 'once' being fulfilled)\r\n    // parameters can be:\r\n        // event, callback - attach an ifoff handler for the passed event\r\n        // callback - attach an ifoff handler for all events\r\n    this.ifoff = function(event, callback) {\r\n        addHandlerToList(this, 'ifoffHandlers', event, callback)\r\n    }\r\n\r\n    // removes either:\r\n        // removeIfoff() - all ifoff handlers (if no arguments are passed), or\r\n        // removeIfoff(event) - all ifoff handlers for the passed event, or\r\n        // removeIfoff(callback) - the passed ifoff-all handler (if the first parameter is the callback)\r\n        // removeIfoff(event, callback) - the specific passed callback for the passed event\r\n    this.removeIfoff = function(event, callback) {\r\n        removeFromHandlerList(this, 'ifoffHandlers', event, callback)\r\n    }\r\n\r\n    // emitter is the emitter to proxy handler binding to\r\n    // options can have one of the following properties:\r\n        // only - an array of events to proxy\r\n        // except - an array of events to *not* proxy\r\n    this.proxy = function(emitter, options) {\r\n        if(options === undefined) options = {}\r\n        if(options.except !== undefined) {\r\n            var except = utils.arrayToMap(options.except)\r\n            var handleIt = function(event){return !(event in except)}\r\n        } else if(options.only !== undefined) {\r\n            var only = utils.arrayToMap(options.only)\r\n            var handleIt = function(event){return event in only}\r\n        } else {\r\n            var handleIt = function(){return true}\r\n        }\r\n\r\n        var that = this, handler;\r\n        this.ifon(function(event) {\r\n            if(handleIt(event)) {\r\n                emitter.on(event, handler = function() {\r\n                    that.emit.apply(that, [event].concat(Array.prototype.slice.call(arguments)))\r\n                })\r\n            }\r\n        })\r\n        this.ifoff(function(event) {\r\n            if(handleIt(event))\r\n                emitter.off(event, handler)\r\n        })\r\n    }\r\n\r\n    /*override*/ this.on = this.addListener = function(event, callback) {\r\n        var triggerIfOn = this.listeners(event).length === 0\r\n        superclass.prototype.on.apply(this,arguments)\r\n        if(triggerIfOn) triggerIfHandlers(this, 'ifonHandlers', event)\r\n    }\r\n\r\n    /*override*/ this.off = this.removeListener = function(event, callback) {\r\n        var triggerIfOff = this.listeners(event).length === 1\r\n        superclass.prototype.removeListener.apply(this,arguments)\r\n        if(triggerIfOff) triggerIfHandlers(this, 'ifoffHandlers', event)\r\n    }\r\n    /*override*/ this.removeAllListeners = function(event) {\r\n        var triggerIfOffForEvents = []\r\n        if(event !== undefined) {\r\n            if(this.listeners(event).length > 0) {\r\n                triggerIfOffForEvents.push(event)\r\n            }\r\n        } else {\r\n            for(var event in this._events) {\r\n                if(this.listeners(event).length > 0) {\r\n                    triggerIfOffForEvents.push(event)\r\n                }\r\n            }\r\n        }\r\n\r\n        superclass.prototype.removeAllListeners.apply(this,arguments)\r\n\r\n        for(var n=0; n<triggerIfOffForEvents.length; n++) {\r\n            triggerIfHandlers(this, 'ifoffHandlers', triggerIfOffForEvents[n])\r\n        }\r\n    }\r\n\r\n})\r\n\r\n\r\n// triggers the if handlers from the normal list and the \"all\" list\r\nfunction triggerIfHandlers(that, handlerListName, event) {\r\n    triggerIfHandlerList(that[handlerListName][event], event)\r\n    triggerIfHandlerList(that[normalHandlerToAllHandlerProperty(handlerListName)], event)\r\n}\r\n\r\n\r\n// triggers the if handlers from a specific list\r\n// ya these names are confusing, sorry : (\r\nfunction triggerIfHandlerList(handlerList, event) {\r\n    if(handlerList !== undefined) {\r\n        for(var n=0; n<handlerList.length; n++) {\r\n            handlerList[n](event)\r\n        }\r\n    }\r\n}\r\n\r\nfunction addHandlerToList(that, handlerListName, event, callback) {\r\n    if(event instanceof Function) {\r\n        // correct arguments\r\n        callback = event\r\n        event = undefined\r\n    }\r\n\r\n    if(event !== undefined && callback !== undefined) {\r\n        var handlerList = that[handlerListName][event]\r\n        if(handlerList === undefined) {\r\n            handlerList = that[handlerListName][event] = []\r\n        }\r\n\r\n        handlerList.push(callback)\r\n    } else {\r\n        that[normalHandlerToAllHandlerProperty(handlerListName)].push(callback)\r\n    }\r\n}\r\n\r\nfunction removeFromHandlerList(that, handlerListName, event, callback) {\r\n    if(event instanceof Function) {\r\n        // correct arguments\r\n        callback = event\r\n        event = undefined\r\n    }\r\n\r\n    if(event !== undefined && callback !== undefined) {\r\n        removeCallbackFromList(that[handlerListName][event], callback)\r\n    } else if(event !== undefined) {\r\n        delete that[handlerListName][event]\r\n    } else if(callback !== undefined) {\r\n        var allHandlerListName = normalHandlerToAllHandlerProperty(handlerListName)\r\n        removeCallbackFromList(that[allHandlerListName], callback)\r\n    } else {\r\n        var allHandlerListName = normalHandlerToAllHandlerProperty(handlerListName)\r\n        that[handlerListName] = {}\r\n        that[allHandlerListName] = []\r\n    }\r\n}\r\n\r\nfunction normalHandlerToAllHandlerProperty(handlerListName) {\r\n    if(handlerListName === 'ifonHandlers')\r\n        return 'ifonAllHandlers'\r\n    if(handlerListName === 'ifoffHandlers')\r\n        return 'ifoffAllHandlers'\r\n}\r\n\r\nfunction removeCallbackFromList(list, callback) {\r\n    var index = list.indexOf(callback)\r\n    list.splice(index,1)\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/EventEmitterB.js\n ** module id = 15\n ** module chunks = 0\n **/","// utilities needed by the configuration (excludes dependencies the configs don't need so the webpack bundle is lean)\r\n\r\nvar path = require('path')\r\n\r\n\r\n// Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1\r\n// any number of objects can be passed into the function and will be merged into the first argument in order\r\n// returns obj1 (now mutated)\r\nvar merge = exports.merge = function(obj1, obj2/*, moreObjects...*/){\r\n    return mergeInternal(arrayify(arguments), false)\r\n}\r\n\r\n// like merge, but traverses the whole object tree\r\n// the result is undefined for objects with circular references\r\nvar deepMerge = exports.deepMerge = function(obj1, obj2/*, moreObjects...*/) {\r\n    return mergeInternal(arrayify(arguments), true)\r\n}\r\n\r\n// returns a new object where properties of b are merged onto a (a's properties may be overwritten)\r\nexports.objectConjunction = function(a, b) {\r\n    var objectCopy = {}\r\n    merge(objectCopy, a)\r\n    merge(objectCopy, b)\r\n    return objectCopy\r\n}\r\n\r\n// turns an array of values into a an object where those values are all keys that point to 'true'\r\nexports.arrayToMap = function(array) {\r\n    var result = {}\r\n    array.forEach(function(v) {\r\n        result[v] = true\r\n    })\r\n    return result\r\n}\r\n\r\nfunction mergeInternal(objects, deep) {\r\n    var obj1 = objects[0]\r\n    var obj2 = objects[1]\r\n\r\n    for(var key in obj2){\r\n       if(Object.hasOwnProperty.call(obj2, key)) {\r\n            if(deep && obj1[key] instanceof Object && obj2[key] instanceof Object) {\r\n                mergeInternal([obj1[key], obj2[key]], true)\r\n            } else {\r\n                obj1[key] = obj2[key]\r\n            }\r\n       }\r\n    }\r\n\r\n    if(objects.length > 2) {\r\n        var newObjects = [obj1].concat(objects.slice(2))\r\n        return mergeInternal(newObjects, deep)\r\n    } else {\r\n        return obj1\r\n    }\r\n}\r\n\r\nfunction arrayify(a) {\r\n    return Array.prototype.slice.call(a, 0)\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/utils.js\n ** module id = 16\n ** module chunks = 0\n **/","\r\n// creates a dom element optionally with a class and attributes\r\n var node = module.exports.node = function(type, className, options) {\r\n    var elem = document.createElement(type)\r\n\r\n    if(options !== undefined) {\r\n        if(options.attr !== undefined) {\r\n            for(var attribute in options.attr) {\r\n                createAttribute(elem, attribute, options.attr[attribute])\r\n            }\r\n        }\r\n        if(options.textContent !== undefined) {\r\n            elem.textContent = options.textContent\r\n        }\r\n    }\r\n\r\n    if(className !== undefined)\r\n        elem.className = className\r\n\r\n    return elem\r\n}\r\n\r\n// convenience function for creating a div\r\nmodule.exports.div = function(className, options) {\r\n    return node('div', className, options)\r\n}\r\n\r\n// adds an attribute to a domNode\r\nvar setAttribute = module.exports.setAttribute = function(/*[domNode,] type, value*/) {\r\n    if (arguments.length === 2) {\r\n        var domNode = this.domNode;\r\n        var type = arguments[0];\r\n        var value = arguments[1];\r\n    } else if (arguments.length === 3) {\r\n        var domNode = arguments[0];\r\n        var type = arguments[1];\r\n        var value = arguments[2];\r\n    } else {\r\n        throw new Error(\"This function expects arguments to be: [domNode,] type, value\");\r\n    }\r\n    var attr = document.createAttribute(type)\r\n    attr.value = value\r\n    domNode.setAttributeNode(attr)\r\n}\r\n\r\n\r\n// sets the selection\r\n//\r\n// works for contenteditable elements\r\nexports.setSelectionRange = function(containerEl, start, end) {\r\n\r\n    if(containerEl.nodeName === 'INPUT' || containerEl.nodeName === 'TEXTAREA') {\r\n        containerEl.setSelectionRange(start, end)\r\n    } else {\r\n        var charIndex = 0, range = document.createRange();\r\n        range.setStart(containerEl, 0);\r\n        range.collapse(true);\r\n        var foundStart = false;\r\n\r\n        iterateThroughLeafNodes(containerEl, function(node) {\r\n            var hiddenCharacters = findHiddenCharacters(node, node.length)\r\n            var nextCharIndex = charIndex + node.length - hiddenCharacters;\r\n\r\n            if (!foundStart && start >= charIndex && start <= nextCharIndex) {\r\n                var nodeIndex = start-charIndex\r\n                var hiddenCharactersBeforeStart = findHiddenCharacters(node, nodeIndex)\r\n                range.setStart(node, nodeIndex + hiddenCharactersBeforeStart);\r\n                foundStart = true;\r\n            }\r\n\r\n            if (foundStart && end >= charIndex && end <= nextCharIndex) {\r\n                var nodeIndex = end-charIndex\r\n                var hiddenCharactersBeforeEnd = findHiddenCharacters(node, nodeIndex)\r\n                range.setEnd(node, nodeIndex + hiddenCharactersBeforeEnd);\r\n                return true; // stop the iteration - we're done here\r\n            }\r\n\r\n            charIndex = nextCharIndex\r\n        })\r\n\r\n        var sel = window.getSelection();\r\n        sel.removeAllRanges();\r\n        sel.addRange(range);\r\n    }\r\n}\r\n\r\n// gets the character offsets of a selection within a particular dom node\r\n// returns undefined if there is no selection in the element\r\n// note: yes this code doesn't work in older versions of IE (or possibly any versions) - if you want it to work in IE, please use http://modernizr.com/ or a polyfill for ranges\r\nexports.getSelectionRange = function (element) {\r\n\r\n    var selection = window.getSelection()\r\n    var isInputOrArea = element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA'\r\n\r\n    for(var n=0; n<selection.rangeCount; n++) {\r\n        var range = selection.getRangeAt(0)\r\n        if(isInputOrArea) {\r\n            if(range.startOffset === range.endOffset && range.startContainer.children[range.startOffset] === element /*|| range.startContainer === element || */) { // I don't think the input or textarea itself will ever be the startContainer\r\n                return [element.selectionStart, element.selectionEnd]\r\n            }\r\n        } else {\r\n            var startsInElement = element.contains(range.startContainer)\r\n            if(startsInElement) {\r\n                var elementToIterateThrough = element\r\n                var startFound = true\r\n            } else {\r\n                var elementToIterateThrough = range.commonAncestorContainer\r\n                var startFound = false\r\n                var startContainerFound = false\r\n            }\r\n\r\n            var visibleCharacterOffset = 0, start, end;\r\n            iterateThroughLeafNodes(elementToIterateThrough, function(leaf) {\r\n                if(!startFound) {\r\n                    if(leaf === range.startContainer) {\r\n                        startContainerFound = true\r\n                    }\r\n\r\n                    if(!element.contains(leaf) || !startContainerFound)\r\n                        return; // continue\r\n                    else if(startContainerFound)\r\n                       startFound = true\r\n                } else if(!startsInElement && !element.contains(leaf)) {\r\n                    return true // done!\r\n                }\r\n\r\n                if(leaf === range.startContainer) {\r\n                    start = visibleCharacterOffset + range.startOffset - findHiddenCharacters(leaf, range.startOffset)\r\n                }\r\n                if(leaf === range.endContainer) {\r\n                    end = visibleCharacterOffset + range.endOffset - findHiddenCharacters(leaf, range.endOffset)\r\n                    return true // done!\r\n                }\r\n\r\n                visibleCharacterOffset += leaf.length - findHiddenCharacters(leaf, leaf.length)\r\n            })\r\n\r\n            if(start === undefined && !startFound) {\r\n                return undefined\r\n            } else {\r\n                if(start === undefined) {\r\n                    start = 0 // start is at the beginning\r\n                }\r\n                if(end === undefined) {\r\n                    end = visibleCharacterOffset // end is all the way at the end (the selection may continue in other elements)\r\n                }\r\n\r\n                return [start, end]\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// iterate through the leaf nodes inside element\r\n// callback(node) - a function called for each leaf node\r\n    // returning true from this ends the iteration\r\nfunction iterateThroughLeafNodes(element, callback) {\r\n    var nodeStack = [element], node;\r\n\r\n    while (node = nodeStack.pop()) {\r\n        if (node.nodeType == 3) {\r\n            if(callback(node) === true)\r\n                break;\r\n        } else {\r\n            var i = node.childNodes.length;\r\n            while (i--) {\r\n                nodeStack.push(node.childNodes[i]);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction findHiddenCharacters(node, beforeCaretIndex) {\r\n    var hiddenCharacters = 0\r\n    var lastCharWasWhiteSpace=true\r\n    for(var n=0; n-hiddenCharacters<beforeCaretIndex &&n<node.length; n++) {\r\n        if([' ','\\n','\\t','\\r'].indexOf(node.textContent[n]) !== -1) {\r\n            if(lastCharWasWhiteSpace)\r\n                hiddenCharacters++\r\n            else\r\n                lastCharWasWhiteSpace = true\r\n        } else {\r\n            lastCharWasWhiteSpace = false\r\n        }\r\n    }\r\n\r\n    return hiddenCharacters\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/domUtils.js\n ** module id = 17\n ** module chunks = 0\n **/","/*\r\n * JSS v0.6 - JavaScript Stylesheets\r\n * https://github.com/Box9/jss\r\n *\r\n * Copyright (c) 2011, David Tang\r\n * MIT Licensed (http://www.opensource.org/licenses/mit-license.php)\r\n */\r\nvar jss = (function() {\r\n    var adjSelAttrRegex = /((?:\\.|#)[^\\.\\s#]+)((?:\\.|#)[^\\.\\s#]+)/g;\r\n    var doubleColonPseudoElRegex = /(::)(before|after|first-line|first-letter|selection)/;\r\n    var singleColonPseudoElRegex = /([^:])(:)(before|after|first-line|first-letter|selection)/;\r\n    var singleColonForPseudoElements; // flag for older browsers\r\n\r\n    function getSelectorsAndRules(sheet) {\r\n        var rules = sheet.cssRules || sheet.rules || [];\r\n        var results = {};\r\n        for (var i = 0; i < rules.length; i++) {\r\n            // Older browsers and FF report pseudo element selectors in an outdated format\r\n            var selectorText = toDoubleColonPseudoElements(rules[i].selectorText);\r\n            if (!results[selectorText]) {\r\n                results[selectorText] = [];\r\n            }\r\n            results[selectorText].push({\r\n                sheet: sheet,\r\n                index: i,\r\n                style: rules[i].style\r\n            });\r\n        }\r\n        return results;\r\n    }\r\n\r\n    function getRules(sheet, selector) {\r\n        var rules = sheet.cssRules || sheet.rules || [];\r\n        var results = [];\r\n        // Browsers report selectors in lowercase\r\n        selector = selector.toLowerCase();\r\n        for (var i = 0; i < rules.length; i++) {\r\n            var selectorText = rules[i].selectorText;\r\n            // Note - certain rules (e.g. @rules) don't have selectorText\r\n            if (selectorText && (selectorText == selector || selectorText == swapAdjSelAttr(selector) || selectorText == swapPseudoElSyntax(selector))) {\r\n                results.push({\r\n                    sheet: sheet,\r\n                    index: i,\r\n                    style: rules[i].style\r\n                });\r\n            }\r\n        }\r\n        return results;\r\n    }\r\n\r\n    function addRule(sheet, selector) {\r\n        var rules = sheet.cssRules || sheet.rules || [];\r\n        var index = rules.length;\r\n        var pseudoElementRule = addPseudoElementRule(sheet, selector, rules, index);\r\n\r\n        if (!pseudoElementRule) {\r\n            addRuleToSheet(sheet, selector, index);\r\n        }\r\n\r\n        return {\r\n            sheet: sheet,\r\n            index: index,\r\n            style: rules[index].style\r\n        };\r\n    };\r\n\r\n    function addRuleToSheet(sheet, selector, index) {\r\n        if (sheet.insertRule) {\r\n            sheet.insertRule(selector + ' { }', index);\r\n        } else {\r\n            sheet.addRule(selector, null, index);\r\n        }\r\n    }\r\n\r\n    // Handles single colon syntax for older browsers and bugzilla.mozilla.org/show_bug.cgi?id=949651\r\n    function addPseudoElementRule(sheet, selector, rules, index) {\r\n        var doubleColonSelector;\r\n        var singleColonSelector;\r\n\r\n        if (doubleColonPseudoElRegex.exec(selector)) {\r\n            doubleColonSelector = selector;\r\n            singleColonSelector = toSingleColonPseudoElements(selector);\r\n        } else if (singleColonPseudoElRegex.exec(selector)) {\r\n            doubleColonSelector = toDoubleColonPseudoElements(selector);\r\n            singleColonSelector = selector;\r\n        } else {\r\n            return false; // Not dealing with a pseudo element\r\n        }\r\n\r\n        if (!singleColonForPseudoElements) {\r\n            // Assume modern browser and then check if successful\r\n            addRuleToSheet(sheet, doubleColonSelector, index);\r\n            if (rules.length <= index) {\r\n                singleColonForPseudoElements = true;\r\n            }\r\n        }\r\n        if (singleColonForPseudoElements) {\r\n            addRuleToSheet(sheet, singleColonSelector, index);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function toDoubleColonPseudoElements(selector) {\r\n        return selector.replace(singleColonPseudoElRegex, function (match, submatch1, submatch2, submatch3) {\r\n            return submatch1 + '::' + submatch3;\r\n        });\r\n    }\r\n\r\n    function toSingleColonPseudoElements(selector) {\r\n        return selector.replace(doubleColonPseudoElRegex, function(match, submatch1, submatch2) {\r\n            return ':' + submatch2;\r\n        })\r\n    }\r\n\r\n    function removeRule(rule) {\r\n        var sheet = rule.sheet;\r\n        if (sheet.deleteRule) {\r\n            sheet.deleteRule(rule.index);\r\n        } else if (sheet.removeRule) {\r\n            sheet.removeRule(rule.index);\r\n        }\r\n    }\r\n\r\n    function extend(dest, src) {\r\n        for (var key in src) {\r\n            if (!src.hasOwnProperty(key))\r\n                continue;\r\n            dest[key] = src[key];\r\n        }\r\n        return dest;\r\n    }\r\n\r\n    function aggregateStyles(rules) {\r\n        var aggregate = {};\r\n        for (var i = 0; i < rules.length; i++) {\r\n            extend(aggregate, declaredProperties(rules[i].style));\r\n        }\r\n        return aggregate;\r\n    }\r\n\r\n    function declaredProperties(style) {\r\n        var declared = {};\r\n        for (var i = 0; i < style.length; i++) {\r\n            declared[style[i]] = style[toCamelCase(style[i])];\r\n        }\r\n        return declared;\r\n    }\r\n\r\n    // IE9 stores rules with attributes (classes or ID's) adjacent in the opposite order as defined\r\n    // causing them to not be found, so this method swaps [#|.]sel1[#|.]sel2 to become [#|.]sel2[#|.]sel1\r\n    function swapAdjSelAttr(selector) {\r\n        var swap = '';\r\n        var lastIndex = 0;\r\n\r\n        while ((match = adjSelAttrRegex.exec(selector)) != null) {\r\n            if (match[0] === '')\r\n                break;\r\n            swap += selector.substring(lastIndex, match.index);\r\n            swap += selector.substr(match.index + match[1].length, match[2].length);\r\n            swap += selector.substr(match.index, match[1].length);\r\n            lastIndex = match.index + match[0].length;\r\n        }\r\n        swap += selector.substr(lastIndex);\r\n\r\n        return swap;\r\n    };\r\n\r\n    // FF and older browsers store rules with pseudo elements using single-colon syntax\r\n    function swapPseudoElSyntax(selector) {\r\n        if (doubleColonPseudoElRegex.exec(selector)) {\r\n            return toSingleColonPseudoElements(selector);\r\n        }\r\n        return selector;\r\n    }\r\n\r\n    function setStyleProperties(rule, properties) {\r\n        for (var key in properties) {\r\n            var value = properties[key];\r\n            var importantIndex = value.indexOf(' !important');\r\n\r\n            // Modern browsers seem to handle overrides fine, but IE9 doesn't\r\n            rule.style.removeProperty(key);\r\n            if (importantIndex > 0) {\r\n                rule.style.setProperty(key, value.substr(0, importantIndex), 'important');\r\n            } else {\r\n                rule.style.setProperty(key, value);\r\n            }\r\n        }\r\n    }\r\n\r\n    function toCamelCase(str) {\r\n        return str.replace(/-([a-z])/g, function (match, submatch) {\r\n            return submatch.toUpperCase();\r\n        });\r\n    }\r\n\r\n    function transformCamelCasedPropertyNames(oldProps) {\r\n        var newProps = {};\r\n        for (var key in oldProps) {\r\n            newProps[unCamelCase(key)] = oldProps[key];\r\n        }\r\n        return newProps;\r\n    }\r\n\r\n    function unCamelCase(str) {\r\n        return str.replace(/([A-Z])/g, function(match, submatch) {\r\n            return '-' + submatch.toLowerCase();\r\n        });\r\n    }\r\n\r\n    var Jss = function(doc) {\r\n        this.doc = doc;\r\n        this.head = this.doc.head || this.doc.getElementsByTagName('head')[0];\r\n        this.sheets = this.doc.styleSheets || [];\r\n    };\r\n\r\n    Jss.prototype = {\r\n        // Returns JSS rules (selector is optional)\r\n        get: function(selector) {\r\n            if (!this.defaultSheet) {\r\n                return {};\r\n            }\r\n            if (selector) {\r\n                return aggregateStyles(getRules(this.defaultSheet, selector));\r\n            }\r\n            var rules = getSelectorsAndRules(this.defaultSheet);\r\n            for (selector in rules) {\r\n                rules[selector] = aggregateStyles(rules[selector]);\r\n            }\r\n            return rules;\r\n        },\r\n        // Returns all rules (selector is required)\r\n        getAll: function(selector) {\r\n            var properties = {};\r\n            for (var i = 0; i < this.sheets.length; i++) {\r\n                extend(properties, aggregateStyles(getRules(this.sheets[i], selector)));\r\n            }\r\n            return properties;\r\n        },\r\n        // Adds JSS rules for the selector based on the given properties\r\n        set: function(selector, properties) {\r\n            if (!this.defaultSheet) {\r\n                this.defaultSheet = this._createSheet();\r\n            }\r\n            properties = transformCamelCasedPropertyNames(properties);\r\n            var rules = getRules(this.defaultSheet, selector);\r\n            if (!rules.length) {\r\n                rules = [addRule(this.defaultSheet, selector)];\r\n            }\r\n            for (var i = 0; i < rules.length; i++) {\r\n                setStyleProperties(rules[i], properties);\r\n            }\r\n        },\r\n        // Removes JSS rules (selector is optional)\r\n        remove: function(selector) {\r\n            if (!this.defaultSheet)\r\n                return;\r\n            if (!selector) {\r\n                this._removeSheet(this.defaultSheet);\r\n                delete this.defaultSheet;\r\n                return;\r\n            }\r\n            var rules = getRules(this.defaultSheet, selector);\r\n            for (var i = 0; i < rules.length; i++) {\r\n                removeRule(rules[i]);\r\n            }\r\n            return rules.length;\r\n        },\r\n        _createSheet: function() {\r\n            var styleNode = this.doc.createElement('style');\r\n            styleNode.type = 'text/css';\r\n            styleNode.rel = 'stylesheet';\r\n            this.head.appendChild(styleNode);\r\n            return styleNode.sheet;\r\n        },\r\n        _removeSheet: function(sheet) {\r\n            var node = sheet.ownerNode;\r\n            node.parentNode.removeChild(node);\r\n        }\r\n    };\r\n\r\n    var exports = new Jss(document);\r\n    exports.forDocument = function(doc) {\r\n        return new Jss(doc);\r\n    };\r\n    return exports;\r\n})();\r\n\r\ntypeof module !== 'undefined' && module.exports && (module.exports = jss); // CommonJS support\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./external/jss.js\n ** module id = 18\n ** module chunks = 0\n **/","var Block = require('Block')\nvar proto = require('proto')\nvar Style = require(\"Style\")\n\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static properties\n\n\tthis.name = 'ListItem'\n\n    this.defaultStyle = Style({\n        display: 'list-item'\n    })\n\n\t// instance properties\n\n\tthis.init = function(/*[label,] contents*/) {\n        if(arguments.length <= 1) {\n            var contents = arguments[0]\n        } else {\n            var label = arguments[0]\n            var contents = arguments[1]\n        }\n\n        this.domNode = document.createElement(\"li\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t\tsuperclass.init.call(this) // superclass constructor\n\t\tthis.label = label\n\n        if(contents instanceof Block) {\n\t\t\tthis.add(contents)\n\t\t} else if(contents !== undefined) {\n            this.domNode.textContent = contents\n        }\n\t}\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Item.js\n ** module id = 19\n ** module chunks = 0\n **/","// note: this is  not intended to be used directly - only through Select and MultiSelect\r\n\r\nvar Block = require('Block')\r\nvar Style = require('Style')\r\nvar proto = require('proto')\r\n//var htmlEntities = require('he')\r\n\r\n// emits a 'change' event when its 'selected' value changes\r\nmodule.exports = proto(Block, function(superclass) {\r\n\r\n    // staic members\r\n\r\n    this.name = 'Option'\r\n\r\n    this.defaultStyle = Style({\r\n        display: 'block'\r\n    })\r\n\r\n\r\n    // instance members\r\n\r\n    this.init = function(label, value, text) {\r\n        this.domNode = document.createElement(\"option\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\r\n        superclass.init.call(this) // superclass constructor\r\n\r\n        this.label = label\r\n\r\n        this.text = text\r\n        this.val = value\r\n    }\r\n\r\n    Object.defineProperty(this, 'val', {\r\n        // returns the value of the Option\r\n        get: function() {\r\n            return this.attr('value')\r\n        },\r\n\r\n        // sets the value of the Option\r\n        set: function(value) {\r\n            if(this.parent !== undefined) {\r\n                if(this.parent.options[value] !== undefined) {\r\n                    throw new Error(\"Can't give an Option the same value as another in the Select or MultiSelect (value: '\"+value+\"')\")\r\n                }\r\n\r\n                if(this.val !== null) {\r\n                    delete this.parent.options[this.val]\r\n                }\r\n\r\n                this.parent.options[value] = this\r\n            }\r\n\r\n            this.attr('value', value)\r\n\r\n        }\r\n    })\r\n\r\n\r\n    Object.defineProperty(this, 'selected', {\r\n        // returns whether or not the option is selected\r\n        get: function() {\r\n            return this.domNode.selected\r\n        },\r\n\r\n        // sets the selected state of the option to the passed value (true for selected)\r\n        set: function(value) {\r\n            var booleanValue = value === true\r\n            if(this.selected === booleanValue) return false; // ignore if there's no change\r\n\r\n            if(this.parent !== undefined)\r\n                this.parent.prepareForValueChange([this.val])\r\n\r\n            this.setSelectedQuiet(booleanValue)\r\n\r\n            if(this.parent !== undefined)\r\n                this.parent.emit('change')\r\n        }\r\n    })\r\n\r\n    Object.defineProperty(this, 'text', {\r\n        get: function() {\r\n            return this.domNode.textContent\r\n        },\r\n\r\n        set: function(text) {\r\n            this.domNode.innerText = text // apparently textContent can't be set or something? unclear\r\n        }\r\n    })\r\n\r\n\r\n    // private\r\n\r\n    // does everything for setting the selected state except emit the parent's change event\r\n    this.setSelectedQuiet = function setOptionSelected(booleanValue) {\r\n        if(this.selected === booleanValue) return; // ignore if there's no change\r\n\r\n        this.domNode.selected = booleanValue\r\n        this.emit('change') // the browser has no listenable event that is triggered on change of the 'checked' property\r\n    }\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Option.js\n ** module id = 20\n ** module chunks = 0\n **/","\n\nvar RowlikeGenerator = require(\"./RowlikeGenerator\");\n\nmodule.exports = RowlikeGenerator('th', \"TableHeader\")\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Header.js\n ** module id = 21\n ** module chunks = 0\n **/","var RowlikeGenerator = require(\"./RowlikeGenerator\");\n\nmodule.exports = RowlikeGenerator('tr', \"TableRow\")\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Row.js\n ** module id = 22\n ** module chunks = 0\n **/","var Block = require('../Block')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static properties\n\n\tthis.name = 'TableCell'\n\t\n\n\t// instance properties\n\n\tthis.init = function(/*[label,] contents*/) {\n        if(arguments.length <= 1) {\n            var contents = arguments[0]\n        } else {\n            var label = arguments[0]\n            var contents = arguments[1]\n        }\n\n        this.domNode = document.createElement(\"td\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t\tsuperclass.init.call(this) // superclass constructor\n\t\tthis.label = label\n\n        if(contents instanceof Block) {\n\t\t\tthis.add(contents)\n\t\t} else if(contents !== undefined) {\n            this.domNode.textContent = contents\n        }\n\t}\n\n\tthis.colspan = function(cols) {\n\t\tthis.attr('colspan',cols);\n\t}\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Cell.js\n ** module id = 23\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/build-modules/~/webpack/~/node-libs-browser/~/events/events.js\n ** module id = 24\n ** module chunks = 0\n **/","\"use strict\";\r\n/* Copyright (c) 2013 Billy Tetrud - Free to use for any purpose: MIT License*/\r\n\r\nvar noop = function() {}\r\n\r\nvar prototypeName='prototype', undefined, protoUndefined='undefined', init='init', ownProperty=({}).hasOwnProperty; // minifiable variables\r\nfunction proto() {\r\n    var args = arguments // minifiable variables\r\n\r\n    if(args.length == 1) {\r\n        var parent = {init: noop}   // set noop init so that every parent has an init\r\n        var prototypeBuilder = args[0]\r\n\r\n    } else { // length == 2\r\n        var parent = args[0]\r\n        var prototypeBuilder = args[1]\r\n    }\r\n\r\n    // special handling for Error objects\r\n    var namePointer = {}    // name used only for Error Objects\r\n    if([Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError].indexOf(parent) !== -1) {\r\n        parent = normalizeErrorObject(parent, namePointer)\r\n    }\r\n\r\n    // set up the parent into the prototype chain if a parent is passed\r\n    var parentIsFunction = typeof(parent) === \"function\"\r\n    if(parentIsFunction) {\r\n        prototypeBuilder[prototypeName] = parent[prototypeName]\r\n    } else {\r\n        prototypeBuilder[prototypeName] = parent\r\n    }\r\n\r\n    // the prototype that will be used to make instances\r\n    var prototype = new prototypeBuilder(parent)\r\n    namePointer.name = prototype.name\r\n\r\n    var ProtoObjectFactory = namedFunction(prototype.name, function() {     // result object factory\r\n        var x = new F()          // empty object\r\n\r\n        if(prototype[init]) {\r\n            var result = prototype[init].apply(x, arguments)    // populate object via the constructor\r\n            if(result === proto[protoUndefined])\r\n                return undefined\r\n            else if(result !== undefined)\r\n                return result\r\n            else\r\n                return x\r\n        } else {\r\n            return x\r\n        }\r\n    })\r\n\r\n    prototype.constructor = ProtoObjectFactory;    // set the constructor property on the prototype\r\n\r\n\r\n    // if there's no init, assume its inheriting a non-proto class, so default to applying the superclass's constructor.\r\n    if(!prototype[init] && parentIsFunction) {\r\n        prototype[init] = function() {\r\n            parent.apply(this, arguments)\r\n        }\r\n    }\r\n\r\n    // constructor for empty object which will be populated via the constructor\r\n    var F = function() {}\r\n        F[prototypeName] = prototype    // set the prototype for created instances\r\n\r\n    // add all the prototype properties onto the static class as well (so you can access that class when you want to reference superclass properties)\r\n    for(var n in prototype) {\r\n        addProperty(ProtoObjectFactory, prototype, n)\r\n    }\r\n\r\n    // add properties from parent that don't exist in the static class object yet\r\n    for(var n in parent) {\r\n        if(Object.hasOwnProperty.call(parent, n) && ProtoObjectFactory[n] === undefined) {\r\n            addProperty(ProtoObjectFactory, parent, n)\r\n        }\r\n    }\r\n\r\n    ProtoObjectFactory.parent = parent;            // special parent property only available on the returned proto class\r\n    ProtoObjectFactory[prototypeName] = prototype  // set the prototype on the object factory\r\n\r\n    return ProtoObjectFactory;\r\n}\r\n\r\nproto[protoUndefined] = {} // a special marker for when you want to return undefined from a constructor\r\n\r\nmodule.exports = proto\r\n\r\nfunction normalizeErrorObject(ErrorObject, namePointer) {\r\n    function NormalizedError() {\r\n        var tmp = new ErrorObject(arguments[0])\r\n        tmp.name = namePointer.name\r\n\r\n        this.message = tmp.message\r\n        if(Object.defineProperty) {\r\n            /*this.stack = */Object.defineProperty(this, 'stack', { // getter for more optimizy goodness\r\n                get: function() {\r\n                    return tmp.stack\r\n                }\r\n            })\r\n        } else {\r\n            this.stack = tmp.stack\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    var IntermediateInheritor = function() {}\r\n        IntermediateInheritor.prototype = ErrorObject.prototype\r\n    NormalizedError.prototype = new IntermediateInheritor()\r\n\r\n    return NormalizedError\r\n}\r\n\r\nfunction addProperty(factoryObject, prototype, property) {\r\n    try {\r\n        var info = Object.getOwnPropertyDescriptor(prototype, property)\r\n        if(info.get !== undefined || info.get !== undefined && Object.defineProperty !== undefined) {\r\n            Object.defineProperty(factoryObject, property, info)\r\n        } else {\r\n            factoryObject[property] = prototype[property]\r\n        }\r\n    } catch(e) {\r\n        // do nothing, if a property (like `name`) can't be set, just ignore it\r\n    }\r\n}\r\n\r\n// returns the function named with the passed name\r\nfunction namedFunction(name, fn) {\r\n    if(name !== undefined) {\r\n        return new Function('fn',\r\n            \"return function \" + name + \"(){ return fn.apply(this,arguments)}\"\r\n        )(fn)\r\n    } else {\r\n        return fn\r\n    }\r\n\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/proto/proto.js\n ** module id = 25\n ** module chunks = 0\n **/","// resolves varargs variable into more usable form\n// args - should be a function arguments variable\n// returns a javascript Array object of arguments that doesn't count trailing undefined values in the length\nmodule.exports = function(theArguments) {\n    var args = Array.prototype.slice.call(theArguments, 0)\n\n    var count = 0;\n    for(var n=args.length-1; n>=0; n--) {\n        if(args[n] === undefined)\n            count++\n        else\n            break\n    }\n    args.splice(args.length-count, count)\n    return args\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/trimArguments/trimArguments.js\n ** module id = 26\n ** module chunks = 0\n **/","var proto = require(\"proto\")\r\nvar EventEmitter = require(\"events\").EventEmitter\r\nvar utils = require(\"./utils\")\r\n\r\n\r\n// emits the event:\r\n    // change - the event data is an object of one of the following forms:\r\n        // {id:_, type: 'set', property: propertyList}\r\n        // {id:_, type: 'added', property: propertyList, index:_, count: numberOfElementsAdded}\r\n        // {id:_, type: 'removed', property: propertyList, index:_, values: removedValues}\r\nvar Observe = module.exports = proto(EventEmitter, function() {\r\n\r\n    // static members\r\n\r\n    this.init = function(obj) {\r\n        this.subject = obj\r\n\r\n        this.setMaxListeners(1000)\r\n    }\r\n\r\n    // instance members\r\n\r\n    // gets an element or member of the subject and returns another Observee\r\n    // changes to the returned Observee will be emitted by its parent as well\r\n    this.get = function(property) {\r\n        return ObserveeChild(this, parsePropertyList(property))\r\n    }\r\n\r\n    // sets a value on the subject\r\n    // property - either an array of members to select, or a string where properties to select are separated by dots\r\n    // value - the value to set\r\n    this.set = function(property, value) {\r\n        setInternal(this, parsePropertyList(property), value, {})\r\n    }\r\n\r\n    // pushes a value onto a list\r\n    this.push = function(/*value...*/) {\r\n        pushInternal(this, [], arguments, {})\r\n    }\r\n\r\n\r\n    // index is the index to remove/insert at\r\n    // countToRemove is the number to remove\r\n    // elementsToAdd is a list of elements to add\r\n    this.splice = function(/*index, countToRemove[, elementsToAdd]*/) {\r\n        return spliceInternal(this, [], arguments, {})\r\n    }\r\n\r\n    // use this instead of concat for mutation behavior\r\n    this.append = function(arrayToAppend) {\r\n        appendInternal(this, [], arguments, {})\r\n    }\r\n\r\n    this.id = function(id) {\r\n        return ObserveeChild(this, [], {id: id})\r\n        //return idFunction(this, [], id)\r\n    }\r\n\r\n    // For the returned object, any property added via set, push, splice, or append joins an internal observee together with this observee, so that\r\n    //      the internal observee and the containing observee will both send 'change' events appropriately\r\n    // collapse - (default: false) if true, any property added will be set to the subject of the value added (so that value won't be an observee anymore\r\n        // note: only use collapse:true if the observees you're unioning isn't actually an object that inherits from an observee - any instance methods on the observee that come from child classes won't be accessible anymore\r\n        // e.g. var x = observe({a:5})\r\n        //      var b = observe({})\r\n        //      x.subject.a === 5    ;; true\r\n        //      b.union(true).set('x', x)\r\n        //      b.subject.x.a === 5            ;; true\r\n        //      b.subject.x.subject.a === 5    ;; false\r\n    this.union = function(collapse) {\r\n        if(collapse === undefined) collapse = false\r\n        return ObserveeChild(this, [], {union: collapse})\r\n    }\r\n\r\n\r\n    /* pause and unpause may cause weird affects in certain cases (e.g. if you remove an element at index 4 and *then* add an element at index 2)\r\n    // pause sending events (for when you want to do a lot of things to an object)\r\n    this.pause = function() {\r\n        this.paused = true\r\n    }\r\n    this.unpause = function() {\r\n        this.paused = undefined\r\n        sendEvent(this)\r\n    }*/\r\n})\r\n\r\n\r\nfunction parsePropertyList(property) {\r\n    if(!(property instanceof Array)) {\r\n        property = property.toString().split('.')\r\n    }\r\n\r\n    return property\r\n}\r\n\r\nfunction getPropertyPointer(subject, propertyList) {\r\n    var current = subject\r\n    for(var n=0; n<propertyList.length-1; n++) {\r\n        current = current[propertyList[n]]\r\n    }\r\n\r\n    return {obj: current, key:propertyList[n]}\r\n}\r\n\r\nvar getPropertyValue = module.exports.getPropertyValue = function(subject, property) {\r\n    var pointer = getPropertyPointer(subject, property)\r\n    if(pointer.key !== undefined) {\r\n        return pointer.obj[pointer.key]\r\n    } else {\r\n        return pointer.obj\r\n    }\r\n}\r\n\r\n// private\r\n\r\n// options can have the properties:\r\n    // union - if true, any value set, pushed, appended, or spliced onto the observee is unioned\r\nvar ObserveeChild = proto(EventEmitter, function() {\r\n\r\n    this.init = function(parent, propertyList, options) {\r\n        if(options === undefined) this.options = {}\r\n        else                      this.options = options\r\n\r\n        if(parent._observeeParent !== undefined)\r\n            this._observeeParent = parent._observeeParent\r\n        else\r\n            this._observeeParent = parent\r\n\r\n        this.property = propertyList\r\n        this.subject = getPropertyValue(parent.subject, propertyList)\r\n\r\n        var that = this\r\n        parent.on('change', function(change) {\r\n            var answers = changeQuestions(that.property, change)\r\n\r\n            if(answers.isWithin ) {\r\n                that.emit('change', {type:change.type, property: change.property.slice(that.property.length), index:change.index, count:change.count, removed: change.removed})\r\n            } else if(answers.couldRelocate) {\r\n                if(change.type === 'removed') {\r\n                    var relevantIndex = that.property[change.property.length]\r\n                    var removedIndexesAreBeforeIndexOfObserveeChild = change.index + change.removed.length - 1 < relevantIndex\r\n\r\n                    if(removedIndexesAreBeforeIndexOfObserveeChild) {\r\n                        that.property[change.property.length] = relevantIndex - change.removed.length // change the propertyList to match the new index\r\n                    }\r\n                } else if(change.type === 'added') {\r\n                    var relevantIndex = that.property[change.property.length]\r\n                    if(change.index < relevantIndex) {\r\n                        that.property[change.property.length] = relevantIndex + change.count // change the propertyList to match the new index\r\n                    }\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    this.get = function(property) {\r\n        return this._observeeParent.get(this.property.concat(parsePropertyList(property)))\r\n    }\r\n\r\n    this.set = function(property, value) {\r\n        setInternal(this._observeeParent, this.property.concat(parsePropertyList(property)), value, this.options)\r\n    }\r\n\r\n    this.push = function(/*values...*/) {\r\n        pushInternal(this._observeeParent, this.property, arguments, this.options)\r\n    }\r\n\r\n    this.splice = function(index, countToRemove/*[, elementsToAdd....]*/) {\r\n        spliceInternal(this._observeeParent, this.property, arguments, this.options)\r\n    }\r\n\r\n    this.append = function(/*[property,] arrayToAppend*/) {\r\n        appendInternal(this._observeeParent, this.property, arguments, this.options)\r\n    }\r\n\r\n    this.id = function(id) {\r\n        return ObserveeChild(this, this.property, utils.merge({}, this.options, {id: id}))\r\n        //return idFunction(this._observeeParent, this.property, id)\r\n    }\r\n\r\n    this.union = function(collapse) {\r\n        if(collapse === undefined) collapse = false\r\n        return ObserveeChild(this, [], utils.merge({}, this.options, {union: collapse}))\r\n    }\r\n\r\n})\r\n\r\n     /*\r\nfunction idFunction(that, propertyList, id) {\r\n    var result = {\r\n        set: function(property, value) {\r\n            var fullPropertyList = propertyList.concat(parsePropertyList(property))\r\n            setInternal(that, fullPropertyList, value, id)\r\n        },\r\n        push: function() {\r\n            pushInternal(that, propertyList, arguments, id)\r\n        },\r\n        splice: function() {\r\n            spliceInternal(that, propertyList, arguments, id)\r\n        },\r\n        append: function() {\r\n            appendInternal(that, propertyList, arguments, id)\r\n        },\r\n        get: function() {\r\n\r\n        }\r\n    }\r\n}\r\n*/\r\n\r\n// that - the Observee object\r\nfunction setInternal(that, propertyList, value, options) {\r\n    var pointer = getPropertyPointer(that.subject, propertyList)\r\n\r\n    var internalObservee = value\r\n    if(options.union === true) {\r\n        value = value.subject\r\n    }\r\n\r\n    pointer.obj[pointer.key] = value\r\n\r\n    var event = {type: 'set', property: propertyList}\r\n    if(options.id !== undefined) event.id = options.id\r\n    that.emit('change',event)\r\n\r\n    if(options.union !== undefined)\r\n        unionizeEvents(that, internalObservee, propertyList, options.union)\r\n}\r\n\r\nfunction pushInternal(that, propertyList, args, options) {\r\n    var array = getPropertyValue(that.subject, propertyList)\r\n    var originalLength = array.length\r\n    array.push.apply(array, args)\r\n\r\n    var internalObservees = unionizeList(array, originalLength, args.length, options.union)\r\n\r\n    var event = {type: 'added', property: propertyList, index: originalLength, count: 1}\r\n    if(options.id !== undefined) event.id = options.id\r\n    that.emit('change', event)\r\n\r\n    unionizeListEvents(that, internalObservees, propertyList, options.union)\r\n}\r\n\r\nfunction spliceInternal(that, propertyList, args, options) {\r\n    var index = args[0]\r\n    var countToRemove = args[1]\r\n\r\n    var array = getPropertyValue(that.subject, propertyList)\r\n    var result = array.splice.apply(array, args)\r\n\r\n    if(countToRemove > 0) {\r\n        var event = {type: 'removed', property: propertyList, index: index, removed: result}\r\n        if(options.id !== undefined) event.id = options.id\r\n        that.emit('change', event)\r\n    }\r\n    if(args.length > 2) {\r\n        var event = {type: 'added', property: propertyList, index: index, count: args.length-2}\r\n\r\n        var internalObservees = unionizeList(array, index, event.count, options.union)\r\n\r\n        if(options.id !== undefined) event.id = options.id\r\n        that.emit('change', event)\r\n\r\n        unionizeListEvents(that, internalObservees, propertyList, options.union)\r\n    }\r\n\r\n    return result\r\n}\r\n\r\n// note: I'm not using splice to do this as an optimization (because otherwise the property list would have to be parsed twice and the value gotten twice) - maybe this optimization wasn't worth it but its already done\r\nfunction appendInternal(that, propertyList, args, options) {\r\n    var arrayToAppend = args[0]\r\n    if(arrayToAppend.length === 0) return; //nothing to do\r\n\r\n    var array = getPropertyValue(that.subject, propertyList)\r\n    var originalLength = array.length\r\n\r\n    var spliceArgs = [originalLength, 0]\r\n    spliceArgs = spliceArgs.concat(arrayToAppend)\r\n    var oldLength = array.length\r\n    array.splice.apply(array, spliceArgs)\r\n\r\n    var internalObservees = unionizeList(array, oldLength, array.length, options.union)\r\n\r\n    var event = {type: 'added', property: propertyList, index: originalLength, count: arrayToAppend.length}\r\n    if(options.id !== undefined) event.id = options.id\r\n    that.emit('change', event)\r\n\r\n    unionizeListEvents(that, internalObservees, propertyList, options.union)\r\n}\r\n\r\n// sets a slice of elements to their subjects and\r\n// returns the original observee objects along with their indexes\r\nfunction unionizeList(array, start, count, union) {\r\n    var internalObservees = [] // list of observees and their property path\r\n    if(union !== undefined) {\r\n        var afterEnd = start+count\r\n        for(var n=start; n<afterEnd; n++) {\r\n            internalObservees.push({obj: array[n], index: n})\r\n            if(union === true)\r\n                array[n] = array[n].subject\r\n        }\r\n    }\r\n\r\n    return internalObservees\r\n}\r\n\r\n// runs unionizeEvents for elements in a list\r\n// internalObservees should be the result from `unionizeList`\r\nfunction unionizeListEvents(that, internalObservees, propertyList, collapse) {\r\n    for(var n=0; n<internalObservees.length; n++) {\r\n        unionizeEvents(that, internalObservees[n].obj, propertyList.concat(internalObservees[n].index), collapse)\r\n    }\r\n}\r\n\r\n\r\n// sets up the union change events for an observee with one of its inner properties\r\n// parameters:\r\n    // that - the container observee\r\n    // innerObservee - the contained observee\r\n    // propertyList - the propertyList to unionize\r\n    // collapse - the union option (true for collapse)\r\nfunction unionizeEvents(that, innerObservee, propertyList, collapse) {\r\n    var propertyListDepth = propertyList.length\r\n\r\n    if(innerObservee.on === undefined || innerObservee.emit === undefined || innerObservee.removeListener === undefined || innerObservee.set === undefined) {\r\n        throw new Error(\"Attempting to union a value that isn't an observee\")\r\n    }\r\n\r\n    var innerChangeHandler, containerChangeHandler\r\n    var ignorableContainerEvents = [], ignorableInnerEvents = []\r\n    innerObservee.on('change', innerChangeHandler = function(change) {\r\n        if(ignorableInnerEvents.indexOf(change) === -1) {        // don't run this for events generated by the union event handlers\r\n            if(collapse) {\r\n                var property = propertyList.concat(change.property)\r\n            } else {\r\n                var property = propertyList.concat(['subject']).concat(change.property)\r\n            }\r\n\r\n            var containerChange = utils.merge({}, change, {property: property})\r\n            ignorableContainerEvents.push(containerChange)\r\n            that.emit('change', containerChange)\r\n        }\r\n    })\r\n    that.on('change', containerChangeHandler = function(change) {\r\n        var changedPropertyDepth = change.property.length\r\n\r\n        var answers = changeQuestions(propertyList, change)\r\n        var changeIsWithinInnerProperty = answers.isWithin\r\n        var changeCouldRelocateInnerProperty = answers.couldRelocate\r\n\r\n        if(changeIsWithinInnerProperty && ignorableContainerEvents.indexOf(change) === -1) {   // don't run this for events generated by the union event handlers\r\n            if(collapse) {\r\n                var property = change.property.slice(propertyListDepth)\r\n            } else {\r\n                var property = change.property.slice(propertyListDepth+1) // +1 for the 'subject'\r\n            }\r\n\r\n            var innerObserveeEvent = utils.merge({}, change, {property: property})\r\n            ignorableInnerEvents.push(innerObserveeEvent)\r\n            innerObservee.emit('change', innerObserveeEvent)\r\n        } else if(changeCouldRelocateInnerProperty) {\r\n            if(change.type === 'set' /*&& changedPropertyDepth <= propertyListDepth  - this part already done above*/) {\r\n                removeUnion()\r\n            } else if(change.type === 'removed') {\r\n                var relevantIndex = propertyList[change.property.length]\r\n                var removedIndexesContainsIndexOfInnerObservee = change.index <= relevantIndex && relevantIndex <= change.index + change.removed.length - 1\r\n                var removedIndexesAreBeforeIndexOfInnerObservee = change.index + change.removed.length - 1 < relevantIndex && relevantIndex\r\n\r\n                if(removedIndexesContainsIndexOfInnerObservee && changedPropertyDepth <= propertyListDepth+1) {\r\n                    removeUnion()\r\n                } else if(removedIndexesAreBeforeIndexOfInnerObservee) {\r\n                    propertyList[change.property.length] = relevantIndex - change.removed.length // change the propertyList to match the new index\r\n                }\r\n            } else if(change.type === 'added') {\r\n                var relevantIndex = propertyList[change.property.length]\r\n                if(change.index < relevantIndex) {\r\n                    propertyList[change.property.length] = relevantIndex + change.count // change the propertyList to match the new index\r\n                }\r\n            }\r\n        }\r\n    })\r\n\r\n    var removeUnion = function() {\r\n        innerObservee.removeListener('change', innerChangeHandler)\r\n        that.removeListener('change', containerChangeHandler)\r\n    }\r\n}\r\n\r\n\r\n// answers certain questions about a change compared to a property list\r\n// returns an object like: {\r\n    // isWithin: _,           // true if changeIsWithinInnerProperty\r\n    // couldRelocate: _       // true if changeCouldRelocateInnerProperty or if innerProperty might be removed\r\n// }\r\nfunction changeQuestions(propertyList, change) {\r\n    var propertyListDepth = propertyList.length\r\n\r\n    var changeIsWithinInnerProperty = true // assume true until proven otherwise\r\n    var changeCouldRelocateInnerProperty = true // assume true until prove otherwise\r\n    for(var n=0; n<propertyListDepth; n++) {\r\n        if(change.property[n] !== propertyList[n]) {\r\n            changeIsWithinInnerProperty = false\r\n            if(n<change.property.length) {\r\n                changeCouldRelocateInnerProperty = false\r\n            }\r\n        }\r\n    }\r\n\r\n    if(change.property.length <= propertyListDepth) {\r\n        changeIsWithinInnerProperty = false\r\n    } else {\r\n        changeCouldRelocateInnerProperty = false\r\n    }\r\n\r\n    return {couldRelocate: changeCouldRelocateInnerProperty, isWithin: changeIsWithinInnerProperty}\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/observe/observe.js\n ** module id = 27\n ** module chunks = 0\n **/","/**\r\n * HashMap - HashMap Class for JavaScript\r\n * @author Ariel Flesler <aflesler@gmail.com>\r\n * @version 2.0.0\r\n * Homepage: https://github.com/flesler/hashmap\r\n */\r\n\r\n(function (factory) {\r\n\tif (typeof define === 'function' && define.amd) {\r\n\t\t// AMD. Register as an anonymous module.\r\n\t\tdefine([], factory);\r\n\t} else if (typeof exports === 'object') {\r\n\t\t// Node js environment\r\n\t\texports.HashMap = factory();\r\n\t} else {\r\n\t\t// Browser globals (this is window)\r\n\t\tthis.HashMap = factory();\r\n\t}\r\n}(function () {\r\n\t\r\n\tfunction HashMap(other) {\r\n\t\tthis.clear();\r\n\t\tswitch (arguments.length) {\r\n\t\t\tcase 0: break;\r\n\t\t\tcase 1: this.copy(other); break;\r\n\t\t\tdefault: multi(this, arguments); break;\r\n\t\t}\r\n\t}\r\n\r\n\tvar proto = HashMap.prototype = {\r\n\t\tconstructor:HashMap,\r\n\r\n\t\tget:function(key) {\r\n\t\t\tvar data = this._data[this.hash(key)];\r\n\t\t\treturn data && data[1];\r\n\t\t},\r\n\t\t\r\n\t\tset:function(key, value) {\r\n\t\t\t// Store original key as well (for iteration)\r\n\t\t\tthis._data[this.hash(key)] = [key, value];\r\n\t\t},\r\n\r\n\t\tmulti:function() {\r\n\t\t\tmulti(this, arguments);\r\n\t\t},\r\n\r\n\t\tcopy:function(other) {\r\n\t\t\tfor (var key in other._data) {\r\n\t\t\t\tthis._data[key] = other._data[key];\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\thas:function(key) {\r\n\t\t\treturn this.hash(key) in this._data;\r\n\t\t},\r\n\t\t\r\n\t\tsearch:function(value) {\r\n\t\t\tfor (var key in this._data) {\r\n\t\t\t\tif (this._data[key][1] === value) {\r\n\t\t\t\t\treturn this._data[key][0];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\t\t},\r\n\t\t\r\n\t\tremove:function(key) {\r\n\t\t\tdelete this._data[this.hash(key)];\r\n\t\t},\r\n\r\n\t\ttype:function(key) {\r\n\t\t\tvar str = Object.prototype.toString.call(key);\r\n\t\t\tvar type = str.slice(8, -1).toLowerCase();\r\n\t\t\t// Some browsers yield DOMWindow for null and undefined, works fine on Node\r\n\t\t\tif (type === 'domwindow' && !key) {\r\n\t\t\t\treturn key + '';\r\n\t\t\t}\r\n\t\t\treturn type;\r\n\t\t},\r\n\r\n\t\tkeys:function() {\r\n\t\t\tvar keys = [];\r\n\t\t\tthis.forEach(function(value, key) { keys.push(key); });\r\n\t\t\treturn keys;\r\n\t\t},\r\n\r\n\t\tvalues:function() {\r\n\t\t\tvar values = [];\r\n\t\t\tthis.forEach(function(value) { values.push(value); });\r\n\t\t\treturn values;\r\n\t\t},\r\n\r\n\t\tcount:function() {\r\n\t\t\treturn this.keys().length;\r\n\t\t},\r\n\r\n\t\tclear:function() {\r\n\t\t\t// TODO: Would Object.create(null) make any difference\r\n\t\t\tthis._data = {};\r\n\t\t},\r\n\r\n\t\tclone:function() {\r\n\t\t\treturn new HashMap(this);\r\n\t\t},\r\n\r\n\t\thash:function(key) {\r\n\t\t\tswitch (this.type(key)) {\r\n\t\t\t\tcase 'undefined':\r\n\t\t\t\tcase 'null':\r\n\t\t\t\tcase 'boolean':\r\n\t\t\t\tcase 'number':\r\n\t\t\t\tcase 'regexp':\r\n\t\t\t\t\treturn key + '';\r\n\r\n\t\t\t\tcase 'date':\r\n\t\t\t\t\treturn ':' + key.getTime();\r\n\r\n\t\t\t\tcase 'string':\r\n\t\t\t\t\treturn '\"' + key;\r\n\r\n\t\t\t\tcase 'array':\r\n\t\t\t\t\tvar hashes = [];\r\n\t\t\t\t\tfor (var i = 0; i < key.length; i++)\r\n\t\t\t\t\t\thashes[i] = this.hash(key[i]);\r\n\t\t\t\t\treturn '[' + hashes.join('|');\r\n\r\n\t\t\t\tcase 'object':\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t// TODO: Don't use expandos when Object.defineProperty is not available?\r\n\t\t\t\t\tif (!key._hmuid_) {\r\n\t\t\t\t\t\tkey._hmuid_ = ++HashMap.uid;\r\n\t\t\t\t\t\thide(key, '_hmuid_');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn '{' + key._hmuid_;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tforEach:function(func) {\r\n\t\t\tfor (var key in this._data) {\r\n\t\t\t\tvar data = this._data[key];\r\n\t\t\t\tfunc.call(this, data[1], data[0]);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tHashMap.uid = 0;\r\n\r\n\t//- Automatically add chaining to some methods\r\n\r\n\tfor (var method in proto) {\r\n\t\t// Skip constructor, valueOf, toString and any other built-in method\r\n\t\tif (method === 'constructor' || !proto.hasOwnProperty(method)) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tvar fn = proto[method];\r\n\t\tif (fn.toString().indexOf('return ') === -1) {\r\n\t\t\tproto[method] = chain(fn);\r\n\t\t}\r\n\t}\r\n\r\n\t//- Utils\r\n\r\n\tfunction multi(map, args) {\r\n\t\tfor (var i = 0; i < args.length; i += 2) {\r\n\t\t\tmap.set(args[i], args[i+1])\r\n\t\t}\r\n\t}\r\n\r\n\tfunction chain(fn) {\r\n\t\treturn function() {\r\n\t\t\tfn.apply(this, arguments);\r\n\t\t\treturn this;\r\n\t\t};\r\n\t}\r\n\r\n\tfunction hide(obj, prop) {\r\n\t\t// Make non iterable if supported\r\n\t\tif (Object.defineProperty) {\r\n\t\t\tObject.defineProperty(obj, prop, {enumerable:false});\r\n\t\t}\r\n\t};\r\n\r\n\treturn HashMap;\r\n\r\n}));\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/hashmap/hashmap.js\n ** module id = 28\n ** module chunks = 0\n **/","var proto = require('proto')\r\n\r\nvar Block = require('Block')\r\nvar Style = require(\"Style\")\r\nvar Cell = require(\"./Cell\");\r\n\r\n// generates either a Header or a Row, depending on what you pass in\r\n// elementType should either be \"tr\" or \"th\r\n// name should either be \"Header\" or \"Row\r\nmodule.exports = function(elementType, name) {\r\n    return proto(Block, function(superclass) {\r\n\r\n        // static properties\r\n\r\n        this.name = name\r\n\r\n        this.defaultStyle = Style({\r\n            display: 'table-row'\r\n        })\r\n\r\n\r\n        // instance properties\r\n\r\n        this.init = function(/*[label,] rowInit*/) {\r\n            if(arguments[0] instanceof Array) {\r\n                var rowInit = arguments[0]\r\n            } else {\r\n                var label = arguments[0]\r\n                var rowInit = arguments[1]\r\n            }\r\n\r\n            this.domNode = document.createElement(elementType) // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\r\n            superclass.init.call(this) // superclass constructor\r\n            this.label = label\r\n\r\n            if(rowInit !== undefined) {\r\n                for(var n=0; n<rowInit.length; n++) {\r\n                    this.cell(rowInit[n])\r\n                }\r\n            }\r\n        }\r\n\r\n        this.cell = function(/*[label,] contents*/) {\r\n            var cell = Cell.apply(undefined, arguments);\r\n            this.add(cell);\r\n            return cell;\r\n        }\r\n    })\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/RowlikeGenerator.js\n ** module id = 29\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/build-modules/~/webpack/~/node-libs-browser/~/path-browserify/index.js\n ** module id = 30\n ** module chunks = 0\n **/","// utilities needed by the configuration (excludes dependencies the configs don't need so the webpack bundle is lean)\r\n\r\nvar path = require('path')\r\n\r\n\r\n// Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1\r\n// any number of objects can be passed into the function and will be merged into the first argument in order\r\n// returns obj1 (now mutated)\r\nvar merge = exports.merge = function(obj1, obj2/*, moreObjects...*/){\r\n    return mergeInternal(arrayify(arguments), false)\r\n}\r\n\r\n// like merge, but traverses the whole object tree\r\n// the result is undefined for objects with circular references\r\nvar deepMerge = exports.deepMerge = function(obj1, obj2/*, moreObjects...*/) {\r\n    return mergeInternal(arrayify(arguments), true)\r\n}\r\n\r\nfunction mergeInternal(objects, deep) {\r\n    var obj1 = objects[0]\r\n    var obj2 = objects[1]\r\n\r\n    for(var key in obj2){\r\n       if(Object.hasOwnProperty.call(obj2, key)) {\r\n            if(deep && obj1[key] instanceof Object && obj2[key] instanceof Object) {\r\n                mergeInternal([obj1[key], obj2[key]], true)\r\n            } else {\r\n                obj1[key] = obj2[key]\r\n            }\r\n       }\r\n    }\r\n\r\n    if(objects.length > 2) {\r\n        var newObjects = [obj1].concat(objects.slice(2))\r\n        return mergeInternal(newObjects, deep)\r\n    } else {\r\n        return obj1\r\n    }\r\n}\r\n\r\nfunction arrayify(a) {\r\n    return Array.prototype.slice.call(a, 0)\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/observe/utils.js\n ** module id = 31\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canMutationObserver = typeof window !== 'undefined'\n    && window.MutationObserver;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    var queue = [];\n\n    if (canMutationObserver) {\n        var hiddenDiv = document.createElement(\"div\");\n        var observer = new MutationObserver(function () {\n            var queueList = queue.slice();\n            queue.length = 0;\n            queueList.forEach(function (fn) {\n                fn();\n            });\n        });\n\n        observer.observe(hiddenDiv, { attributes: true });\n\n        return function nextTick(fn) {\n            if (!queue.length) {\n                hiddenDiv.setAttribute('yes', 'no');\n            }\n            queue.push(fn);\n        };\n    }\n\n    if (canPost) {\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/build-modules/~/webpack/~/node-libs-browser/~/process/browser.js\n ** module id = 32\n ** module chunks = 0\n **/"],"sourceRoot":""}