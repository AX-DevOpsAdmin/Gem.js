{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///blocks.umd.js","webpack:///webpack/bootstrap 25e46c271fcdf3323517","webpack:///./blocks.browser.js","webpack:///./~/Block.js","webpack:///./~/Style.js","webpack:///./~/Components/Canvas.js","webpack:///./~/Components/Container.js","webpack:///./~/Components/Button.js","webpack:///./~/Components/CheckBox.js","webpack:///./~/Components/Image.js","webpack:///./~/Components/List.js","webpack:///./~/Components/Radio.js","webpack:///./~/Components/Select.js","webpack:///./~/Components/Table.js","webpack:///./~/Components/TextArea.js","webpack:///./~/Components/TextField.js","webpack:///./~/Components/Text.js","webpack:///./external/jss.js","webpack:///./~/utils.js","webpack:///./~/blockStyleUtils.js","webpack:///./~/EventEmitterB.js","webpack:///./~/domUtils.js","webpack:///./~/Components/Option.js","webpack:///./~/Components/Item.js","webpack:///./~/Components/Header.js","webpack:///./~/Components/Row.js","webpack:///./~/Components/Cell.js","webpack:///../~/build-modules/~/webpack/~/node-libs-browser/~/events/events.js","webpack:///../~/hashmap/hashmap.js","webpack:///../~/trimArguments/trimArguments.js","webpack:///../~/observe/observe.js","webpack:///../~/proto/proto.js","webpack:///./~/Components/RowlikeGenerator.js","webpack:///../~/build-modules/~/webpack/~/node-libs-browser/~/path-browserify/index.js","webpack:///../~/observe/utils.js","webpack:///../~/build-modules/~/webpack/~/node-libs-browser/~/process/browser.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","Block","Style","Canvas","Container","Button","CheckBox","Image","List","Radio","Select","Table","TextArea","TextField","Text","Object","defineProperty","get","dev","set","v","attach","apply","arguments","detach","createBody","isBlock","undefined","add","children","Array","domNode","EventEmitterB","proto","trimArguments","observe","utils","domUtils","blockStyleUtils","isDev","components","setOfBrowserEvents","arrayToMap","superclass","init","that","name","Error","defaultBlockStyle","defaultStyleMap","constructor","createDefaultBlockStyle","state","parent","div","build","attr","classList","className","push","defaultClassName","join","ifonHandlers","ifon","event","excludeDomEvents","addEventListener","emit","concat","prototype","slice","ifoff","removeEventListener","length","label","_label","addAt","index","nodes","normalizeAddAtArguments","i","node","splice","beforeChild","appendChild","insertBefore","getParentStyleMap","computedStyleMap","propogateStyleSet","addBefore","addBeforeNode","indexOf","remove","removals","normalizeRemoveArguments","sort","a","b","n","r","removeChild","childNodes","attribute","getAttribute","attributes","setAttribute","value","removeAttribute","style","display","setToVisible","_displayStyle","document","activeElement","setToInFocus","focus","blur","_style","styleObject","styleMap","setCurrentStyle","getStyleForComponent","specificStyle","styleMapConjunction","componentStyleMap","getSelectionRange","selection","setSelectionRange","currentStyle","_styleSetupStates","body","callback","dom","implementation","createDocument","createElement","documentElement","setTimeout","map","removal","parameterIndex","createTieredPseudoClasses","pseudoClassStyles","tieredPseudoClasses","key","pseudoClassList","split","emulatablePseudoClasses","nonEmulatablePseudoClasses","pseudoClass","pseudoClassParts","getPseudoClassParts","emulatedPseudoClasses","validatePurePseudoClassStyles","createPseudoClassRules","emulatablePseudoClassKey","merge","nonEmulatablePsuedoClassKey","secondTier","pseudoclassCombinations","tieredPseudoClassesKeys","keys","reverse","parts","keyA","k","j","result","combinePseudoclasses","nthChildCheck","component","testFn","parentNode","nthLastChildCheck","parameter","parseInt","nthChildParameterFn","match","nthChildParameter","constant","variable","cssValue","cssStyleName","cssNumber","toString","selector","pseudoClassStyle","pseudoClassCss","cssStyle","mapCamelCase","defaultJss","styleDefinitions","isStyleObject","fullPsuedoClass","x","pseudoClassRegex","class","flattenPseudoClassStyles","nonPseudoClassStyles","subpseudoClasses","subPseudoClass","substr","flattenedStyles","o","ascii","charCodeAt","asciiA","asciiZ","String","fromCharCode","difference","jssModule","HashMap","baseClassName","nextClassNumber","forDocument","defaultSheet","_createSheet","jss","styleDefinition","privateOptions","inLabel","labelStyleMap","labelStyles","cssProperties","Function","setup","kill","jssSheet","baseStyle","mergedStyle","pseudoClasesToEmulate","preSplitPseudoClasses","pseudoClassesToEmulationInfo","newStyle","fns","info","processParameter","initializeState","pseudoClassEmulationInfo","check","changeStyleIfNecessary","longestMatchingLength","mostSpecificMatchingStyle","wrapSetupAndKill","originalSetup","emulationInfo","originalKill","labelStyle","pseudoclasses","resultKeyParts","resultValue","part","hover","querySelectorAll","startCallback","endCallback","on","start","end","off","checked","selected","setupState","listener","removeListener","required","observer","MutationObserver","disconnect","last-child","setupObserver","childList","nth-child","parameterCheck","checkAndCallCallbacks","addPseudoClass","column-count","fill-opacity","flex-grow","flex-shrink","font-weight","line-height","opacity","order","orphans","widows","z-index","zoom","defaultStyleValues","azimuth","border-collapse","border-spacing","caption-side","direction","elevation","empty-cells","letter-spacing","list-style-image","list-style-position","list-style-type","pitch-range","pitch","position","quotes","richness","speak-header","speak-numeral","speak-punctuation","speak","speak-rate","stress","text-align","text-indent","text-transform","voice-family","volume","white-space","word-spacing","cursor","computedStyles","height","width","context","getContext","toImg","toDataURL","contentArgs","text","newValue","curValue","imageSource","src","Item","listInit","ordered","type","defaultStyle","listStyleType","item","selectSibling","button","buttons","group","values","buttonToSelect","setButtonInGroup","_selected","getRandomInt","min","max","Math","floor","random","EventEmitter","randomStart","RadioButton","val","originalSelected","radioGroup","preventDefault","keyCode","selectNext","selectPrevious","oldValue","booleanValue","previouslySelected","Option","options","option","newOption","nodesToAdd","forEach","anyWereSelected","removalIndexes","theSelectedWasRemoved","prepareForValueChange","optionValue","setSelectedQuiet","headerOrRegularRow","Prototype","args","row","Header","Row","Cell","borderSpacing","tableInit","header","password","whiteSpace","data","eventData","newText","srcElement","textContent","oldText","lastFocus","innerText","getSelectorsAndRules","sheet","rules","cssRules","results","selectorText","toDoubleColonPseudoElements","getRules","toLowerCase","swapAdjSelAttr","swapPseudoElSyntax","addRule","pseudoElementRule","addPseudoElementRule","addRuleToSheet","insertRule","doubleColonSelector","singleColonSelector","doubleColonPseudoElRegex","exec","toSingleColonPseudoElements","singleColonPseudoElRegex","singleColonForPseudoElements","replace","submatch1","submatch2","submatch3","removeRule","rule","deleteRule","extend","dest","hasOwnProperty","aggregateStyles","aggregate","declaredProperties","declared","toCamelCase","swap","lastIndex","adjSelAttrRegex","substring","setStyleProperties","properties","importantIndex","removeProperty","setProperty","str","submatch","toUpperCase","transformCamelCasedPropertyNames","oldProps","newProps","unCamelCase","Jss","doc","head","getElementsByTagName","sheets","styleSheets","getAll","_removeSheet","styleNode","rel","ownerNode","mergeInternal","objects","deep","obj1","obj2","newObjects","arrayify","deepMerge","objectConjunction","objectCopy","array","applyStyleSetupFunction","_styleSetupObject","applyStyleKillFunction","setStyleClass","RegExp","trim","validateDefaultStyle","styleFromMap","mainStyle","block","secondaryStyleMap","primaryStyleMap","cachedStyleMap","defaultStyles","nextConstructor","defaultStyleSet","default","triggerIfHandlers","handlerListName","triggerIfHandlerList","normalHandlerToAllHandlerProperty","handlerList","addHandlerToList","removeFromHandlerList","removeCallbackFromList","allHandlerListName","list","ifoffHandlers","ifonAllHandlers","ifoffAllHandlers","eventName","_events","listeners","removeIfon","removeIfoff","proxy","emitter","except","handleIt","only","handler","addListener","triggerIfOn","triggerIfOff","removeAllListeners","triggerIfOffForEvents","iterateThroughLeafNodes","element","nodeStack","pop","nodeType","findHiddenCharacters","beforeCaretIndex","hiddenCharacters","lastCharWasWhiteSpace","elem","createAttribute","setAttributeNode","containerEl","nodeName","charIndex","range","createRange","setStart","collapse","foundStart","nextCharIndex","nodeIndex","hiddenCharactersBeforeStart","hiddenCharactersBeforeEnd","setEnd","sel","window","getSelection","removeAllRanges","addRange","isInputOrArea","rangeCount","getRangeAt","startsInElement","contains","startContainer","elementToIterateThrough","startFound","commonAncestorContainer","startContainerFound","visibleCharacterOffset","leaf","startOffset","endContainer","endOffset","selectionStart","selectionEnd","contents","RowlikeGenerator","colspan","cols","_maxListeners","isFunction","arg","isNumber","isObject","isUndefined","defaultMaxListeners","setMaxListeners","isNaN","TypeError","er","len","error","newListener","warned","console","trace","once","g","fired","ret","listenerCount","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","other","clear","copy","multi","chain","fn","hide","obj","prop","enumerable","_data","hash","has","search","count","clone","getTime","hashes","_hmuid_","uid","func","method","theArguments","parsePropertyList","property","getPropertyPointer","subject","propertyList","current","setInternal","pointer","internalObservee","union","unionizeEvents","pushInternal","getPropertyValue","originalLength","internalObservees","unionizeList","unionizeListEvents","spliceInternal","countToRemove","removed","appendInternal","arrayToAppend","spliceArgs","oldLength","afterEnd","innerObservee","propertyListDepth","innerChangeHandler","containerChangeHandler","ignorableContainerEvents","ignorableInnerEvents","change","containerChange","changedPropertyDepth","answers","changeQuestions","changeIsWithinInnerProperty","isWithin","changeCouldRelocateInnerProperty","couldRelocate","innerObserveeEvent","removeUnion","relevantIndex","removedIndexesContainsIndexOfInnerObservee","removedIndexesAreBeforeIndexOfInnerObservee","ObserveeChild","append","_observeeParent","removedIndexesAreBeforeIndexOfObserveeChild","noop","prototypeBuilder","namePointer","EvalError","RangeError","ReferenceError","SyntaxError","URIError","normalizeErrorObject","parentIsFunction","prototypeName","F","constructorName","ProtoObjectFactory","protoUndefined","addProperty","ownProperty","ErrorObject","NormalizedError","tmp","message","stack","IntermediateInheritor","factoryObject","getOwnPropertyDescriptor","e","elementType","rowInit","cell","process","normalizeArray","allowAboveRoot","up","last","unshift","filter","xs","f","res","splitPathRe","splitPath","filename","resolve","resolvedPath","resolvedAbsolute","path","cwd","charAt","normalize","isAbsolute","trailingSlash","paths","relative","from","to","arr","fromParts","toParts","samePartsLength","outputParts","sep","delimiter","dirname","dir","basename","ext","extname","nextTick","canSetImmediate","setImmediate","canMutationObserver","canPost","postMessage","queue","hiddenDiv","queueList","ev","source","stopPropagation","shift","title","browser","env","argv","binding","chdir"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,OAAAH,GACA,gBAAAC,SACAA,QAAA,OAAAD,IAEAD,EAAA,OAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAP,WACAS,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,QAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDgBM,SAASL,EAAQD,EAASM,GEtDhCN,EAAAe,MAAAT,EAAA,GACAN,EAAAgB,MAAAV,EAAA,GAEAN,EAAAiB,OAAAX,EAAA,GACAN,EAAAkB,UAAAZ,EAAA,GACAN,EAAAmB,OAAAb,EAAA,GACAN,EAAAoB,SAAAd,EAAA,GACAN,EAAAqB,MAAAf,EAAA,GACAN,EAAAsB,KAAAhB,EAAA,GAEAN,EAAAuB,MAAAjB,EAAA,GACAN,EAAAwB,OAAAlB,EAAA,IACAN,EAAAyB,MAAAnB,EAAA,IACAN,EAAA0B,SAAApB,EAAA,IACAN,EAAA2B,UAAArB,EAAA,IACAN,EAAA4B,KAAAtB,EAAA,IAIAuB,OAAAC,eAAA9B,EAAA,OACA+B,IAAA,WACA,MAAA/B,GAAAe,MAAAiB,KACKC,IAAA,SAAAC,GACLlC,EAAAe,MAAAiB,IAAAE,KAIAlC,EAAAmC,OAAA,WACAnC,EAAAe,MAAAoB,OAAAC,MAAAhC,KAAAiC,YAEArC,EAAAsC,OAAA,WACAtC,EAAAe,MAAAuB,OAAAF,MAAAhC,KAAAiC,YAGArC,EAAAuC,WAAA,WACAvC,EAAAe,MAAAuB,OAAAF,MAAAhC,KAAAiC,aF6DM,SAASpC,EAAQD,EAASM,GGmVhC,QAAAkC,GAAA3B,GACA,MAAA4B,UAAA5B,EAAA6B,KAAA7B,EAAA8B,mBAAAC,QAAAH,SAAA5B,EAAAgC,QApbA,GAAAC,GAAAxC,EAAA,IACAyC,EAAAzC,EAAA,IACA0C,EAAA1C,EAAA,IACA2C,EAAA3C,EAAA,IAEA4C,EAAA5C,EAAA,IACA6C,EAAA7C,EAAA,IACA8C,EAAA9C,EAAA,IAEAU,EAAAV,EAAA,EACAU,GAAAqC,MAAA,WAA0B,MAAApD,GAAAD,QAAAgC,IAE1B,KAAAsB,MAEAC,EAAAL,EAAAM,YACA,sHACA,iHACA,sIACA,sIACA,mIACA,gIACA,6HACA,+HACA,kIACA,oIACA,sIACA,4HACA,mHAMAvD,GAAAD,QAAA+C,EAAAD,EAAA,SAAAW,GAKArD,KAAAsD,KAAA,WACA,GAAAC,GAAAvD,IAEA,IAAAqC,SAAArC,KAAAwD,KACA,SAAAC,OAAA,6CAGA,IAAAC,GAAAV,EAAAW,gBAAAhC,IAAA3B,KAAA4D,YACAvB,UAAAqB,IACAA,EAAAV,EAAAa,wBAAA7D,OAGAqD,EAAAC,KAAA/C,KAAAP,MAEAA,KAAAuC,YACAvC,KAAA8D,MAAAjB,MACA7C,KAAA+D,OAAA1B,OAEAA,SAAArC,KAAAK,KACA6C,EAAAlD,KAAAK,IAAAL,MAGAqC,SAAArC,KAAAyC,UACAzC,KAAAyC,QAAAM,EAAAiB,OAGAhE,KAAAiE,MAAAjC,MAAAhC,KAAAiC,WAGAjC,KAAAkE,KAAA,UAAAlE,KAAAwD,KAGA,IAAAW,IAAAnE,KAAAyC,QAAA2B,UACAV,MAAA,GAAAS,EAAAE,KAAAX,EAAAU,WACAD,EAAAE,KAAAzD,EAAA0D,kBACAtE,KAAAyC,QAAA2B,UAAAD,EAAAI,KAAA,IAGA,IAAAC,KACAjB,GAAAkB,KAAA,SAAAC,KACAA,IAAAvB,KAAAd,SAAAkB,EAAAoB,kBAAAD,IAAAnB,GAAAoB,kBACApB,EAAAd,QAAAmC,iBAAAF,EAAAF,EAAAE,GAAA,WACAnB,EAAAsB,KAAA7C,MAAAuB,GAAAmB,GAAAI,OAAAtC,MAAAuC,UAAAC,MAAAzE,KAAA0B,iBAIAsB,EAAA0B,MAAA,SAAAP,KACAA,IAAAvB,KAAAd,SAAAkB,EAAAoB,kBAAAD,IAAAnB,GAAAoB,kBACApB,EAAAd,QAAAyC,oBAAAR,EAAAF,EAAAE,OAWA1E,KAAAiE,MAAA,WACA,IAAAhC,UAAAkD,OACAnF,KAAAyC,QAAAR,UAAA,GACSA,UAAAkD,QAAA,IACTnF,KAAAoF,MAAAnD,UAAA,GACAjC,KAAAyC,QAAAR,UAAA,KAQAjC,KAAAyC,QACAzC,KAAAoF,MACApF,KAAA2E,iBACA3E,KAAAuC,SAGAd,OAAAC,eAAA1B,KAAA,SACA2B,IAAA,WACA,MAAA3B,MAAAqF,QACSxD,IAAA,SAAAC,GACT,GAAAO,SAAArC,KAAAqF,OAOA,SAAA5B,OAAA,6DAAAzD,KAAAqF,OAAA,IANArF,MAAAqF,OAAAvD,EAEAjC,EAAAD,QAAAgC,KACA5B,KAAAkE,KAAA,QAAAlE,KAAAqF,WAYArF,KAAAsC,IAAA,WACAtC,KAAAsF,MAAAtD,MAAAhC,WAAAyC,QAAAF,SAAA4C,QAAAL,OAAAlC,EAAAX,cAOAjC,KAAAsF,MAAA,SAAAC,GAGA,OAFAC,GAAAC,EAAAzD,MAAAhC,KAAAiC,WAEAyD,EAAA,EAAqBA,EAAAF,EAAAL,OAAeO,IAAA,CACpC,GAAAC,GAAAH,EAAAE,EAGA,IAFA1F,KAAAuC,SAAAqD,OAAAL,EAAAG,EAAA,EAAAC,IAEAvD,EAAAuD,GACA,SAAAlC,OAAA,sBAGAkC,GAAA5B,OAAA1B,OACAsD,EAAAd,KAAA,gBAEA,IAAAgB,GAAA7F,KAAAuC,SAAA,EAAAmD,EAAAH,EACAlD,UAAAwD,EACA7F,KAAAyC,QAAAqD,YAAAH,EAAAlD,SAEAzC,KAAAyC,QAAAsD,aAAAJ,EAAAlD,QAAAoD,EAAApD,SAGAkD,EAAA5B,OAAA/D,KACA2F,EAAAd,KAAA,YAIA,IAAAtB,GAAAvD,IACA2F,GAAAK,kBAAA,WAAqD,MAAAzC,GAAA0C,kBACrDjD,EAAAkD,mBAAAP,GAAA3F,KAAAiG,oBAUAjG,KAAAmG,UAAAnG,KAAAoG,cAAA,SAAAP,GACA,GAAAL,GAAA5C,EAAAX,WAAA+C,MAAA,EACA,IAAA3C,SAAAwD,EACA7F,KAAAsC,IAAAN,MAAAhC,KAAAwF,OACS,CACT,GAAAD,GAAAvF,KAAAuC,SAAA8D,QAAAR,EACA7F,MAAAsF,MAAAtD,MAAAhC,MAAAuF,GAAAT,OAAAU,MAUAxF,KAAAsG,OAAA,WACA,GAAAC,GAAAC,EAAAxE,MAAAhC,KAAAiC,UACAsE,KAAAE,KAAA,SAAAC,EAAAC,GACA,MAAAA,GAAAD,GAGA,QAAAE,GAAA,EAAoBA,EAAAL,EAAApB,OAAmByB,IAAA,CACvC,GAAAC,GAAAN,EAAAK,GACAnG,EAAAT,KAAAuC,SAAAsE,EAEA,IAAAxE,SAAA5B,EACA,SAAAgD,OAAA,8BAAAoD,EAGApG,GAAAsD,OAAA1B,OACArC,KAAAuC,SAAAqD,OAAAiB,EAAA,GACA7G,KAAAyC,QAAAqE,YAAA9G,KAAAyC,QAAAsE,WAAAF,IAEApG,EAAAoE,KAAA,mBASA7E,KAAAkE,KAAA,WACA,OAAAjC,UAAAkD,OAAA,CACA,KAAAlD,UAAA,YAAAR,SAKa,CACb,GAAAuF,GAAAhH,KAAAyC,QAAAwE,aAAAhF,UAAA,GACA,eAAA+E,EACA3E,OAEA2E,EATA,GAAAE,GAAAjF,UAAA,EACA,QAAA+E,KAAAE,GACAnE,EAAAoE,aAAAnH,KAAAyC,QAAAuE,EAAA/E,UAAA,GAAA+E,QAUS,CACT,GAAAA,GAAA/E,UAAA,EACA,IAAAI,SAAAJ,UAAA,IACA,GAAAmF,GAAAnF,UAAA,EACAc,GAAAoE,aAAAnH,KAAAyC,QAAAR,UAAA,GAAAmF,OAEApH,MAAAyC,QAAA4E,gBAAAL,KAKAvF,OAAAC,eAAA1B,KAAA,WAEA2B,IAAA,WACA,eAAA3B,KAAAyC,QAAA6E,MAAAC,SAGS1F,IAAA,SAAA2F,GACTA,EACAnF,SAAArC,KAAAyH,eACAzH,KAAAyC,QAAA6E,MAAAC,QAAAvH,KAAAyH,cACAzH,KAAAyH,cAAApF,QAEArC,KAAAyC,QAAA6E,MAAAC,QAAA,IAGA,KAAAvH,KAAAyC,QAAA6E,MAAAC,SAAA,SAAAvH,KAAAyC,QAAA6E,MAAAC,UACAvH,KAAAyH,cAAAzH,KAAAyC,QAAA6E,MAAAC,SAGAvH,KAAAyC,QAAA6E,MAAAC,QAAA,WAMA9F,OAAAC,eAAA1B,KAAA,SAEA2B,IAAA,WACA,MAAA+F,UAAAC,gBAAA3H,KAAAyC,SAGSZ,IAAA,SAAA+F,GACTA,EACA5H,KAAAyC,QAAAoF,QAEA7H,KAAAyC,QAAAqF,UAKArG,OAAAC,eAAA1B,KAAA,SACA2B,IAAA,WACA,MAAA3B,MAAA+H,QAGSlG,IAAA,SAAAmG,GACT,GAAA3F,SAAA2F,EAAA,CACA,GAAAC,GAAAjI,KAAAgG,mBACA3D,UAAA4F,EACAjF,EAAAkF,gBAAAlI,KAAAgD,EAAAmF,qBAAAF,EAAAjI,OAEAgD,EAAAkF,gBAAAlI,KAAAqC,QAGArC,KAAAiG,iBAAAgC,MAEa,CACbjF,EAAAkF,gBAAAlI,KAAAgI,EACA,IAAAI,GAAAJ,EAAArG,IAAA3B,KAEAA,MAAAiG,iBADA5D,SAAArC,KAAAgG,oBACAhD,EAAAqF,oBAAArI,KAAAgG,oBAAAoC,EAAAE,mBAEAF,EAAAE,kBAIAtI,KAAA+H,OAAAC,EACAhF,EAAAkD,kBAAAlG,KAAAuC,SAAAvC,KAAAiG,qBAIAxE,OAAAC,eAAA1B,KAAA,kBAGA2B,IAAA,WACA,MAAAoB,GAAAwF,kBAAAvI,KAAAyC,UAGSZ,IAAA,SAAA2G,GACTzF,EAAA0F,kBAAAzI,KAAAyC,QAAA+F,EAAA,GAAAA,EAAA,OAIAxI,KAAA+B,OAAA,WACAA,EAAA/B,OAEAA,KAAAkC,OAAA,WACAA,EAAAlC,OAMAA,KAAAgG,kBAAA,aACAhG,KAAAiG,iBAEAjG,KAAA+H,OACA/H,KAAA0I,aACA1I,KAAAyH,cACAzH,KAAA2I,oBAIA9I,EAAAD,QAAAgC,KAAA,CAIA,IAAAG,GAAAlC,EAAAD,QAAAmC,OAAA,WACA,GAAAE,UAAA,YAAAO,OACA,GAAAU,GAAAjB,UAAA,OAEA,IAAAiB,GAAAjB,SAGA,WAAAyF,SAAAkB,KAAA,SAAAnF,OAAA,sCAEA,QAAAmD,GAAA,EAAgBA,EAAA1D,EAAAiC,OAAqByB,IACrCc,SAAAkB,KAAA9C,YAAA5C,EAAA0D,GAAAnE,UAIAP,EAAArC,EAAAD,QAAAsC,OAAA,WACA,GAAAD,UAAA,YAAAO,OACA,GAAAU,GAAAjB,UAAA,OAEA,IAAAiB,GAAAjB,SAGA,QAAA2E,GAAA,EAAgBA,EAAA1D,EAAAiC,OAAqByB,IACrCc,SAAAkB,KAAA9B,YAAA5D,EAAA0D,GAAAnE,SAMA5C,GAAAD,QAAAuC,WAAA,SAAA0G,GACA,GAAAC,GAAApB,SAAAqB,eAAAC,eAAA,4CACAJ,EAAAE,EAAAG,cAAA,OACAH,GAAAI,gBAAApD,YAAA8C,GACAO,WAAA,WACAN,KACK,GAOL,IAAArC,GAAA3G,EAAAD,QAAA4G,yBAAA,WACA,GAAAjD,GAAAvD,IAEA,IAAAiC,UAAA,YAAAO,OACA,GAAA+D,GAAAtE,UAAA,OAEA,IAAAsE,GAAA/D,MAAAuC,UAAAC,MAAAzE,KAAA0B,UAGA,OAAAsE,GAAA6C,IAAA,SAAAC,EAAAC,GACA,GAAAlH,EAAAiH,GAAA,CACA,GAAA9D,GAAAhC,EAAAhB,SAAA8D,QAAAgD,EACA,SAAA9D,EACA,SAAA9B,OAAA,6BAAA6F,EAAA,iCAEA,OAAA/D,GAEA,MAAA8D,MAOA5D,EAAA5F,EAAAD,QAAA6F,wBAAA,WACA,WAAAxD,UAAAkD,OACAlD,UAAA,YAAAO,OACAP,UAAA,IAEAA,UAAA,IAGAW,EAAAX,WAAA+C,MAAA,KH+GM,SAASnF,EAAQD,EAASM,GInQhC,QAAAqJ,GAAAjC,EAAAkC,GACA,GAAAC,KACA,QAAAC,KAAAF,GAAA,CACA,GAAApC,GAAAoC,EAAAE,GAGAC,EAAAD,EAAAE,MAAA,KACAC,KACAC,IACA,QAAAlD,KAAA+C,GAAA,CACA,GAAAI,GAAAJ,EAAA/C,GACAoD,EAAAC,EAAAF,EACAC,aAAAE,GACAL,EAAAxF,KAAA0F,GAEAD,EAAAzF,KAAA0F,GAKA,OAAAF,EAAA1E,OACAgF,EAAAT,EAAAtC,GACAgD,EAAA9C,EAAAoC,EAAA,IAAApC,EAAAlD,UAAA,IAAAsF,EAAAtC,OAES,CAETyC,EAAApD,MACA,IAAA4D,GAAAR,EAAAtF,KAAA,IAIA,IAHAlC,SAAAoH,EAAAY,KACAZ,EAAAY,OAEA,IAAAP,EAAA3E,OACArC,EAAAwH,MAAAb,EAAAY,GAAAjD,OACa,CACb0C,EAAArD,MACA,IAAA8D,GAAAT,EAAAvF,KAAA,KAEAiG,IACAA,GAAA,KAAAD,GAAAnD,EAEAtE,EAAAwH,MAAAb,EAAAY,GAAAG,KAKA,MAAAf,GAQA,QAAAgB,GAAAhB,GAKA,OAJAiB,GAAAjJ,OAAAkJ,KAAAlB,GAAAmB,UAAAxB,IAAA,SAAAtH,GACA,OAAgB4H,IAAA5H,EAAA+I,MAAA/I,EAAA8H,MAAA,QAGhBhD,EAAA,EAAgBA,EAAA8D,EAAAvF,OAAkCyB,IAElD,OADAkE,GAAAJ,EAAA9D,GACAmE,EAAA,EAAoBA,GAAAL,EAAAvF,OAAqC4F,IACzD,OAAAC,GAAApE,EAAA,EAA0BoE,EAAAN,EAAAvF,QAAA4F,EAAA,GAAwCC,IAAA,CAClE,GAAAC,GAAAC,EAAAzB,GAAAqB,GAAAhG,OAAA4F,EAAA1F,MAAAgG,EAAAD,IACAE,GAAAvB,MAAAD,GACA3G,EAAAwH,MAAAb,EAAAwB,EAAAvB,KAAAuB,EAAA7D,OAEAqC,EAAAwB,EAAAvB,KAAAuB,EAAA7D,OAmNA,QAAA+D,GAAAC,EAAAC,GACA,UAAAD,EAAA3I,QAAA6I,WACA,QAEA,IAAA/I,GAAA6I,EAAA3I,QAAA6I,WAAA/I,SACAgD,EAAA/C,MAAAuC,UAAAsB,QAAA9F,KAAAgC,EAAA6I,EAAA3I,QACA,OAAA4I,GAAA9F,GAGA,QAAAgG,GAAAH,EAAAI,GACA,UAAAJ,EAAA3I,QAAA6I,WACA,QAEA,IAAA/I,GAAA6I,EAAA3I,QAAA6I,WAAA/I,SACAgD,EAAAhD,EAAA4C,OAAAsG,SAAAD,EACA,OAAAjJ,GAAAgD,KAAA6F,EAAA3I,QAKA,QAAAiJ,GAAAF,GACA,GAAAX,GAAAW,EAAAG,MAAAC,EACA,WAAAf,EACA,SAAApH,OAAA,wBAAA+H,EAAA,gBAEA,IAAAnJ,SAAAwI,EAAA,GACA,GAAAgB,GAAAhB,EAAA,GACAiB,EAAAjB,EAAA,OAEA,IAAAgB,GAAAhB,EAAA,GACAiB,EAAAjB,EAAA,EAQA,OALAgB,GAAAxJ,SAAAwJ,EAAA,EACAJ,SAAAI,GACAC,EAAAzJ,SAAAyJ,EAAA,EACAL,SAAAK,GAEA,IAAAA,EACA,SAAAvG,GACA,MAAAA,GAAA,IAAAsG,GAGA,SAAAtG,GACA,OAAAA,EAAA,EAAAsG,GAAAC,EAAA,OAQA,QAAAC,GAAAC,EAAA5E,GAEA,0BAAA/E,SAAA4J,EAAAD,GACA5E,EAAA,KAEAA,EAAA8E,WAIA,QAAA9B,GAAA7G,EAAAwG,EAAAoC,EAAAC,GAEA,GAAAC,KACA,QAAA3C,KAAA0C,GAAA,CACA,GAAAhF,GAAAgF,EAAA1C,EAEA,IAAAtC,YAAA3F,QAKA,SAAAgC,OAAA,4CAAAsG,EAAA,uBAJA,IAAAuC,GAAA5C,EACAsC,EAAAO,EAAAD,EACAD,GAAAL,GAAAD,EAAAC,EAAA5E,GAOAoF,EAAA3K,IAAAsK,EAAAE,GAGA9I,EAAAkJ,oBACAlJ,EAAAkJ,iBAAAN,GAAAE,EAKA,QAAAlC,GAAAJ,EAAAP,GACA,OAAAE,KAAAF,GAAA,CACA,GAAApC,GAAAoC,EAAAE,EAEA,IAAAgD,EAAAtF,GACA,SAAA3D,OAAA,gCAAAsG,EAAA,sBACS,eAAAL,EACT,SAAAjG,OAAA,kDAAAsG,EAAA,IACS,cAAAL,EACT,SAAAjG,OAAA,iDAAAsG,EAAA,IACS,QAAAL,EAAArD,QAAA,KACT,SAAA5C,OAAA,wDAAAsG,EAAA,MAOA,QAAAE,GAAA0C,GACA,GAAAC,GAAAD,EAAAhB,MAAAkB,EACA,WAAAD,EAAA,SAAAnJ,OAAA,gBAAAkJ,EAAA,eACA,QAAYG,QAAAF,EAAA,GAAApB,UAAAoB,EAAA,IAMZ,QAAAG,GAAAhD,EAAAqC,GACA,GAAAY,MACAC,IACA,QAAAvD,KAAA0C,GAAA,CACA,GAAAhF,GAAAgF,EAAA1C,EAEA,QAAAA,EAAArD,QAAA,OACA,GAAA6G,GAAAxD,EAAAyD,OAAA,EACA,SAAAD,EACA,SAAAzJ,OAAA,qDAGAwJ,GAAAC,GAAA9F,MAEA4F,GAAAtD,GAAAtC,EAKA,GAAAgG,KACA,QAAAF,KAAAD,GAAA,CACA,GAAA7F,GAAA6F,EAAAC,EAEAR,GAAAtF,GACAgG,EAAArD,EAAA,IAAAmD,GAAA9F,EAEAtE,EAAAwH,MAAA8C,EAAAL,EAAAhD,EAAA,IAAAmD,EAAApK,EAAAwH,SAAgH0C,EAAA5F,KAOhH,MAFAgG,GAAArD,GAAAiD,EAEAI,EAoBA,QAAAV,GAAAW,GACA,MAAAhL,UAAAgL,EAAA/E,kBAKA,QAAAiE,GAAAP,GACA,OAAApF,GAAA,EAAgBA,EAAAoF,EAAA7G,OAAuByB,IAAA,CACvC,GAAA0G,GAAAtB,EAAAuB,WAAA3G,EACA0G,IAAAE,GAAAC,GAAAH,IACAtB,IAAAhH,MAAA,EAAA4B,GAAA,IAAA8G,OAAAC,aAAAL,EAAAM,GAAA5B,EAAAhH,MAAA4B,EAAA,GACAA,KAIA,MAAAoF,GAruBA,GAAA6B,GAAA3N,EAAA,IACAyC,EAAAzC,EAAA,IACA4N,EAAA5N,EAAA,IAEA4C,EAAA5C,EAAA,IAGA6N,GAFA7N,EAAA,IAEA,oBACA8N,EAAA,EAEAxB,EAAAqB,EAAAI,YAAAvG,SACA8E,GAAA0B,aAAA1B,EAAA2B,cACA,IAAAC,GAAAP,EAAAI,YAAAvG,SACA0G,GAAAF,aAAAE,EAAAD,cAGA,IAAAvN,GAAAf,EAAAD,QAAA+C,EAAA,WAEA3C,KAAAsE,iBAAA,YASAtE,KAAAsD,KAAA,SAAA+K,EAAAC,GACAjM,SAAAiM,UACAjM,SAAAiM,EAAAC,mBAAA,GAEAvO,KAAAoE,UAAA2J,EAAAC,EACAA,IAEAhO,KAAAsI,qBACAtI,KAAAwO,gBAEA,IAAAC,MACAjF,KACAkF,IACA,QAAAhF,KAAA2E,GAAA,CACA,GAAAjH,GAAAiH,EAAA3E,EAEA,eAAAA,EAAA,CACA,KAAAtC,YAAAuH,WAAA,SAAAlL,OAAA,mEACAzD,MAAA4O,MAAAxH,MAEa,cAAAsC,EAAA,CACb,KAAAtC,YAAAuH,WAAA,SAAAlL,OAAA,iEACAzD,MAAA6O,KAAAzH,MAEa,QAAAsC,EAAArD,QAAA,OACb,GAAA0D,GAAAwC,EAAA7C,EAAAyD,OAAA,GACA,SAAApD,EACA,SAAAtG,OAAA,qDAGAX,GAAAwH,MAAAd,EAAAuD,EAAAhD,EAAA3C,QAEa,QAAAsC,EAAArD,QAAA,MACb,GAAAiI,EAAAC,QACA,SAAA9K,OAAA,mCAAAiG,EAAA,8CAEA,IAAAtE,GAAAsE,EAAAyD,OAAA,EACA,SAAA/H,EACA,SAAA3B,OAAA,6CAGAgL,GAAArJ,GAAAgC,MAEa,IAAAsF,EAAAtF,GACbpH,KAAAsI,kBAAAoB,GAAAtC,MAEa,IAAAA,YAAA3F,QACbzB,KAAAsI,kBAAAoB,GAAA9I,EAAAwG,OACa,CACb,GAAAkF,GAAA5C,EACAsC,EAAAO,EAAAD,EACAoC,GAAA1C,GAAAD,EAAAC,EAAA5E,IAKA,GAAAkH,aACA,GAAAQ,GAAAtC,MAEA,IAAAsC,GAAAV,CAWA,IARAU,EAAAjN,IAAA,IAAA7B,KAAAoE,UAAAsK,GAGA1O,KAAAyM,oBACAzM,KAAAyM,iBAAA,IAAAzM,KAAAoE,WAAAsK,EAIAjN,OAAAkJ,KAAA8D,GAAAtJ,OAAA,GACA,GAAA4J,GAAAjM,EAAAwH,SAA0CoE,EAAA1O,KAAAsI,kBAE1C,QAAAlD,KAAAqJ,GACA,GAAA/B,EAAA+B,EAAArJ,IACApF,KAAAwO,cAAApJ,GAAAqJ,EAAArJ,OACiB,CACjB,GAAA4J,GAAAlM,EAAAwH,SAAoDyE,EAAAN,EAAArJ,GACpDpF,MAAAwO,cAAApJ,GAAAxE,EAAAoO,GAAoET,SAAA,KAMpE,GAAA9M,OAAAkJ,KAAAnB,GAAArE,OAAA,GAEA,GAAAsE,GAAAF,EAAAvJ,KAAAwJ,EACAiB,GAAAhB,EAKA,IAAAwF,MACAC,KACAC,IACA,QAAAzF,KAAAD,GAAA,CACA,GAAAiD,EAAAjD,EAAAC,IACAD,EAAAC,GAAAD,EAAAC,OACiB,CACjB,GAAA0F,GAAAxO,EAAAkC,EAAAwH,SAAuDoE,EAAAjF,EAAAC,IAGvD,QAAAqB,KAAA/K,MAAAsI,kBACAjG,SAAA+M,EAAA9G,kBAAAyC,KACAqE,EAAA9G,kBAAAyC,GAAA/K,KAAAsI,kBAAAyC,GAEA,QAAAA,KAAA/K,MAAAwO,cACAnM,SAAA+M,EAAAZ,cAAAzD,KACAqE,EAAAZ,cAAAzD,GAAA/K,KAAAwO,cAAAzD,GAGAtB,GAAAC,GAAA0F,EAKA,OADAzF,GAAAD,EAAAE,MAAA,KACAhD,EAAA,EAA4BA,EAAA+C,EAAAxE,OAA0ByB,IAAA,CACtD,GAAAmD,GAAAJ,EAAA/C,EACA,SAAAqI,EAAA5I,QAAA0D,GAAA,CACAkF,EAAA5K,KAAA0F,EAEA,IAAAC,GAAAC,EAAAF,GACAsF,EAAAnF,EAAAF,YACAsF,GAAoCD,MACpChN,UAAAgN,EAAAE,mBACAD,EAAA9D,UAAA6D,EAAAE,iBAAAvF,EAAAwB,YAEA2D,EAAApF,GAAAuF,GAIAJ,EAAA7K,MAAAsF,EAAAF,EAAAC,KAIA,GAAA8F,GAAA,SAAApE,GAEA,OADAtH,MACA8C,EAAA,EAA4BA,EAAAqI,EAAA9J,OAAgCyB,IAAA,CAC5D,GAAAmD,GAAAkF,EAAArI,GACA6I,EAAAN,EAAApF,EACAjG,GAAAiG,GAAA0F,EAAAJ,IAAAK,MAAAtE,EAAAqE,EAAAjE,WAGA,MAAA1H,IAGAP,EAAAvD,KACA2P,EAAA,SAAAjH,EAAA0C,EAAAtH,GAGA,OAFA8L,GAAA,EACAC,EAAAtM,EACAqD,EAAA,EAA4BA,EAAAsI,EAAA/J,OAAgCyB,IAAA,CAE5D,OADA+C,GAAAuF,EAAAtI,GAAA,GACAoE,EAAA,EAAgCA,EAAArB,EAAAxE,QAChCrB,EAAA6F,EAAAqB,IAD0DA,KAM1DA,IAAArB,EAAAxE,QAAA6F,EAAA4E,IACAA,EAAA5E,EACA6E,EAAAX,EAAAtI,GAAA,IAIAiJ,IAAAnH,IACA0C,EAAA9D,MAAAuI,IASAC,EAAA,SAAAxI,GACA,GAAAyI,GAAAzI,EAAAsH,KACAtH,GAAAsH,MAAA,SAAAxD,GACA,GAAA7H,GAAAvD,IAEAA,MAAA2I,oBACA,IAAA7E,GAAA0L,EAAApE,EACA,QAAArB,KAAAoF,IACyB,SAAApF,EAAAiG,GACzBzM,EAAAoF,kBAAAoB,GAAAiG,EAAAX,IAAAT,MAAAxD,EAAA,WACAtH,EAAAiG,IAAA,EACA4F,EAAApM,EAAA6H,EAAAtH,IAC6B,WAC7BA,EAAAiG,IAAA,EACA4F,EAAApM,EAAA6H,EAAAtH,IAC6BkM,EAAAxE,YAEJzB,EAAAoF,EAAApF,GAGzB4F,GAAApM,EAAA6H,EAAAtH,GAEAzB,SAAA0N,GACAA,EAAA/N,MAAAhC,KAAAiC,WAIA,IAAAgO,GAAA3I,EAAAuH,IACAvH,GAAAuH,KAAA,SAAAzD,GACA,OAAArB,KAAAoF,GAAA,CACA,GAAAa,GAAAb,EAAApF,EACAiG,GAAAX,IAAAR,KAAAzD,EAAApL,KAAA2I,kBAAAoB,IAGA1H,SAAA4N,GACAA,EAAAjO,MAAAhC,KAAAiC,YAOA,QAAAyH,KAAAD,GAAA,CACA,GAAAnC,GAAAmC,EAAAC,EACAoG,GAAAxI,GAGAwI,EAAA9P,QAMAA,KAAAoE,UACApE,KAAAsI,kBACAtI,KAAAwO,cACAxO,KAAA4O,MACA5O,KAAA6O,KAGA7O,KAAA2B,IAAA,SAAAyJ,GACA,GAAA/I,SAAA+I,EAAAhG,MAAA,CACA,GAAA8K,GAAAlQ,KAAAwO,cAAApD,EAAAhG,MACA,IAAA/C,SAAA6N,EACA,MAAAA,GAIA,MAAAlQ,SA+FAkL,EAAA,SAAAiF,EAAAxF,GAGA,OAFAyF,GAAAzF,EAAA,GAAAE,MACAwF,EAAAvN,EAAAwH,SAAoC6F,EAAAxF,EAAA,GAAAjB,MACpC9C,EAAA,EAAgBA,EAAA+D,EAAAxF,OAAeyB,IAAA,CAG/B,OAFA8C,GAAAiB,EAAA/D,GAEAoE,EAAA,EAAoBA,EAAAtB,EAAAmB,MAAA1F,OAAoB6F,IAAA,CACxC,GAAAsF,GAAA5G,EAAAmB,MAAAG,EACA,MAAAoF,EAAA/J,QAAAiK,IACAF,EAAA/L,KAAAiM,GAKAxN,EAAAwH,MAAA+F,EAAAF,EAAAzG,QAGA,OAAYA,IAAA0G,EAAA7L,KAAA,KAAA6C,MAAAiJ,IAUZnG,GACAqG,OACAb,MAAA,SAAAtE,GAEA,OADA5F,GAAAkC,SAAA8I,iBAAA,UACA5J,EAAA,EAAwBA,EAAApB,EAAAL,OAAgByB,IACxC,GAAApB,EAAAoB,KAAAwE,EAAA3I,QACA,QAGA,WAEAmM,MAAA,SAAAxD,EAAAqF,EAAAC,GAMA,MALAtF,GAAAuF,GAAA,uBACAF,MAEArF,EAAAuF,GAAA,WAAAD,IAEoBE,MAAAH,EAAAI,IAAAH,IAEpB7B,KAAA,SAAAzD,EAAAtH,GACAsH,EAAA0F,IAAA,YAAAhN,EAAA8M,OACAxF,EAAA0F,IAAA,WAAAhN,EAAA+M,OAGAE,SACArB,MAAA,SAAAtE,GACA,MAAAA,GAAA4F,UAEApC,MAAA,SAAAxD,EAAAqF,EAAAC,GACA,GAAAO,KASA,OARA7F,GAAAuF,GAAA,SAAAM,EAAAC,SAAA,WACA9F,EAAA4F,SACAP,IAEAC,MAIAO,GAEApC,KAAA,SAAAzD,EAAAtH,GACAsH,EAAA+F,eAAA,SAAArN,EAAAoN,YAGAE,UACA1B,MAAA,SAAAtE,GACA,MAAA/I,UAAA+I,EAAAlH,KAAA,aAEA0K,MAAA,SAAAxD,EAAAqF,EAAAC,GACA,GAAAW,GAAA,GAAAC,kBAAA,WACAjP,SAAA+I,EAAAlH,KAAA,YACAuM,IAEAC,KAMA,OAFAW,GAAAxO,QAAAuI,EAAA3I,SAAiDyE,YAAA,KAE7BmK,aAEpBxC,KAAA,SAAAzD,EAAAtH,GACAA,EAAAuN,SAAAE,eAGAC,cACA9B,MAAA,SAAAtE,GACA,MAAAG,GAAAH,EAAA,MAEAwD,MAAA,SAAAxD,EAAAqF,EAAAC,GACA,GAAAW,GAAA,GAAAC,kBAAA,WACA/F,EAAAH,EAAA,KACAqF,IAEAC,MAIAe,EAAA,WAEAJ,EAAAxO,QAAAuI,EAAArH,OAAAtB,SAA4DiP,WAAA,IAc5D,OAXArP,UAAA+I,EAAArH,QACA0N,IAGArG,EAAAuF,GAAA,uBACAc,MAEArG,EAAAuF,GAAA,2BACAU,EAAAE,gBAGoBF,aAEpBxC,KAAA,SAAAzD,EAAAtH,GACAA,EAAAuN,SAAAE,eAGAI,aAEAjC,MAAA,SAAAtE,EAAAwG,GACA,MAAAzG,GAAAC,EAAAwG,IAEAhD,MAAA,SAAAxD,EAAAqF,EAAAC,EAAAkB,GAEA,GAAAC,GAAA,WACA1G,EAAAC,EAAAwG,GACAnB,IAEAC,KAIAW,EAAA,GAAAC,kBAAA,WACAO,MAGAJ,EAAA,WAEAJ,EAAAxO,QAAAuI,EAAArH,OAAAtB,SAA4DiP,WAAA,IAgB5D,OAbArP,UAAA+I,EAAArH,QACA0N,IAGArG,EAAAuF,GAAA,uBACAc,IACAI,MAEAzG,EAAAuF,GAAA,2BACAU,EAAAE,aACAM,OAGoBR,aAEpBxC,KAAA,SAAAzD,EAAAtH,GACAA,EAAAuN,SAAAE,cAEAhC,iBAAA,SAAA/D,GACA,MAAAE,GAAAF,KAmBA3L,GAAAD,QAAAkS,eAAA,SAAAtO,EAAA6L,GACA,GAAAhN,SAAA6H,EAAA1G,GAAA,SAAAC,OAAA,oBAAAD,EAAA,wBAEA0G,GAAA1G,GAAA6L,EAuBA,IAAAzD,GAAA,oDAoFAiB,EAAA,uBAgDAZ,GACA8F,eAAA,EACAC,eAAA,EACAC,YAAA,EACAC,cAAA,EACAC,cAAA,EACAC,cAAA,EACAC,QAAA,EACAC,MAAA,EACAC,QAAA,EACAC,OAAA,EACAC,UAAA,EACAC,KAAA,GAQAlF,EAAA,IAAAD,WAAA,GAAAE,EAAA,IAAAF,WAAA,GAAAK,EAAA,IAAAL,WAAA,GAAAC,EAeAmF,GACAC,QAAA,SACAC,kBAAA,WACAC,iBAAA,IACAC,eAAA,MAGAC,UAAA,MACAzL,QAAA,eACA0L,UAAA,GACAC,cAAA,OAMAC,iBAAA,SACAf,cAAA,SACAgB,mBAAA,OACAC,sBAAA,UACAC,kBAAA,OACAf,QAAA,IACAgB,cAAA,GACAC,MAAA,GACAC,SAAA,WACAC,OAAA,GACAC,SAAA,GACAC,eAAA,GACAC,gBAAA,GACAC,oBAAA,GACAC,MAAA,GACAC,aAAA,GACAC,OAAA,GACAC,aAAA,OACAC,cAAA,IACAC,iBAAA,OAEAC,eAAA,GACAC,OAAA,GACAC,cAAA,SACA/B,OAAA,IACAgC,eAAA,SAGAhI,GAAA3K,IAAA,IAAAjB,EAAA0D,iBAAAqO,GAEAnG,EAAA3K,IAAA,SACA4S,OAAA,YAGA5U,EAAAD,QAAAqD,KAEApD,GAAAD,QAAA8U,eAAA,GAAA5G,IJoiBM,SAASjO,EAAQD,EAASM,GKl0ChC,IAAAS,GAAAT,EAAA,GACAyC,EAAAzC,EAAA,GACAA,GAAA,GAEAL,EAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,KAAA,SAEAxD,KAAAsD,KAAA,WACA,OAAArB,UAAAkD,OACA,GAAAwP,GAAA1S,UAAA,GACA2S,EAAA3S,UAAA,OAEA,IAAAmD,GAAAnD,UAAA,GACA0S,EAAA1S,UAAA,GACA2S,EAAA3S,UAAA,EAGAjC,MAAAyC,QAAAiF,SAAAuB,cAAA,UACA5F,EAAAC,KAAA/C,KAAAP,MAEAA,KAAAoF,QACApF,KAAA2U,SACA3U,KAAA4U,SAKAnT,OAAAC,eAAA1B,KAAA,SACA2B,IAAA,WACA,MAAA3B,MAAAyC,QAAAmS,OACS/S,IAAA,SAAAC,GACT9B,KAAAyC,QAAAmS,MAAA9S,KAGAL,OAAAC,eAAA1B,KAAA,UACA2B,IAAA,WACA,MAAA3B,MAAAyC,QAAAkS,QACS9S,IAAA,SAAAC,GACT9B,KAAAyC,QAAAkS,OAAA7S,KAIA9B,KAAA6U,QAAA,WACA,MAAA7U,MAAAyC,QAAAqS,WAAA9S,MAAAhC,KAAAyC,QAAAR,YAGAjC,KAAA+U,MAAA/U,KAAAgV,UAAA,WACA,MAAAhV,MAAAyC,QAAAuS,gBL20CM,SAASnV,EAAQD,EAASM,GM73ChC,GAAAS,GAAAT,EAAA,GACAyC,EAAAzC,EAAA,GAEAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,KAAA,YAKAxD,KAAAsD,KAAA,WACA,OAAArB,UAAAkD,OACA,GAAA8P,IAAAhT,UAAA,QACS,IAAAA,UAAAkD,OAAA,EACT,mBAAAlD,WAAA,GACA,GAAAmD,GAAAnD,UAAA,GACAgT,EAAAzS,MAAAuC,UAAAC,MAAAzE,KAAA0B,UAAA,OAEA,IAAAgT,GAAAhT,SAKAoB,GAAAC,KAAA/C,KAAAP,MAEAA,KAAAoF,QAEA/C,SAAA4S,GACAjV,KAAAsC,IAAAN,MAAAhC,KAAAiV,ONs4CM,SAASpV,EAAQD,EAASM,GOp6ChC,GAAAS,GAAAT,EAAA,GACAyC,EAAAzC,EAAA,GAEAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,KAAA,SAKAxD,KAAAsD,KAAA,WACA,GAAArB,UAAAkD,QAAA,EACA,GAAAC,GAAAnD,UAAA,GACAiT,EAAAjT,UAAA,OAEA,IAAAiT,GAAAjT,UAAA,EAGAjC,MAAAyC,QAAAiF,SAAAuB,cAAA,SACA5F,EAAAC,KAAA/C,KAAAP,MAEAA,KAAAoF,QACApF,KAAAkE,KAAA,iBACAlE,KAAAkV,QAGAzT,OAAAC,eAAA1B,KAAA,QACA2B,IAAA,WACA,MAAA3B,MAAAkE,KAAA,UAEArC,IAAA,SAAAqT,GACAlV,KAAAkE,KAAA,QAAAgR,SP+6CM,SAASrV,EAAQD,EAASM,GQh9ChC,GAAAS,GAAAT,EAAA,GACAyC,EAAAzC,EAAA,GAEAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAEArD,KAAAwD,KAAA,WAGAxD,KAAAsD,KAAA,SAAA8B,GAGApF,KAAAyC,QAAAiF,SAAAuB,cAAA,SACA5F,EAAAC,KAAA/C,KAAAP,MAEAA,KAAAoF,QACApF,KAAAkE,KAAA,oBAGAzC,OAAAC,eAAA1B,KAAA,YAEA2B,IAAA,WACA,MAAA3B,MAAAyC,QAAAsO,SAGAlP,IAAA,SAAAkP,GACA,GAAAoE,GAAApE,KAAA,EACAqE,EAAApV,KAAAyC,QAAAsO,OACAqE,KAAAD,IAEAnV,KAAAyC,QAAAsO,QAAAoE,EACAnV,KAAA6E,KAAA,iBR09CM,SAAShF,EAAQD,EAASM,GSx/ChC,GAAAS,GAAAT,EAAA,GACAyC,EAAAzC,EAAA,GAEAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,KAAA,QAEAxD,KAAAsD,KAAA,WACA,OAAArB,UAAAkD,OACA,GAAAkQ,GAAApT,UAAA,OAEA,IAAAmD,GAAAnD,UAAA,GACAoT,EAAApT,UAAA,EAGAjC,MAAAyC,QAAAiF,SAAAuB,cAAA,OACA5F,EAAAC,KAAA/C,KAAAP,KAIAA,MAAAoF,QACA/C,SAAAgT,IAAArV,KAAAsV,IAAAD,IAKA5T,OAAAC,eAAA1B,KAAA,OACA2B,IAAA,WACA,MAAA3B,MAAAyC,QAAA6S,KACSzT,IAAA,SAAAC,GACT9B,KAAAyC,QAAA6S,IAAAxT,QTkgDM,SAASjC,EAAQD,EAASM,GUliDhC,GAAAyC,GAAAzC,EAAA,IAEAS,EAAAT,EAAA,GACAU,EAAAV,EAAA,GAEAqV,EAAArV,EAAA,GAEAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAuV,OAEAvV,KAAAwD,KAAA,OAIAxD,KAAAsD,KAAA,WACA,GAAArB,UAAA,YAAAO,OACA,GAAAgT,GAAAvT,UAAA,OACS,CACT,GAAAA,UAAA,YAAAO,OACA,GAAAgT,GAAAvT,UAAA,OACa,IAAAA,UAAA,YAAAO,OACb,GAAAgT,GAAAvT,UAAA,EAGA,qBAAAA,WAAA,GACA,GAAAwT,GAAAxT,UAAA,OACa,CACb,oBAAAA,WAAA,GACA,GAAAwT,GAAAxT,UAAA,OAEA,IAAAwT,IAAA,CAGA,oBAAAxT,WAAA,GACA,GAAAmD,GAAAnD,UAAA,IAKA,GAAAwT,EACA,GAAAC,GAAA,SACS,CACT,GAAAA,GAAA,IACA1V,MAAA2V,aAAA/U,GACAgV,cAAA,YASA,GAJA5V,KAAAyC,QAAAiF,SAAAuB,cAAAyM,GACArS,EAAAC,KAAA/C,KAAAP,MACAA,KAAAoF,QAEA/C,SAAAmT,EACA,OAAA5O,GAAA,EAAwBA,EAAA4O,EAAArQ,OAAmByB,IAC3C5G,KAAA6V,KAAAL,EAAA5O,KAKA5G,KAAA6V,KAAA,WACA,GAAAA,GAAAN,EAAAvT,MAAAhC,KAAAiC,UAEA,OADAjC,MAAAsC,IAAAuT,GACAA,MV0iDM,SAAShW,EAAQD,EAASM,GWl4ChC,QAAA4V,GAAAC,EAAA/C,GACA,GAAAgD,GAAAD,EAAAE,MAAAD,QACAE,EAAAzU,OAAAkJ,KAAAqL,GACAzQ,EAAA2Q,EAAA7P,QAAA0P,EAAA7R,KAAA,SACA,QAAA8O,GAAAzN,IAAA2Q,EAAA/Q,OAAA,EACA,GAAAgR,GAAAH,EAAAE,EAAA,QACK,SAAAlD,GAAA,IAAAzN,EACL,GAAA4Q,GAAAH,EAAAE,IAAA/Q,OAAA,QAGA,IAAAgR,GAAAH,EAAAE,EAAA3Q,EAAAyN,GAGAmD,GAAAnF,UAAA,EACAmF,EAAAtO,QAGA,QAAAuO,GAAAH,EAAAF,GACA,GAAA/E,GAAAiF,EAAAI,SACAhU,UAAA2O,MAAAvO,QAAAsO,SAAA,GACAgF,EAAAtT,QAAAsO,SAAA,EACAkF,EAAAI,UAAAN,EAGA,QAAAO,GAAAC,EAAAC,GACA,MAAAC,MAAAC,MAAAD,KAAAE,UAAAH,EAAAD,MAnQA,GAAA5T,GAAAzC,EAAA,IACA0W,EAAA1W,EAAA,IAAA0W,aAEAjW,EAAAT,EAAA,GAEA2W,EAAAP,EAAA,SAGAzW,GAAAD,QAAA+C,EAAAiU,EAAA,WAIA5W,KAAAwD,KAAA,QAMAxD,KAAAsD,KAAA,SAAA8N,GAEApR,KAAAoR,cAAA,GAAA/O,SAAA+O,EACApR,KAAAgW,WACAhW,KAAA6W,iBAIA7W,KAAA+V,OAAA,WACA,GAAA9T,UAAAkD,QAAA,EACA,GAAAC,GAAAnD,UAAA,GACAmF,EAAAnF,UAAA,OAEA,IAAAmF,GAAAnF,UAAA,EAGA,IAAAI,SAAArC,KAAAgW,QAAA5O,GACA,SAAA3D,OAAA,4EAAA2D,EAAA,KAGA,IAAA2O,GAAAe,EAAA9W,KAAAoF,EAAAgC,EAAA,cAAApH,KAAA6W,YAOA,OANA7W,MAAAgW,QAAA5O,GAAA2O,EAEA/V,KAAAoR,UAAA/O,SAAArC,KAAAqW,YACAN,EAAA/E,UAAA,GAGA+E,GAIAtU,OAAAC,eAAA1B,KAAA,YACA2B,IAAA,WACA,MAAA3B,MAAAqW,WAEAxU,IAAA,WACA,SAAA4B,OAAA,2CAIAhC,OAAAC,eAAA1B,KAAA,OAEA2B,IAAA,WACA,GAAAqP,GAAAhR,KAAAqW,SACA,OAAAhU,UAAA2O,EAAA3O,OAEA2O,EAAA9M,KAAA,UAMArC,IAAA,SAAAuF,GACA,GAAA/E,SAAA+E,EAAA,CACA,GAAA4J,GAAAhR,KAAAqW,SACAhU,UAAA2O,IACAA,YAAA,OAEa,CACb,GAAA+E,GAAA/V,KAAAgW,QAAA5O,EACA,IAAA/E,SAAA0T,EAAA,SAAAtS,OAAA,yDAAA2D,EAAA,IAEA2O,GAAA/E,UAAA,MAWAhR,KAAAsG,OAAA,WACA,GAAArE,UAAA,YAAAO,OACA,GAAA+D,GAAAtE,UAAA,OAEA,IAAAsE,GAAAtE,SAGA,QAAA2E,GAAA,EAAoBA,EAAAL,EAAApB,OAAmByB,IAAA,CACvC,GAAAC,GAAAN,EAAAK,EAEA,IAAAC,YAAAiQ,GAAA,CACA,GAAAf,GAAAlP,EACAO,EAAAP,EAAAkQ,GAEA,IAAA/W,KAAAgW,QAAA5O,KAAAP,EACA,SAAApD,OAAA,8BAAAmD,EAAA,kCAEa,CACb,GAAAmP,GAAA/V,KAAAgW,QAAAnP,GACAO,EAAAP,CAEA,IAAAxE,SAAA0T,EACA,SAAAtS,OAAA,yDAAA2D,EAAA,KAIA,GAAA4P,GAAAhX,KAAAgR,QACAhR,MAAAgR,WAAA+E,IACA/V,KAAAqW,UAAAhU,QAGArC,KAAAgW,QAAA5O,GAAA6O,MAAA5T,aACArC,MAAAgW,QAAA5O,GAGA,GAAApH,KAAAoR,UAAA/O,SAAArC,KAAAgR,SACA,OAAAlP,KAAA9B,MAAAgW,QAAA,CACAhW,KAAAgW,QAAAlU,GAAAkP,UAAA,CACA,WAESgG,KAAAhX,KAAAgR,UACThR,KAAA6E,KAAA,YAMA,IAAAiS,GAAAnU,EAAAhC,EAAA,SAAA0C,GACArD,KAAAwD,KAAA,cAEAxD,KAAAsD,KAAA,SAAA2T,EAAA7R,EAAAgC,EAAA5D,GACAxD,KAAAyC,QAAAiF,SAAAuB,cAAA,SACA5F,EAAAC,KAAA/C,KAAAP,MAEAA,KAAAoF,QACApF,KAAAiW,MAAAgB,EAEAjX,KAAAkE,KAAA,gBACAlE,KAAAkE,KAAA,OAAAV,GACAxD,KAAA+W,IAAA3P,CAEA,IAAA7D,GAAAvD,IACAA,MAAA2Q,GAAA,qBAAAjM,GACAA,EAAAwS,iBAEA3T,EAAA0S,MAAA7E,SACA7N,EAAAyN,YAAA,IACAzN,EAAAyN,UAAA,GAGAzN,EAAAyN,UAAAzN,EAAAyN,WAGAhR,KAAA2Q,GAAA,iBAAAjM,GACAA,EAAAwS,mBAEAlX,KAAA2Q,GAAA,mBAAAjM,GACA,KAAAA,EAAAyS,SAAA,KAAAzS,EAAAyS,SACAzS,EAAAwS,iBACA3T,EAAA6T,eACa,KAAA1S,EAAAyS,SAAA,KAAAzS,EAAAyS,WACbzS,EAAAwS,iBACA3T,EAAA8T,qBAKA5V,OAAAC,eAAA1B,KAAA,OAEA2B,IAAA,WACA,MAAA3B,MAAAkE,KAAA,UAIArC,IAAA,SAAAuF,GACA,GAAA/E,SAAArC,KAAAiW,MAAAD,QAAA5O,GACA,SAAA3D,OAAA,4EAAA2D,EAAA,KAGA,IAAAkQ,GAAAtX,KAAA+W,GACA/W,MAAAkE,KAAA,QAAAkD,GACA/E,SAAAiV,SAAAtX,MAAAiW,MAAAD,QAAAsB,GACAtX,KAAAiW,MAAAD,QAAA5O,GAAApH,QAKAyB,OAAAC,eAAA1B,KAAA,YAEA2B,IAAA,WACA,MAAA3B,MAAAyC,QAAAsO,SAIAlP,IAAA,SAAAuF,GACA,GAAAmQ,GAAAnQ,KAAA,CACA,IAAApH,KAAAgR,WAAA5J,EAAA,CAEA,GAAAmQ,EAAA,CACA,GAAAC,GAAAxX,KAAAiW,MAAAjF,QACAoF,GAAApW,KAAAiW,MAAAjW,MACAqC,SAAAmV,GACAA,EAAA3S,KAAA,cACa,CACb,GAAA7E,KAAAiW,MAAA7E,SAAA,SAAA3N,OAAA,mDACAzD,MAAAyC,QAAAsO,SAAA,EACA/Q,KAAAiW,MAAAI,UAAAhU,OAEArC,KAAA6E,KAAA,UACA7E,KAAAiW,MAAApR,KAAA,cAIA7E,KAAAoX,WAAA,WACAtB,EAAA9V,KAAA,IAEAA,KAAAqX,eAAA,WACAvB,EAAA9V,KAAA,QXkpDM,SAASH,EAAQD,EAASM,GYt3DhC,GAAAS,GAAAT,EAAA,GACAyC,EAAAzC,EAAA,IAEAuX,EAAAvX,EAAA,GAGAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,KAAA,SAEAxD,KAAAyX,SAEAzX,KAAAsD,KAAA,WACA,GAAArB,UAAA,YAAAR,QACA,GAAAiW,GAAAzV,UAAA,OAEA,IAAAmD,GAAAnD,UAAA,GACAyV,EAAAzV,UAAA,EAGAjC,MAAAyC,QAAAiF,SAAAuB,cAAA,UACA5F,EAAAC,KAAA/C,KAAAP,MACAA,KAAAoF,QAEApF,KAAA0X,UAEA,QAAAtQ,KAAAsQ,GACA1X,KAAA2X,OAAAvQ,EAAAsQ,EAAAtQ,KAOA3F,OAAAC,eAAA1B,KAAA,OAEA2B,IAAA,WACA,OAAAyF,KAAApH,MAAA0X,QACA,GAAA1X,KAAA0X,QAAAtQ,GAAA4J,SACA,MAAA5J,IAKAvF,IAAA,SAAAuF,GACA,GAAAuQ,GAAA3X,KAAA0X,QAAAtQ,EACA,IAAA/E,SAAAsV,EAAA,SAAAlU,OAAA,qDAAA2D,EAAA,IACAuQ,GAAA3G,UAAA,KAIAhR,KAAA2X,OAAA,WACA,OAAA1V,UAAAkD,OACA,GAAAiC,GAAAnF,UAAA,GACAiT,EAAAjT,UAAA,OACS,QAAAA,UAAAkD,OAKT,SAAA1B,OAAA,8BAJA,IAAA2B,GAAAnD,UAAA,GACAmF,EAAAnF,UAAA,GACAiT,EAAAjT,UAAA,GAKA,GAAA2V,GAAAH,EAAArS,EAAAgC,EAAA8N,EAGA,OAFAlV,MAAAsC,IAAAsV,GAEAA,GAKA5X,KAAAsF,MAAA,SAAAC,GACA,GAAAhC,GAAAvD,KAEA6X,EAAAlX,EAAA8E,wBAAAzD,MAAAhC,KAAAiC,UAGA4V,GAAAC,QAAA,SAAAH,GACA,GAAAtV,SAAAkB,EAAAmU,QAAAC,EAAAZ,KACA,SAAAtT,OAAA,yEAAAkU,EAAAZ,IAAA,QAIA1T,EAAAiC,MAAA/E,KAAAP,KAAAuF,EAAAsS,EAGA,IAAAE,IAAA,CACAF,GAAAC,QAAA,SAAAH,GACAA,EAAA3G,WAAA+G,GAAA,GACAxU,EAAAmU,QAAAC,EAAAZ,KAAAY,EAKAA,EAAAhH,GAAA,uBACAgH,EAAA5T,OAAAgT,IAAAY,EAAAZ,QAIAgB,GACA/X,KAAA6E,KAAA,WAKA7E,KAAAsG,OAAA,WACA,GAAA/C,GAAAvD,KAEAgY,EAAArX,EAAA6F,yBAAAxE,MAAAhC,KAAAiC,WACAsE,EAAAyR,EAAA5O,IAAA,SAAA7D,GACA,MAAAhC,GAAAhB,SAAAgD,IAGAlC,GAAAiD,OAAA/F,KAAAP,KAAAgY,EAGA,IAAAC,IAAA,CACA1R,GAAAuR,QAAA,SAAAH,GACAA,EAAA3G,WAAAiH,GAAA,SACA1U,GAAAmU,QAAAC,EAAAZ,OAGAkB,GAEAjY,KAAA6E,KAAA,WAOA7E,KAAAkY,sBAAA,SAAAhC,GACA,GAAA9O,GAAA8O,EAAA,EAEA,QAAAiC,KAAAnY,MAAA0X,QACA,GAAAS,IAAA/Q,EAAA,CACA,GAAAuQ,GAAA3X,KAAA0X,QAAAS,EACAR,GAAA3G,YAAA,GACA2G,EAAAS,kBAAA,QZm4DM,SAASvY,EAAQD,EAASM,Gaz9DhC,QAAAmY,GAAA9U,EAAA+U,EAAAC,GACA,GAAAC,GAAAF,EAAAtW,MAAAK,OAAAkW,EAEA,OADAhV,GAAAjB,IAAAkW,GACAA,EAzDA,GAAA7V,GAAAzC,EAAA,IAEAS,EAAAT,EAAA,GACAU,EAAAV,EAAA,GAEAuY,EAAAvY,EAAA,IACAwY,EAAAxY,EAAA,IACAyY,EAAAzY,EAAA,GAEAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,KAAA,QAEAxD,KAAA2V,aAAA/U,GACAgY,cAAA,IAGA5Y,KAAA0Y,MACA1Y,KAAAyY,SACAzY,KAAA2Y,OAKA3Y,KAAAsD,KAAA,WACA,GAAArB,UAAA,YAAAO,OACA,GAAAqW,GAAA5W,UAAA,OAEA,IAAAmD,GAAAnD,UAAA,GACA4W,EAAA5W,UAAA,EAOA,IAJAjC,KAAAyC,QAAAiF,SAAAuB,cAAA,SACA5F,EAAAC,KAAA/C,KAAAP,MACAA,KAAAoF,QAEA/C,SAAAwW,EACA,OAAAjS,GAAA,EAAwBA,EAAAiS,EAAA1T,OAAoByB,IAC5C5G,KAAAwY,IAAAK,EAAAjS,KAKA5G,KAAA8Y,OAAA,WACA,MAAAT,GAAArY,KAAAyY,EAAAxW,YAGAjC,KAAAwY,IAAA,WACA,MAAAH,GAAArY,KAAA0Y,EAAAzW,eb6hEM,SAASpC,EAAQD,EAASM,Gc/kEhC,GAAAS,GAAAT,EAAA,GACAyC,EAAAzC,EAAA,GAEAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,KAAA,WAEAxD,KAAAsD,KAAA,SAAA8B,GACApF,KAAAyC,QAAAiF,SAAAuB,cAAA,YACA5F,EAAAC,KAAA/C,KAAAP,MACAA,KAAAoF,SAOA3D,OAAAC,eAAA1B,KAAA,OAEA2B,IAAA,WACA,MAAA3B,MAAAyC,QAAA2E,OAIAvF,IAAA,SAAAuF,GACApH,KAAA+W,MAAA3P,IAEApH,KAAAyC,QAAA2E,QACApH,KAAA6E,KAAA,iBdylEM,SAAShF,EAAQD,EAASM,GevnEhC,GAAAS,GAAAT,EAAA,GACAyC,EAAAzC,EAAA,IAEA6C,EAAA7C,EAAA,GAEAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,KAAA,YAEAxD,KAAAsD,KAAA,WACA,OAAArB,UAAAkD,OACA,GAAA4T,GAAA9W,UAAA,OACS,IAAAA,UAAAkD,OAAA,EACT,GAAAC,GAAAnD,UAAA,GACA8W,EAAA9W,UAAA,EAGAjC,MAAAyC,QAAAiF,SAAAuB,cAAA,SACA5F,EAAAC,KAAA/C,KAAAP,MAEAA,KAAAoF,QACApF,KAAAyC,QAAA2B,UAAA,QACArB,EAAAoE,aAAAnH,KAAAyC,QAAA,eACAsW,GACAhW,EAAAoE,aAAAnH,KAAAyC,QAAA,oBAMAhB,OAAAC,eAAA1B,KAAA,OAEA2B,IAAA,WACA,MAAA3B,MAAAyC,QAAA2E,OAIAvF,IAAA,SAAAuF,GACApH,KAAA+W,MAAA3P,IAEApH,KAAAyC,QAAA2E,QACApH,KAAA6E,KAAA,iBfkoEM,SAAShF,EAAQD,EAASM,GgB7qEhC,GAAAS,GAAAT,EAAA,GACAyC,EAAAzC,EAAA,IACAU,EAAAV,EAAA,EAEAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,KAAA,OAEAxD,KAAA2V,aAAA/U,GACAoY,WAAA,QAGAhZ,KAAAsD,KAAA,WACA,OAAArB,UAAAkD,OACA,GAAA+P,GAAAjT,UAAA,OAEA,IAAAmD,GAAAnD,UAAA,GACAiT,EAAAjT,UAAA,EAGAI,UAAA6S,MAAA,IAEA7R,EAAAC,KAAA/C,KAAAP,KAEA,IAAAuD,GAAAvD,IAEAA,MAAAoF,QACApF,KAAAkV,OAEAlV,KAAA2Q,GAAA,iBAAAsI,GACA,GAAAC,IAA6BC,QAAAF,EAAAG,WAAAC,YAAAC,QAAA/V,EAAA+V,QAC7B/V,GAAA+V,QAAAJ,EAAAC,UAIAnZ,KAAA2Q,GAAA,gBAAAsI,GACA,GAAAC,IAA6BC,QAAAF,EAAAG,WAAAC,YAAAC,QAAA/V,EAAAgW,UAC7BhW,GAAAgW,UAAAL,EAAAC,WAOA1X,OAAAC,eAAA1B,KAAA,QACA2B,IAAA,WACA,MAAA3B,MAAAyC,QAAA4W,aACSxX,IAAA,SAAAC,GACT9B,KAAAyC,QAAA+W,UAAA1X,QhBurEM,SAASjC,GiBluEf,GAAAuO,GAAA,WAMA,QAAAqL,GAAAC,GAGA,OAFAC,GAAAD,EAAAE,UAAAF,EAAAC,UACAE,KACAnU,EAAA,EAAuBA,EAAAiU,EAAAxU,OAAkBO,IAAA,CAEzC,GAAAoU,GAAAC,EAAAJ,EAAAjU,GAAAoU,aACAD,GAAAC,KACAD,EAAAC,OAEAD,EAAAC,GAAAzV,MACAqV,QACAnU,MAAAG,EACA4B,MAAAqS,EAAAjU,GAAA4B,QAGA,MAAAuS,GAGA,QAAAG,GAAAN,EAAAvN,GACA,GAAAwN,GAAAD,EAAAE,UAAAF,EAAAC,UACAE,IAEA1N,KAAA8N,aACA,QAAAvU,GAAA,EAAuBA,EAAAiU,EAAAxU,OAAkBO,IAAA,CACzC,GAAAoU,GAAAH,EAAAjU,GAAAoU,cAEAA,MAAA3N,GAAA2N,GAAAI,EAAA/N,IAAA2N,GAAAK,EAAAhO,IACA0N,EAAAxV,MACAqV,QACAnU,MAAAG,EACA4B,MAAAqS,EAAAjU,GAAA4B,QAIA,MAAAuS,GAGA,QAAAO,GAAAV,EAAAvN,GACA,GAAAwN,GAAAD,EAAAE,UAAAF,EAAAC,UACApU,EAAAoU,EAAAxU,OACAkV,EAAAC,EAAAZ,EAAAvN,EAAAwN,EAAApU,EAMA,OAJA8U,IACAE,EAAAb,EAAAvN,EAAA5G,IAIAmU,QACAnU,QACA+B,MAAAqS,EAAApU,GAAA+B,OAIA,QAAAiT,GAAAb,EAAAvN,EAAA5G,GACAmU,EAAAc,WACAd,EAAAc,WAAArO,EAAA,OAA6C5G,GAE7CmU,EAAAU,QAAAjO,EAAA,KAAA5G,GAKA,QAAA+U,GAAAZ,EAAAvN,EAAAwN,EAAApU,GACA,GAAAkV,GACAC,CAEA,IAAAC,EAAAC,KAAAzO,GACAsO,EAAAtO,EACAuO,EAAAG,EAAA1O,OACS,KAAA2O,EAAAF,KAAAzO,GAIT,QAHAsO,GAAAV,EAAA5N,GACAuO,EAAAvO,EAgBA,MAXA4O,KAEAR,EAAAb,EAAAe,EAAAlV,GACAoU,EAAAxU,QAAAI,IACAwV,GAAA,IAGAA,GACAR,EAAAb,EAAAgB,EAAAnV,IAGA,EAGA,QAAAwU,GAAA5N,GACA,MAAAA,GAAA6O,QAAAF,EAAA,SAAAnP,EAAAsP,EAAAC,EAAAC,GACA,MAAAF,GAAA,KAAAE,IAIA,QAAAN,GAAA1O,GACA,MAAAA,GAAA6O,QAAAL,EAAA,SAAAhP,EAAAsP,EAAAC,GACA,UAAAA,IAIA,QAAAE,GAAAC,GACA,GAAA3B,GAAA2B,EAAA3B,KACAA,GAAA4B,WACA5B,EAAA4B,WAAAD,EAAA9V,OACSmU,EAAA0B,YACT1B,EAAA0B,WAAAC,EAAA9V,OAIA,QAAAgW,GAAAC,EAAAlG,GACA,OAAA5L,KAAA4L,GACAA,EAAAmG,eAAA/R,KAEA8R,EAAA9R,GAAA4L,EAAA5L,GAEA,OAAA8R,GAGA,QAAAE,GAAA/B,GAEA,OADAgC,MACAjW,EAAA,EAAuBA,EAAAiU,EAAAxU,OAAkBO,IACzC6V,EAAAI,EAAAC,EAAAjC,EAAAjU,GAAA4B,OAEA,OAAAqU,GAGA,QAAAC,GAAAtU,GAEA,OADAuU,MACAnW,EAAA,EAAuBA,EAAA4B,EAAAnC,OAAkBO,IACzCmW,EAAAvU,EAAA5B,IAAA4B,EAAAwU,EAAAxU,EAAA5B,IAEA,OAAAmW,GAKA,QAAA3B,GAAA/N,GAIA,IAHA,GAAA4P,GAAA,GACAC,EAAA,EAEA,OAAArQ,MAAAsQ,EAAArB,KAAAzO,KACA,KAAAR,MAAA,IAEAoQ,GAAA5P,EAAA+P,UAAAF,EAAArQ,MAAApG,OACAwW,GAAA5P,EAAAgB,OAAAxB,MAAApG,MAAAoG,MAAA,GAAAxG,OAAAwG,MAAA,GAAAxG,QACA4W,GAAA5P,EAAAgB,OAAAxB,MAAApG,MAAAoG,MAAA,GAAAxG,QACA6W,EAAArQ,MAAApG,MAAAoG,MAAA,GAAAxG,MAIA,OAFA4W,IAAA5P,EAAAgB,OAAA6O,GAMA,QAAA7B,GAAAhO,GACA,MAAAwO,GAAAC,KAAAzO,GACA0O,EAAA1O,GAEAA,EAGA,QAAAgQ,GAAAd,EAAAe,GACA,OAAA1S,KAAA0S,GAAA,CACA,GAAAhV,GAAAgV,EAAA1S,GACA2S,EAAAjV,EAAAf,QAAA,cAGAgV,GAAA/T,MAAAgV,eAAA5S,GACA2S,EAAA,EACAhB,EAAA/T,MAAAiV,YAAA7S,EAAAtC,EAAA+F,OAAA,EAAAkP,GAAA,aAEAhB,EAAA/T,MAAAiV,YAAA7S,EAAAtC,IAKA,QAAA0U,GAAAU,GACA,MAAAA,GAAAxB,QAAA,qBAAArP,EAAA8Q,GACA,MAAAA,GAAAC,gBAIA,QAAAC,GAAAC,GACA,GAAAC,KACA,QAAAnT,KAAAkT,GACAC,EAAAC,EAAApT,IAAAkT,EAAAlT,EAEA,OAAAmT,GAGA,QAAAC,GAAAN,GACA,MAAAA,GAAAxB,QAAA,oBAAArP,EAAA8Q,GACA,UAAAA,EAAAxC,gBAvMA,GAGAc,GAHAkB,EAAA,0CACAtB,EAAA,uDACAG,EAAA,4DAyMAiC,EAAA,SAAAC,GACAhd,KAAAgd,MACAhd,KAAAid,KAAAjd,KAAAgd,IAAAC,MAAAjd,KAAAgd,IAAAE,qBAAA,WACAld,KAAAmd,OAAAnd,KAAAgd,IAAAI,gBAGAL,GAAAhY,WAEApD,IAAA,SAAAwK,GACA,IAAAnM,KAAAkO,aACA,QAEA,IAAA/B,EACA,MAAAuP,GAAA1B,EAAAha,KAAAkO,aAAA/B,GAEA,IAAAwN,GAAAF,EAAAzZ,KAAAkO,aACA,KAAA/B,IAAAwN,GACAA,EAAAxN,GAAAuP,EAAA/B,EAAAxN,GAEA,OAAAwN,IAGA0D,OAAA,SAAAlR,GAEA,OADAiQ,MACA1W,EAAA,EAA2BA,EAAA1F,KAAAmd,OAAAhY,OAAwBO,IACnD6V,EAAAa,EAAAV,EAAA1B,EAAAha,KAAAmd,OAAAzX,GAAAyG,IAEA,OAAAiQ,IAGAva,IAAA,SAAAsK,EAAAiQ,GACApc,KAAAkO,eACAlO,KAAAkO,aAAAlO,KAAAmO,gBAEAiO,EAAAO,EAAAP,EACA,IAAAzC,GAAAK,EAAAha,KAAAkO,aAAA/B,EACAwN,GAAAxU,SACAwU,GAAAS,EAAApa,KAAAkO,aAAA/B,IAEA,QAAAzG,GAAA,EAA2BA,EAAAiU,EAAAxU,OAAkBO,IAC7CyW,EAAAxC,EAAAjU,GAAA0W,IAIA9V,OAAA,SAAA6F,GACA,GAAAnM,KAAAkO,aAAA,CAEA,IAAA/B,EAGA,MAFAnM,MAAAsd,aAAAtd,KAAAkO,yBACAlO,MAAAkO,YAIA,QADAyL,GAAAK,EAAAha,KAAAkO,aAAA/B,GACAzG,EAAA,EAA2BA,EAAAiU,EAAAxU,OAAkBO,IAC7C0V,EAAAzB,EAAAjU,GAEA,OAAAiU,GAAAxU,SAEAgJ,aAAA,WACA,GAAAoP,GAAAvd,KAAAgd,IAAA/T,cAAA,QAIA,OAHAsU,GAAA7H,KAAA,WACA6H,EAAAC,IAAA,aACAxd,KAAAid,KAAAnX,YAAAyX,GACAA,EAAA7D,OAEA4D,aAAA,SAAA5D,GACA,GAAA/T,GAAA+T,EAAA+D,SACA9X,GAAA2F,WAAAxE,YAAAnB,IAIA,IAAA/F,GAAA,GAAAmd,GAAArV,SAIA,OAHA9H,GAAAqO,YAAA,SAAA+O,GACA,UAAAD,GAAAC,IAEApd,IAGA,oBAAAC,MAAAD,UAAAC,EAAAD,QAAAwO,IjB+uEM,SAASvO,EAAQD,EAASM,GkB7+EhC,QAAAwd,GAAAC,EAAAC,GACA,GAAAC,GAAAF,EAAA,GACAG,EAAAH,EAAA,EAEA,QAAAjU,KAAAoU,GACArc,OAAAga,eAAAlb,KAAAud,EAAApU,KACAkU,GAAAC,EAAAnU,YAAAjI,SAAAqc,EAAApU,YAAAjI,QACAic,GAAAG,EAAAnU,GAAAoU,EAAApU,KAAA,GAEAmU,EAAAnU,GAAAoU,EAAApU,GAKA,IAAAiU,EAAAxY,OAAA,GACA,GAAA4Y,IAAAF,GAAA/Y,OAAA6Y,EAAA3Y,MAAA,GACA,OAAA0Y,GAAAK,EAAAH,GAEA,MAAAC,GAIA,QAAAG,GAAAtX,GACA,MAAAlE,OAAAuC,UAAAC,MAAAzE,KAAAmG,EAAA,GAxDA,IAMA4D,IANApK,EAAA,IAMAN,EAAA0K,MAAA,WACA,MAAAoT,GAAAM,EAAA/b,YAAA,IAKArC,GAAAqe,UAAA,WACA,MAAAP,GAAAM,EAAA/b,YAAA,IAIArC,EAAAse,kBAAA,SAAAxX,EAAAC,GACA,GAAAwX,KAGA,OAFA7T,GAAA6T,EAAAzX,GACA4D,EAAA6T,EAAAxX,GACAwX,GAIAve,EAAAwD,WAAA,SAAAgb,GACA,GAAAnT,KAIA,OAHAmT,GAAAtG,QAAA,SAAAhW,GACAmJ,EAAAnJ,IAAA,IAEAmJ,IlBkjFM,SAASpL,EAAQD,EAASM,GmBh9EhC,QAAAme,GAAAjT,EAAA9D,GAEA8D,EAAAkT,kBADAjc,SAAAiF,GAAAjF,SAAAiF,EAAAsH,MACAtH,EAAAsH,MAAAxD,GAEA/I,OAIA,QAAAkc,GAAAnT,GACA,GAAA1C,GAAA0C,EAAA1C,YACA,IAAArG,SAAAqG,GAAArG,SAAAqG,EAAAkG,MAAA,CACA,GAAAvM,SAAAqG,EAAAmG,KACA,SAAApL,OAAA,wFAEAiF,GAAAmG,KAAAzD,IAAAkT,oBAKA,QAAAE,GAAApT,EAAA9D,GACA,GAAAoB,GAAA0C,EAAA1C,YACArG,UAAAqG,IACA0C,EAAA3I,QAAA2B,UAAAgH,EAAA3I,QAAA2B,UAAA4W,QAAA,GAAAyD,QAAA,QAAA/V,EAAAtE,UAAA,YAEA/B,SAAAiF,IACA8D,EAAA3I,QAAA2B,UAAAkD,EAAAlD,UAAA,IAAAgH,EAAA3I,QAAA2B,UAAAsa,QAIA,QAAAC,GAAAhJ,GACA,KAAAA,YAAA/U,IACA,SAAA6C,OAAA,+CACK,IACLpB,SAAAsT,EAAA/G,OAAAvM,SAAAsT,EAAA9G,MACApN,OAAAkJ,KAAAgL,EAAArN,mBAAAnD,OAAA,GAAA1D,OAAAkJ,KAAAgL,EAAAnH,eAAArJ,OAAA,EAGA,SAAA1B,OAAA,iIArKA,GAAAqK,GAAA5N,EAAA,IAEAU,EAAAV,EAAA,GACA4C,EAAA5C,EAAA,GAEAN,GAAA+D,gBAAA,GAAAmK,EAIA,IAAA5H,GAAAtG,EAAAsG,kBAAA,SAAAhD,EAAA+E,GACA,OAAArB,GAAA,EAAgBA,EAAA1D,EAAAiC,OAAqByB,IAAA,CACrC,GAAAnG,GAAAyC,EAAA0D,EAGA,IAAAvE,SAAA5B,EAAAsH,OACA,GAAA1F,SAAA4F,EACAC,EAAAzH,EAAA4B;IACa,CACb,GAAAuc,GAAAzW,EAAAF,EAAAxH,EACA4B,UAAAuc,GACA1W,EAAAzH,EAAAme,GAMA,GAAAC,EACAxc,UAAA5B,EAAAsH,OACA8W,EAAApe,EAAAsH,OAAApG,IAAAlB,GACS4B,SAAA4F,IACT4W,EAAA1W,EAAAF,EAAAxH,GACA4B,SAAAwc,IACAA,IAAAld,IAAAlB,KAMAA,EAAAwF,iBAFA5D,SAAAwc,EACAxc,SAAA4F,EACAI,EAAAJ,EAAA4W,EAAAvW,mBAEAuW,EAAAvW,kBAGAL,EAGA/B,EAAAzF,EAAA8B,SAAA9B,EAAAwF,oBAMAkC,EAAAvI,EAAAuI,qBAAA,SAAAF,EAAA6W,GAEA,IADA,GAAAlb,GAAAkb,EAAAlb,YACAvB,SAAAuB,GAAA,CACA,GAAA0D,GAAAW,EAAArE,EAAAJ,KACA,IAAAnB,SAAAiF,EACA,MAAAA,EAEA1D,KAAAG,SAOAsE,EAAAzI,EAAAyI,oBAAA,SAAA0W,EAAAC,GACA,GAAAC,GAAAre,EAAA8T,eAAA/S,KAAAod,EAAAC,GAMA,OALA3c,UAAA4c,IACAA,EAAAnc,EAAAob,kBAAAa,EAAAC,GACApe,EAAA8T,eAAA7S,KAAAkd,EAAAC,GAAAC,IAGAA,GAIA/W,EAAAtI,EAAAsI,gBAAA,SAAAkD,EAAA9D,GACA,GAAAA,IAAA8D,EAAA1C,aAAA,CAEA,GAAArG,SAAAiF,EACA,GAAAc,GAAAd,EAAA3F,IAAAyJ,OAEA,IAAAhD,GAAAd,CAEAkX,GAAApT,EAAAhD,GACAmW,EAAAnT,GACAA,EAAA1C,aAAAN,EACAiW,EAAAjT,EAAAhD,IAIAxI,GAAAiE,wBAAA,SAAAN,GACAlB,SAAAkB,EAAAoS,cACAgJ,EAAApb,EAAAoS,aAMA,KAFA,GAAAuJ,MACAC,EAAA5b,EAAAK,YACAvB,SAAA8c,GACA9c,SAAA8c,EAAAxJ,cACAuJ,EAAA7a,KAAA8a,EAAAxJ,cAEAwJ,IAAApb,MAIA,IAAAqb,KASA,IARAF,EAAAtU,UAAAkN,QAAA,SAAAxQ,GACA,OAAAyD,KAAAzD,GAAAmF,iBAAA,CACA3J,EAAAwH,MAAA8U,EAAA9X,EAAAmF,iBAAA1B,GACA,UAKAtJ,OAAAkJ,KAAAyU,GAAAja,OAAA,EACA,GAAAzB,GAAA9C,EAAAwe,GAAwDC,WAAA,QAExD,IAAA3b,IAAA,CAGA,OADA9D,GAAA+D,gBAAA9B,IAAA0B,EAAAK,YAAAF,GACAA,InBooFM,SAAS7D,EAAQD,EAASM,GoBhoFhC,QAAAof,GAAA/b,EAAAgc,EAAA7a,GACA8a,EAAAjc,EAAAgc,GAAA7a,MACA8a,EAAAjc,EAAAkc,EAAAF,IAAA7a,GAMA,QAAA8a,GAAAE,EAAAhb,GACA,GAAArC,SAAAqd,EACA,OAAA9Y,GAAA,EAAoBA,EAAA8Y,EAAAva,OAAsByB,IAC1C8Y,EAAA9Y,GAAAlC,GAKA,QAAAib,GAAApc,EAAAgc,EAAA7a,EAAAmE,GAOA,GANAnE,YAAAiK,YAEA9F,EAAAnE,EACAA,EAAArC,QAGAA,SAAAqC,GAAArC,SAAAwG,EAAA,CACA,GAAA6W,GAAAnc,EAAAgc,GAAA7a,EACArC,UAAAqd,IACAA,EAAAnc,EAAAgc,GAAA7a,OAGAgb,EAAArb,KAAAwE,OAEAtF,GAAAkc,EAAAF,IAAAlb,KAAAwE,GAIA,QAAA+W,GAAArc,EAAAgc,EAAA7a,EAAAmE,GAOA,GANAnE,YAAAiK,YAEA9F,EAAAnE,EACAA,EAAArC,QAGAA,SAAAqC,GAAArC,SAAAwG,EACAgX,EAAAtc,EAAAgc,GAAA7a,GAAAmE,OACK,IAAAxG,SAAAqC,QACLnB,GAAAgc,GAAA7a,OACK,IAAArC,SAAAwG,EAAA,CACL,GAAAiX,GAAAL,EAAAF,EACAM,GAAAtc,EAAAuc,GAAAjX,OACK,CACL,GAAAiX,GAAAL,EAAAF,EACAhc,GAAAgc,MACAhc,EAAAuc,OAIA,QAAAL,GAAAF,GACA,uBAAAA,EACA,kBACA,kBAAAA,EACA,mBADA,OAIA,QAAAM,GAAAE,EAAAlX,GACA,GAAAtD,GAAAwa,EAAA1Z,QAAAwC,EACAkX,GAAAna,OAAAL,EAAA,GAlMA,GAAAqR,GAAA1W,EAAA,IAAA0W,aACAjU,EAAAzC,EAAA,IACA4C,EAAA5C,EAAA,GAEAL,GAAAD,QAAA+C,EAAAiU,EAAA,SAAAvT,GAEArD,KAAAsD,KAAA,WACAD,EAAArB,MAAAhC,KAAAiC,WAEAjC,KAAAwE,gBACAxE,KAAAggB,iBACAhgB,KAAAigB,mBACAjgB,KAAAkgB,qBASAlgB,KAAAyE,KAAA,SAAAC,EAAAmE,GACA,GAAAnE,YAAAiK,UAAA,CACA9F,EAAAnE,CACA,QAAAyb,KAAAngB,MAAAogB,QACApgB,KAAAqgB,UAAAF,GAAAhb,OAAA,GACA0D,EAAAsX,OAGSngB,MAAAqgB,UAAA3b,GAAAS,OAAA,GACT0D,EAAAnE,EAGAib,GAAA3f,KAAA,eAAA0E,EAAAmE,IAQA7I,KAAAsgB,WAAA,SAAA5b,EAAAmE,GACA+W,EAAA5f,KAAA,eAAA0E,EAAAmE,IAQA7I,KAAAiF,MAAA,SAAAP,EAAAmE,GACA8W,EAAA3f,KAAA,gBAAA0E,EAAAmE,IAQA7I,KAAAugB,YAAA,SAAA7b,EAAAmE,GACA+W,EAAA5f,KAAA,gBAAA0E,EAAAmE,IAOA7I,KAAAwgB,MAAA,SAAAC,EAAA/I,GAEA,GADArV,SAAAqV,UACArV,SAAAqV,EAAAgJ,OACA,GAAAA,GAAA5d,EAAAM,WAAAsU,EAAAgJ,QACAC,EAAA,SAAAjc,GAA2C,QAAAA,IAAAgc,SAClC,IAAAre,SAAAqV,EAAAkJ,KACT,GAAAA,GAAA9d,EAAAM,WAAAsU,EAAAkJ,MACAD,EAAA,SAAAjc,GAA2C,MAAAA,KAAAkc,QAE3C,IAAAD,GAAA,WAAsC,SAGtC,IAAAE,GAAAtd,EAAAvD,IACAA,MAAAyE,KAAA,SAAAC,GACAic,EAAAjc,IACA+b,EAAA9P,GAAAjM,EAAAmc,EAAA,WACAtd,EAAAsB,KAAA7C,MAAAuB,GAAAmB,GAAAI,OAAAtC,MAAAuC,UAAAC,MAAAzE,KAAA0B,iBAIAjC,KAAAiF,MAAA,SAAAP,GACAic,EAAAjc,IACA+b,EAAA3P,IAAApM,EAAAmc,MAIA7gB,KAAA2Q,GAAA3Q,KAAA8gB,YAAA,SAAApc,GACA,GAAAqc,GAAA,IAAA/gB,KAAAqgB,UAAA3b,GAAAS,MACA9B,GAAA0B,UAAA4L,GAAA3O,MAAAhC,KAAAiC,WACA8e,GAAAzB,EAAAtf,KAAA,eAAA0E,IAGA1E,KAAA8Q,IAAA9Q,KAAAmR,eAAA,SAAAzM,GACA,GAAAsc,GAAA,IAAAhhB,KAAAqgB,UAAA3b,GAAAS,MACA9B,GAAA0B,UAAAoM,eAAAnP,MAAAhC,KAAAiC,WACA+e,GAAA1B,EAAAtf,KAAA,gBAAA0E,IAEA1E,KAAAihB,mBAAA,SAAAvc,GACA,GAAAwc,KACA,IAAA7e,SAAAqC,EACA1E,KAAAqgB,UAAA3b,GAAAS,OAAA,GACA+b,EAAA7c,KAAAK,OAGA,QAAAA,KAAA1E,MAAAogB,QACApgB,KAAAqgB,UAAA3b,GAAAS,OAAA,GACA+b,EAAA7c,KAAAK,EAKArB,GAAA0B,UAAAkc,mBAAAjf,MAAAhC,KAAAiC,UAEA,QAAA2E,GAAA,EAAoBA,EAAAsa,EAAA/b,OAAgCyB,IACpD0Y,EAAAtf,KAAA,gBAAAkhB,EAAAta,QpBi1FM,SAAS/G,EAAQD,GqB7yFvB,QAAAuhB,GAAAC,EAAAvY,GAGA,IAFA,GAAAlD,GAAA0b,GAAAD,GAEAzb,EAAA0b,EAAAC,OACA,MAAA3b,EAAA4b,UACA,GAAA1Y,EAAAlD,MAAA,EACA,UAGA,KADA,GAAAD,GAAAC,EAAAoB,WAAA5B,OACAO,KACA2b,EAAAhd,KAAAsB,EAAAoB,WAAArB,IAMA,QAAA8b,GAAA7b,EAAA8b,GAGA,OAFAC,GAAA,EACAC,GAAA,EACA/a,EAAA,EAAgB6a,EAAA7a,EAAA8a,GAAA9a,EAAAjB,EAAAR,OAAqDyB,IACrE,yBAAAP,QAAAV,EAAA0T,YAAAzS,IACA+a,EACAD,IAEAC,GAAA,EAEAA,GAAA,CAIA,OAAAD,GAzLA,GAAA/b,GAAA9F,EAAAD,QAAA+F,KAAA,SAAA+P,EAAAtR,EAAAsT,GACA,GAAAkK,GAAAla,SAAAuB,cAAAyM,EAEA,IAAArT,SAAAqV,EAAA,CACA,GAAArV,SAAAqV,EAAAxT,KACA,OAAA8C,KAAA0Q,GAAAxT,KACA2d,gBAAAD,EAAA5a,EAAA0Q,EAAAxT,KAAA8C,GAGA3E,UAAAqV,EAAA2B,cACAuI,EAAAvI,YAAA3B,EAAA2B,aAOA,MAHAhX,UAAA+B,IACAwd,EAAAxd,aAEAwd,EAIA/hB,GAAAD,QAAAoE,IAAA,SAAAI,EAAAsT,GACA,MAAA/R,GAAA,MAAAvB,EAAAsT,GAIA7X,GAAAD,QAAAuH,aAAA,WACA,OAAAlF,UAAAkD,OACA,GAAA1C,GAAAzC,KAAAyC,QACAiT,EAAAzT,UAAA,GACAmF,EAAAnF,UAAA,OACK,QAAAA,UAAAkD,OAKL,SAAA1B,OAAA,gEAJA,IAAAhB,GAAAR,UAAA,GACAyT,EAAAzT,UAAA,GACAmF,EAAAnF,UAAA,GAIA,GAAAiC,GAAAwD,SAAAma,gBAAAnM,EACAxR,GAAAkD,QACA3E,EAAAqf,iBAAA5d,GAOAtE,GAAA6I,kBAAA,SAAAsZ,EAAAnR,EAAAC,GAEA,aAAAkR,EAAAC,UAAA,aAAAD,EAAAC,SACAD,EAAAtZ,kBAAAmI,EAAAC,OACK,CACL,GAAAoR,GAAA,EAAAC,EAAAxa,SAAAya,aACAD,GAAAE,SAAAL,EAAA,GACAG,EAAAG,UAAA,EACA,IAAAC,IAAA,CAEAnB,GAAAY,EAAA,SAAApc,GACA,GAAA+b,GAAAF,EAAA7b,IAAAR,QACAod,EAAAN,EAAAtc,EAAAR,OAAAuc,CAEA,KAAAY,GAAA1R,GAAAqR,GAAAM,GAAA3R,EAAA,CACA,GAAA4R,GAAA5R,EAAAqR,EACAQ,EAAAjB,EAAA7b,EAAA6c,EACAN,GAAAE,SAAAzc,EAAA6c,EAAAC,GACAH,GAAA,EAGA,GAAAA,GAAAzR,GAAAoR,GAAAM,GAAA1R,EAAA,CACA,GAAA2R,GAAA3R,EAAAoR,EACAS,EAAAlB,EAAA7b,EAAA6c,EAEA,OADAN,GAAAS,OAAAhd,EAAA6c,EAAAE,IACA,EAGAT,EAAAM,GAGA,IAAAK,GAAAC,OAAAC,cACAF,GAAAG,kBACAH,EAAAI,SAAAd,KAOAtiB,EAAA2I,kBAAA,SAAA6Y,GAKA,OAHA5Y,GAAAqa,OAAAC,eACAG,EAAA,UAAA7B,EAAAY,UAAA,aAAAZ,EAAAY,SAEApb,EAAA,EAAgBA,EAAA4B,EAAA0a,WAAwBtc,IAAA,CACxC,GAAAsb,GAAA1Z,EAAA2a,WAAA,EACA,KAAAF,EAIS,CACT,GAAAG,GAAAhC,EAAAiC,SAAAnB,EAAAoB,eACA,IAAAF,EACA,GAAAG,GAAAnC,EACAoC,GAAA,MAEA,IAAAD,GAAArB,EAAAuB,wBACAD,GAAA,EACAE,GAAA,CAGA,IAAA9S,GAAAC,EAAA8S,EAAA,CA0BA,OAzBAxC,GAAAoC,EAAA,SAAAK,GACA,GAAAJ,GASiB,IAAAJ,IAAAhC,EAAAiC,SAAAO,GACjB,aAVA,CAKA,GAJAA,IAAA1B,EAAAoB,iBACAI,GAAA,IAGAtC,EAAAiC,SAAAO,KAAAF,EACA,MACAA,KACAF,GAAA,GAQA,MAHAI,KAAA1B,EAAAoB,iBACA1S,EAAA+S,EAAAzB,EAAA2B,YAAArC,EAAAoC,EAAA1B,EAAA2B,cAEAD,IAAA1B,EAAA4B,cACAjT,EAAA8S,EAAAzB,EAAA6B,UAAAvC,EAAAoC,EAAA1B,EAAA6B,YACA,QAGAJ,GAAAC,EAAAze,OAAAqc,EAAAoC,IAAAze,WAGA9C,SAAAuO,GAAA4S,GAGAnhB,SAAAuO,IACAA,EAAA,GAEAvO,SAAAwO,IACAA,EAAA8S,IAGA/S,EAAAC,IATAxO,OAzCA,GAAA6f,EAAA2B,cAAA3B,EAAA6B,WAAA7B,EAAAoB,eAAA/gB,SAAA2f,EAAA2B,eAAAzC,EACA,OAAAA,EAAA4C,eAAA5C,EAAA6C,iBrB0iGM,SAASpkB,EAAQD,EAASM,GsB1oGhC,GAAAS,GAAAT,EAAA,GACAU,EAAAV,EAAA,GACAyC,EAAAzC,EAAA,GAIAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,KAAA,SAEAxD,KAAA2V,aAAA/U,GACA2G,QAAA,UAMAvH,KAAAsD,KAAA,SAAA8B,EAAAgC,EAAA8N,GACAlV,KAAAyC,QAAAiF,SAAAuB,cAAA,UACA5F,EAAAC,KAAA/C,KAAAP,MAEAA,KAAAoF,QAEApF,KAAAkV,OACAlV,KAAA+W,IAAA3P,GAGA3F,OAAAC,eAAA1B,KAAA,OAEA2B,IAAA,WACA,MAAA3B,MAAAkE,KAAA,UAIArC,IAAA,SAAAuF,GACA,GAAA/E,SAAArC,KAAA+D,OAAA,CACA,GAAA1B,SAAArC,KAAA+D,OAAA2T,QAAAtQ,GACA,SAAA3D,OAAA,wFAAA2D,EAAA,KAGA,QAAApH,KAAA+W,WACA/W,MAAA+D,OAAA2T,QAAA1X,KAAA+W,KAGA/W,KAAA+D,OAAA2T,QAAAtQ,GAAApH,KAGAA,KAAAkE,KAAA,QAAAkD,MAMA3F,OAAAC,eAAA1B,KAAA,YAEA2B,IAAA,WACA,MAAA3B,MAAAyC,QAAAuO,UAIAnP,IAAA,SAAAuF,GACA,GAAAmQ,GAAAnQ,KAAA,CACA,OAAApH,MAAAgR,WAAAuG,GAAA,GAEAlV,SAAArC,KAAA+D,QACA/D,KAAA+D,OAAAmU,uBAAAlY,KAAA+W,MAEA/W,KAAAoY,iBAAAb,QAEAlV,SAAArC,KAAA+D,QACA/D,KAAA+D,OAAAc,KAAA,eAIApD,OAAAC,eAAA1B,KAAA,QACA2B,IAAA,WACA,MAAA3B,MAAAyC,QAAA4W,aAGAxX,IAAA,SAAAqT,GACAlV,KAAAyC,QAAA+W,UAAAtE,KAQAlV,KAAAoY,iBAAA,SAAAb,GACAvX,KAAAgR,WAAAuG,IAEAvX,KAAAyC,QAAAuO,SAAAuG,EACAvX,KAAA6E,KAAA,etBopGM,SAAShF,EAAQD,EAASM,GuBpvGhC,GAAAS,GAAAT,EAAA,GACAyC,EAAAzC,EAAA,IACAU,EAAAV,EAAA,EAEAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,KAAA,WAEAxD,KAAA2V,aAAA/U,GACA2G,QAAA,cAKAvH,KAAAsD,KAAA,WACA,GAAArB,UAAAkD,QAAA,EACA,GAAA+e,GAAAjiB,UAAA,OAEA,IAAAmD,GAAAnD,UAAA,GACAiiB,EAAAjiB,UAAA,EAGAjC,MAAAyC,QAAAiF,SAAAuB,cAAA,MACA5F,EAAAC,KAAA/C,KAAAP,MACAA,KAAAoF,QAEA8e,YAAAvjB,GACAX,KAAAsC,IAAA4hB,GACG7hB,SAAA6hB,IACHlkB,KAAAyC,QAAA4W,YAAA6K,OvB8vGM,SAASrkB,EAAQD,EAASM,GwB3xGhC,GAAAikB,GAAAjkB,EAAA,GAEAL,GAAAD,QAAAukB,EAAA,qBxBmyGM,SAAStkB,EAAQD,EAASM,GyBvyGhC,GAAAikB,GAAAjkB,EAAA,GAEAL,GAAAD,QAAAukB,EAAA,kBzB8yGM,SAAStkB,EAAQD,EAASM,G0BhzGhC,GAAAS,GAAAT,EAAA,GACAyC,EAAAzC,EAAA,GAEAL,GAAAD,QAAA+C,EAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,KAAA,YAKAxD,KAAAsD,KAAA,WACA,GAAArB,UAAAkD,QAAA,EACA,GAAA+e,GAAAjiB,UAAA,OAEA,IAAAmD,GAAAnD,UAAA,GACAiiB,EAAAjiB,UAAA,EAGAjC,MAAAyC,QAAAiF,SAAAuB,cAAA,MACA5F,EAAAC,KAAA/C,KAAAP,MACAA,KAAAoF,QAEA8e,YAAAvjB,GACAX,KAAAsC,IAAA4hB,GACG7hB,SAAA6hB,IACHlkB,KAAAyC,QAAA4W,YAAA6K,IAIAlkB,KAAAokB,QAAA,SAAAC,GACArkB,KAAAkE,KAAA,UAAAmgB,O1ByzGM,SAASxkB,G2Bp0Gf,QAAA+W,KACA5W,KAAAogB,QAAApgB,KAAAogB,YACApgB,KAAAskB,cAAAtkB,KAAAskB,eAAAjiB,OAuQA,QAAAkiB,GAAAC,GACA,wBAAAA,GAGA,QAAAC,GAAAD,GACA,sBAAAA,GAGA,QAAAE,GAAAF,GACA,sBAAAA,IAAA,OAAAA,EAGA,QAAAG,GAAAH,GACA,gBAAAA,EAlRA3kB,EAAAD,QAAAgX,EAGAA,iBAEAA,EAAA7R,UAAAqb,QAAA/d,OACAuU,EAAA7R,UAAAuf,cAAAjiB,OAIAuU,EAAAgO,oBAAA,GAIAhO,EAAA7R,UAAA8f,gBAAA,SAAAje,GACA,IAAA6d,EAAA7d,IAAA,EAAAA,GAAAke,MAAAle,GACA,KAAAme,WAAA,8BAEA,OADA/kB,MAAAskB,cAAA1d,EACA5G,MAGA4W,EAAA7R,UAAAF,KAAA,SAAA6Q,GACA,GAAAsP,GAAAnE,EAAAoE,EAAA1M,EAAA7S,EAAA2a,CAMA,IAJArgB,KAAAogB,UACApgB,KAAAogB,YAGA,UAAA1K,KACA1V,KAAAogB,QAAA8E,OACAR,EAAA1kB,KAAAogB,QAAA8E,SAAAllB,KAAAogB,QAAA8E,MAAA/f,QAAA,CAEA,GADA6f,EAAA/iB,UAAA,GACA+iB,YAAAvhB,OACA,KAAAuhB,EAEA,MAAAD,WAAA,wCAMA,GAFAlE,EAAA7gB,KAAAogB,QAAA1K,GAEAiP,EAAA9D,GACA,QAEA,IAAA0D,EAAA1D,GACA,OAAA5e,UAAAkD,QAEA,OACA0b,EAAAtgB,KAAAP,KACA,MACA,QACA6gB,EAAAtgB,KAAAP,KAAAiC,UAAA,GACA,MACA,QACA4e,EAAAtgB,KAAAP,KAAAiC,UAAA,GAAAA,UAAA,GACA,MAEA,SAGA,IAFAgjB,EAAAhjB,UAAAkD,OACAoT,EAAA,GAAA/V,OAAAyiB,EAAA,GACAvf,EAAA,EAAmBuf,EAAAvf,EAASA,IAC5B6S,EAAA7S,EAAA,GAAAzD,UAAAyD,EACAmb,GAAA7e,MAAAhC,KAAAuY,OAEG,IAAAmM,EAAA7D,GAAA,CAGH,IAFAoE,EAAAhjB,UAAAkD,OACAoT,EAAA,GAAA/V,OAAAyiB,EAAA,GACAvf,EAAA,EAAeuf,EAAAvf,EAASA,IACxB6S,EAAA7S,EAAA,GAAAzD,UAAAyD,EAIA,KAFA2a,EAAAQ,EAAA7b,QACAigB,EAAA5E,EAAAlb,OACAO,EAAA,EAAeuf,EAAAvf,EAASA,IACxB2a,EAAA3a,GAAA1D,MAAAhC,KAAAuY,GAGA,UAGA3B,EAAA7R,UAAA+b,YAAA,SAAApL,EAAAxE,GACA,GAAA1Q,EAEA,KAAA+jB,EAAArT,GACA,KAAA6T,WAAA,8BAuBA,IArBA/kB,KAAAogB,UACApgB,KAAAogB,YAIApgB,KAAAogB,QAAA+E,aACAnlB,KAAA6E,KAAA,cAAA6Q,EACA6O,EAAArT,YACAA,cAEAlR,KAAAogB,QAAA1K,GAGAgP,EAAA1kB,KAAAogB,QAAA1K,IAEA1V,KAAAogB,QAAA1K,GAAArR,KAAA6M,GAGAlR,KAAAogB,QAAA1K,IAAA1V,KAAAogB,QAAA1K,GAAAxE,GANAlR,KAAAogB,QAAA1K,GAAAxE,EASAwT,EAAA1kB,KAAAogB,QAAA1K,MAAA1V,KAAAogB,QAAA1K,GAAA0P,OAAA,CACA,GAAA5kB,EAIAA,GAHAmkB,EAAA3kB,KAAAskB,eAGA1N,EAAAgO,oBAFA5kB,KAAAskB,cAKA9jB,KAAA,GAAAR,KAAAogB,QAAA1K,GAAAvQ,OAAA3E,IACAR,KAAAogB,QAAA1K,GAAA0P,QAAA,EACAC,QAAAH,MAAA,mIAGAllB,KAAAogB,QAAA1K,GAAAvQ,QACA,kBAAAkgB,SAAAC,OAEAD,QAAAC,SAKA,MAAAtlB,OAGA4W,EAAA7R,UAAA4L,GAAAiG,EAAA7R,UAAA+b,YAEAlK,EAAA7R,UAAAwgB,KAAA,SAAA7P,EAAAxE,GAMA,QAAAsU,KACAxlB,KAAAmR,eAAAuE,EAAA8P,GAEAC,IACAA,GAAA,EACAvU,EAAAlP,MAAAhC,KAAAiC,YAVA,IAAAsiB,EAAArT,GACA,KAAA6T,WAAA,8BAEA,IAAAU,IAAA,CAcA,OAHAD,GAAAtU,WACAlR,KAAA2Q,GAAA+E,EAAA8P,GAEAxlB,MAIA4W,EAAA7R,UAAAoM,eAAA,SAAAuE,EAAAxE,GACA,GAAA6O,GAAAtM,EAAAtO,EAAAO,CAEA,KAAA6e,EAAArT,GACA,KAAA6T,WAAA,8BAEA,KAAA/kB,KAAAogB,UAAApgB,KAAAogB,QAAA1K,GACA,MAAA1V,KAMA,IAJA+f,EAAA/f,KAAAogB,QAAA1K,GACAvQ,EAAA4a,EAAA5a,OACAsO,EAAA,GAEAsM,IAAA7O,GACAqT,EAAAxE,EAAA7O,WAAA6O,EAAA7O,mBACAlR,MAAAogB,QAAA1K,GACA1V,KAAAogB,QAAAjP,gBACAnR,KAAA6E,KAAA,iBAAA6Q,EAAAxE,OAEG,IAAAwT,EAAA3E,GAAA,CACH,IAAAra,EAAAP,EAAoBO,IAAA,GACpB,GAAAqa,EAAAra,KAAAwL,GACA6O,EAAAra,GAAAwL,UAAA6O,EAAAra,GAAAwL,aAAA,CACAuC,EAAA/N,CACA,OAIA,KAAA+N,EACA,MAAAzT,KAEA,KAAA+f,EAAA5a,QACA4a,EAAA5a,OAAA,QACAnF,MAAAogB,QAAA1K,IAEAqK,EAAAna,OAAA6N,EAAA,GAGAzT,KAAAogB,QAAAjP,gBACAnR,KAAA6E,KAAA,iBAAA6Q,EAAAxE,GAGA,MAAAlR,OAGA4W,EAAA7R,UAAAkc,mBAAA,SAAAvL,GACA,GAAAhM,GAAA2W,CAEA,KAAArgB,KAAAogB,QACA,MAAApgB,KAGA,KAAAA,KAAAogB,QAAAjP,eAKA,MAJA,KAAAlP,UAAAkD,OACAnF,KAAAogB,WACApgB,KAAAogB,QAAA1K,UACA1V,MAAAogB,QAAA1K,GACA1V,IAIA,QAAAiC,UAAAkD,OAAA,CACA,IAAAuE,IAAA1J,MAAAogB,QACA,mBAAA1W,GACA1J,KAAAihB,mBAAAvX,EAIA,OAFA1J,MAAAihB,mBAAA,kBACAjhB,KAAAogB,WACApgB,KAKA,GAFAqgB,EAAArgB,KAAAogB,QAAA1K,GAEA6O,EAAAlE,GACArgB,KAAAmR,eAAAuE,EAAA2K,OAGA,MAAAA,EAAAlb,QACAnF,KAAAmR,eAAAuE,EAAA2K,IAAAlb,OAAA,GAIA,cAFAnF,MAAAogB,QAAA1K,GAEA1V,MAGA4W,EAAA7R,UAAAsb,UAAA,SAAA3K,GACA,GAAAgQ,EAOA,OAHAA,GAHA1lB,KAAAogB,SAAApgB,KAAAogB,QAAA1K,GAEA6O,EAAAvkB,KAAAogB,QAAA1K,KACA1V,KAAAogB,QAAA1K,IAEA1V,KAAAogB,QAAA1K,GAAA1Q,YAIA4R,EAAA+O,cAAA,SAAAlF,EAAA/K,GACA,GAAAgQ,EAOA,OAHAA,GAHAjF,EAAAL,SAAAK,EAAAL,QAAA1K,GAEA6O,EAAA9D,EAAAL,QAAA1K,IACA,EAEA+K,EAAAL,QAAA1K,GAAAvQ,OAJA,I3Bs3GM,SAAStF,EAAQD,G4B5oHvB,GAAAgmB,GAAAC,EAAAC,GAOA,SAAAnmB,GAGAkmB,KAAAD,EAAA,EAAAE,EAAA,kBAAAF,KAAA5jB,MAAApC,EAAAimB,GAAAD,IAAAvjB,SAAAyjB,IAAAjmB,EAAAD,QAAAkmB,KAQC,WAED,QAAAhY,GAAAiY,GAEA,OADA/lB,KAAAgmB,QACA/jB,UAAAkD,QACA,YACA,QAAAnF,KAAAimB,KAAAF,EAA4B,MAC5B,SAAAG,EAAAlmB,KAAAiC,YA0IA,QAAAikB,GAAA9c,EAAAmP,GACA,OAAA7S,GAAA,EAAiBA,EAAA6S,EAAApT,OAAiBO,GAAA,EAClC0D,EAAAvH,IAAA0W,EAAA7S,GAAA6S,EAAA7S,EAAA,IAIA,QAAAygB,GAAAC,GACA,kBAEA,MADAA,GAAApkB,MAAAhC,KAAAiC,WACAjC,MAIA,QAAAqmB,GAAAC,EAAAC,GAEA9kB,OAAAC,gBACAD,OAAAC,eAAA4kB,EAAAC,GAAqCC,YAAA,IAtJrC,GAAA7jB,GAAAmL,EAAA/I,WACAnB,YAAAkK,EAEAnM,IAAA,SAAA+H,GACA,GAAAuP,GAAAjZ,KAAAymB,MAAAzmB,KAAA0mB,KAAAhd,GACA,OAAAuP,MAAA,IAGApX,IAAA,SAAA6H,EAAAtC,GAEApH,KAAAymB,MAAAzmB,KAAA0mB,KAAAhd,OAAAtC,IAGA8e,MAAA,WACAA,EAAAlmB,KAAAiC,YAGAgkB,KAAA,SAAAF,GACA,OAAArc,KAAAqc,GAAAU,MACAzmB,KAAAymB,MAAA/c,GAAAqc,EAAAU,MAAA/c,IAIAid,IAAA,SAAAjd,GACA,MAAA1J,MAAA0mB,KAAAhd,IAAA1J,MAAAymB,OAGAG,OAAA,SAAAxf,GACA,OAAAsC,KAAA1J,MAAAymB,MACA,GAAAzmB,KAAAymB,MAAA/c,GAAA,KAAAtC,EACA,MAAApH,MAAAymB,MAAA/c,GAAA,EAIA,cAGApD,OAAA,SAAAoD,SACA1J,MAAAymB,MAAAzmB,KAAA0mB,KAAAhd,KAGAgM,KAAA,SAAAhM,GACA,GAAA8S,GAAA/a,OAAAsD,UAAAmH,SAAA3L,KAAAmJ,GACAgM,EAAA8G,EAAAxX,MAAA,MAAAiV,aAEA,qBAAAvE,GAAAhM,EAGAgM,EAFAhM,EAAA,IAKAiB,KAAA,WACA,GAAAA,KAEA,OADA3K,MAAA8X,QAAA,SAAA1Q,EAAAsC,GAAsCiB,EAAAtG,KAAAqF,KACtCiB,GAGAuL,OAAA,WACA,GAAAA,KAEA,OADAlW,MAAA8X,QAAA,SAAA1Q,GAAiC8O,EAAA7R,KAAA+C,KACjC8O,GAGA2Q,MAAA,WACA,MAAA7mB,MAAA2K,OAAAxF,QAGA6gB,MAAA,WAEAhmB,KAAAymB,UAGAK,MAAA,WACA,UAAAhZ,GAAA9N,OAGA0mB,KAAA,SAAAhd,GACA,OAAA1J,KAAA0V,KAAAhM,IACA,gBACA,WACA,cACA,aACA,aACA,MAAAA,GAAA,EAEA,YACA,UAAAA,EAAAqd,SAEA,cACA,UAAArd,CAEA,aAEA,OADAsd,MACAthB,EAAA,EAAoBA,EAAAgE,EAAAvE,OAAgBO,IACpCshB,EAAAthB,GAAA1F,KAAA0mB,KAAAhd,EAAAhE,GACA,WAAAshB,EAAAziB,KAAA,IAEA,cACA,QAOA,MALAmF,GAAAud,UACAvd,EAAAud,UAAAnZ,EAAAoZ,IACAb,EAAA3c,EAAA,YAGA,IAAcA,EAAAud,UAIdnP,QAAA,SAAAqP,GACA,OAAAzd,KAAA1J,MAAAymB,MAAA,CACA,GAAAxN,GAAAjZ,KAAAymB,MAAA/c,EACAyd,GAAA5mB,KAAAP,KAAAiZ,EAAA,GAAAA,EAAA,MAKAnL,GAAAoZ,IAAA,CAIA,QAAAE,KAAAzkB,GAEA,mBAAAykB,GAAAzkB,EAAA8Y,eAAA2L,GAAA,CAGA,GAAAhB,GAAAzjB,EAAAykB,EACA,MAAAhB,EAAAla,WAAA7F,QAAA,aACA1D,EAAAykB,GAAAjB,EAAAC,IA0BA,MAAAtY,M5BqpHM,SAASjO,G6Bz0HfA,EAAAD,QAAA,SAAAynB,GAIA,OAHA9O,GAAA/V,MAAAuC,UAAAC,MAAAzE,KAAA8mB,EAAA,GAEAR,EAAA,EACAjgB,EAAA2R,EAAApT,OAAA,EAA4ByB,GAAA,GAC5BvE,SAAAkW,EAAA3R,GADkCA,IAElCigB,GAKA,OADAtO,GAAA3S,OAAA2S,EAAApT,OAAA0hB,KACAtO,I7Bm1HM,SAAS1Y,EAAQD,EAASM,G8B3wHhC,QAAAonB,GAAAC,GAKA,MAJAA,aAAA/kB,SACA+kB,IAAArb,WAAAtC,MAAA,MAGA2d,EAGA,QAAAC,GAAAC,EAAAC,GAEA,OADAC,GAAAF,EACA7gB,EAAA,EAAgBA,EAAA8gB,EAAAviB,OAAA,EAAyByB,IACzC+gB,IAAAD,EAAA9gB,GAGA,QAAY0f,IAAAqB,EAAAje,IAAAge,EAAA9gB,IA8GZ,QAAAghB,GAAArkB,EAAAmkB,EAAAtgB,EAAAsQ,GACA,GAAAmQ,GAAAL,EAAAjkB,EAAAkkB,QAAAC,GAEAI,EAAA1gB,CACAsQ,GAAAqQ,SAAA,IACA3gB,IAAAqgB,SAGAI,EAAAvB,IAAAuB,EAAAne,KAAAtC,CAEA,IAAA1C,IAAiBgR,KAAA,MAAA6R,SAAAG,EACjBrlB,UAAAqV,EAAArX,KAAAqE,EAAArE,GAAAqX,EAAArX,IACAkD,EAAAsB,KAAA,SAAAH,GAEArC,SAAAqV,EAAAqQ,OACAC,EAAAzkB,EAAAukB,EAAAJ,EAAAhQ,EAAAqQ,OAGA,QAAAE,GAAA1kB,EAAAmkB,EAAAnP,EAAAb,GACA,GAAA0G,GAAA8J,EAAA3kB,EAAAkkB,QAAAC,GACAS,EAAA/J,EAAAjZ,MACAiZ,GAAA/Z,KAAArC,MAAAoc,EAAA7F,EAEA,IAAA6P,GAAAC,EAAAjK,EAAA+J,EAAA5P,EAAApT,OAAAuS,EAAAqQ,OAEArjB,GAAiBgR,KAAA,QAAA6R,SAAAG,EAAAniB,MAAA4iB,EAAAtB,MAAA,EACjBxkB,UAAAqV,EAAArX,KAAAqE,EAAArE,GAAAqX,EAAArX,IACAkD,EAAAsB,KAAA,SAAAH,GAEA4jB,EAAA/kB,EAAA6kB,EAAAV,EAAAhQ,EAAAqQ,OAGA,QAAAQ,GAAAhlB,EAAAmkB,EAAAnP,EAAAb,GACA,GAAAnS,GAAAgT,EAAA,GACAiQ,EAAAjQ,EAAA,GAEA6F,EAAA8J,EAAA3kB,EAAAkkB,QAAAC,GACAzc,EAAAmT,EAAAxY,OAAA5D,MAAAoc,EAAA7F,EAEA,IAAAiQ,EAAA,GACA,GAAA9jB,IAAqBgR,KAAA,UAAA6R,SAAAG,EAAAniB,QAAAkjB,QAAAxd,EACrB5I,UAAAqV,EAAArX,KAAAqE,EAAArE,GAAAqX,EAAArX,IACAkD,EAAAsB,KAAA,SAAAH,GAEA,GAAA6T,EAAApT,OAAA,GACA,GAAAT,IAAqBgR,KAAA,QAAA6R,SAAAG,EAAAniB,QAAAshB,MAAAtO,EAAApT,OAAA,GAErBijB,EAAAC,EAAAjK,EAAA7Y,EAAAb,EAAAmiB,MAAAnP,EAAAqQ,MAEA1lB,UAAAqV,EAAArX,KAAAqE,EAAArE,GAAAqX,EAAArX,IACAkD,EAAAsB,KAAA,SAAAH,GAEA4jB,EAAA/kB,EAAA6kB,EAAAV,EAAAhQ,EAAAqQ,OAGA,MAAA9c,GAIA,QAAAyd,GAAAnlB,EAAAmkB,EAAAnP,EAAAb,GACA,GAAAiR,GAAApQ,EAAA,EACA,QAAAoQ,EAAAxjB,OAAA,CAEA,GAAAiZ,GAAA8J,EAAA3kB,EAAAkkB,QAAAC,GACAS,EAAA/J,EAAAjZ,OAEAyjB,GAAAT,EAAA,EACAS,KAAA9jB,OAAA6jB,EACA,IAAAE,GAAAzK,EAAAjZ,MACAiZ,GAAAxY,OAAA5D,MAAAoc,EAAAwK,EAEA,IAAAR,GAAAC,EAAAjK,EAAAyK,EAAAzK,EAAAjZ,OAAAuS,EAAAqQ,OAEArjB,GAAiBgR,KAAA,QAAA6R,SAAAG,EAAAniB,MAAA4iB,EAAAtB,MAAA8B,EAAAxjB,OACjB9C,UAAAqV,EAAArX,KAAAqE,EAAArE,GAAAqX,EAAArX,IACAkD,EAAAsB,KAAA,SAAAH,GAEA4jB,EAAA/kB,EAAA6kB,EAAAV,EAAAhQ,EAAAqQ,QAKA,QAAAM,GAAAjK,EAAAxN,EAAAiW,EAAAkB,GACA,GAAAK,KACA,IAAA/lB,SAAA0lB,EAEA,OADAe,GAAAlY,EAAAiW,EACAjgB,EAAAgK,EAAwBkY,EAAAliB,EAAYA,IACpCwhB,EAAA/jB,MAAoCiiB,IAAAlI,EAAAxX,GAAArB,MAAAqB,IACpCmhB,KAAA,IACA3J,EAAAxX,GAAAwX,EAAAxX,GAAA6gB,QAIA,OAAAW,GAKA,QAAAE,GAAA/kB,EAAA6kB,EAAAV,EAAArF,GACA,OAAAzb,GAAA,EAAgBA,EAAAwhB,EAAAjjB,OAA4ByB,IAC5CohB,EAAAzkB,EAAA6kB,EAAAxhB,GAAA0f,IAAAoB,EAAA5iB,OAAAsjB,EAAAxhB,GAAArB,OAAA8c,GAWA,QAAA2F,GAAAzkB,EAAAwlB,EAAArB,EAAArF,GACA,GAAA2G,GAAAtB,EAAAviB,MAEA,IAAA9C,SAAA0mB,EAAApY,IAAAtO,SAAA0mB,EAAAlkB,MAAAxC,SAAA0mB,EAAA5X,gBAAA9O,SAAA0mB,EAAAlnB,IACA,SAAA4B,OAAA,qDAGA,IAAAwlB,GAAAC,EACAC,KAAAC,IACAL,GAAApY,GAAA,SAAAsY,EAAA,SAAAI,GACA,QAAAD,EAAA/iB,QAAAgjB,GAAA,CACA,GAAAhH,EACA,GAAAkF,GAAAG,EAAA5iB,OAAAukB,EAAA9B,cAEA,IAAAA,GAAAG,EAAA5iB,QAAA,YAAAA,OAAAukB,EAAA9B,SAGA,IAAA+B,GAAAxmB,EAAAwH,SAAgD+e,GAAW9B,YAC3D4B,GAAA9kB,KAAAilB,GACA/lB,EAAAsB,KAAA,SAAAykB,MAGA/lB,EAAAoN,GAAA,SAAAuY,EAAA,SAAAG,GACA,GAAAE,GAAAF,EAAA9B,SAAApiB,OAEAqkB,EAAAC,EAAA/B,EAAA2B,GACAK,EAAAF,EAAAG,SACAC,EAAAJ,EAAAK,aAEA,IAAAH,GAAA,KAAAP,EAAA9iB,QAAAgjB,GAAA,CACA,GAAAhH,EACA,GAAAkF,GAAA8B,EAAA9B,SAAAviB,MAAAgkB,OAEA,IAAAzB,GAAA8B,EAAA9B,SAAAviB,MAAAgkB,EAAA,EAGA,IAAAc,GAAAhnB,EAAAwH,SAAmD+e,GAAW9B,YAC9D6B,GAAA/kB,KAAAylB,GACAf,EAAAlkB,KAAA,SAAAilB,OACS,IAAAF,EACT,WAAAP,EAAA3T,KACAqU,QACa,gBAAAV,EAAA3T,KAAA,CACb,GAAAsU,GAAAtC,EAAA2B,EAAA9B,SAAApiB,QACA8kB,EAAAZ,EAAA9jB,OAAAykB,MAAAX,EAAA9jB,MAAA8jB,EAAAZ,QAAAtjB,OAAA,EACA+kB,EAAAb,EAAA9jB,MAAA8jB,EAAAZ,QAAAtjB,OAAA,EAAA6kB,IAEAC,IAAAjB,EAAA,GAAAO,EACAQ,IACiBG,IACjBxC,EAAA2B,EAAA9B,SAAApiB,QAAA6kB,EAAAX,EAAAZ,QAAAtjB,YAEa,cAAAkkB,EAAA3T,KAAA,CACb,GAAAsU,GAAAtC,EAAA2B,EAAA9B,SAAApiB,OACAkkB,GAAA9jB,MAAAykB,IACAtC,EAAA2B,EAAA9B,SAAApiB,QAAA6kB,EAAAX,EAAAxC,SAMA,IAAAkD,GAAA,WACAhB,EAAA5X,eAAA,SAAA8X,GACA1lB,EAAA4N,eAAA,SAAA+X,IAUA,QAAAO,GAAA/B,EAAA2B,GAKA,OAJAL,GAAAtB,EAAAviB,OAEAukB,GAAA,EACAE,GAAA,EACAhjB,EAAA,EAAgBoiB,EAAApiB,EAAqBA,IACrCyiB,EAAA9B,SAAA3gB,KAAA8gB,EAAA9gB,KACA8iB,GAAA,EACA9iB,EAAAyiB,EAAA9B,SAAApiB,SACAykB,GAAA,GAWA,OANAP,GAAA9B,SAAApiB,QAAA6jB,EACAU,GAAA,EAEAE,GAAA,GAGYC,cAAAD,EAAAD,SAAAD,GA9ZZ,GAAA/mB,GAAAzC,EAAA,IACA0W,EAAA1W,EAAA,IAAA0W,aACA9T,EAAA5C,EAAA,IAqGAgoB,GA7FAroB,EAAAD,QAAA+C,EAAAiU,EAAA,WAIA5W,KAAAsD,KAAA,SAAAgjB,GACAtmB,KAAAynB,QAAAnB,EAEAtmB,KAAA6kB,gBAAA,MAOA7kB,KAAA2B,IAAA,SAAA4lB,GACA,MAAA4C,GAAAnqB,KAAAsnB,EAAAC,KAMAvnB,KAAA6B,IAAA,SAAA0lB,EAAAngB,GACAwgB,EAAA5nB,KAAAsnB,EAAAC,GAAAngB,OAIApH,KAAAqE,KAAA,WACA4jB,EAAAjoB,QAAAiC,eAOAjC,KAAA4F,OAAA,WACA,MAAA2iB,GAAAvoB,QAAAiC,eAIAjC,KAAAoqB,OAAA,WACA1B,EAAA1oB,QAAAiC,eAGAjC,KAAAK,GAAA,SAAAA,GACA,MAAA8pB,GAAAnqB,SAAwCK,QAcxCL,KAAA+nB,MAAA,SAAA1F,GAEA,MADAhgB,UAAAggB,OAAA,GACA8H,EAAAnqB,SAAwC+nB,MAAA1F,OAiCxCxiB,EAAAD,QAAAsoB,iBAAA,SAAAT,EAAAF,GACA,GAAAM,GAAAL,EAAAC,EAAAF,EACA,OAAAllB,UAAAwlB,EAAAne,IACAme,EAAAvB,IAAAuB,EAAAne,KAEAme,EAAAvB,MAQA6D,EAAAxnB,EAAAiU,EAAA,WAEA5W,KAAAsD,KAAA,SAAAS,EAAA2jB,EAAAhQ,GACA1X,KAAA0X,QAAArV,SAAAqV,KACAA,EAGA1X,KAAAqqB,gBADAhoB,SAAA0B,EAAAsmB,gBACAtmB,EAAAsmB,gBAEAtmB,EAEA/D,KAAAunB,SAAAG,EACA1nB,KAAAynB,QAAAS,EAAAnkB,EAAA0jB,QAAAC,EAEA,IAAAnkB,GAAAvD,IACA+D,GAAA4M,GAAA,kBAAA0Y,GACA,GAAAG,GAAAC,EAAAlmB,EAAAgkB,SAAA8B,EAEA,IAAAG,EAAAG,SACApmB,EAAAsB,KAAA,UAAqC6Q,KAAA2T,EAAA3T,KAAA6R,SAAA8B,EAAA9B,SAAAviB,MAAAzB,EAAAgkB,SAAApiB,QAAAI,MAAA8jB,EAAA9jB,MAAAshB,MAAAwC,EAAAxC,MAAA4B,QAAAY,EAAAZ,cACxB,IAAAe,EAAAK,cACb,eAAAR,EAAA3T,KAAA,CACA,GAAAsU,GAAAzmB,EAAAgkB,SAAA8B,EAAA9B,SAAApiB,QACAmlB,EAAAjB,EAAA9jB,MAAA8jB,EAAAZ,QAAAtjB,OAAA,EAAA6kB,CAEAM,KACA/mB,EAAAgkB,SAAA8B,EAAA9B,SAAApiB,QAAA6kB,EAAAX,EAAAZ,QAAAtjB,YAEiB,cAAAkkB,EAAA3T,KAAA,CACjB,GAAAsU,GAAAzmB,EAAAgkB,SAAA8B,EAAA9B,SAAApiB,OACAkkB,GAAA9jB,MAAAykB,IACAzmB,EAAAgkB,SAAA8B,EAAA9B,SAAApiB,QAAA6kB,EAAAX,EAAAxC,WAOA7mB,KAAA2B,IAAA,SAAA4lB,GACA,MAAAvnB,MAAAqqB,gBAAA1oB,IAAA3B,KAAAunB,SAAAziB,OAAAwiB,EAAAC,MAGAvnB,KAAA6B,IAAA,SAAA0lB,EAAAngB,GACAwgB,EAAA5nB,KAAAqqB,gBAAArqB,KAAAunB,SAAAziB,OAAAwiB,EAAAC,IAAAngB,EAAApH,KAAA0X,UAGA1X,KAAAqE,KAAA,WACA4jB,EAAAjoB,KAAAqqB,gBAAArqB,KAAAunB,SAAAtlB,UAAAjC,KAAA0X,UAGA1X,KAAA4F,OAAA,WACA2iB,EAAAvoB,KAAAqqB,gBAAArqB,KAAAunB,SAAAtlB,UAAAjC,KAAA0X,UAGA1X,KAAAoqB,OAAA,WACA1B,EAAA1oB,KAAAqqB,gBAAArqB,KAAAunB,SAAAtlB,UAAAjC,KAAA0X,UAGA1X,KAAAK,GAAA,SAAAA,GACA,MAAA8pB,GAAAnqB,UAAAunB,SAAAzkB,EAAAwH,SAAgEtK,KAAA0X,SAAiBrX,SAIjFL,KAAA+nB,MAAA,SAAA1F,GAEA,MADAhgB,UAAAggB,OAAA,GACA8H,EAAAnqB,QAAA8C,EAAAwH,SAAqDtK,KAAA0X,SAAiBqQ,MAAA1F,S9BilIhE,SAASxiB,G+BtwIf,YAMA,SAAA8C,KACA,GAAA4V,GAAAtW,SAEA,OAAAsW,EAAApT,OACA,GAAApB,IAAsBT,KAAAinB,GACtBC,EAAAjS,EAAA,OAGA,IAAAxU,GAAAwU,EAAA,GACAiS,EAAAjS,EAAA,EAIA,IAAAkS,KACA,OAAAhnB,MAAAinB,UAAAC,WAAAC,eAAAC,YAAA9F,UAAA+F,UAAAzkB,QAAAtC,KACAA,EAAAgnB,EAAAhnB,EAAA0mB,GAIA,IAAAO,GAAA,oBAEAR,GAAAS,GADAD,EACAjnB,EAAAknB,GAEAlnB,CAIA,IAAAgB,GAAA,GAAAylB,GAAAzmB,EACA0mB,GAAAjnB,KAAAuB,EAAAvB,MAGAuB,EAAAzB,IAAA0nB,IACAjmB,EAAAzB,GAAA,WACAS,EAAA/B,MAAAhC,KAAAiC,YAKA,IAAAipB,GAAA,YACAA,GAAAD,GAAAlmB,CAEA,IAAAomB,GAAApmB,EAAAvB,KAAAuB,EAAAvB,KAAA,EACA,IAAAuB,EAAAzB,KAAAjB,GAAA0C,EAAAzB,KAAAinB,EACA,GAAAa,GAAA,GAAAzc,UAAA,IACA,mBAAAwc,EAAA,sBAGAD,OAGA,IAAAE,GAAA,GAAAzc,UAAA,gBACA,mBAAAwc,EAAA,8GASAD,EAAAnmB,EAAAzB,GAAAX,EAAA0oB,GAGAtmB,GAAAnB,YAAAwnB,CAGA,QAAAxkB,KAAA7B,GACAumB,EAAAF,EAAArmB,EAAA6B,EAIA,QAAAA,KAAA7C,GACAwnB,EAAAhrB,KAAAwD,EAAA6C,IAAAwkB,EAAAxkB,KAAAvE,GACAipB,EAAAF,EAAArnB,EAAA6C,EAOA,OAHAwkB,GAAArnB,SACAqnB,EAAAH,GAAAlmB,EAEAqmB,EAOA,QAAAL,GAAAS,EAAAf,GACA,QAAAgB,KACA,GAAAC,GAAA,GAAAF,GAAAvpB,UAAA,GAcA,OAbAypB,GAAAloB,KAAAinB,EAAAjnB,KAEAxD,KAAA2rB,QAAAD,EAAAC,QACAlqB,OAAAC,eACAD,OAAAC,eAAA1B,KAAA,SACA2B,IAAA,WACA,MAAA+pB,GAAAE,SAIA5rB,KAAA4rB,MAAAF,EAAAE,MAGA5rB,KAGA,GAAA6rB,GAAA,YAIA,OAHAA,GAAA9mB,UAAAymB,EAAAzmB,UACA0mB,EAAA1mB,UAAA,GAAA8mB,GAEAJ,EAGA,QAAAH,GAAAQ,EAAA/mB,EAAAwiB,GACA,IACA,GAAAjY,GAAA7N,OAAAsqB,yBAAAhnB,EAAAwiB,EACAjY,GAAA3N,MAAAU,GAAAiN,EAAA3N,MAAAU,GAAAZ,OAAAC,iBAAAW,EACAZ,OAAAC,eAAAoqB,EAAAvE,EAAAjY,GAEAwc,EAAAvE,GAAAxiB,EAAAwiB,GAEK,MAAAyE,KA5HL,GAEA3pB,GAFAkoB,EAAA,aAEAU,EAAA,YAAAI,EAAA,YAAA/nB,EAAA,OAAAioB,KAAkG9P,cAoFlG9Y,GAAA0oB,MAEAxrB,EAAAD,QAAA+C,G/BmzIM,SAAS9C,EAAQD,EAASM,GgC94IhC,GAAAyC,GAAAzC,EAAA,IAEAS,EAAAT,EAAA,GACAU,EAAAV,EAAA,GACAyY,EAAAzY,EAAA,GAKAL,GAAAD,QAAA,SAAAqsB,EAAAzoB,GACA,MAAAb,GAAAhC,EAAA,SAAA0C,GAIArD,KAAAwD,OAEAxD,KAAA2V,aAAA/U,GACA2G,QAAA,cAMAvH,KAAAsD,KAAA,WACA,GAAArB,UAAA,YAAAO,OACA,GAAA0pB,GAAAjqB,UAAA,OAEA,IAAAmD,GAAAnD,UAAA,GACAiqB,EAAAjqB,UAAA,EAOA,IAJAjC,KAAAyC,QAAAiF,SAAAuB,cAAAgjB,GACA5oB,EAAAC,KAAA/C,KAAAP,MACAA,KAAAoF,QAEA/C,SAAA6pB,EACA,OAAAtlB,GAAA,EAA4BA,EAAAslB,EAAA/mB,OAAkByB,IAC9C5G,KAAAmsB,KAAAD,EAAAtlB,KAKA5G,KAAAmsB,KAAA,WACA,GAAAA,GAAAxT,EAAA3W,MAAAK,OAAAJ,UAEA,OADAjC,MAAAsC,IAAA6pB,GACAA,OhCu5IM,SAAStsB,EAAQD,EAASM,IiCp8IhC,SAAAksB,GAyBA,QAAAC,GAAAxhB,EAAAyhB,GAGA,OADAC,GAAA,EACA7mB,EAAAmF,EAAA1F,OAAA,EAAgCO,GAAA,EAAQA,IAAA,CACxC,GAAA8mB,GAAA3hB,EAAAnF,EACA,OAAA8mB,EACA3hB,EAAAjF,OAAAF,EAAA,GACK,OAAA8mB,GACL3hB,EAAAjF,OAAAF,EAAA,GACA6mB,KACKA,IACL1hB,EAAAjF,OAAAF,EAAA,GACA6mB,KAKA,GAAAD,EACA,KAAUC,IAAMA,EAChB1hB,EAAA4hB,QAAA,KAIA,OAAA5hB,GA+JA,QAAA6hB,GAAAC,EAAAC,GACA,GAAAD,EAAAD,OAAA,MAAAC,GAAAD,OAAAE,EAEA,QADAC,MACAnnB,EAAA,EAAmBA,EAAAinB,EAAAxnB,OAAeO,IAClCknB,EAAAD,EAAAjnB,KAAAinB,IAAAE,EAAAxoB,KAAAsoB,EAAAjnB,GAEA,OAAAmnB,GAhKA,GAAAC,GACA,gEACAC,EAAA,SAAAC,GACA,MAAAF,GAAAlS,KAAAoS,GAAAhoB,MAAA,GAKApF,GAAAqtB,QAAA,WAIA,OAHAC,GAAA,GACAC,GAAA,EAEAznB,EAAAzD,UAAAkD,OAAA,EAAoCO,GAAA,KAAAynB,EAA8BznB,IAAA,CAClE,GAAA0nB,GAAA1nB,GAAA,EAAAzD,UAAAyD,GAAA0mB,EAAAiB,KAGA,oBAAAD,GACA,SAAArI,WAAA,4CACKqI,KAILF,EAAAE,EAAA,IAAAF,EACAC,EAAA,MAAAC,EAAAE,OAAA,IAWA,MAJAJ,GAAAb,EAAAK,EAAAQ,EAAAtjB,MAAA,cAAAlJ,GACA,QAAAA,KACGysB,GAAA5oB,KAAA,MAEH4oB,EAAA,QAAAD,GAAA,KAKAttB,EAAA2tB,UAAA,SAAAH,GACA,GAAAI,GAAA5tB,EAAA4tB,WAAAJ,GACAK,EAAA,MAAAtgB,EAAAigB,EAAA,GAcA,OAXAA,GAAAf,EAAAK,EAAAU,EAAAxjB,MAAA,cAAAlJ,GACA,QAAAA,KACG8sB,GAAAjpB,KAAA,KAEH6oB,GAAAI,IACAJ,EAAA,KAEAA,GAAAK,IACAL,GAAA,MAGAI,EAAA,QAAAJ,GAIAxtB,EAAA4tB,WAAA,SAAAJ,GACA,YAAAA,EAAAE,OAAA,IAIA1tB,EAAA2E,KAAA,WACA,GAAAmpB,GAAAlrB,MAAAuC,UAAAC,MAAAzE,KAAA0B,UAAA,EACA,OAAArC,GAAA2tB,UAAAb,EAAAgB,EAAA,SAAAhtB,GACA,mBAAAA,GACA,SAAAqkB,WAAA,yCAEA,OAAArkB,KACG6D,KAAA,OAMH3E,EAAA+tB,SAAA,SAAAC,EAAAC,GAIA,QAAAnP,GAAAoP,GAEA,IADA,GAAAld,GAAA,EACUA,EAAAkd,EAAA3oB,QACV,KAAA2oB,EAAAld,GAD8BA,KAK9B,IADA,GAAAC,GAAAid,EAAA3oB,OAAA,EACU0L,GAAA,GACV,KAAAid,EAAAjd,GADoBA,KAIpB,MAAAD,GAAAC,KACAid,EAAA9oB,MAAA4L,EAAAC,EAAAD,EAAA,GAfAgd,EAAAhuB,EAAAqtB,QAAAW,GAAAzgB,OAAA,GACA0gB,EAAAjuB,EAAAqtB,QAAAY,GAAA1gB,OAAA,EAsBA,QALA4gB,GAAArP,EAAAkP,EAAAhkB,MAAA,MACAokB,EAAAtP,EAAAmP,EAAAjkB,MAAA,MAEAzE,EAAAsR,KAAAF,IAAAwX,EAAA5oB,OAAA6oB,EAAA7oB,QACA8oB,EAAA9oB,EACAO,EAAA,EAAiBP,EAAAO,EAAYA,IAC7B,GAAAqoB,EAAAroB,KAAAsoB,EAAAtoB,GAAA,CACAuoB,EAAAvoB,CACA,OAKA,OADAwoB,MACAxoB,EAAAuoB,EAA+BvoB,EAAAqoB,EAAA5oB,OAAsBO,IACrDwoB,EAAA7pB,KAAA,KAKA,OAFA6pB,KAAAppB,OAAAkpB,EAAAhpB,MAAAipB,IAEAC,EAAA3pB,KAAA,MAGA3E,EAAAuuB,IAAA,IACAvuB,EAAAwuB,UAAA,IAEAxuB,EAAAyuB,QAAA,SAAAjB,GACA,GAAAniB,GAAA8hB,EAAAK,GACA1tB,EAAAuL,EAAA,GACAqjB,EAAArjB,EAAA,EAEA,OAAAvL,IAAA4uB,GAKAA,IAEAA,IAAAnhB,OAAA,EAAAmhB,EAAAnpB,OAAA,IAGAzF,EAAA4uB,GARA,KAYA1uB,EAAA2uB,SAAA,SAAAnB,EAAAoB,GACA,GAAA5B,GAAAG,EAAAK,GAAA,EAKA,OAHAoB,IAAA5B,EAAAzf,OAAA,GAAAqhB,EAAArpB,UAAAqpB,IACA5B,IAAAzf,OAAA,EAAAyf,EAAAznB,OAAAqpB,EAAArpB,SAEAynB,GAIAhtB,EAAA6uB,QAAA,SAAArB,GACA,MAAAL,GAAAK,GAAA,GAaA,IAAAjgB,GAAA,WAAAA,OAAA,IACA,SAAAqP,EAAA5L,EAAAqU,GAAkC,MAAAzI,GAAArP,OAAAyD,EAAAqU,IAClC,SAAAzI,EAAA5L,EAAAqU,GAEA,MADA,GAAArU,MAAA4L,EAAArX,OAAAyL,GACA4L,EAAArP,OAAAyD,EAAAqU,MjC08I8B1kB,KAAKX,EAASM,EAAoB,MAI1D,SAASL,EAAQD,EAASM,GkCzpJhC,QAAAwd,GAAAC,EAAAC,GACA,GAAAC,GAAAF,EAAA,GACAG,EAAAH,EAAA,EAEA,QAAAjU,KAAAoU,GACArc,OAAAga,eAAAlb,KAAAud,EAAApU,KACAkU,GAAAC,EAAAnU,YAAAjI,SAAAqc,EAAApU,YAAAjI,QACAic,GAAAG,EAAAnU,GAAAoU,EAAApU,KAAA,GAEAmU,EAAAnU,GAAAoU,EAAApU,GAKA,IAAAiU,EAAAxY,OAAA,GACA,GAAA4Y,IAAAF,GAAA/Y,OAAA6Y,EAAA3Y,MAAA,GACA,OAAA0Y,GAAAK,EAAAH,GAEA,MAAAC,GAIA,QAAAG,GAAAtX,GACA,MAAAlE,OAAAuC,UAAAC,MAAAzE,KAAAmG,EAAA,GAvCAxG,EAAA,IAMAN,EAAA0K,MAAA,WACA,MAAAoT,GAAAM,EAAA/b,YAAA,IAKArC,EAAAqe,UAAA,WACA,MAAAP,GAAAM,EAAA/b,YAAA,KlC6sJM,SAASpC,GmCzpJf,QAAA0qB,MAjEA,GAAA6B,GAAAvsB,EAAAD,UAEAwsB,GAAAsC,SAAA,WACA,GAAAC,GAAA,mBAAA9L,SACAA,OAAA+L,aACAC,EAAA,mBAAAhM,SACAA,OAAAvR,iBACAwd,EAAA,mBAAAjM,SACAA,OAAAkM,aAAAlM,OAAAje,gBAGA,IAAA+pB,EACA,gBAAA/B,GAA6B,MAAA/J,QAAA+L,aAAAhC,GAG7B,IAAAoC,KAEA,IAAAH,EAAA,CACA,GAAAI,GAAAvnB,SAAAuB,cAAA,OACAoI,EAAA,GAAAC,kBAAA,WACA,GAAA4d,GAAAF,EAAAhqB,OACAgqB,GAAA7pB,OAAA,EACA+pB,EAAApX,QAAA,SAAAsO,GACAA,OAMA,OAFA/U,GAAAxO,QAAAosB,GAAqC/nB,YAAA,IAErC,SAAAkf,GACA4I,EAAA7pB,QACA8pB,EAAA9nB,aAAA,YAEA6nB,EAAA3qB,KAAA+hB,IAIA,MAAA0I,IACAjM,OAAAje,iBAAA,mBAAAuqB,GACA,GAAAC,GAAAD,EAAAC,MACA,KAAAA,IAAAvM,QAAA,OAAAuM,IAAA,iBAAAD,EAAAlW,OACAkW,EAAAE,kBACAL,EAAA7pB,OAAA,IACA,GAAAihB,GAAA4I,EAAAM,OACAlJ,QAGS,GAET,SAAAA,GACA4I,EAAA3qB,KAAA+hB,GACAvD,OAAAkM,YAAA,sBAIA,SAAA3I,GACAjd,WAAAid,EAAA,OAIAgG,EAAAmD,MAAA,UACAnD,EAAAoD,SAAA,EACApD,EAAAqD,OACArD,EAAAsD,QAIAtD,EAAAzb,GAAA4Z,EACA6B,EAAAtL,YAAAyJ,EACA6B,EAAA7G,KAAAgF,EACA6B,EAAAtb,IAAAyZ,EACA6B,EAAAjb,eAAAoZ,EACA6B,EAAAnL,mBAAAsJ,EACA6B,EAAAvnB,KAAA0lB,EAEA6B,EAAAuD,QAAA,WACA,SAAAlsB,OAAA,qCAIA2oB,EAAAiB,IAAA,WAA2B,WAC3BjB,EAAAwD,MAAA,WACA,SAAAnsB,OAAA","file":"blocks.umd.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"blocks\"] = factory();\n\telse\n\t\troot[\"blocks\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"blocks\"] = factory();\n\telse\n\t\troot[\"blocks\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\texports.Block = __webpack_require__(1)\r\n\texports.Style = __webpack_require__(2)\r\n\t\r\n\texports.Canvas = __webpack_require__(3)\r\n\texports.Container = __webpack_require__(4)\r\n\texports.Button = __webpack_require__(5)\r\n\texports.CheckBox = __webpack_require__(6)\r\n\texports.Image = __webpack_require__(7)\r\n\texports.List = __webpack_require__(8)\r\n\t//exports.MultiSelect = require(\"Components/MultiSelect\") // not ready yet\r\n\texports.Radio = __webpack_require__(9)\r\n\texports.Select = __webpack_require__(10)\r\n\texports.Table = __webpack_require__(11)\r\n\texports.TextArea = __webpack_require__(12)\r\n\texports.TextField = __webpack_require__(13)\r\n\texports.Text = __webpack_require__(14)\r\n\t\r\n\t\r\n\t\r\n\tObject.defineProperty(exports, 'dev', {\r\n\t    get: function() {\r\n\t        return exports.Block.dev\r\n\t    }, set: function(v) {\r\n\t        exports.Block.dev = v\r\n\t    }\r\n\t})\r\n\t\r\n\texports.attach = function(/*component,component,.. or components*/) {\r\n\t    exports.Block.attach.apply(this,arguments)\r\n\t}\r\n\texports.detach = function(/*component,component,.. or components*/) {\r\n\t    exports.Block.detach.apply(this,arguments)\r\n\t}\r\n\t\r\n\texports.createBody = function(callback) {\r\n\t    exports.Block.detach.apply(this,arguments)\r\n\t}\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar EventEmitterB = __webpack_require__(18)\n\tvar proto = __webpack_require__(29);\n\tvar trimArguments = __webpack_require__(27)\n\tvar observe = __webpack_require__(28)\n\t\n\tvar utils = __webpack_require__(16)\n\tvar domUtils = __webpack_require__(19)\n\tvar blockStyleUtils = __webpack_require__(17)\n\t\n\tvar Style = __webpack_require__(2)\n\tStyle.isDev = function() {return module.exports.dev}\n\t\n\tvar components = {};\n\t\n\tvar setOfBrowserEvents = utils.arrayToMap([\n\t    'abort','afterprint','animationend','animationiteration','animationstart','audioprocess','beforeprint','beforeunload',\n\t    'beginEvent','blocked','blur','cached','canplay','canplaythrough','change','chargingchange','chargingtimechange',\n\t    'checking','click','close','compassneedscalibration','complete','compositionend','compositionstart','compositionupdate','contextmenu',\n\t    'copy','cut','dblclick','decivelight','devicemotion','deviceorientation','deviceproximity','dischargingtimechange','DOMContentLoaded',\n\t    'downloading','drag','dragend','dragenter','dragleave','dragover','dragstart','drop','durationchange','emptied','ended','endEvent',\n\t    'error','focus','focusin','focusout','fullscreenchange','fullscreenerror','gamepadconnected','gamepaddisconnected','hashchange',\n\t    'input','invalid','keydown','keypress','keyup','languagechange','levelchange','load','loadeddata','loadedmetadata','loadend',\n\t    'loadstart','message','mousedown','mouseenter','mouseleave','mousemove','mouseout','mouseover','mouseup','noupdate','obsolete',\n\t    'offline','online','open','orientationchange','pagehide','pageshow','paste','pause','pointerlockchange','pointerlockerror','play',\n\t    'playing','popstate','progress','ratechange','readystatechange','repeatEvent','reset','resize','scroll','seeked','seeking','select',\n\t    'show','stalled','storage','submit','success','suspend','SVGAbort','SVGError','SVGLoad','SVGResize','SVGScroll','SVGUnload','SVGZoom',\n\t    'timeout','timeupdate','touchcancel','touchend','touchenter','touchleave','touchmove','touchstart','transitionend','unload',\n\t    'updateready','upgradeneeded','userproximity','versionchange','visibilitychange','volumechange','waiting','wheel'\n\t])\n\t\n\t// events:\n\t    // newParent - emits this when a component gets a new parent\n\t    // parentRemoved - emits this when a component is detached from its parent\n\tvar Block = module.exports = proto(EventEmitterB,function(superclass) {\n\t\n\t    // static properties\n\t\n\t    // constructor\n\t\tthis.init = function() {\n\t        var that = this\n\t\n\t        if(this.name === undefined) {\n\t            throw new Error(\"The 'name' property is required for Blocks\")\n\t        }\n\t\n\t        var defaultBlockStyle = blockStyleUtils.defaultStyleMap.get(this.constructor)\n\t        if(defaultBlockStyle === undefined) {\n\t            defaultBlockStyle = blockStyleUtils.createDefaultBlockStyle(this)\n\t        }\n\t\n\t        superclass.init.call(this)\n\t\n\t        this.children = []\n\t        this.state = observe({})\n\t        this.parent = undefined;\n\t\n\t\t\tif (this.id !== undefined) {\n\t\t\t\tcomponents[this.id] = this;\n\t\t\t}\n\t\n\t        if(this.domNode === undefined) {\n\t            this.domNode = domUtils.div()\n\t        }\n\t\n\t        this.build.apply(this, arguments)\n\t\n\t        //if(module.exports.dev) {\n\t            this.attr('blkName', this.name)\n\t        //}\n\t\n\t        var classList = [this.domNode.className]\n\t        if(defaultBlockStyle !== false) classList.push(defaultBlockStyle.className)\n\t        classList.push(Style.defaultClassName)\n\t        this.domNode.className = classList.join(' ') // note that the order of classes doesn't matter\n\t\n\t        // set up dom event handlers\n\t        var ifonHandlers={}\n\t        that.ifon(function(event) {\n\t            if(event in setOfBrowserEvents && (that.excludeDomEvents === undefined || !(event in that.excludeDomEvents))) {\n\t                that.domNode.addEventListener(event, ifonHandlers[event]=function() {\n\t                    that.emit.apply(that, [event].concat(Array.prototype.slice.call(arguments)))\n\t                })\n\t            }\n\t        })\n\t        that.ifoff(function(event) {\n\t            if(event in setOfBrowserEvents && (that.excludeDomEvents === undefined || !(event in that.excludeDomEvents))) {\n\t                that.domNode.removeEventListener(event,ifonHandlers[event])\n\t            }\n\t        })\n\t\t}\n\t\n\t    // sub-constructor - called by the constructor\n\t    // parameters:\n\t        // label - (Optional) A label that can be used to style a component differently.\n\t                   // Intended to be some string describing what the component is being used for.\n\t                   // Note, tho, that labels are not dynamic - changing the label won't affect styling until a new style is applied to the component)\n\t        // domNode - (Optional) A domNode to be used as the container domNode instead of the default (a div)\n\t    this.build = function(/*[label,] domNode*/) {\n\t        if(arguments.length === 1) {\n\t            this.domNode = arguments[0]\n\t        } else if(arguments.length >= 2) {\n\t            this.label = arguments[0]\n\t            this.domNode = arguments[1]\n\t        }\n\t    }\n\t\t\n\t\n\t\t// instance properties\n\t\n\t\t\n\t\tthis.domNode;\n\t    this.label;\n\t    this.excludeDomEvents;\n\t    this.children;     // a list of child components that are a part of a Block object (these are used so Styles can be propogated down to child components)\n\t\n\t\n\t    Object.defineProperty(this, 'label', {\n\t        get: function() {\n\t            return this._label\n\t        }, set: function(v) {\n\t            if(this._label === undefined) {\n\t                this._label = v\n\t\n\t                if(module.exports.dev) {\n\t                    this.attr('label', this._label)\n\t                }\n\t            } else {\n\t                throw new Error(\"A Block's label can only be set once (was already set to: \"+this._label+\")\")\n\t            }\n\t        }\n\t    })\n\t\n\t    // adds elements to the components main domNode\n\t    // arguments can be one of the following:\n\t        // component, component, component, ...\n\t        // listOfBlocks\n\t    this.add = function() {\n\t        this.addAt.apply(this, [this.domNode.children.length].concat(trimArguments(arguments)))\n\t\t}\n\t\n\t    // adds nodes at a particular index\n\t    // nodes can be one of the following:\n\t        // component, component, component, ...\n\t        // listOfBlocks\n\t    this.addAt = function(index/*, nodes...*/) {\n\t        var nodes = normalizeAddAtArguments.apply(this, arguments)\n\t\n\t        for (var i=0;i<nodes.length;i++) {\n\t\t\t\tvar node = nodes[i];\n\t            this.children.splice(index+i, 0, node)\n\t\n\t            if(!isBlock(node)) {\n\t                throw new Error(\"node is not a Block\")\n\t            }\n\t\n\t            node.parent = undefined\n\t            node.emit('parentRemoved')\n\t\n\t            var beforeChild = this.children[1+i+index]\n\t            if(beforeChild === undefined) {\n\t                this.domNode.appendChild(node.domNode)\n\t            } else {\n\t                this.domNode.insertBefore(node.domNode, beforeChild.domNode)\n\t            }\n\t\n\t            node.parent = this;\n\t            node.emit('newParent')\n\t\n\t            // apply styles\n\t            //if(itsaBlock) { // its always a component now\n\t                var that = this\n\t                node.getParentStyleMap = function() {return that.computedStyleMap}\n\t                blockStyleUtils.propogateStyleSet([node], this.computedStyleMap)\n\t            //}\n\t\t\t}\n\t    }\n\t\n\t\t// add a list of nodes before a particular node\n\t    // if beforeChild is undefined, this will append the given nodes\n\t    // arguments can be one of the following:\n\t        // component, component, component, ...\n\t        // listOfBlocks\n\t    this.addBefore = this.addBeforeNode = function(beforeChild) {\n\t        var nodes = trimArguments(arguments).slice(1)\n\t        if(beforeChild === undefined) {\n\t            this.add.apply(this, nodes)\n\t        } else {\n\t            var index = this.children.indexOf(beforeChild)\n\t            this.addAt.apply(this, [index].concat(nodes))\n\t        }\n\t    }\n\t\n\t\n\t    // arguments can be one of the following:\n\t        // component, component, component, ...\n\t        // index, index, index, ... - each index is the numerical index to remove\n\t        // arrayOfComponents\n\t        // arrayOfIndexes\n\t    this.remove = function() {\n\t        var removals = normalizeRemoveArguments.apply(this, arguments)\n\t        removals = removals.sort(function(a,b) {\n\t            return b-a // reverse sort (so that removing multiple indexes doesn't mess up)\n\t        })\n\t\n\t        for(var n=0; n<removals.length; n++) {\n\t            var r = removals[n]\n\t            var c = this.children[r]\n\t\n\t            if(c === undefined) {\n\t                throw new Error(\"There is no child at index \"+r)\n\t            }\n\t\n\t            c.parent = undefined\n\t            this.children.splice(r, 1)\n\t            this.domNode.removeChild(this.domNode.childNodes[r])\n\t\n\t            c.emit('parentRemoved')\n\t        }\n\t    }\n\t\n\t    // sets or gets an attribute on the components domNode\n\t    // parameter sets:\n\t    // if one argument is passed, the attribute's value is returned (if there is no attribute, undefined is returned)\n\t    // if there are two arguments passed, the attribute is set\n\t        // if 'value' is undefined, the attribute is removed\n\t    this.attr = function(/*attribute, value OR attributeObject*/) {\n\t        if(arguments.length === 1) {\n\t            if(arguments[0] instanceof Object) {\n\t                var attributes = arguments[0]\n\t                for(var attribute in attributes) {\n\t                    domUtils.setAttribute(this.domNode, attribute, arguments[0][attribute])\n\t                }\n\t            } else {\n\t                var attribute = this.domNode.getAttribute(arguments[0])\n\t                if(attribute === null) {\n\t                    return undefined // screw null\n\t                } else {\n\t                    return attribute\n\t                }\n\t            }\n\t        } else {\n\t            var attribute = arguments[0]\n\t            if(arguments[1] !== undefined) {\n\t                var value = arguments[1]\n\t                domUtils.setAttribute(this.domNode, arguments[0], value)\n\t            } else {\n\t                this.domNode.removeAttribute(attribute)\n\t            }\n\t        }\n\t    }\n\t\n\t    Object.defineProperty(this, 'visible', {\n\t        // returns true if the element is visible\n\t        get: function() {\n\t            return this.domNode.style.display !== 'none';\n\t\n\t        // sets whether or not the element is visible\n\t        }, set: function(setToVisible) {\n\t            if(setToVisible) {\n\t                if (this._displayStyle !== undefined) {\n\t                    this.domNode.style.display = this._displayStyle // set back to its previous inline style\n\t                    this._displayStyle = undefined\n\t                } else {\n\t                    this.domNode.style.display = ''\n\t                }\n\t            } else {\n\t                if(this.domNode.style.display !== '' && this.domNode.style.display !== 'none') { // domNode has inline style\n\t                    this._displayStyle = this.domNode.style.display\n\t                }\n\t\n\t                this.domNode.style.display = 'none'\n\t            }\n\t        }\n\t    })\n\t\n\t\n\t    Object.defineProperty(this, 'focus', {\n\t        // returns true if the element is in focus\n\t        get: function() {\n\t            return document.activeElement === this.domNode\n\t\n\t        // sets whether or not the element is in focus (setting it to true gives it focus, setting it to false blurs it)\n\t        }, set: function(setToInFocus) {\n\t            if(setToInFocus) {\n\t                this.domNode.focus()\n\t            } else {\n\t                this.domNode.blur()\n\t            }\n\t        }\n\t    })\n\t\n\t    Object.defineProperty(this, 'style', {\n\t        get: function() {\n\t            return this._style\n\t\n\t        // sets the style, replacing one if one already exists\n\t        }, set: function(styleObject) {\n\t            if(styleObject === undefined) {\n\t                var styleMap = this.getParentStyleMap()\n\t                if(styleMap !== undefined) {\n\t                    blockStyleUtils.setCurrentStyle(this, blockStyleUtils.getStyleForComponent(styleMap, this))\n\t                } else {\n\t                    blockStyleUtils.setCurrentStyle(this, undefined)\n\t                }\n\t\n\t                this.computedStyleMap = styleMap\n\t\n\t            } else {\n\t                blockStyleUtils.setCurrentStyle(this, styleObject)\n\t                var specificStyle = styleObject.get(this)\n\t                if(this.getParentStyleMap() !== undefined) {\n\t                    this.computedStyleMap = blockStyleUtils.styleMapConjunction(this.getParentStyleMap(), specificStyle.componentStyleMap)\n\t                } else {\n\t                    this.computedStyleMap = specificStyle.componentStyleMap\n\t                }\n\t            }\n\t\n\t            this._style = styleObject\n\t            blockStyleUtils.propogateStyleSet(this.children, this.computedStyleMap) // propogate styles to children\n\t        }\n\t    })\n\t\n\t    Object.defineProperty(this, 'selectionRange', {\n\t        // returns the visible character selection range inside the element\n\t        // returns an array like [offsetStart, offsetEnd]\n\t        get: function() {\n\t            return domUtils.getSelectionRange(this.domNode)\n\t\n\t        // sets the visible character selection range\n\t        }, set: function(selection) {\n\t            domUtils.setSelectionRange(this.domNode, selection[0], selection[1])\n\t        }\n\t    })\n\t\n\t    this.attach = function() {\n\t        attach(this)\n\t    }\n\t    this.detach = function() {\n\t        detach(this)\n\t    }\n\t\n\t\n\t\t// private instance variables/functions\n\t\n\t    this.getParentStyleMap = function() {/*default returns undefined*/}  // should be set to a function that returns the computedStyleMap of the component containing this one (so Styles objects can be inherited)\n\t    this.computedStyleMap;  // a map of style objects computed from the Styles set on a given component and its parent components\n\t\n\t\tthis._style;              // the object's explicit Style object (undefined if it inherits a style)\n\t    this.currentStyle;       // the object's current Style (inherited or explicit)\n\t    this._displayStyle;      // temporariliy stores an inline display style while the element is hidden (for use when 'show' is called)\n\t    this._styleSetupStates   // place to put states for setup functions (used for css pseudoclass emulation)\n\t});\n\t\n\t\n\tmodule.exports.dev = false // set to true to enable dom element naming (so you can see boundaries of components when inspecting the dom)\n\t\n\t\n\t// appends components to the body\n\tvar attach = module.exports.attach = function(/*component,component,.. or components*/) {\n\t    if(arguments[0] instanceof Array) {\n\t        var components = arguments[0]\n\t    } else {\n\t        var components = arguments\n\t    }\n\t\n\t    if(document.body === null) throw new Error(\"Your document does not have a body.\")\n\t\n\t    for(var n=0; n<components.length; n++) {\n\t        document.body.appendChild(components[n].domNode)\n\t    }\n\t}\n\t// removes components from the body\n\tvar detach = module.exports.detach = function(/*component,component,.. or components*/) {\n\t    if(arguments[0] instanceof Array) {\n\t        var components = arguments[0]\n\t    } else {\n\t        var components = arguments\n\t    }\n\t\n\t    for(var n=0; n<components.length; n++) {\n\t        document.body.removeChild(components[n].domNode)\n\t    }\n\t}\n\t\n\t// creates a body tag (only call this if document.body is null)\n\t\n\tmodule.exports.createBody = function(callback) {\n\t    var dom = document.implementation.createDocument('http://www.w3.org/1999/xhtml', 'html', null);\n\t    var body = dom.createElement(\"body\")\n\t    dom.documentElement.appendChild(body)\n\t    setTimeout(function() {  // set timeout is needed because the body tag is only added after javascript goes back to the scheduler\n\t        callback()\n\t    },0)\n\t}\n\t\n\t\n\t\n\t\n\t// returns a list of indexes to remove from Block.remove's arguments\n\t/*private*/ var normalizeRemoveArguments = module.exports.normalizeRemoveArguments = function() {\n\t    var that = this\n\t\n\t    if(arguments[0] instanceof Array) {\n\t        var removals = arguments[0]\n\t    } else {\n\t        var removals = Array.prototype.slice.call(arguments)\n\t    }\n\t\n\t    return removals.map(function(removal, parameterIndex) {\n\t        if(isBlock(removal)) {\n\t            var index = that.children.indexOf(removal)\n\t            if(index === -1) {\n\t                throw new Error(\"The Block passed at index \"+parameterIndex+\" is not a child of this Block.\")\n\t            }\n\t            return index\n\t        } else {\n\t            return removal\n\t        }\n\t\n\t    })\n\t}\n\t\n\t// returns a list of nodes to add\n\t/*private*/ var normalizeAddAtArguments = module.exports.normalizeAddAtArguments = function() {\n\t    if(arguments.length === 2) {\n\t        if(arguments[1] instanceof Array) {\n\t            return arguments[1]\n\t        } else {\n\t            return [arguments[1]]\n\t        }\n\t    } else { // > 2\n\t        return trimArguments(arguments).slice(1)\n\t    }\n\t}\n\t\n\tfunction isBlock(c) {\n\t    return c.add !== undefined && c.children instanceof Array && c.domNode !== undefined\n\t}\n\tfunction isDomNode(node) {\n\t    return node.nodeName !== undefined\n\t}\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar jssModule = __webpack_require__(15)\n\tvar proto = __webpack_require__(29)\n\tvar HashMap = __webpack_require__(26) // .HashMap // weirdly, it looks like this is being treated like an AMD module\n\t\n\tvar utils = __webpack_require__(16)\n\tvar blockStyleUtils = __webpack_require__(17)\n\t\n\tvar baseClassName = '_ComponentStyle_' // the base name for generated class names\n\tvar nextClassNumber = 0\n\t\n\tvar defaultJss = jssModule.forDocument(document) // must be created before the jss object (so that the styles there override the styles in the default sheet)\n\tdefaultJss.defaultSheet = defaultJss._createSheet() // create its sheet first (before the regular jss sheet)\n\tvar jss = jssModule.forDocument(document)\n\tjss.defaultSheet = jss._createSheet()\n\t\n\t// creates a style object\n\tvar Style = module.exports = proto(function() {\n\t\n\t    this.defaultClassName = '_default_'     // the name of the default class (used to prevent style inheritance)\n\t\n\t    // styleDefinition is an object where key-value pairs can be any of the following:\n\t    // <cssPropertyName>: the value should be a valid css value for that style attribute\n\t    // <ComponentName>: the value can either be a Style object or a nested styleDefinition object\n\t    // $setup: the value is a function to be run on a component when the style is applied to it\n\t    // $kill: the value is a function to be run on a component when a style is removed from it\n\t    // $state: the value should be a state handler function\n\t    // $<label>: the value should be a nested styleDefinition object that does not contain any label styles.\n\t    this.init = function(styleDefinition, privateOptions) {\n\t        if(privateOptions === undefined) privateOptions = {}\n\t        if(privateOptions.inLabel===undefined) inLabel = false\n\t\n\t        this.className = baseClassName+nextClassNumber\n\t        nextClassNumber++\n\t\n\t        this.componentStyleMap = {}\n\t        this.labelStyleMap = {}\n\t\n\t        var labelStyles = {}\n\t        var pseudoClassStyles = {}\n\t        var cssProperties = {}\n\t        for(var key in styleDefinition) {\n\t            var value = styleDefinition[key]\n\t\n\t            if(key === '$setup') {\n\t                if(!(value instanceof Function)) throw new Error(\"$setup key must be a function ('setup' can't be used as a label)\")\n\t                this.setup = value\n\t\n\t            } else if(key === '$kill') {\n\t                if(!(value instanceof Function)) throw new Error(\"$kill key must be a function ('kill' can't be used as a label)\")\n\t                this.kill = value\n\t\n\t            } else if(key.indexOf('$$') === 0) { // pseudo-class style\n\t                var pseudoClass = mapCamelCase(key.substr(2))\n\t                if(pseudoClass === '') {\n\t                    throw new Error(\"Empty pseudo-class name not valid (style key '$$')\")\n\t                }\n\t\n\t                utils.merge(pseudoClassStyles, flattenPseudoClassStyles(pseudoClass, value))\n\t\n\t            } else if(key.indexOf('$') === 0) {   // label style\n\t                if(privateOptions.inLabel)\n\t                    throw new Error(\"Can't create nested label style \"+key+\" because components can only have one label\")\n\t\n\t                var label = key.substr(1)\n\t                if(label === '') {\n\t                    throw new Error(\"Empty label name not valid (style key '$')\")\n\t                }\n\t\n\t                labelStyles[label] = value\n\t\n\t            } else if(isStyleObject(value)) {\n\t                this.componentStyleMap[key] = value\n\t\n\t            } else if(value instanceof Object) {\n\t                this.componentStyleMap[key] = Style(value)  // turn the object description into a full fledged style object\n\t            } else {\n\t                var cssStyle = key\n\t                var cssStyleName = mapCamelCase(cssStyle)\n\t                cssProperties[cssStyleName] = cssValue(cssStyleName, value)\n\t            }\n\t        }\n\t\n\t        // create the css class\n\t        if(privateOptions.default) {\n\t            var jssSheet = defaultJss\n\t        } else {\n\t            var jssSheet = jss\n\t        }\n\t\n\t        jssSheet.set('.'+this.className, cssProperties)\n\t\n\t        //if(module.exports.isDev) {\n\t            this.styleDefinitions = {}\n\t            this.styleDefinitions['.'+this.className] = cssProperties\n\t        //}\n\t\n\t        // create label styles\n\t        if(Object.keys(labelStyles).length > 0) {\n\t            var baseStyle = utils.merge({}, cssProperties, this.componentStyleMap)\n\t\n\t            for(var label in labelStyles) {\n\t                if(isStyleObject(labelStyles[label])) {\n\t                    this.labelStyleMap[label] = labelStyles[label]\n\t                } else {\n\t                    var mergedStyle = utils.merge({}, baseStyle, labelStyles[label])\n\t                    this.labelStyleMap[label] = Style(mergedStyle, {inLabel:true})\n\t                }\n\t            }\n\t        }\n\t\n\t        // create pseudoclass styles\n\t        if(Object.keys(pseudoClassStyles).length > 0) {\n\t\n\t            var tieredPseudoClasses = createTieredPseudoClasses(this, pseudoClassStyles)\n\t            pseudoclassCombinations(tieredPseudoClasses) // mutates tieredPseudoClasses\n\t\n\t            // turn the emulatable pseudo classes into Style objects\n\t            // also build up the set of psuedoclasses that will be emulated\n\t            // also build up a map of pseudoclasses-to-emulate to the emulation functions for those pseudoclasses\n\t            var pseudoClasesToEmulate = []\n\t            var preSplitPseudoClasses = [] // a list where each element looks like: [pseudoClassList, styleObject]  (this is primarily for performance - so we don't have to split the key every time we check for state changes)\n\t            var pseudoClassesToEmulationInfo = {}\n\t            for(var key in tieredPseudoClasses) {\n\t                if(isStyleObject(tieredPseudoClasses[key])) {\n\t                    tieredPseudoClasses[key] = tieredPseudoClasses[key]\n\t                } else {\n\t                    var newStyle = Style(utils.merge({}, cssProperties, tieredPseudoClasses[key])) // pseudoClassStyles merged with parent css styles\n\t\n\t                    // merge in componentStyleMap and labelStyleMap\n\t                    for(var k in this.componentStyleMap) {\n\t                        if(newStyle.componentStyleMap[k] === undefined)\n\t                            newStyle.componentStyleMap[k] = this.componentStyleMap[k]\n\t                    }\n\t                    for(var k in this.labelStyleMap) {\n\t                        if(newStyle.labelStyleMap[k] === undefined)\n\t                            newStyle.labelStyleMap[k] = this.labelStyleMap[k]\n\t                    }\n\t\n\t                    tieredPseudoClasses[key] = newStyle\n\t                }\n\t\n\t\n\t                var pseudoClassList = key.split(\":\")\n\t                for(var n=0; n<pseudoClassList.length; n++) {\n\t                    var pseudoClass = pseudoClassList[n]\n\t                    if(pseudoClasesToEmulate.indexOf(pseudoClass) === -1) {\n\t                        pseudoClasesToEmulate.push(pseudoClass)\n\t\n\t                        var pseudoClassParts = getPseudoClassParts(pseudoClass)\n\t                        var fns = emulatedPseudoClasses[pseudoClassParts.class]\n\t                        var info = {fns: fns}\n\t                        if(fns.processParameter !== undefined) {\n\t                            info.parameter = fns.processParameter(pseudoClassParts.parameter)\n\t                        }\n\t                        pseudoClassesToEmulationInfo[pseudoClass] = info\n\t                    }\n\t                }\n\t\n\t                preSplitPseudoClasses.push([pseudoClassList, tieredPseudoClasses[key]])\n\t            }\n\t\n\t            // create functions that initialize and keep track of state\n\t            var initializeState = function(component) {\n\t                var state = {}\n\t                for(var n=0; n<pseudoClasesToEmulate.length; n++) {\n\t                    var pseudoClass = pseudoClasesToEmulate[n]\n\t                    var pseudoClassEmulationInfo = pseudoClassesToEmulationInfo[pseudoClass]\n\t                    state[pseudoClass] = pseudoClassEmulationInfo.fns.check(component, pseudoClassEmulationInfo.parameter)\n\t                }\n\t\n\t                return state\n\t            }\n\t\n\t            var that = this\n\t            var changeStyleIfNecessary = function(currentStyle, component, state) {\n\t                var longestMatchingLength = 0;\n\t                var mostSpecificMatchingStyle = that; // if nothing else matches, change back to the base style object\n\t                for(var n=0; n<preSplitPseudoClasses.length; n++) {\n\t                    var pseudoClassList = preSplitPseudoClasses[n][0]\n\t                    for(var j=0; j<pseudoClassList.length; j++) {\n\t                        if(!state[pseudoClassList[j]]) {\n\t                            break;\n\t                        }\n\t                    }\n\t\n\t                    if(j === pseudoClassList.length && j > longestMatchingLength) {\n\t                        longestMatchingLength = j\n\t                        mostSpecificMatchingStyle = preSplitPseudoClasses[n][1]\n\t                    }\n\t                }\n\t\n\t                if(mostSpecificMatchingStyle !== currentStyle) {\n\t                    component.style = mostSpecificMatchingStyle\n\t\n\t                    //blockStyleUtils.setCurrentStyle(component, mostSpecificMatchingStyle)\n\t                    //blockStyleUtils.propogateStyleSet(component.children, component.computedStyleMap) // propogate styles to children\n\t                }\n\t            }\n\t\n\t            // setup pseudoclass emulation with $setup and $kill handlers\n\t\n\t            var wrapSetupAndKill = function(style) {\n\t                var originalSetup = style.setup\n\t                style.setup = function(component) {\n\t                    var that = this\n\t\n\t                    this._styleSetupStates = {} // maps pseudoClass to setupState\n\t                    var state = initializeState(component)\n\t                    for(var pseudoClass in pseudoClassesToEmulationInfo) {\n\t                        ;(function(pseudoClass, emulationInfo){   // close over those variables (so they keep the value they had when the function was setup)\n\t                            that._styleSetupStates[pseudoClass] = emulationInfo.fns.setup(component, function() { // start\n\t                                state[pseudoClass] = true\n\t                                changeStyleIfNecessary(that, component, state)\n\t                            }, function() { // end\n\t                                state[pseudoClass] = false\n\t                                changeStyleIfNecessary(that, component, state)\n\t                            }, emulationInfo.parameter)\n\t\n\t                        })(pseudoClass, pseudoClassesToEmulationInfo[pseudoClass])\n\t                    }\n\t\n\t                    changeStyleIfNecessary(that, component, state)\n\t\n\t                    if(originalSetup !== undefined) {\n\t                        originalSetup.apply(this, arguments)\n\t                    }\n\t                }\n\t\n\t                var originalKill = style.kill\n\t                style.kill = function(component) {\n\t                    for(var pseudoClass in pseudoClassesToEmulationInfo) {\n\t                        var emulationInfo = pseudoClassesToEmulationInfo[pseudoClass]\n\t                        emulationInfo.fns.kill(component, this._styleSetupStates[pseudoClass])\n\t                    }\n\t\n\t                    if(originalKill !== undefined) {\n\t                        originalKill.apply(this, arguments)\n\t                    }\n\t                }\n\t            }\n\t\n\t            // wrap all the setup and kill functions\n\t\n\t            for(var key in tieredPseudoClasses) {\n\t                var style = tieredPseudoClasses[key]\n\t                wrapSetupAndKill(style)\n\t            }\n\t\n\t            wrapSetupAndKill(this)\n\t        }\n\t    }\n\t\n\t    // instance properties\n\t\n\t    this.className          // the css classname for this style\n\t    this.componentStyleMap; // maps a Component name to a Style object for that component\n\t    this.labelStyleMap;     // maps a label name to a Style object for that label\n\t    this.setup;             // run some javascript on any element this class is applied to\n\t    this.kill;              // a function to run on removal of the style (should reverse setup)\n\t\n\t    // gets the style object for a component based on the current style object (takes into account whether the component has a label\n\t    this.get = function(component) {\n\t        if(component.label !== undefined) {\n\t            var labelStyle = this.labelStyleMap[component.label]\n\t            if(labelStyle !==  undefined) {\n\t                return labelStyle\n\t            }\n\t        }\n\t        // else\n\t        return this\n\t    }\n\t})\n\t\n\t\n\t// private\n\t\n\t\n\t// returns a two-level map where the top-level keys are emulatable psuedo classes, and non-emulatable pseudo classes are at the second level\n\t// the classes will also be sorted and deduped\n\t// Example return value: {\"hover:lastChild\": {color:'red', \"$$visited:disabled\": {fontWeight: 'bold'}}, }\n\t// parameters:\n\t    // style - the style object being created\n\t    // pseudoClassStyles - a flat object where each key is a list of pseudoclasses separated by colons (e.g. \"hover\" or \"hover:focus\") and the value is an object of styles that don't contain pseudoclasses\n\tfunction createTieredPseudoClasses(style, pseudoClassStyles) {\n\t    var tieredPseudoClasses = {} // the two-level map\n\t    for(var key in pseudoClassStyles) {\n\t        var value = pseudoClassStyles[key]\n\t\n\t        // split key into pseudoclass list\n\t        var pseudoClassList = key.split(\":\")\n\t        var emulatablePseudoClasses = []\n\t        var nonEmulatablePseudoClasses = []\n\t        for(var n in pseudoClassList) {\n\t            var pseudoClass = pseudoClassList[n]\n\t            var pseudoClassParts = getPseudoClassParts(pseudoClass)\n\t            if(pseudoClassParts.class in emulatedPseudoClasses) {\n\t                emulatablePseudoClasses.push(pseudoClass)\n\t            } else {\n\t                nonEmulatablePseudoClasses.push(pseudoClass)\n\t            }\n\t        }\n\t\n\t        // todo: add a third branch as an optimization: if the Style can be rendered without emulation - do that\n\t        if(emulatablePseudoClasses.length === 0) { // if none of the pseudoclasses can be emulated using javascript\n\t            validatePurePseudoClassStyles(key, value)                        // then validate the value and\n\t            createPseudoClassRules(style, key, '.'+style.className+\":\"+key, value)   // create pseudoClassRules\n\t\n\t        } else { // if some of the pseudoclasses can be emulated using javascript\n\t\n\t            emulatablePseudoClasses.sort()\n\t            var emulatablePseudoClassKey = emulatablePseudoClasses.join(':')\n\t            if(tieredPseudoClasses[emulatablePseudoClassKey] === undefined)\n\t                tieredPseudoClasses[emulatablePseudoClassKey] = {}\n\t\n\t            if(nonEmulatablePseudoClasses.length === 0) {\n\t                utils.merge(tieredPseudoClasses[emulatablePseudoClassKey], value)\n\t            } else {\n\t                nonEmulatablePseudoClasses.sort()\n\t                var nonEmulatablePsuedoClassKey = nonEmulatablePseudoClasses.join(':')\n\t\n\t                var secondTier = {}\n\t                secondTier['$$'+nonEmulatablePsuedoClassKey] = value\n\t\n\t                utils.merge(tieredPseudoClasses[emulatablePseudoClassKey], secondTier)\n\t            }\n\t        }\n\t    }\n\t\n\t    return tieredPseudoClasses\n\t}\n\t\n\t\n\t\n\t// make combinations of the emulatable pseudoclasses, so that they combine like the non-emulated ones do\n\t// info about mathematical combination: https://en.wikipedia.org/wiki/Combination\n\t// mutates tieredPseudoClasses\n\tfunction pseudoclassCombinations(tieredPseudoClasses) {\n\t    var tieredPseudoClassesKeys = Object.keys(tieredPseudoClasses).reverse().map(function(v) {    // reverse first so that more specific pseudoclasses go first\n\t        return {key: v, parts: v.split(':')} // so it doesn't have to split every time\n\t    })\n\t\n\t    for(var n=0; n<tieredPseudoClassesKeys.length; n++) {\n\t        var keyA = tieredPseudoClassesKeys[n]\n\t        for(var k=2; k <= tieredPseudoClassesKeys.length; k++) { // k is the number of psuedoclasses to combine\n\t            for(var j=n+1; j<tieredPseudoClassesKeys.length-(k-2); j++) {\n\t                var result = combinePseudoclasses(tieredPseudoClasses, [keyA].concat(tieredPseudoClassesKeys.slice(j, k)))\n\t                if(result.key in tieredPseudoClasses) {\n\t                    utils.merge(tieredPseudoClasses[result.key], result.value)\n\t                } else { // new key\n\t                    tieredPseudoClasses[result.key] = result.value\n\t                }\n\t            }\n\t        }\n\t    }\n\t}\n\t\n\t\n\t\n\t// keys is a list of objects where each object has the members:\n\t    // key - the original string key\n\t    // parts - the key split by \":\"\n\t// returns an object with the following members:\n\t    // key - the new combined key\n\t    // value - the new merged value\n\tvar combinePseudoclasses = function(pseudoclasses, keys) {\n\t    var resultKeyParts = keys[0].parts\n\t    var resultValue = utils.merge({}, pseudoclasses[keys[0].key]) // make a copy\n\t    for(var n=1; n<keys.length; n++) {\n\t        var key = keys[n]\n\t        // merge all psuedoclasses that don't already exist into the resultKey\n\t        for(var j=0; j<key.parts.length; j++) {\n\t            var part = key.parts[j]\n\t            if(resultKeyParts.indexOf(part) === -1) {\n\t                resultKeyParts.push(part)\n\t            }\n\t        }\n\t\n\t        // merge the value into resultValue\n\t        utils.merge(resultValue, pseudoclasses[key.key])\n\t    }\n\t\n\t    return {key: resultKeyParts.join(':'), value: resultValue}\n\t}\n\t\n\t// a map of pseudoclass names and how they are emulated with javascript\n\t// each pseudoclass sets up the following functions:\n\t    // check - a function that checks if that pseudoclass currently applies to the component when its called\n\t    // setup - calls a callback when the pseudoClass starts and stops applying\n\t        // should return an object that will be passed to the kill function (as its 'state' parameter)\n\t    // kill - cleans up anything set up in the 'setup' function\n\t    // processParameter - takes the pseudoclass parameter and returns some object representing it that will be used by the setup and check functions\n\tvar emulatedPseudoClasses = {\n\t    hover: {\n\t        check: function(component) {\n\t            var nodes = document.querySelectorAll( \":hover\" )\n\t            for(var n=0; n<nodes.length; n++) {\n\t                if(nodes[n] === component.domNode) {\n\t                    return true\n\t                }\n\t            }\n\t            return false\n\t        },\n\t        setup: function(component, startCallback, endCallback) {\n\t            component.on(\"mouseover\", function() {\n\t                startCallback()\n\t            })\n\t            component.on(\"mouseout\", endCallback)\n\t\n\t            return {start: startCallback, end: endCallback}\n\t        },\n\t        kill: function(component, state) {\n\t            component.off(\"mouseover\", state.start)\n\t            component.off(\"mouseout\", state.end)\n\t        }\n\t    },\n\t    checked: {\n\t        check: function(component) {\n\t            return component.selected\n\t        },\n\t        setup: function(component, startCallback, endCallback) {\n\t            var setupState = {}\n\t            component.on(\"change\", setupState.listener = function() {\n\t                if(component.selected) {\n\t                    startCallback()\n\t                } else {\n\t                    endCallback()\n\t                }\n\t            })\n\t\n\t            return setupState\n\t        },\n\t        kill: function(component, state) {\n\t            component.removeListener(\"change\", state.listener)\n\t        }\n\t    },\n\t    required: {\n\t        check: function(component) {\n\t            return component.attr('required') !== undefined\n\t        },\n\t        setup: function(component, startCallback, endCallback) {\n\t            var observer = new MutationObserver(function() {\n\t                if(component.attr('required') !== undefined) {\n\t                    startCallback()\n\t                } else {\n\t                    endCallback()\n\t                }\n\t            })\n\t\n\t            observer.observe(component.domNode, {attributes: true})\n\t\n\t            return {observer: observer}\n\t        },\n\t        kill: function(component, state) {\n\t            state.observer.disconnect()\n\t        }\n\t    },\n\t    'last-child': {\n\t        check: function(component) {\n\t            return nthLastChildCheck(component, '1')\n\t        },\n\t        setup: function(component, startCallback, endCallback) {\n\t            var observer = new MutationObserver(function() {\n\t                if(nthLastChildCheck(component, '1')) {\n\t                    startCallback()\n\t                } else {\n\t                    endCallback()\n\t                }\n\t            })\n\t\n\t            var setupObserver = function() {\n\t                // note that since this uses the component parent rather than domNode.parentNode, this won't work for components added to non-component nodes (and there's no good way to do it, because you would have to poll for parent changes)\n\t                observer.observe(component.parent.domNode, {childList: true})\n\t            }\n\t\n\t            if(component.parent !== undefined) {\n\t                setupObserver()\n\t            }\n\t\n\t            component.on('newParent', function() {\n\t                setupObserver()\n\t            })\n\t            component.on('parentRemoved', function() {\n\t                observer.disconnect()\n\t            })\n\t\n\t            return {observer: observer}\n\t        },\n\t        kill: function(component, state) {\n\t            state.observer.disconnect()\n\t        }\n\t    },\n\t    'nth-child': {\n\t        // todo: support full an+b parameters for nth-child https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-child\n\t        check: function(component, parameterCheck) {\n\t            return nthChildCheck(component, parameterCheck)\n\t        },\n\t        setup: function(component, startCallback, endCallback, parameterCheck) {\n\t\n\t            var checkAndCallCallbacks = function() {\n\t                if(nthChildCheck(component, parameterCheck)) {\n\t                    startCallback()\n\t                } else {\n\t                    endCallback()\n\t                }\n\t            }\n\t\n\t            var observer = new MutationObserver(function() {\n\t                checkAndCallCallbacks()\n\t            })\n\t\n\t            var setupObserver = function() {\n\t                // note that since this uses the component parent rather than domNode.parentNode, this won't work for components added to non-component nodes (and there's no good way to do it, because you would have to poll for parent changes)\n\t                observer.observe(component.parent.domNode, {childList: true})\n\t            }\n\t\n\t            if(component.parent !== undefined) {\n\t                setupObserver()\n\t            }\n\t\n\t            component.on('newParent', function() {\n\t                setupObserver()\n\t                checkAndCallCallbacks()\n\t            })\n\t            component.on('parentRemoved', function() {\n\t                observer.disconnect()\n\t                checkAndCallCallbacks()\n\t            })\n\t\n\t            return {observer: observer}\n\t        },\n\t        kill: function(component, state) {\n\t            state.observer.disconnect()\n\t        },\n\t        processParameter: function(parameter) {\n\t            return nthChildParameterFn(parameter)\n\t        }\n\t    },\n\t\n\t    // not's parameter is a statement consisting of pseudoclasses separated either by & or ,\n\t    // $$not(pseudoclass1&pseudoclass2,psuedoclass3) translates to the css :not(:pseudoclass1:pseudoclass2,:psuedoclass3)\n\t    /*not: {\n\t        check: function() {\n\t\n\t        },\n\t    }*/\n\t}\n\t\n\t// name is the name of the new pseudoclass\n\t// fns is an object with the members:\n\t    // check(component) - returns true if the pseudoclass applies to the component\n\t    // setup(component, startCallback, endCallback, parameter) - a function that should call startCallback when the pseudoclass starts applying, and endCallback when it stops applying\n\t        // parameter - the parameter passed to the pseudoclass (e.g. in :not(:first-child), \":first-child\" is the parameter)\n\t    // kill - a function that cleans up any event listeners or anything else set up in the 'setup' function\n\tmodule.exports.addPseudoClass = function(name, fns) {\n\t    if(emulatedPseudoClasses[name] !== undefined) throw new Error(\"The pseudoclass '\"+name+\"' is already defined.\")\n\t    // else\n\t    emulatedPseudoClasses[name] = fns\n\t}\n\t\n\t\n\tfunction nthChildCheck(component, testFn) {\n\t    if(component.domNode.parentNode === null)\n\t        return false\n\t\n\t    var children = component.domNode.parentNode.children                    // must be domNode.parentNode, because child nodes may not be Components\n\t    var index = Array.prototype.indexOf.call(children, component.domNode)\n\t    return testFn(index)\n\t}\n\t\n\tfunction nthLastChildCheck(component, parameter) {\n\t    if(component.domNode.parentNode === null)\n\t        return false\n\t\n\t    var children = component.domNode.parentNode.children                    // must be domNode.parentNode, because child nodes may not be Components\n\t    var index = children.length - parseInt(parameter)\n\t    return children[index] === component.domNode\n\t}\n\t\n\t// returns a function that takes an index and tell you if that index applies to the nthChildParameter\n\tvar nthChildParameter = /^(((-?\\d*)(([+-]\\d*)n?)?)|((-?\\d)*n?([+-]\\d*)?))$/\n\tfunction nthChildParameterFn(parameter) {\n\t    var parts = parameter.match(nthChildParameter)\n\t    if(parts === null)\n\t        throw new Error(\"nth-child parameter '\"+parameter+\"' isn't valid\")\n\t\n\t    if(parts[2] !== undefined) {\n\t        var constant = parts[3]\n\t        var variable = parts[5]\n\t    } else {\n\t        var constant = parts[8]\n\t        var variable = parts[7]\n\t    }\n\t\n\t    if(constant === undefined) constant = 0\n\t    else                       constant = parseInt(constant)\n\t    if(variable === undefined) variable = 0\n\t    else                       variable = parseInt(variable)\n\t\n\t    if(variable === 0) {\n\t        return function(index) {\n\t            return index+1 === constant\n\t        }\n\t    } else {\n\t        return function(index) {\n\t            return ((index+1-constant)/variable) % 1 === 0\n\t        }\n\t    }\n\t\n\t}\n\t\n\t// maps a style value to a css value\n\t// style values that are numbers are mapped to strings, usually with px postfix\n\tfunction cssValue(cssStyleName, value) {\n\t    // If a number was passed in, add 'px' to the (except for certain CSS properties) [also taken from jquery's code]\n\t    if(typeof(value) === \"number\" && cssNumber[cssStyleName] === undefined) {\n\t        return value+\"px\"\n\t    } else {\n\t        return value.toString()\n\t    }\n\t}\n\t\n\tfunction createPseudoClassRules(that, pseudoClass, selector, pseudoClassStyle) {\n\t\n\t    var pseudoClassCss = {}\n\t    for(var key in pseudoClassStyle) {\n\t        var value = pseudoClassStyle[key]\n\t\n\t        if(!(value instanceof Object)) {\n\t            var cssStyle = key\n\t            var cssStyleName = mapCamelCase(cssStyle)\n\t            pseudoClassCss[cssStyleName] = cssValue(cssStyleName, value)\n\t        } else {\n\t            throw new Error(\"All properties within the pseudoclasses '\"+pseudoClass+\"' must be css styles\")\n\t        }\n\t    }\n\t\n\t    // create immediate pseudo class style\n\t    defaultJss.set(selector, pseudoClassCss) // create the css class with the pseudoClass\n\t\n\t    //if(module.exports.isDev) {\n\t        that.styleDefinitions = {}\n\t        that.styleDefinitions[selector] = pseudoClassCss\n\t    //}\n\t}\n\t\n\t// throws exceptions for various style configurations that are unsupported by pure pseudo classes (ones that can't be emulated usuing javascript)\n\tfunction validatePurePseudoClassStyles(pseudoClass, pseudoClassStyles) {\n\t    for(var key in pseudoClassStyles) {\n\t        var value = pseudoClassStyles[key]\n\t\n\t        if(isStyleObject(value)) {\n\t            throw new Error(\"Can't set the pseudoclasses '\"+pseudoClass+\"' to a Style object\")\n\t        } else if(key === '$setup') {\n\t            throw new Error(\"$setup can't be used within the pseudoclasses '\"+pseudoClass+\"'\")\n\t        } else if(key === '$kill') {\n\t            throw new Error(\"$kill can't be used within the pseudoclasses '\"+pseudoClass+\"'\")\n\t        } else if(key.indexOf('$') === 0) {   // label style\n\t            throw new Error(\"Block labels can't be used within the pseudoclasses '\"+pseudoClass+\"'\")\n\t        }\n\t    }\n\t}\n\t\n\t// e.g. pulls out 'nth-child' and '2+3n' from 'nth-child(2+3n)'\n\tvar pseudoClassRegex = /^([^(]*)(\\((.*)\\))?$/\n\tfunction getPseudoClassParts(fullPsuedoClass) {\n\t    var x = fullPsuedoClass.match(pseudoClassRegex)\n\t    if(x === null) throw new Error(\"Pseudoclass '\"+fullPsuedoClass+\"' is invalid\")\n\t    return {class: x[1], parameter: x[3]}\n\t}\n\t\n\t\n\t// takes in a list of pseudoClassRules and changes any nesting like {hover: {focus: {}}} into something like {hover: {}, \"hover:focus\": {}}\n\t// also does some validation\n\tfunction flattenPseudoClassStyles(pseudoClass, pseudoClassStyle) {\n\t    var nonPseudoClassStyles = {}\n\t    var subpseudoClasses = {}\n\t    for(var key in pseudoClassStyle) {\n\t        var value = pseudoClassStyle[key]\n\t\n\t        if(key.indexOf('$$') === 0) { // pseudo-class style\n\t            var subPseudoClass = key.substr(2)\n\t            if(subPseudoClass === '') {\n\t                throw new Error(\"Empty pseudo-class name not valid (style key '$$')\")\n\t            }\n\t\n\t            subpseudoClasses[subPseudoClass] = value\n\t        } else {\n\t            nonPseudoClassStyles[key] = value\n\t        }\n\t    }\n\t\n\t    // create flattened styles (with merged in styles from its parent pseudoclass\n\t    var flattenedStyles = {}\n\t    for(var subPseudoClass in subpseudoClasses) {\n\t        var value = subpseudoClasses[subPseudoClass]\n\t\n\t        if(isStyleObject(value)) {\n\t            flattenedStyles[pseudoClass+\":\"+subPseudoClass] =  value\n\t        } else {\n\t            utils.merge(flattenedStyles, flattenPseudoClassStyles(pseudoClass+\":\"+subPseudoClass, utils.merge({}, nonPseudoClassStyles, value)))\n\t        }\n\t    }\n\t\n\t    // write the top-level pseudoClass\n\t    flattenedStyles[pseudoClass] = nonPseudoClassStyles\n\t\n\t    return flattenedStyles\n\t}\n\t\n\t\n\t// taken from jquery's code\n\tvar cssNumber = {\n\t    \"column-count\": 1,\n\t    \"fill-opacity\": 1,\n\t    \"flex-grow\": 1,\n\t    \"flex-shrink\": 1,\n\t    \"font-weight\": 1,\n\t    \"line-height\": 1,\n\t    \"opacity\": 1,\n\t    \"order\": 1,\n\t    \"orphans\": 1,\n\t    \"widows\": 1,\n\t    \"z-index\": 1,\n\t    \"zoom\": 1\n\t}\n\t\n\tfunction isStyleObject(o) {\n\t    return o.componentStyleMap !== undefined\n\t}\n\t\n\t\n\tvar asciiA = 'A'.charCodeAt(0), asciiZ = 'Z'.charCodeAt(0), difference = 'a'.charCodeAt(0) - asciiA\n\tfunction mapCamelCase(cssStyleName) {\n\t    for(var n=0; n<cssStyleName.length; n++) {\n\t        var ascii = cssStyleName.charCodeAt(n)\n\t        if(asciiA <= ascii && ascii <= asciiZ) { // found capital letter\n\t            cssStyleName = cssStyleName.slice(0, n) + '-'+String.fromCharCode(ascii+difference) + cssStyleName.slice(n+1)\n\t            n++ // increment a second time for the dash\n\t        }\n\t    }\n\t\n\t    return cssStyleName\n\t}\n\t\n\t// maps all the styles that are inherited by descendant nodes to their default values\n\t// source: http://stackoverflow.com/questions/5612302/which-css-styles-are-inherited\n\tvar defaultStyleValues = {\n\t    'azimuth': 'center',\n\t    'border-collapse': 'separate',\n\t    'border-spacing': '0',\n\t    'caption-side': 'top',\n\t    //'color': 'black',         // let this inherit\n\t    //'cursor': 'auto',         // let this one inherit - its weird otherwise\n\t    'direction': 'ltr',\n\t     display: 'inline-block', // changes the default display to inline-block\n\t    'elevation': '',\n\t    'empty-cells': 'show',\n\t    // 'font-family': '',       // let this inherit\n\t    // 'font-size': 'medium',   // let this inherit\n\t    //'font-style': 'normal',   // let this inherit\n\t    //'font-variant': 'normal', // let this inherit\n\t    //'font-weight': 'normal',  // let this inherit\n\t    'letter-spacing': 'normal',\n\t    'line-height': 'normal',\n\t    'list-style-image': 'none',\n\t    'list-style-position': 'outside',\n\t    'list-style-type': 'disc',\n\t    'orphans': '2',\n\t    'pitch-range': '',\n\t    'pitch': '',\n\t     position: 'relative', // changes the default positioning so that absolute is relative to its parent by default\n\t    'quotes': '',\n\t    'richness': '',\n\t    'speak-header': '',\n\t    'speak-numeral': '',\n\t    'speak-punctuation': '',\n\t    'speak': '',\n\t    'speak-rate': '',\n\t    'stress': '',\n\t    'text-align': 'left',\n\t    'text-indent': '0',\n\t    'text-transform': 'none',\n\t    //'visibility': 'visible',    // let this inherit - otherwise you just hide the container and not the contents\n\t    'voice-family': '',\n\t    'volume': '',\n\t    'white-space': 'normal',\n\t    'widows': '2',\n\t    'word-spacing': 'normal'\n\t}\n\t\n\tdefaultJss.set('.'+Style.defaultClassName, defaultStyleValues) // creates default css class in order to prevent inheritance\n\t\n\tdefaultJss.set('input', { // chrome and firefox user agent stylesheets mess with this otherwise\n\t    cursor: 'inherit'\n\t})\n\t\n\t/*private*/ module.exports.isDev; // should be set by Block\n\t\n\tvar computedStyles = module.exports.computedStyles = new HashMap() // stores a map from styleMap components, to the combined style map\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(29)\n\tvar Style = __webpack_require__(2)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t    //static properties\n\t\n\t    this.name = 'Canvas'\n\t\n\t    this.init = function(/*[label,] height, width*/) {\n\t        if(arguments.length === 2) {\n\t            var height = arguments[0]\n\t            var width = arguments[1]\n\t        } else {\n\t            var label = arguments[0]\n\t            var height = arguments[1]\n\t            var width = arguments[2]\n\t        }\n\t\n\t        this.domNode = document.createElement('canvas') // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t\n\t        this.label = label\n\t        this.height = height\n\t        this.width = width\n\t    }\n\t\n\t    // instance properties\n\t\n\t    Object.defineProperty(this, 'width', {\n\t        get: function() {\n\t            return this.domNode.width\n\t        }, set: function(v) {\n\t            this.domNode.width = v\n\t        }\n\t    })\n\t    Object.defineProperty(this, 'height', {\n\t        get: function() {\n\t            return this.domNode.height\n\t        }, set: function(v) {\n\t            this.domNode.height = v\n\t        }\n\t    })\n\t\n\t    this.context = function() {\n\t        return this.domNode.getContext.apply(this.domNode, arguments)\n\t    }\n\t\n\t    this.toImg = this.toDataURL = function() {\n\t        return this.domNode.toDataURL()\n\t    }\n\t});\n\n\n/***/ },\n/* 4 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(29)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t\t// static properties\n\t\n\t    this.name = 'Container'\n\t\n\t\n\t\t// instance properties\n\t\n\t\tthis.init = function (/*[label,] content*/) {\n\t        if(arguments.length === 1) {\n\t            var contentArgs = [arguments[0]]\n\t        } else if(arguments.length > 1) {\n\t            if(typeof(arguments[0]) === 'string') {\n\t                var label = arguments[0]\n\t                var contentArgs = Array.prototype.slice.call(arguments, 1)\n\t            } else {\n\t                var contentArgs = arguments\n\t            }\n\t        }\n\t\n\t\t\tvar that = this\n\t        superclass.init.call(this) // superclass constructor\n\t\n\t        this.label = label\n\t\n\t\t\tif(contentArgs !== undefined)\n\t            this.add.apply(this,contentArgs)\n\t\t}\n\t})\n\n\n/***/ },\n/* 5 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(29)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t    // static variables\n\t\n\t    this.name = 'Button'\n\t\n\t\n\t    // instance properties\n\t\n\t\tthis.init = function(/*[label,] text*/) {\n\t        if(arguments.length >= 2) {\n\t            var label = arguments[0]\n\t            var text = arguments[1]\n\t        } else {\n\t            var text = arguments[0]\n\t        }\n\t\n\t        this.domNode = document.createElement(\"input\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t\n\t        this.label = label\n\t\t\tthis.attr('type','button');\n\t\t\tthis.text = text\n\t\t}\n\t\n\t    Object.defineProperty(this, 'text', {\n\t        get: function() {\n\t            return this.attr('value')\n\t        },\n\t        set: function(text) {\n\t            this.attr('value', text)\n\t        }\n\t    })\n\t\n\t})\n\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(29)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\t// static variables\n\t    this.name = 'CheckBox'\n\t\n\t\t// instance methods\n\t\tthis.init = function(label) {\n\t        var that = this\n\t\n\t        this.domNode = document.createElement(\"input\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t\n\t        this.label = label\n\t\t\tthis.attr('type','checkbox')\n\t\t}\n\t\n\t    Object.defineProperty(this, 'selected', {\n\t        // returns whether or not the checkbox is checked\n\t        get: function() {\n\t            return this.domNode.checked\n\t        },\n\t        // sets the value of the checkbox to the passed value (true for checked)\n\t        set: function(checked) {\n\t            var newValue = checked === true\n\t            var curValue = this.domNode.checked\n\t            if(curValue === newValue) return;  // do nothing if nothing's changing\n\t\n\t            this.domNode.checked = newValue\n\t            this.emit('change') // the browser has no listenable event that is triggered on change of the 'checked' property\n\t        }\n\t    })\n\t})\n\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(29)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t    //static properties\n\t\n\t    this.name = 'Image'\n\t\n\t    this.init = function(/*[label,] imageSource*/) {\n\t        if(arguments.length === 1) {\n\t            var imageSource = arguments[0]\n\t        } else {\n\t            var label = arguments[0]\n\t            var imageSource = arguments[1]\n\t        }\n\t\n\t        this.domNode = document.createElement('img') // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t\n\t        var that = this\n\t\n\t        this.label = label\n\t        if(imageSource !==  undefined) this.src = imageSource\n\t    }\n\t\n\t    // instance properties\n\t\n\t    Object.defineProperty(this, 'src', {\n\t        get: function() {\n\t            return this.domNode.src\n\t        }, set: function(v) {\n\t            this.domNode.src = v\n\t        }\n\t    })\n\t});\n\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar proto = __webpack_require__(29)\n\t\n\tvar Block = __webpack_require__(1)\n\tvar Style = __webpack_require__(2)\n\t\n\tvar Item = __webpack_require__(21);\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t\t// static properties\n\t\n\t\tthis.Item = Item\n\t\n\t    this.name = 'List'\n\t\n\t\t// instance properties\n\t\n\t\tthis.init = function(/*[label,] [ordered,] listInit*/) {\n\t\t\tif(arguments[0] instanceof Array) {\n\t            var listInit = arguments[0]\n\t        } else {\n\t            if(arguments[1] instanceof Array) {\n\t                var listInit = arguments[1]\n\t            } else if(arguments[2] instanceof Array) {\n\t                var listInit = arguments[2]\n\t            }\n\t\n\t            if(typeof(arguments[0]) === 'boolean') {\n\t                var ordered = arguments[0]\n\t            } else {\n\t                if(typeof(arguments[1]) === 'boolean') {\n\t                    var ordered = arguments[1]\n\t                } else {\n\t                    var ordered = false // default\n\t                }\n\t\n\t                if(typeof(arguments[0]) === 'string') {\n\t                    var label = arguments[0]\n\t                }\n\t            }\n\t        }\n\t\n\t        if(ordered) {\n\t            var type = 'ol'\n\t        } else {\n\t            var type = 'ul'\n\t            this.defaultStyle = Style({\n\t                listStyleType: 'decimal'\n\t            })\n\t        }\n\t\n\t\n\t        this.domNode = document.createElement(type) // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t        this.label = label\n\t\n\t        if(listInit !== undefined) {\n\t            for(var n=0; n<listInit.length; n++) {\n\t                this.item(listInit[n])\n\t            }\n\t        }\n\t\t}\n\t\n\t\tthis.item = function() {\n\t\t\tvar item = Item.apply(this, arguments)\n\t        this.add(item)\n\t        return item\n\t\t}\n\t});\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar proto = __webpack_require__(29)\n\tvar EventEmitter = __webpack_require__(25).EventEmitter\n\t\n\tvar Block = __webpack_require__(1)\n\t\n\tvar randomStart = getRandomInt(0,999999) // a random number used to start off the numbers given to radio button names (using a random number in case there are somehow two different instances of blocks.js on the page)\n\t\n\t// A group of radio buttons\n\tmodule.exports = proto(EventEmitter, function(superclass) {\n\t\n\t\t// static properties\n\t\n\t    this.name = 'Radio'\n\t\n\t\t// instance properties\n\t\n\t\n\t    // required - If true, a radio button must always be selected. Otherwise, radio buttons can be deselected by clicking on them.\n\t\tthis.init = function(required) {\n\t        //this.selected\n\t        this.required = required === true || required === undefined\n\t        this.buttons = {} // maps values to the buttons that have each value\n\t        this.randomStart = randomStart++\n\t\t}\n\t\n\t    // returns a new radio button\n\t    this.button = function(/*[label,] value*/) {\n\t        if(arguments.length >= 2) {\n\t            var label = arguments[0]\n\t            var value = arguments[1]\n\t        } else {\n\t            var value = arguments[0]\n\t        }\n\t\n\t        if(this.buttons[value] !== undefined) {\n\t            throw new Error(\"Can't give a RadioButton the same value as another in the group (value: '\"+value+\"')\")\n\t        }\n\t\n\t        var button = RadioButton(this, label, value, \"_radioblock\"+this.randomStart)\n\t        this.buttons[value] = button\n\t\n\t        if(this.required && this._selected === undefined) {\n\t            button.selected = true\n\t        }\n\t\n\t        return button\n\t    }\n\t\n\t    // returns the RadioButton in the group that's selected (or undefined if none are selected)\n\t    Object.defineProperty(this, 'selected', {\n\t        get: function() {\n\t            return this._selected\n\t        },\n\t        set: function() {\n\t            throw new Error(\"Can't set selected on a Radio object\")\n\t        }\n\t    })\n\t\n\t    Object.defineProperty(this, 'val', {\n\t        // returns the value of the selected radio button in the group (undefined if none are selected)\n\t        get: function() {\n\t            var selected = this._selected\n\t            if(selected === undefined) return undefined\n\t            // else\n\t            return selected.attr('value')\n\t        },\n\t\n\t        // sets the value of the checkbox to the passed value (true for checked)\n\t        // throws an exception if none of the radio buttons have that value\n\t        // throws an exception if an unset is attempted for a required Radio set\n\t        set: function(value) {\n\t            if(value === undefined) {\n\t                var selected = this._selected\n\t                if(selected !== undefined) {\n\t                    selected.selected = false\n\t                }\n\t            } else {\n\t                var button = this.buttons[value]\n\t                if(button === undefined) throw new Error(\"There is no RadioButton in the group with the value: '\"+value+\"'\")\n\t\n\t                button.selected = true\n\t            }\n\t        }\n\t    })\n\t\n\t\n\t    // arguments can be one of the following:\n\t        // RadioButton, RadioButton, RadioButton, ...\n\t        // value, value, value, ... - each value is the value of the RadioButton to remove\n\t        // arrayOfRadioButtons\n\t        // arrayOfValues\n\t    this.remove = function() {\n\t        if(arguments[0] instanceof Array) {\n\t            var removals = arguments[0]\n\t        } else {\n\t            var removals = arguments\n\t        }\n\t\n\t        for(var n=0; n<removals.length; n++) {\n\t            var r = removals[n]\n\t\n\t            if(r instanceof RadioButton) {\n\t                var button = r\n\t                var value = r.val\n\t\n\t                if(this.buttons[value] !== r) {\n\t                    throw new Error(\"The button passed at index \"+n+\" is not part of the group.\")\n\t                }\n\t            } else {\n\t                var button = this.buttons[r]\n\t                var value = r\n\t\n\t                if(button === undefined) {\n\t                    throw new Error(\"There is no RadioButton in the group with the value: '\"+value+\"'\")\n\t                }\n\t            }\n\t\n\t            var originalSelected = this.selected\n\t            if(this.selected === button) {\n\t                this._selected = undefined\n\t            }\n\t\n\t            this.buttons[value].group = undefined // fully remove it from the group\n\t            delete this.buttons[value]\n\t        }\n\t\n\t        if(this.required && this.selected === undefined) {\n\t            for(var v in this.buttons) {\n\t                this.buttons[v].selected = true // just select the first one\n\t                break; // yes this doesn't loop\n\t            }\n\t        } else if(originalSelected !== this.selected) {\n\t            this.emit('change')\n\t        }\n\t    }\n\t\n\t})\n\t\n\tvar RadioButton = proto(Block, function(superclass) {\n\t    this.name = 'RadioButton'\n\t\n\t    this.init = function(radioGroup, label, value, name) {\n\t        this.domNode = document.createElement(\"input\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t\n\t        this.label = label\n\t        this.group = radioGroup\n\t\n\t        this.attr('type', 'radio')\n\t        this.attr('name', name) // the name is needed so that using tab to move through page elements can tab between different radio groups\n\t        this.val = value\n\t\n\t        var that = this\n\t\t\tthis.on(\"mousedown\",function(event) {\n\t            event.preventDefault()           // this needs to be here otherwise the radio button can't be changed\n\t\n\t\t\t\tif(that.group.required) {\n\t                if(that.selected === false) {\n\t                    that.selected = true\n\t                }\n\t            } else {\n\t                that.selected = !that.selected // toggle\n\t            }\n\t\t\t})\n\t        this.on(\"click\",function(event) {\n\t            event.preventDefault()         // this needs to be here otherwise the radio button can't be *unset*\n\t        })\n\t        this.on(\"keydown\",function(event) {\n\t            if(event.keyCode === 40 || event.keyCode === 39) { // down or right\n\t                event.preventDefault()         // this needs to be here otherwise the radio button strangely calls the click handler which causes things to mess up\n\t                that.selectNext()\n\t            } else if(event.keyCode === 38 || event.keyCode === 37) { // up or left\n\t                event.preventDefault()         // this needs to be here otherwise the radio button strangely calls the click handler which causes things to mess up\n\t                that.selectPrevious()\n\t            }\n\t        })\n\t    }\n\t\n\t    Object.defineProperty(this, 'val', {\n\t        // returns the value attribute of the checkbox\n\t        get: function() {\n\t            return this.attr('value')\n\t        },\n\t\n\t        // sets the value attribute of the checkbox\n\t        set: function(value) {\n\t            if(this.group.buttons[value] !== undefined) {\n\t                throw new Error(\"Can't give a RadioButton the same value as another in the group (value: '\"+value+\"')\")\n\t            }\n\t\n\t            var oldValue = this.val\n\t            this.attr('value', value)\n\t            if(oldValue !== undefined) delete this.group.buttons[oldValue]\n\t            this.group.buttons[value] = this\n\t        }\n\t    })\n\t\n\t\n\t    Object.defineProperty(this, 'selected', {\n\t        // returns whether or not the checkbox is checked\n\t        get: function() {\n\t            return this.domNode.checked\n\t        },\n\t\n\t        // sets the selected state of the checkbox to the passed value (true for checked)\n\t        set: function(value) {\n\t            var booleanValue = value === true\n\t            if(this.selected === value) return; // ignore if there's no change\n\t\n\t            if(booleanValue) {\n\t                var previouslySelected = this.group.selected\n\t                setButtonInGroup(this.group, this)\n\t                if(previouslySelected !== undefined)\n\t                    previouslySelected.emit('change')\n\t            } else {\n\t                if(this.group.required) throw new Error(\"Can't unset this Radio set, a value is required.\")\n\t                this.domNode.checked = false\n\t                this.group._selected = undefined\n\t            }\n\t            this.emit('change') // the browser has no listenable event that is triggered on change of the 'checked' property\n\t            this.group.emit('change')\n\t        }\n\t    })\n\t\n\t    this.selectNext = function() {\n\t        selectSibling(this,1)\n\t    }\n\t    this.selectPrevious = function() {\n\t        selectSibling(this,-1)\n\t    }\n\t\n\t})\n\t\n\t// direction can be +1 or -1\n\tfunction selectSibling(button, direction) {\n\t    var buttons = button.group.buttons\n\t    var values = Object.keys(buttons)\n\t    var index = values.indexOf(button.attr('value'))\n\t    if(direction === 1 && index === values.length-1) {\n\t        var buttonToSelect = buttons[values[0]]\n\t    } else if(direction === -1 && index === 0) {\n\t        var buttonToSelect = buttons[values[values.length-1]]\n\t\n\t    } else {\n\t        var buttonToSelect = buttons[values[index+direction]]\n\t    }\n\t\n\t    buttonToSelect.selected = true\n\t    buttonToSelect.focus()\n\t}\n\t\n\tfunction setButtonInGroup(group, button) {\n\t    var selected = group._selected\n\t    if(selected !== undefined) selected.domNode.checked = false\n\t    button.domNode.checked = true\n\t    group._selected = button\n\t}\n\t\n\tfunction getRandomInt(min, max) {\n\t  return Math.floor(Math.random() * (max - min)) + min;\n\t}\n\n/***/ },\n/* 10 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(29)\n\t\n\tvar Option = __webpack_require__(20)\n\t\n\t// emits a 'change' event when its 'val' changes\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t\t// static variables\n\t\n\t    this.name = 'Select'\n\t\n\t    this.Option = Option\n\t\n\t\tthis.init = function(/*[label,] options*/) {\n\t        if(arguments[0] instanceof Object) {\n\t            var options = arguments[0]\n\t        } else {\n\t            var label = arguments[0]\n\t            var options = arguments[1]\n\t        }\n\t\n\t        this.domNode = document.createElement(\"select\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t        this.label = label\n\t\n\t        this.options = {}\n\t\n\t\t\tfor(var value in options) {\n\t\t\t\tthis.option(value, options[value])\n\t\t\t}\n\t\t}\n\t\n\t\n\t\t// instance methods\n\t\n\t    Object.defineProperty(this, 'val', {\n\t        // returns the value that is selected\n\t        get: function() {\n\t            for(var value in this.options) {\n\t                if(this.options[value].selected) {\n\t                    return value\n\t                }\n\t            }\n\t        },\n\t\n\t        set: function(value) {\n\t            var option = this.options[value]\n\t            if(option === undefined) throw new Error(\"There is no Option in the Select with the value: '\"+value+\"'\")\n\t            option.selected = true\n\t        }\n\t    })\n\t\t\n\t\tthis.option = function(/*[label,] value,text*/) {\n\t        if(arguments.length === 2) {\n\t            var value = arguments[0]\n\t            var text = arguments[1]\n\t        } else if(arguments.length === 3) {\n\t            var label = arguments[0]\n\t            var value = arguments[1]\n\t            var text = arguments[2]\n\t        } else {\n\t            throw new Error(\"Invalid number of arguments\")\n\t        }\n\t\n\t        var newOption = Option(label, value,text)\n\t        this.add(newOption)\n\t\n\t        return newOption\n\t\n\t\t}\n\t\n\t    // same interface as Block.addAt\n\t    /*override*/ this.addAt = function(index/*, nodes...*/) {\n\t        var that = this\n\t\n\t        var nodesToAdd = Block.normalizeAddAtArguments.apply(this, arguments)\n\t\n\t        // validation first\n\t        nodesToAdd.forEach(function(option) {\n\t            if(that.options[option.val] !== undefined) {\n\t                throw new Error(\"Can't give an Option the same value as another in the Select (value: '\"+option.val+\"')\")\n\t            }\n\t        })\n\t\n\t        superclass.addAt.call(this, index, nodesToAdd)\n\t\n\t        // Select specific state modifications - this must be done after the superclass call in case an error is thrown from it\n\t        var anyWereSelected = false\n\t        nodesToAdd.forEach(function(option) {\n\t            if(option.selected) anyWereSelected = true\n\t            that.options[option.val] = option\n\t\n\t            // set up Select events\n\t            // todo: remove events when the Option is removed\n\t\n\t            option.on(\"mousedown\",function(event) {\n\t                option.parent.val = option.val      // select this one\n\t            })\n\t        })\n\t\n\t        if(anyWereSelected) {\n\t            this.emit('change')\n\t        }\n\t    }\n\t\n\t    // same interface as Block.remove\n\t    /*override*/ this.remove = function() {\n\t        var that = this\n\t\n\t        var removalIndexes = Block.normalizeRemoveArguments.apply(this, arguments)\n\t        var removals = removalIndexes.map(function(index) {\n\t            return that.children[index]\n\t        })\n\t\n\t        superclass.remove.call(this, removalIndexes)\n\t\n\t        // Select specific state modifications - this must be done after the superclass call in case an error is thrown from it\n\t        var theSelectedWasRemoved = false\n\t        removals.forEach(function(option) {\n\t            if(option.selected) theSelectedWasRemoved = true\n\t            delete that.options[option.val]\n\t        })\n\t\n\t        if(theSelectedWasRemoved) {\n\t            //this.children[0].selected = true // I think the browser does this automatically??\n\t            this.emit('change')\n\t        }\n\t    }\n\t\n\t\n\t    // private\n\t\n\t    this.prepareForValueChange = function(values) {\n\t        var value = values[0]\n\t\n\t        for(var optionValue in this.options) {\n\t            if(optionValue !== value) {\n\t                var option = this.options[optionValue]\n\t                if(option.selected === true) {\n\t                    option.setSelectedQuiet(false)\n\t                }\n\t            }\n\t        }\n\t    }\n\t})\n\t\n\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar proto = __webpack_require__(29)\n\t\n\tvar Block = __webpack_require__(1)\n\tvar Style = __webpack_require__(2)\n\t\n\tvar Header = __webpack_require__(22);\n\tvar Row = __webpack_require__(23);\n\tvar Cell = __webpack_require__(24);\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t\t// static properties\n\t\n\t    this.name = 'Table'\n\t\n\t    this.defaultStyle = Style({\n\t        borderSpacing: 0\n\t    })\n\t\n\t    this.Row = Row\n\t\tthis.Header = Header\n\t    this.Cell = Cell\n\t\n\t\n\t\t// instance properties\n\t\n\t\tthis.init = function(/*[label,] tableInit*/) {\n\t\t\tif(arguments[0] instanceof Array) {\n\t            var tableInit = arguments[0]\n\t        } else {\n\t            var label = arguments[0]\n\t            var tableInit = arguments[1]\n\t        }\n\t\n\t        this.domNode = document.createElement(\"table\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t        this.label = label\n\t\n\t        if(tableInit !== undefined) {\n\t            for(var n=0; n<tableInit.length; n++) {\n\t                this.row(tableInit[n])\n\t            }\n\t        }\n\t\t}\n\t\t\n\t\tthis.header = function(/*[]label,] listOfBlocksOrText*/) {\n\t        return headerOrRegularRow(this, Header, arguments)\n\t\t}\n\t\n\t\tthis.row = function() {\n\t\t\treturn headerOrRegularRow(this, Row, arguments)\n\t\t}\n\t});\n\t\n\tfunction headerOrRegularRow(that, Prototype, args) {\n\t    var row = Prototype.apply(undefined, args)\n\t    that.add(row)\n\t    return row\n\t}\n\n/***/ },\n/* 12 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(29)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t\t// static variables\n\t\n\t    this.name = 'TextArea'\n\t\n\t\tthis.init = function(label) {\n\t        this.domNode = document.createElement(\"textarea\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t\t\tthis.label = label\n\t\t}\n\t\n\t\n\t\t// instance properties\n\t\n\t\n\t    Object.defineProperty(this, 'val', {\n\t        // returns the value of the Option\n\t        get: function() {\n\t            return this.domNode.value\n\t        },\n\t\n\t        // sets the value of the Option\n\t        set: function(value) {\n\t            if(this.val === value) return; // do nothing if there's no change\n\t\n\t            this.domNode.value = value\n\t            this.emit('change')\n\t        }\n\t    })\n\t});\n\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(29)\n\t\n\tvar domUtils = __webpack_require__(19)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t\t// static properties\n\t\n\t    this.name = 'TextField'\n\t\n\t\tthis.init = function(/*[label,] password*/) {\n\t        if(arguments.length === 1) {\n\t            var password = arguments[0]\n\t        } else if(arguments.length > 1) {\n\t            var label = arguments[0]\n\t            var password = arguments[1]\n\t        }\n\t\n\t        this.domNode = document.createElement(\"input\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t        superclass.init.call(this) // superclass constructor\n\t\n\t\t\tthis.label = label\n\t        this.domNode.className = 'field'\n\t\t\tdomUtils.setAttribute(this.domNode,'type','text');\n\t        if(password)\n\t            domUtils.setAttribute(this.domNode, 'type', 'password')\n\t\t}\n\t\n\t\n\t\t// instance properties\n\t\n\t    Object.defineProperty(this, 'val', {\n\t        // returns the value of the Option\n\t        get: function() {\n\t            return this.domNode.value\n\t        },\n\t\n\t        // sets the value of the Option\n\t        set: function(value) {\n\t            if(this.val === value) return; // do nothing if there's no change\n\t\n\t            this.domNode.value = value\n\t            this.emit('change')\n\t        }\n\t    })\n\t\n\t});\n\n\n/***/ },\n/* 14 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(29)\n\tvar Style = __webpack_require__(2)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t    //static properties\n\t\n\t    this.name = 'Text'\n\t\n\t    this.defaultStyle = Style({\n\t        whiteSpace: 'pre'\n\t    })\n\t\n\t    this.init = function(/*[label,] text*/) {\n\t        if(arguments.length === 1) {\n\t            var text = arguments[0]\n\t        } else {\n\t            var label = arguments[0]\n\t            var text = arguments[1]\n\t        }\n\t\n\t        if (text === undefined) text = '';\n\t\n\t        superclass.init.call(this) // superclass constructor\n\t\n\t        var that = this\n\t\n\t        this.label = label\n\t        this.text = text\n\t\n\t        this.on(\"input\",function(data) {\n\t            var eventData = {newText:data.srcElement.textContent,oldText:that.oldText};\n\t            that.oldText = eventData.newText;\n\t            //that.emit(\"input\",eventData);\n\t        });\n\t\n\t        this.on(\"blur\",function(data) {\n\t            var eventData = {newText:data.srcElement.textContent,oldText:that.lastFocus};\n\t            that.lastFocus = eventData.newText;\n\t            //that.emit(\"blur\",eventData);\n\t        });\n\t    }\n\t\n\t    // instance properties\n\t\n\t    Object.defineProperty(this, 'text', {\n\t        get: function() {\n\t            return this.domNode.textContent\n\t        }, set: function(v) {\n\t            this.domNode.innerText = v   // apparently textContent can't be set or something\n\t        }\n\t    })\n\t});\n\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/*\r\n\t * JSS v0.6 - JavaScript Stylesheets\r\n\t * https://github.com/Box9/jss\r\n\t *\r\n\t * Copyright (c) 2011, David Tang\r\n\t * MIT Licensed (http://www.opensource.org/licenses/mit-license.php)\r\n\t */\r\n\tvar jss = (function() {\r\n\t    var adjSelAttrRegex = /((?:\\.|#)[^\\.\\s#]+)((?:\\.|#)[^\\.\\s#]+)/g;\r\n\t    var doubleColonPseudoElRegex = /(::)(before|after|first-line|first-letter|selection)/;\r\n\t    var singleColonPseudoElRegex = /([^:])(:)(before|after|first-line|first-letter|selection)/;\r\n\t    var singleColonForPseudoElements; // flag for older browsers\r\n\t\r\n\t    function getSelectorsAndRules(sheet) {\r\n\t        var rules = sheet.cssRules || sheet.rules || [];\r\n\t        var results = {};\r\n\t        for (var i = 0; i < rules.length; i++) {\r\n\t            // Older browsers and FF report pseudo element selectors in an outdated format\r\n\t            var selectorText = toDoubleColonPseudoElements(rules[i].selectorText);\r\n\t            if (!results[selectorText]) {\r\n\t                results[selectorText] = [];\r\n\t            }\r\n\t            results[selectorText].push({\r\n\t                sheet: sheet,\r\n\t                index: i,\r\n\t                style: rules[i].style\r\n\t            });\r\n\t        }\r\n\t        return results;\r\n\t    }\r\n\t\r\n\t    function getRules(sheet, selector) {\r\n\t        var rules = sheet.cssRules || sheet.rules || [];\r\n\t        var results = [];\r\n\t        // Browsers report selectors in lowercase\r\n\t        selector = selector.toLowerCase();\r\n\t        for (var i = 0; i < rules.length; i++) {\r\n\t            var selectorText = rules[i].selectorText;\r\n\t            // Note - certain rules (e.g. @rules) don't have selectorText\r\n\t            if (selectorText && (selectorText == selector || selectorText == swapAdjSelAttr(selector) || selectorText == swapPseudoElSyntax(selector))) {\r\n\t                results.push({\r\n\t                    sheet: sheet,\r\n\t                    index: i,\r\n\t                    style: rules[i].style\r\n\t                });\r\n\t            }\r\n\t        }\r\n\t        return results;\r\n\t    }\r\n\t\r\n\t    function addRule(sheet, selector) {\r\n\t        var rules = sheet.cssRules || sheet.rules || [];\r\n\t        var index = rules.length;\r\n\t        var pseudoElementRule = addPseudoElementRule(sheet, selector, rules, index);\r\n\t\r\n\t        if (!pseudoElementRule) {\r\n\t            addRuleToSheet(sheet, selector, index);\r\n\t        }\r\n\t\r\n\t        return {\r\n\t            sheet: sheet,\r\n\t            index: index,\r\n\t            style: rules[index].style\r\n\t        };\r\n\t    };\r\n\t\r\n\t    function addRuleToSheet(sheet, selector, index) {\r\n\t        if (sheet.insertRule) {\r\n\t            sheet.insertRule(selector + ' { }', index);\r\n\t        } else {\r\n\t            sheet.addRule(selector, null, index);\r\n\t        }\r\n\t    }\r\n\t\r\n\t    // Handles single colon syntax for older browsers and bugzilla.mozilla.org/show_bug.cgi?id=949651\r\n\t    function addPseudoElementRule(sheet, selector, rules, index) {\r\n\t        var doubleColonSelector;\r\n\t        var singleColonSelector;\r\n\t\r\n\t        if (doubleColonPseudoElRegex.exec(selector)) {\r\n\t            doubleColonSelector = selector;\r\n\t            singleColonSelector = toSingleColonPseudoElements(selector);\r\n\t        } else if (singleColonPseudoElRegex.exec(selector)) {\r\n\t            doubleColonSelector = toDoubleColonPseudoElements(selector);\r\n\t            singleColonSelector = selector;\r\n\t        } else {\r\n\t            return false; // Not dealing with a pseudo element\r\n\t        }\r\n\t\r\n\t        if (!singleColonForPseudoElements) {\r\n\t            // Assume modern browser and then check if successful\r\n\t            addRuleToSheet(sheet, doubleColonSelector, index);\r\n\t            if (rules.length <= index) {\r\n\t                singleColonForPseudoElements = true;\r\n\t            }\r\n\t        }\r\n\t        if (singleColonForPseudoElements) {\r\n\t            addRuleToSheet(sheet, singleColonSelector, index);\r\n\t        }\r\n\t\r\n\t        return true;\r\n\t    }\r\n\t\r\n\t    function toDoubleColonPseudoElements(selector) {\r\n\t        return selector.replace(singleColonPseudoElRegex, function (match, submatch1, submatch2, submatch3) {\r\n\t            return submatch1 + '::' + submatch3;\r\n\t        });\r\n\t    }\r\n\t\r\n\t    function toSingleColonPseudoElements(selector) {\r\n\t        return selector.replace(doubleColonPseudoElRegex, function(match, submatch1, submatch2) {\r\n\t            return ':' + submatch2;\r\n\t        })\r\n\t    }\r\n\t\r\n\t    function removeRule(rule) {\r\n\t        var sheet = rule.sheet;\r\n\t        if (sheet.deleteRule) {\r\n\t            sheet.deleteRule(rule.index);\r\n\t        } else if (sheet.removeRule) {\r\n\t            sheet.removeRule(rule.index);\r\n\t        }\r\n\t    }\r\n\t\r\n\t    function extend(dest, src) {\r\n\t        for (var key in src) {\r\n\t            if (!src.hasOwnProperty(key))\r\n\t                continue;\r\n\t            dest[key] = src[key];\r\n\t        }\r\n\t        return dest;\r\n\t    }\r\n\t\r\n\t    function aggregateStyles(rules) {\r\n\t        var aggregate = {};\r\n\t        for (var i = 0; i < rules.length; i++) {\r\n\t            extend(aggregate, declaredProperties(rules[i].style));\r\n\t        }\r\n\t        return aggregate;\r\n\t    }\r\n\t\r\n\t    function declaredProperties(style) {\r\n\t        var declared = {};\r\n\t        for (var i = 0; i < style.length; i++) {\r\n\t            declared[style[i]] = style[toCamelCase(style[i])];\r\n\t        }\r\n\t        return declared;\r\n\t    }\r\n\t\r\n\t    // IE9 stores rules with attributes (classes or ID's) adjacent in the opposite order as defined\r\n\t    // causing them to not be found, so this method swaps [#|.]sel1[#|.]sel2 to become [#|.]sel2[#|.]sel1\r\n\t    function swapAdjSelAttr(selector) {\r\n\t        var swap = '';\r\n\t        var lastIndex = 0;\r\n\t\r\n\t        while ((match = adjSelAttrRegex.exec(selector)) != null) {\r\n\t            if (match[0] === '')\r\n\t                break;\r\n\t            swap += selector.substring(lastIndex, match.index);\r\n\t            swap += selector.substr(match.index + match[1].length, match[2].length);\r\n\t            swap += selector.substr(match.index, match[1].length);\r\n\t            lastIndex = match.index + match[0].length;\r\n\t        }\r\n\t        swap += selector.substr(lastIndex);\r\n\t\r\n\t        return swap;\r\n\t    };\r\n\t\r\n\t    // FF and older browsers store rules with pseudo elements using single-colon syntax\r\n\t    function swapPseudoElSyntax(selector) {\r\n\t        if (doubleColonPseudoElRegex.exec(selector)) {\r\n\t            return toSingleColonPseudoElements(selector);\r\n\t        }\r\n\t        return selector;\r\n\t    }\r\n\t\r\n\t    function setStyleProperties(rule, properties) {\r\n\t        for (var key in properties) {\r\n\t            var value = properties[key];\r\n\t            var importantIndex = value.indexOf(' !important');\r\n\t\r\n\t            // Modern browsers seem to handle overrides fine, but IE9 doesn't\r\n\t            rule.style.removeProperty(key);\r\n\t            if (importantIndex > 0) {\r\n\t                rule.style.setProperty(key, value.substr(0, importantIndex), 'important');\r\n\t            } else {\r\n\t                rule.style.setProperty(key, value);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    function toCamelCase(str) {\r\n\t        return str.replace(/-([a-z])/g, function (match, submatch) {\r\n\t            return submatch.toUpperCase();\r\n\t        });\r\n\t    }\r\n\t\r\n\t    function transformCamelCasedPropertyNames(oldProps) {\r\n\t        var newProps = {};\r\n\t        for (var key in oldProps) {\r\n\t            newProps[unCamelCase(key)] = oldProps[key];\r\n\t        }\r\n\t        return newProps;\r\n\t    }\r\n\t\r\n\t    function unCamelCase(str) {\r\n\t        return str.replace(/([A-Z])/g, function(match, submatch) {\r\n\t            return '-' + submatch.toLowerCase();\r\n\t        });\r\n\t    }\r\n\t\r\n\t    var Jss = function(doc) {\r\n\t        this.doc = doc;\r\n\t        this.head = this.doc.head || this.doc.getElementsByTagName('head')[0];\r\n\t        this.sheets = this.doc.styleSheets || [];\r\n\t    };\r\n\t\r\n\t    Jss.prototype = {\r\n\t        // Returns JSS rules (selector is optional)\r\n\t        get: function(selector) {\r\n\t            if (!this.defaultSheet) {\r\n\t                return {};\r\n\t            }\r\n\t            if (selector) {\r\n\t                return aggregateStyles(getRules(this.defaultSheet, selector));\r\n\t            }\r\n\t            var rules = getSelectorsAndRules(this.defaultSheet);\r\n\t            for (selector in rules) {\r\n\t                rules[selector] = aggregateStyles(rules[selector]);\r\n\t            }\r\n\t            return rules;\r\n\t        },\r\n\t        // Returns all rules (selector is required)\r\n\t        getAll: function(selector) {\r\n\t            var properties = {};\r\n\t            for (var i = 0; i < this.sheets.length; i++) {\r\n\t                extend(properties, aggregateStyles(getRules(this.sheets[i], selector)));\r\n\t            }\r\n\t            return properties;\r\n\t        },\r\n\t        // Adds JSS rules for the selector based on the given properties\r\n\t        set: function(selector, properties) {\r\n\t            if (!this.defaultSheet) {\r\n\t                this.defaultSheet = this._createSheet();\r\n\t            }\r\n\t            properties = transformCamelCasedPropertyNames(properties);\r\n\t            var rules = getRules(this.defaultSheet, selector);\r\n\t            if (!rules.length) {\r\n\t                rules = [addRule(this.defaultSheet, selector)];\r\n\t            }\r\n\t            for (var i = 0; i < rules.length; i++) {\r\n\t                setStyleProperties(rules[i], properties);\r\n\t            }\r\n\t        },\r\n\t        // Removes JSS rules (selector is optional)\r\n\t        remove: function(selector) {\r\n\t            if (!this.defaultSheet)\r\n\t                return;\r\n\t            if (!selector) {\r\n\t                this._removeSheet(this.defaultSheet);\r\n\t                delete this.defaultSheet;\r\n\t                return;\r\n\t            }\r\n\t            var rules = getRules(this.defaultSheet, selector);\r\n\t            for (var i = 0; i < rules.length; i++) {\r\n\t                removeRule(rules[i]);\r\n\t            }\r\n\t            return rules.length;\r\n\t        },\r\n\t        _createSheet: function() {\r\n\t            var styleNode = this.doc.createElement('style');\r\n\t            styleNode.type = 'text/css';\r\n\t            styleNode.rel = 'stylesheet';\r\n\t            this.head.appendChild(styleNode);\r\n\t            return styleNode.sheet;\r\n\t        },\r\n\t        _removeSheet: function(sheet) {\r\n\t            var node = sheet.ownerNode;\r\n\t            node.parentNode.removeChild(node);\r\n\t        }\r\n\t    };\r\n\t\r\n\t    var exports = new Jss(document);\r\n\t    exports.forDocument = function(doc) {\r\n\t        return new Jss(doc);\r\n\t    };\r\n\t    return exports;\r\n\t})();\r\n\t\r\n\ttypeof module !== 'undefined' && module.exports && (module.exports = jss); // CommonJS support\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// utilities needed by the configuration (excludes dependencies the configs don't need so the webpack bundle is lean)\r\n\t\r\n\tvar path = __webpack_require__(31)\r\n\t\r\n\t\r\n\t// Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1\r\n\t// any number of objects can be passed into the function and will be merged into the first argument in order\r\n\t// returns obj1 (now mutated)\r\n\tvar merge = exports.merge = function(obj1, obj2/*, moreObjects...*/){\r\n\t    return mergeInternal(arrayify(arguments), false)\r\n\t}\r\n\t\r\n\t// like merge, but traverses the whole object tree\r\n\t// the result is undefined for objects with circular references\r\n\tvar deepMerge = exports.deepMerge = function(obj1, obj2/*, moreObjects...*/) {\r\n\t    return mergeInternal(arrayify(arguments), true)\r\n\t}\r\n\t\r\n\t// returns a new object where properties of b are merged onto a (a's properties may be overwritten)\r\n\texports.objectConjunction = function(a, b) {\r\n\t    var objectCopy = {}\r\n\t    merge(objectCopy, a)\r\n\t    merge(objectCopy, b)\r\n\t    return objectCopy\r\n\t}\r\n\t\r\n\t// turns an array of values into a an object where those values are all keys that point to 'true'\r\n\texports.arrayToMap = function(array) {\r\n\t    var result = {}\r\n\t    array.forEach(function(v) {\r\n\t        result[v] = true\r\n\t    })\r\n\t    return result\r\n\t}\r\n\t\r\n\tfunction mergeInternal(objects, deep) {\r\n\t    var obj1 = objects[0]\r\n\t    var obj2 = objects[1]\r\n\t\r\n\t    for(var key in obj2){\r\n\t       if(Object.hasOwnProperty.call(obj2, key)) {\r\n\t            if(deep && obj1[key] instanceof Object && obj2[key] instanceof Object) {\r\n\t                mergeInternal([obj1[key], obj2[key]], true)\r\n\t            } else {\r\n\t                obj1[key] = obj2[key]\r\n\t            }\r\n\t       }\r\n\t    }\r\n\t\r\n\t    if(objects.length > 2) {\r\n\t        var newObjects = [obj1].concat(objects.slice(2))\r\n\t        return mergeInternal(newObjects, deep)\r\n\t    } else {\r\n\t        return obj1\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction arrayify(a) {\r\n\t    return Array.prototype.slice.call(a, 0)\r\n\t}\r\n\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// some functionality that is needed by Block.js but is related to styling (some things are also needed by Style.js)\r\n\t\r\n\tvar HashMap = __webpack_require__(26)\r\n\t\r\n\tvar Style = __webpack_require__(2)\r\n\tvar utils = __webpack_require__(16)\r\n\t\r\n\texports.defaultStyleMap = new HashMap() // maps from a proto class to its computed default style\r\n\t\r\n\t// propogates a style-set change to a set of components\r\n\t    // styleMap should be a *copy* of a Style's componentStyleMap property (because it will be modified)\r\n\tvar propogateStyleSet = exports.propogateStyleSet = function (components, styleMap) {\r\n\t    for(var n=0; n<components.length; n++) {\r\n\t        var c = components[n]\r\n\t\r\n\t        // object inherits style if its in the styleSet and if it doesn't have an explicitly set style\r\n\t        if(c._style === undefined) {\r\n\t            if(styleMap === undefined) {\r\n\t                setCurrentStyle(c, undefined)\r\n\t            } else {\r\n\t                var styleFromMap = getStyleForComponent(styleMap, c)\r\n\t                if(styleFromMap !== undefined) {\r\n\t                    setCurrentStyle(c, styleFromMap)\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        // set the computed style set\r\n\t        var mainStyle; // the style directly given to a component, either its `style` property, or its inherited style\r\n\t        if(c._style !== undefined) {\r\n\t            mainStyle = c._style.get(c)\r\n\t        } else if(styleMap !== undefined) {\r\n\t            mainStyle = getStyleForComponent(styleMap, c)\r\n\t            if(mainStyle !== undefined) {\r\n\t                mainStyle = mainStyle.get(c) // get the specific style (taking into account any label)\r\n\t            }\r\n\t        }\r\n\t\r\n\t        if(mainStyle !== undefined) {\r\n\t            if(styleMap !== undefined) {\r\n\t                c.computedStyleMap = styleMapConjunction(styleMap, mainStyle.componentStyleMap)\r\n\t            } else {\r\n\t                c.computedStyleMap = mainStyle.componentStyleMap\r\n\t            }\r\n\t        } else {\r\n\t            c.computedStyleMap = styleMap\r\n\t        }\r\n\t\r\n\t        propogateStyleSet(c.children, c.computedStyleMap)\r\n\t    }\r\n\t}\r\n\t\r\n\t// gets the right style from the styleMap\r\n\t// takes the component's inheritance tree into account (relies on the block.constructor.parent property)\r\n\tvar getStyleForComponent = exports.getStyleForComponent = function (styleMap, block) {\r\n\t    var constructor = block.constructor\r\n\t    while(constructor !== undefined) {\r\n\t        var style = styleMap[constructor.name]\r\n\t        if(style !== undefined) {\r\n\t            return style\r\n\t        } else {\r\n\t            constructor = constructor.parent\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\t// returns the conjunction of two style maps\r\n\t// gets it from the computedStyles cache if its already in there\r\n\tvar styleMapConjunction = exports.styleMapConjunction = function (secondaryStyleMap, primaryStyleMap) {\r\n\t    var cachedStyleMap = Style.computedStyles.get([secondaryStyleMap, primaryStyleMap])\r\n\t    if(cachedStyleMap === undefined) {\r\n\t        cachedStyleMap = utils.objectConjunction(secondaryStyleMap, primaryStyleMap)\r\n\t        Style.computedStyles.set([secondaryStyleMap, primaryStyleMap], cachedStyleMap)\r\n\t    }\r\n\t\r\n\t    return cachedStyleMap\r\n\t}\r\n\t\r\n\t// takes labels into account\r\n\tvar setCurrentStyle = exports.setCurrentStyle = function (component, style) {\r\n\t    if(style === component.currentStyle) return; // do nothing\r\n\t\r\n\t    if(style !== undefined)\r\n\t        var specificStyle = style.get(component)\r\n\t    else\r\n\t        var specificStyle = style\r\n\t\r\n\t    setStyleClass(component, specificStyle)\r\n\t    applyStyleKillFunction(component)\r\n\t    component.currentStyle = specificStyle\r\n\t    applyStyleSetupFunction(component, specificStyle)\r\n\t}\r\n\t\r\n\t\r\n\texports.createDefaultBlockStyle = function (that) {\r\n\t    if(that.defaultStyle !== undefined) {\r\n\t        validateDefaultStyle(that.defaultStyle)\r\n\t    }\r\n\t\r\n\t    // get list of default styles\r\n\t    var defaultStyles = []\r\n\t    var nextConstructor = that.constructor\r\n\t    while(nextConstructor !== undefined) {\r\n\t        if(nextConstructor.defaultStyle !== undefined) {\r\n\t            defaultStyles.push(nextConstructor.defaultStyle)\r\n\t        }\r\n\t        nextConstructor = nextConstructor.parent\r\n\t    }\r\n\t\r\n\t    // generate merged default style\r\n\t    var defaultStyleSet = {}\r\n\t    defaultStyles.reverse().forEach(function(style) {\r\n\t        for(var k in style.styleDefinitions) {\r\n\t            utils.merge(defaultStyleSet, style.styleDefinitions[k])\r\n\t            break; // just do first key (shouldn't be more than one key, because only simple stylings are allowed for default styles)\r\n\t        }\r\n\t\r\n\t    })\r\n\t\r\n\t    if(Object.keys(defaultStyleSet).length > 0)\r\n\t        var defaultBlockStyle = Style(defaultStyleSet, {default:true})\r\n\t    else\r\n\t        var defaultBlockStyle = false // no special default\r\n\t\r\n\t    exports.defaultStyleMap.set(that.constructor, defaultBlockStyle)\r\n\t    return defaultBlockStyle\r\n\t}\r\n\t\r\n\t\r\n\t// applies setup appropriately\r\n\tfunction applyStyleSetupFunction(component, style) {\r\n\t    if(style !== undefined && style.setup !== undefined) {\r\n\t        component._styleSetupObject = style.setup(component) // call setup on the component\r\n\t    } else {\r\n\t        component._styleSetupObject = undefined\r\n\t    }\r\n\t}\r\n\t// applies kill appropriately\r\n\tfunction applyStyleKillFunction(component) {\r\n\t    var currentStyle = component.currentStyle\r\n\t    if(currentStyle !== undefined && currentStyle.setup !== undefined) {\r\n\t        if(currentStyle.kill === undefined)\r\n\t            throw new Error('style has been unset but does not have a \"kill\" function to undo its \"setup\" function')\r\n\t\r\n\t        currentStyle.kill(component, component._styleSetupObject)\r\n\t    }\r\n\t}\r\n\t\r\n\t// sets the style, replacing one if one already exists\r\n\tfunction setStyleClass(component, style) {\r\n\t    var currentStyle = component.currentStyle\r\n\t    if(currentStyle !== undefined) {\r\n\t        component.domNode.className = component.domNode.className.replace(new RegExp(\" ?\\\\b\"+currentStyle.className+\"\\\\b\"),'') // remove the previous css class\r\n\t    }\r\n\t    if(style !== undefined) {\r\n\t        component.domNode.className = style.className+' '+component.domNode.className.trim() // note that the order of classes doesn't matter\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction validateDefaultStyle(defaultStyle) {\r\n\t    if(!(defaultStyle instanceof Style)) {\r\n\t        throw new Error(\"defaultStyle property must be a Style object\")\r\n\t    } else if(\r\n\t        defaultStyle.setup !== undefined || defaultStyle.kill !== undefined ||\r\n\t        Object.keys(defaultStyle.componentStyleMap).length > 0 || Object.keys(defaultStyle.labelStyleMap).length > 0 /*||\r\n\t        Object.keys(defaultStyle.pseudoClassStyles).length > 0*/\r\n\t    ) {\r\n\t        throw new Error(\"A Block's defaultStyle can only contain basic css stylings, no Block, label, or pseudoclass stylings, nor run/kill javascript\")\r\n\t    }\r\n\t}\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar EventEmitter = __webpack_require__(25).EventEmitter\r\n\tvar proto = __webpack_require__(29)\r\n\tvar utils = __webpack_require__(16)\r\n\t\r\n\tmodule.exports = proto(EventEmitter, function(superclass) {\r\n\t\r\n\t    this.init = function() {\r\n\t        superclass.apply(this, arguments)\r\n\t\r\n\t        this.ifonHandlers = {}\r\n\t        this.ifoffHandlers = {}\r\n\t        this.ifonAllHandlers = []\r\n\t        this.ifoffAllHandlers = []\r\n\t    }\r\n\t\r\n\t    // callback will be triggered immediately if there is already a listener attached, or\r\n\t    // callback will be triggered when the first listener for the event is added\r\n\t    // (regardless of whether its done through on or once)\r\n\t    // parameters can be:\r\n\t        // event, callback - attach an ifon handler for the passed event\r\n\t        // callback - attach an ifon handler for all events\r\n\t    this.ifon = function(event, callback) {\r\n\t        if(event instanceof Function) {     // event not passed, only a callback\r\n\t            callback = event // fix the argument\r\n\t            for(var eventName in this._events) {\r\n\t                if(this.listeners(eventName).length > 0) {\r\n\t                    callback(eventName)\r\n\t                }\r\n\t            }\r\n\t        } else if(this.listeners(event).length > 0) {\r\n\t            callback(event)\r\n\t        }\r\n\t\r\n\t        addHandlerToList(this, 'ifonHandlers', event, callback)\r\n\t    }\r\n\t\r\n\t    // removes either:\r\n\t        // removeIfon() - all ifon handlers (if no arguments are passed), or\r\n\t        // removeIfon(event) - all ifon handlers for the passed event, or\r\n\t        // removeIfon(callback) - the passed ifon-all handler (if the first parameter is the callback)\r\n\t        // removeIfon(event, callback) - the specific passed callback for the passed event\r\n\t    this.removeIfon = function(event, callback) {\r\n\t        removeFromHandlerList(this, 'ifonHandlers', event, callback)\r\n\t    }\r\n\t\r\n\t    // callback will be triggered when the last listener for the 'click' event is removed (will not trigger immediately if there is no event listeners on call of ifoff)\r\n\t    // (regardless of whether this is done through removeListener or as a result of 'once' being fulfilled)\r\n\t    // parameters can be:\r\n\t        // event, callback - attach an ifoff handler for the passed event\r\n\t        // callback - attach an ifoff handler for all events\r\n\t    this.ifoff = function(event, callback) {\r\n\t        addHandlerToList(this, 'ifoffHandlers', event, callback)\r\n\t    }\r\n\t\r\n\t    // removes either:\r\n\t        // removeIfoff() - all ifoff handlers (if no arguments are passed), or\r\n\t        // removeIfoff(event) - all ifoff handlers for the passed event, or\r\n\t        // removeIfoff(callback) - the passed ifoff-all handler (if the first parameter is the callback)\r\n\t        // removeIfoff(event, callback) - the specific passed callback for the passed event\r\n\t    this.removeIfoff = function(event, callback) {\r\n\t        removeFromHandlerList(this, 'ifoffHandlers', event, callback)\r\n\t    }\r\n\t\r\n\t    // emitter is the emitter to proxy handler binding to\r\n\t    // options can have one of the following properties:\r\n\t        // only - an array of events to proxy\r\n\t        // except - an array of events to *not* proxy\r\n\t    this.proxy = function(emitter, options) {\r\n\t        if(options === undefined) options = {}\r\n\t        if(options.except !== undefined) {\r\n\t            var except = utils.arrayToMap(options.except)\r\n\t            var handleIt = function(event){return !(event in except)}\r\n\t        } else if(options.only !== undefined) {\r\n\t            var only = utils.arrayToMap(options.only)\r\n\t            var handleIt = function(event){return event in only}\r\n\t        } else {\r\n\t            var handleIt = function(){return true}\r\n\t        }\r\n\t\r\n\t        var that = this, handler;\r\n\t        this.ifon(function(event) {\r\n\t            if(handleIt(event)) {\r\n\t                emitter.on(event, handler = function() {\r\n\t                    that.emit.apply(that, [event].concat(Array.prototype.slice.call(arguments)))\r\n\t                })\r\n\t            }\r\n\t        })\r\n\t        this.ifoff(function(event) {\r\n\t            if(handleIt(event))\r\n\t                emitter.off(event, handler)\r\n\t        })\r\n\t    }\r\n\t\r\n\t    /*override*/ this.on = this.addListener = function(event, callback) {\r\n\t        var triggerIfOn = this.listeners(event).length === 0\r\n\t        superclass.prototype.on.apply(this,arguments)\r\n\t        if(triggerIfOn) triggerIfHandlers(this, 'ifonHandlers', event)\r\n\t    }\r\n\t\r\n\t    /*override*/ this.off = this.removeListener = function(event, callback) {\r\n\t        var triggerIfOff = this.listeners(event).length === 1\r\n\t        superclass.prototype.removeListener.apply(this,arguments)\r\n\t        if(triggerIfOff) triggerIfHandlers(this, 'ifoffHandlers', event)\r\n\t    }\r\n\t    /*override*/ this.removeAllListeners = function(event) {\r\n\t        var triggerIfOffForEvents = []\r\n\t        if(event !== undefined) {\r\n\t            if(this.listeners(event).length > 0) {\r\n\t                triggerIfOffForEvents.push(event)\r\n\t            }\r\n\t        } else {\r\n\t            for(var event in this._events) {\r\n\t                if(this.listeners(event).length > 0) {\r\n\t                    triggerIfOffForEvents.push(event)\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        superclass.prototype.removeAllListeners.apply(this,arguments)\r\n\t\r\n\t        for(var n=0; n<triggerIfOffForEvents.length; n++) {\r\n\t            triggerIfHandlers(this, 'ifoffHandlers', triggerIfOffForEvents[n])\r\n\t        }\r\n\t    }\r\n\t\r\n\t})\r\n\t\r\n\t\r\n\t// triggers the if handlers from the normal list and the \"all\" list\r\n\tfunction triggerIfHandlers(that, handlerListName, event) {\r\n\t    triggerIfHandlerList(that[handlerListName][event], event)\r\n\t    triggerIfHandlerList(that[normalHandlerToAllHandlerProperty(handlerListName)], event)\r\n\t}\r\n\t\r\n\t\r\n\t// triggers the if handlers from a specific list\r\n\t// ya these names are confusing, sorry : (\r\n\tfunction triggerIfHandlerList(handlerList, event) {\r\n\t    if(handlerList !== undefined) {\r\n\t        for(var n=0; n<handlerList.length; n++) {\r\n\t            handlerList[n](event)\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction addHandlerToList(that, handlerListName, event, callback) {\r\n\t    if(event instanceof Function) {\r\n\t        // correct arguments\r\n\t        callback = event\r\n\t        event = undefined\r\n\t    }\r\n\t\r\n\t    if(event !== undefined && callback !== undefined) {\r\n\t        var handlerList = that[handlerListName][event]\r\n\t        if(handlerList === undefined) {\r\n\t            handlerList = that[handlerListName][event] = []\r\n\t        }\r\n\t\r\n\t        handlerList.push(callback)\r\n\t    } else {\r\n\t        that[normalHandlerToAllHandlerProperty(handlerListName)].push(callback)\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction removeFromHandlerList(that, handlerListName, event, callback) {\r\n\t    if(event instanceof Function) {\r\n\t        // correct arguments\r\n\t        callback = event\r\n\t        event = undefined\r\n\t    }\r\n\t\r\n\t    if(event !== undefined && callback !== undefined) {\r\n\t        removeCallbackFromList(that[handlerListName][event], callback)\r\n\t    } else if(event !== undefined) {\r\n\t        delete that[handlerListName][event]\r\n\t    } else if(callback !== undefined) {\r\n\t        var allHandlerListName = normalHandlerToAllHandlerProperty(handlerListName)\r\n\t        removeCallbackFromList(that[allHandlerListName], callback)\r\n\t    } else {\r\n\t        var allHandlerListName = normalHandlerToAllHandlerProperty(handlerListName)\r\n\t        that[handlerListName] = {}\r\n\t        that[allHandlerListName] = []\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction normalHandlerToAllHandlerProperty(handlerListName) {\r\n\t    if(handlerListName === 'ifonHandlers')\r\n\t        return 'ifonAllHandlers'\r\n\t    if(handlerListName === 'ifoffHandlers')\r\n\t        return 'ifoffAllHandlers'\r\n\t}\r\n\t\r\n\tfunction removeCallbackFromList(list, callback) {\r\n\t    var index = list.indexOf(callback)\r\n\t    list.splice(index,1)\r\n\t}\n\n/***/ },\n/* 19 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\r\n\t// creates a dom element optionally with a class and attributes\r\n\t var node = module.exports.node = function(type, className, options) {\r\n\t    var elem = document.createElement(type)\r\n\t\r\n\t    if(options !== undefined) {\r\n\t        if(options.attr !== undefined) {\r\n\t            for(var attribute in options.attr) {\r\n\t                createAttribute(elem, attribute, options.attr[attribute])\r\n\t            }\r\n\t        }\r\n\t        if(options.textContent !== undefined) {\r\n\t            elem.textContent = options.textContent\r\n\t        }\r\n\t    }\r\n\t\r\n\t    if(className !== undefined)\r\n\t        elem.className = className\r\n\t\r\n\t    return elem\r\n\t}\r\n\t\r\n\t// convenience function for creating a div\r\n\tmodule.exports.div = function(className, options) {\r\n\t    return node('div', className, options)\r\n\t}\r\n\t\r\n\t// adds an attribute to a domNode\r\n\tvar setAttribute = module.exports.setAttribute = function(/*[domNode,] type, value*/) {\r\n\t    if (arguments.length === 2) {\r\n\t        var domNode = this.domNode;\r\n\t        var type = arguments[0];\r\n\t        var value = arguments[1];\r\n\t    } else if (arguments.length === 3) {\r\n\t        var domNode = arguments[0];\r\n\t        var type = arguments[1];\r\n\t        var value = arguments[2];\r\n\t    } else {\r\n\t        throw new Error(\"This function expects arguments to be: [domNode,] type, value\");\r\n\t    }\r\n\t    var attr = document.createAttribute(type)\r\n\t    attr.value = value\r\n\t    domNode.setAttributeNode(attr)\r\n\t}\r\n\t\r\n\t\r\n\t// sets the selection\r\n\t//\r\n\t// works for contenteditable elements\r\n\texports.setSelectionRange = function(containerEl, start, end) {\r\n\t\r\n\t    if(containerEl.nodeName === 'INPUT' || containerEl.nodeName === 'TEXTAREA') {\r\n\t        containerEl.setSelectionRange(start, end)\r\n\t    } else {\r\n\t        var charIndex = 0, range = document.createRange();\r\n\t        range.setStart(containerEl, 0);\r\n\t        range.collapse(true);\r\n\t        var foundStart = false;\r\n\t\r\n\t        iterateThroughLeafNodes(containerEl, function(node) {\r\n\t            var hiddenCharacters = findHiddenCharacters(node, node.length)\r\n\t            var nextCharIndex = charIndex + node.length - hiddenCharacters;\r\n\t\r\n\t            if (!foundStart && start >= charIndex && start <= nextCharIndex) {\r\n\t                var nodeIndex = start-charIndex\r\n\t                var hiddenCharactersBeforeStart = findHiddenCharacters(node, nodeIndex)\r\n\t                range.setStart(node, nodeIndex + hiddenCharactersBeforeStart);\r\n\t                foundStart = true;\r\n\t            }\r\n\t\r\n\t            if (foundStart && end >= charIndex && end <= nextCharIndex) {\r\n\t                var nodeIndex = end-charIndex\r\n\t                var hiddenCharactersBeforeEnd = findHiddenCharacters(node, nodeIndex)\r\n\t                range.setEnd(node, nodeIndex + hiddenCharactersBeforeEnd);\r\n\t                return true; // stop the iteration - we're done here\r\n\t            }\r\n\t\r\n\t            charIndex = nextCharIndex\r\n\t        })\r\n\t\r\n\t        var sel = window.getSelection();\r\n\t        sel.removeAllRanges();\r\n\t        sel.addRange(range);\r\n\t    }\r\n\t}\r\n\t\r\n\t// gets the character offsets of a selection within a particular dom node\r\n\t// returns undefined if there is no selection in the element\r\n\t// note: yes this code doesn't work in older versions of IE (or possibly any versions) - if you want it to work in IE, please use http://modernizr.com/ or a polyfill for ranges\r\n\texports.getSelectionRange = function (element) {\r\n\t\r\n\t    var selection = window.getSelection()\r\n\t    var isInputOrArea = element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA'\r\n\t\r\n\t    for(var n=0; n<selection.rangeCount; n++) {\r\n\t        var range = selection.getRangeAt(0)\r\n\t        if(isInputOrArea) {\r\n\t            if(range.startOffset === range.endOffset && range.startContainer.children[range.startOffset] === element /*|| range.startContainer === element || */) { // I don't think the input or textarea itself will ever be the startContainer\r\n\t                return [element.selectionStart, element.selectionEnd]\r\n\t            }\r\n\t        } else {\r\n\t            var startsInElement = element.contains(range.startContainer)\r\n\t            if(startsInElement) {\r\n\t                var elementToIterateThrough = element\r\n\t                var startFound = true\r\n\t            } else {\r\n\t                var elementToIterateThrough = range.commonAncestorContainer\r\n\t                var startFound = false\r\n\t                var startContainerFound = false\r\n\t            }\r\n\t\r\n\t            var visibleCharacterOffset = 0, start, end;\r\n\t            iterateThroughLeafNodes(elementToIterateThrough, function(leaf) {\r\n\t                if(!startFound) {\r\n\t                    if(leaf === range.startContainer) {\r\n\t                        startContainerFound = true\r\n\t                    }\r\n\t\r\n\t                    if(!element.contains(leaf) || !startContainerFound)\r\n\t                        return; // continue\r\n\t                    else if(startContainerFound)\r\n\t                       startFound = true\r\n\t                } else if(!startsInElement && !element.contains(leaf)) {\r\n\t                    return true // done!\r\n\t                }\r\n\t\r\n\t                if(leaf === range.startContainer) {\r\n\t                    start = visibleCharacterOffset + range.startOffset - findHiddenCharacters(leaf, range.startOffset)\r\n\t                }\r\n\t                if(leaf === range.endContainer) {\r\n\t                    end = visibleCharacterOffset + range.endOffset - findHiddenCharacters(leaf, range.endOffset)\r\n\t                    return true // done!\r\n\t                }\r\n\t\r\n\t                visibleCharacterOffset += leaf.length - findHiddenCharacters(leaf, leaf.length)\r\n\t            })\r\n\t\r\n\t            if(start === undefined && !startFound) {\r\n\t                return undefined\r\n\t            } else {\r\n\t                if(start === undefined) {\r\n\t                    start = 0 // start is at the beginning\r\n\t                }\r\n\t                if(end === undefined) {\r\n\t                    end = visibleCharacterOffset // end is all the way at the end (the selection may continue in other elements)\r\n\t                }\r\n\t\r\n\t                return [start, end]\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\t\r\n\t// iterate through the leaf nodes inside element\r\n\t// callback(node) - a function called for each leaf node\r\n\t    // returning true from this ends the iteration\r\n\tfunction iterateThroughLeafNodes(element, callback) {\r\n\t    var nodeStack = [element], node;\r\n\t\r\n\t    while (node = nodeStack.pop()) {\r\n\t        if (node.nodeType == 3) {\r\n\t            if(callback(node) === true)\r\n\t                break;\r\n\t        } else {\r\n\t            var i = node.childNodes.length;\r\n\t            while (i--) {\r\n\t                nodeStack.push(node.childNodes[i]);\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction findHiddenCharacters(node, beforeCaretIndex) {\r\n\t    var hiddenCharacters = 0\r\n\t    var lastCharWasWhiteSpace=true\r\n\t    for(var n=0; n-hiddenCharacters<beforeCaretIndex &&n<node.length; n++) {\r\n\t        if([' ','\\n','\\t','\\r'].indexOf(node.textContent[n]) !== -1) {\r\n\t            if(lastCharWasWhiteSpace)\r\n\t                hiddenCharacters++\r\n\t            else\r\n\t                lastCharWasWhiteSpace = true\r\n\t        } else {\r\n\t            lastCharWasWhiteSpace = false\r\n\t        }\r\n\t    }\r\n\t\r\n\t    return hiddenCharacters\r\n\t}\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// note: this is  not intended to be used directly - only through Select and MultiSelect\r\n\t\r\n\tvar Block = __webpack_require__(1)\r\n\tvar Style = __webpack_require__(2)\r\n\tvar proto = __webpack_require__(29)\r\n\t//var htmlEntities = require('he')\r\n\t\r\n\t// emits a 'change' event when its 'selected' value changes\r\n\tmodule.exports = proto(Block, function(superclass) {\r\n\t\r\n\t    // staic members\r\n\t\r\n\t    this.name = 'Option'\r\n\t\r\n\t    this.defaultStyle = Style({\r\n\t        display: 'block'\r\n\t    })\r\n\t\r\n\t\r\n\t    // instance members\r\n\t\r\n\t    this.init = function(label, value, text) {\r\n\t        this.domNode = document.createElement(\"option\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\r\n\t        superclass.init.call(this) // superclass constructor\r\n\t\r\n\t        this.label = label\r\n\t\r\n\t        this.text = text\r\n\t        this.val = value\r\n\t    }\r\n\t\r\n\t    Object.defineProperty(this, 'val', {\r\n\t        // returns the value of the Option\r\n\t        get: function() {\r\n\t            return this.attr('value')\r\n\t        },\r\n\t\r\n\t        // sets the value of the Option\r\n\t        set: function(value) {\r\n\t            if(this.parent !== undefined) {\r\n\t                if(this.parent.options[value] !== undefined) {\r\n\t                    throw new Error(\"Can't give an Option the same value as another in the Select or MultiSelect (value: '\"+value+\"')\")\r\n\t                }\r\n\t\r\n\t                if(this.val !== null) {\r\n\t                    delete this.parent.options[this.val]\r\n\t                }\r\n\t\r\n\t                this.parent.options[value] = this\r\n\t            }\r\n\t\r\n\t            this.attr('value', value)\r\n\t\r\n\t        }\r\n\t    })\r\n\t\r\n\t\r\n\t    Object.defineProperty(this, 'selected', {\r\n\t        // returns whether or not the option is selected\r\n\t        get: function() {\r\n\t            return this.domNode.selected\r\n\t        },\r\n\t\r\n\t        // sets the selected state of the option to the passed value (true for selected)\r\n\t        set: function(value) {\r\n\t            var booleanValue = value === true\r\n\t            if(this.selected === booleanValue) return false; // ignore if there's no change\r\n\t\r\n\t            if(this.parent !== undefined)\r\n\t                this.parent.prepareForValueChange([this.val])\r\n\t\r\n\t            this.setSelectedQuiet(booleanValue)\r\n\t\r\n\t            if(this.parent !== undefined)\r\n\t                this.parent.emit('change')\r\n\t        }\r\n\t    })\r\n\t\r\n\t    Object.defineProperty(this, 'text', {\r\n\t        get: function() {\r\n\t            return this.domNode.textContent\r\n\t        },\r\n\t\r\n\t        set: function(text) {\r\n\t            this.domNode.innerText = text // apparently textContent can't be set or something? unclear\r\n\t        }\r\n\t    })\r\n\t\r\n\t\r\n\t    // private\r\n\t\r\n\t    // does everything for setting the selected state except emit the parent's change event\r\n\t    this.setSelectedQuiet = function setOptionSelected(booleanValue) {\r\n\t        if(this.selected === booleanValue) return; // ignore if there's no change\r\n\t\r\n\t        this.domNode.selected = booleanValue\r\n\t        this.emit('change') // the browser has no listenable event that is triggered on change of the 'checked' property\r\n\t    }\r\n\t})\n\n/***/ },\n/* 21 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(29)\n\tvar Style = __webpack_require__(2)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t\t// static properties\n\t\n\t\tthis.name = 'ListItem'\n\t\n\t    this.defaultStyle = Style({\n\t        display: 'list-item'\n\t    })\n\t\n\t\t// instance properties\n\t\n\t\tthis.init = function(/*[label,] contents*/) {\n\t        if(arguments.length <= 1) {\n\t            var contents = arguments[0]\n\t        } else {\n\t            var label = arguments[0]\n\t            var contents = arguments[1]\n\t        }\n\t\n\t        this.domNode = document.createElement(\"li\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t\t\tsuperclass.init.call(this) // superclass constructor\n\t\t\tthis.label = label\n\t\n\t        if(contents instanceof Block) {\n\t\t\t\tthis.add(contents)\n\t\t\t} else if(contents !== undefined) {\n\t            this.domNode.textContent = contents\n\t        }\n\t\t}\n\t});\n\n\n/***/ },\n/* 22 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\n\t\n\tvar RowlikeGenerator = __webpack_require__(30);\n\t\n\tmodule.exports = RowlikeGenerator('th', \"TableHeader\")\n\n/***/ },\n/* 23 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar RowlikeGenerator = __webpack_require__(30);\n\t\n\tmodule.exports = RowlikeGenerator('tr', \"TableRow\")\n\n\n/***/ },\n/* 24 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar Block = __webpack_require__(1)\n\tvar proto = __webpack_require__(29)\n\t\n\tmodule.exports = proto(Block, function(superclass) {\n\t\n\t\t// static properties\n\t\n\t\tthis.name = 'TableCell'\n\t\t\n\t\n\t\t// instance properties\n\t\n\t\tthis.init = function(/*[label,] contents*/) {\n\t        if(arguments.length <= 1) {\n\t            var contents = arguments[0]\n\t        } else {\n\t            var label = arguments[0]\n\t            var contents = arguments[1]\n\t        }\n\t\n\t        this.domNode = document.createElement(\"td\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t\t\tsuperclass.init.call(this) // superclass constructor\n\t\t\tthis.label = label\n\t\n\t        if(contents instanceof Block) {\n\t\t\t\tthis.add(contents)\n\t\t\t} else if(contents !== undefined) {\n\t            this.domNode.textContent = contents\n\t        }\n\t\t}\n\t\n\t\tthis.colspan = function(cols) {\n\t\t\tthis.attr('colspan',cols);\n\t\t}\n\t});\n\n\n/***/ },\n/* 25 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\tfunction EventEmitter() {\n\t  this._events = this._events || {};\n\t  this._maxListeners = this._maxListeners || undefined;\n\t}\n\tmodule.exports = EventEmitter;\n\t\n\t// Backwards-compat with node 0.10.x\n\tEventEmitter.EventEmitter = EventEmitter;\n\t\n\tEventEmitter.prototype._events = undefined;\n\tEventEmitter.prototype._maxListeners = undefined;\n\t\n\t// By default EventEmitters will print a warning if more than 10 listeners are\n\t// added to it. This is a useful default which helps finding memory leaks.\n\tEventEmitter.defaultMaxListeners = 10;\n\t\n\t// Obviously not all Emitters should be limited to 10. This function allows\n\t// that to be increased. Set to zero for unlimited.\n\tEventEmitter.prototype.setMaxListeners = function(n) {\n\t  if (!isNumber(n) || n < 0 || isNaN(n))\n\t    throw TypeError('n must be a positive number');\n\t  this._maxListeners = n;\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.emit = function(type) {\n\t  var er, handler, len, args, i, listeners;\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // If there is no 'error' event listener then throw.\n\t  if (type === 'error') {\n\t    if (!this._events.error ||\n\t        (isObject(this._events.error) && !this._events.error.length)) {\n\t      er = arguments[1];\n\t      if (er instanceof Error) {\n\t        throw er; // Unhandled 'error' event\n\t      }\n\t      throw TypeError('Uncaught, unspecified \"error\" event.');\n\t    }\n\t  }\n\t\n\t  handler = this._events[type];\n\t\n\t  if (isUndefined(handler))\n\t    return false;\n\t\n\t  if (isFunction(handler)) {\n\t    switch (arguments.length) {\n\t      // fast cases\n\t      case 1:\n\t        handler.call(this);\n\t        break;\n\t      case 2:\n\t        handler.call(this, arguments[1]);\n\t        break;\n\t      case 3:\n\t        handler.call(this, arguments[1], arguments[2]);\n\t        break;\n\t      // slower\n\t      default:\n\t        len = arguments.length;\n\t        args = new Array(len - 1);\n\t        for (i = 1; i < len; i++)\n\t          args[i - 1] = arguments[i];\n\t        handler.apply(this, args);\n\t    }\n\t  } else if (isObject(handler)) {\n\t    len = arguments.length;\n\t    args = new Array(len - 1);\n\t    for (i = 1; i < len; i++)\n\t      args[i - 1] = arguments[i];\n\t\n\t    listeners = handler.slice();\n\t    len = listeners.length;\n\t    for (i = 0; i < len; i++)\n\t      listeners[i].apply(this, args);\n\t  }\n\t\n\t  return true;\n\t};\n\t\n\tEventEmitter.prototype.addListener = function(type, listener) {\n\t  var m;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events)\n\t    this._events = {};\n\t\n\t  // To avoid recursion in the case that type === \"newListener\"! Before\n\t  // adding it to the listeners, first emit \"newListener\".\n\t  if (this._events.newListener)\n\t    this.emit('newListener', type,\n\t              isFunction(listener.listener) ?\n\t              listener.listener : listener);\n\t\n\t  if (!this._events[type])\n\t    // Optimize the case of one listener. Don't need the extra array object.\n\t    this._events[type] = listener;\n\t  else if (isObject(this._events[type]))\n\t    // If we've already got an array, just append.\n\t    this._events[type].push(listener);\n\t  else\n\t    // Adding the second element, need to change to array.\n\t    this._events[type] = [this._events[type], listener];\n\t\n\t  // Check for listener leak\n\t  if (isObject(this._events[type]) && !this._events[type].warned) {\n\t    var m;\n\t    if (!isUndefined(this._maxListeners)) {\n\t      m = this._maxListeners;\n\t    } else {\n\t      m = EventEmitter.defaultMaxListeners;\n\t    }\n\t\n\t    if (m && m > 0 && this._events[type].length > m) {\n\t      this._events[type].warned = true;\n\t      console.error('(node) warning: possible EventEmitter memory ' +\n\t                    'leak detected. %d listeners added. ' +\n\t                    'Use emitter.setMaxListeners() to increase limit.',\n\t                    this._events[type].length);\n\t      if (typeof console.trace === 'function') {\n\t        // not supported in IE 10\n\t        console.trace();\n\t      }\n\t    }\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\t\n\tEventEmitter.prototype.once = function(type, listener) {\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  var fired = false;\n\t\n\t  function g() {\n\t    this.removeListener(type, g);\n\t\n\t    if (!fired) {\n\t      fired = true;\n\t      listener.apply(this, arguments);\n\t    }\n\t  }\n\t\n\t  g.listener = listener;\n\t  this.on(type, g);\n\t\n\t  return this;\n\t};\n\t\n\t// emits a 'removeListener' event iff the listener was removed\n\tEventEmitter.prototype.removeListener = function(type, listener) {\n\t  var list, position, length, i;\n\t\n\t  if (!isFunction(listener))\n\t    throw TypeError('listener must be a function');\n\t\n\t  if (!this._events || !this._events[type])\n\t    return this;\n\t\n\t  list = this._events[type];\n\t  length = list.length;\n\t  position = -1;\n\t\n\t  if (list === listener ||\n\t      (isFunction(list.listener) && list.listener === listener)) {\n\t    delete this._events[type];\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t\n\t  } else if (isObject(list)) {\n\t    for (i = length; i-- > 0;) {\n\t      if (list[i] === listener ||\n\t          (list[i].listener && list[i].listener === listener)) {\n\t        position = i;\n\t        break;\n\t      }\n\t    }\n\t\n\t    if (position < 0)\n\t      return this;\n\t\n\t    if (list.length === 1) {\n\t      list.length = 0;\n\t      delete this._events[type];\n\t    } else {\n\t      list.splice(position, 1);\n\t    }\n\t\n\t    if (this._events.removeListener)\n\t      this.emit('removeListener', type, listener);\n\t  }\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.removeAllListeners = function(type) {\n\t  var key, listeners;\n\t\n\t  if (!this._events)\n\t    return this;\n\t\n\t  // not listening for removeListener, no need to emit\n\t  if (!this._events.removeListener) {\n\t    if (arguments.length === 0)\n\t      this._events = {};\n\t    else if (this._events[type])\n\t      delete this._events[type];\n\t    return this;\n\t  }\n\t\n\t  // emit removeListener for all listeners on all events\n\t  if (arguments.length === 0) {\n\t    for (key in this._events) {\n\t      if (key === 'removeListener') continue;\n\t      this.removeAllListeners(key);\n\t    }\n\t    this.removeAllListeners('removeListener');\n\t    this._events = {};\n\t    return this;\n\t  }\n\t\n\t  listeners = this._events[type];\n\t\n\t  if (isFunction(listeners)) {\n\t    this.removeListener(type, listeners);\n\t  } else {\n\t    // LIFO order\n\t    while (listeners.length)\n\t      this.removeListener(type, listeners[listeners.length - 1]);\n\t  }\n\t  delete this._events[type];\n\t\n\t  return this;\n\t};\n\t\n\tEventEmitter.prototype.listeners = function(type) {\n\t  var ret;\n\t  if (!this._events || !this._events[type])\n\t    ret = [];\n\t  else if (isFunction(this._events[type]))\n\t    ret = [this._events[type]];\n\t  else\n\t    ret = this._events[type].slice();\n\t  return ret;\n\t};\n\t\n\tEventEmitter.listenerCount = function(emitter, type) {\n\t  var ret;\n\t  if (!emitter._events || !emitter._events[type])\n\t    ret = 0;\n\t  else if (isFunction(emitter._events[type]))\n\t    ret = 1;\n\t  else\n\t    ret = emitter._events[type].length;\n\t  return ret;\n\t};\n\t\n\tfunction isFunction(arg) {\n\t  return typeof arg === 'function';\n\t}\n\t\n\tfunction isNumber(arg) {\n\t  return typeof arg === 'number';\n\t}\n\t\n\tfunction isObject(arg) {\n\t  return typeof arg === 'object' && arg !== null;\n\t}\n\t\n\tfunction isUndefined(arg) {\n\t  return arg === void 0;\n\t}\n\n\n/***/ },\n/* 26 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**\r\n\t * HashMap - HashMap Class for JavaScript\r\n\t * @author Ariel Flesler <aflesler@gmail.com>\r\n\t * @version 2.0.0\r\n\t * Homepage: https://github.com/flesler/hashmap\r\n\t */\r\n\t\r\n\t(function (factory) {\r\n\t\tif (true) {\r\n\t\t\t// AMD. Register as an anonymous module.\r\n\t\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\r\n\t\t} else if (typeof exports === 'object') {\r\n\t\t\t// Node js environment\r\n\t\t\texports.HashMap = factory();\r\n\t\t} else {\r\n\t\t\t// Browser globals (this is window)\r\n\t\t\tthis.HashMap = factory();\r\n\t\t}\r\n\t}(function () {\r\n\t\t\r\n\t\tfunction HashMap(other) {\r\n\t\t\tthis.clear();\r\n\t\t\tswitch (arguments.length) {\r\n\t\t\t\tcase 0: break;\r\n\t\t\t\tcase 1: this.copy(other); break;\r\n\t\t\t\tdefault: multi(this, arguments); break;\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tvar proto = HashMap.prototype = {\r\n\t\t\tconstructor:HashMap,\r\n\t\r\n\t\t\tget:function(key) {\r\n\t\t\t\tvar data = this._data[this.hash(key)];\r\n\t\t\t\treturn data && data[1];\r\n\t\t\t},\r\n\t\t\t\r\n\t\t\tset:function(key, value) {\r\n\t\t\t\t// Store original key as well (for iteration)\r\n\t\t\t\tthis._data[this.hash(key)] = [key, value];\r\n\t\t\t},\r\n\t\r\n\t\t\tmulti:function() {\r\n\t\t\t\tmulti(this, arguments);\r\n\t\t\t},\r\n\t\r\n\t\t\tcopy:function(other) {\r\n\t\t\t\tfor (var key in other._data) {\r\n\t\t\t\t\tthis._data[key] = other._data[key];\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\t\r\n\t\t\thas:function(key) {\r\n\t\t\t\treturn this.hash(key) in this._data;\r\n\t\t\t},\r\n\t\t\t\r\n\t\t\tsearch:function(value) {\r\n\t\t\t\tfor (var key in this._data) {\r\n\t\t\t\t\tif (this._data[key][1] === value) {\r\n\t\t\t\t\t\treturn this._data[key][0];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\r\n\t\t\t\treturn null;\r\n\t\t\t},\r\n\t\t\t\r\n\t\t\tremove:function(key) {\r\n\t\t\t\tdelete this._data[this.hash(key)];\r\n\t\t\t},\r\n\t\r\n\t\t\ttype:function(key) {\r\n\t\t\t\tvar str = Object.prototype.toString.call(key);\r\n\t\t\t\tvar type = str.slice(8, -1).toLowerCase();\r\n\t\t\t\t// Some browsers yield DOMWindow for null and undefined, works fine on Node\r\n\t\t\t\tif (type === 'domwindow' && !key) {\r\n\t\t\t\t\treturn key + '';\r\n\t\t\t\t}\r\n\t\t\t\treturn type;\r\n\t\t\t},\r\n\t\r\n\t\t\tkeys:function() {\r\n\t\t\t\tvar keys = [];\r\n\t\t\t\tthis.forEach(function(value, key) { keys.push(key); });\r\n\t\t\t\treturn keys;\r\n\t\t\t},\r\n\t\r\n\t\t\tvalues:function() {\r\n\t\t\t\tvar values = [];\r\n\t\t\t\tthis.forEach(function(value) { values.push(value); });\r\n\t\t\t\treturn values;\r\n\t\t\t},\r\n\t\r\n\t\t\tcount:function() {\r\n\t\t\t\treturn this.keys().length;\r\n\t\t\t},\r\n\t\r\n\t\t\tclear:function() {\r\n\t\t\t\t// TODO: Would Object.create(null) make any difference\r\n\t\t\t\tthis._data = {};\r\n\t\t\t},\r\n\t\r\n\t\t\tclone:function() {\r\n\t\t\t\treturn new HashMap(this);\r\n\t\t\t},\r\n\t\r\n\t\t\thash:function(key) {\r\n\t\t\t\tswitch (this.type(key)) {\r\n\t\t\t\t\tcase 'undefined':\r\n\t\t\t\t\tcase 'null':\r\n\t\t\t\t\tcase 'boolean':\r\n\t\t\t\t\tcase 'number':\r\n\t\t\t\t\tcase 'regexp':\r\n\t\t\t\t\t\treturn key + '';\r\n\t\r\n\t\t\t\t\tcase 'date':\r\n\t\t\t\t\t\treturn ':' + key.getTime();\r\n\t\r\n\t\t\t\t\tcase 'string':\r\n\t\t\t\t\t\treturn '\"' + key;\r\n\t\r\n\t\t\t\t\tcase 'array':\r\n\t\t\t\t\t\tvar hashes = [];\r\n\t\t\t\t\t\tfor (var i = 0; i < key.length; i++)\r\n\t\t\t\t\t\t\thashes[i] = this.hash(key[i]);\r\n\t\t\t\t\t\treturn '[' + hashes.join('|');\r\n\t\r\n\t\t\t\t\tcase 'object':\r\n\t\t\t\t\tdefault:\r\n\t\t\t\t\t\t// TODO: Don't use expandos when Object.defineProperty is not available?\r\n\t\t\t\t\t\tif (!key._hmuid_) {\r\n\t\t\t\t\t\t\tkey._hmuid_ = ++HashMap.uid;\r\n\t\t\t\t\t\t\thide(key, '_hmuid_');\r\n\t\t\t\t\t\t}\r\n\t\r\n\t\t\t\t\t\treturn '{' + key._hmuid_;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\r\n\t\t\tforEach:function(func) {\r\n\t\t\t\tfor (var key in this._data) {\r\n\t\t\t\t\tvar data = this._data[key];\r\n\t\t\t\t\tfunc.call(this, data[1], data[0]);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\tHashMap.uid = 0;\r\n\t\r\n\t\t//- Automatically add chaining to some methods\r\n\t\r\n\t\tfor (var method in proto) {\r\n\t\t\t// Skip constructor, valueOf, toString and any other built-in method\r\n\t\t\tif (method === 'constructor' || !proto.hasOwnProperty(method)) {\r\n\t\t\t\tcontinue;\r\n\t\t\t}\r\n\t\t\tvar fn = proto[method];\r\n\t\t\tif (fn.toString().indexOf('return ') === -1) {\r\n\t\t\t\tproto[method] = chain(fn);\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\t//- Utils\r\n\t\r\n\t\tfunction multi(map, args) {\r\n\t\t\tfor (var i = 0; i < args.length; i += 2) {\r\n\t\t\t\tmap.set(args[i], args[i+1])\r\n\t\t\t}\r\n\t\t}\r\n\t\r\n\t\tfunction chain(fn) {\r\n\t\t\treturn function() {\r\n\t\t\t\tfn.apply(this, arguments);\r\n\t\t\t\treturn this;\r\n\t\t\t};\r\n\t\t}\r\n\t\r\n\t\tfunction hide(obj, prop) {\r\n\t\t\t// Make non iterable if supported\r\n\t\t\tif (Object.defineProperty) {\r\n\t\t\t\tObject.defineProperty(obj, prop, {enumerable:false});\r\n\t\t\t}\r\n\t\t};\r\n\t\r\n\t\treturn HashMap;\r\n\t\r\n\t}));\r\n\n\n/***/ },\n/* 27 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// resolves varargs variable into more usable form\n\t// args - should be a function arguments variable\n\t// returns a javascript Array object of arguments that doesn't count trailing undefined values in the length\n\tmodule.exports = function(theArguments) {\n\t    var args = Array.prototype.slice.call(theArguments, 0)\n\t\n\t    var count = 0;\n\t    for(var n=args.length-1; n>=0; n--) {\n\t        if(args[n] === undefined)\n\t            count++\n\t        else\n\t            break\n\t    }\n\t    args.splice(args.length-count, count)\n\t    return args\n\t}\n\n/***/ },\n/* 28 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar proto = __webpack_require__(29)\r\n\tvar EventEmitter = __webpack_require__(25).EventEmitter\r\n\tvar utils = __webpack_require__(32)\r\n\t\r\n\t\r\n\t// emits the event:\r\n\t    // change - the event data is an object of one of the following forms:\r\n\t        // {id:_, type: 'set', property: propertyList}\r\n\t        // {id:_, type: 'added', property: propertyList, index:_, count: numberOfElementsAdded}\r\n\t        // {id:_, type: 'removed', property: propertyList, index:_, values: removedValues}\r\n\tvar Observe = module.exports = proto(EventEmitter, function() {\r\n\t\r\n\t    // static members\r\n\t\r\n\t    this.init = function(obj) {\r\n\t        this.subject = obj\r\n\t\r\n\t        this.setMaxListeners(1000)\r\n\t    }\r\n\t\r\n\t    // instance members\r\n\t\r\n\t    // gets an element or member of the subject and returns another Observee\r\n\t    // changes to the returned Observee will be emitted by its parent as well\r\n\t    this.get = function(property) {\r\n\t        return ObserveeChild(this, parsePropertyList(property))\r\n\t    }\r\n\t\r\n\t    // sets a value on the subject\r\n\t    // property - either an array of members to select, or a string where properties to select are separated by dots\r\n\t    // value - the value to set\r\n\t    this.set = function(property, value) {\r\n\t        setInternal(this, parsePropertyList(property), value, {})\r\n\t    }\r\n\t\r\n\t    // pushes a value onto a list\r\n\t    this.push = function(/*value...*/) {\r\n\t        pushInternal(this, [], arguments, {})\r\n\t    }\r\n\t\r\n\t\r\n\t    // index is the index to remove/insert at\r\n\t    // countToRemove is the number to remove\r\n\t    // elementsToAdd is a list of elements to add\r\n\t    this.splice = function(/*index, countToRemove[, elementsToAdd]*/) {\r\n\t        return spliceInternal(this, [], arguments, {})\r\n\t    }\r\n\t\r\n\t    // use this instead of concat for mutation behavior\r\n\t    this.append = function(arrayToAppend) {\r\n\t        appendInternal(this, [], arguments, {})\r\n\t    }\r\n\t\r\n\t    this.id = function(id) {\r\n\t        return ObserveeChild(this, [], {id: id})\r\n\t        //return idFunction(this, [], id)\r\n\t    }\r\n\t\r\n\t    // For the returned object, any property added via set, push, splice, or append joins an internal observee together with this observee, so that\r\n\t    //      the internal observee and the containing observee will both send 'change' events appropriately\r\n\t    // collapse - (default: false) if true, any property added will be set to the subject of the value added (so that value won't be an observee anymore\r\n\t        // note: only use collapse:true if the observees you're unioning isn't actually an object that inherits from an observee - any instance methods on the observee that come from child classes won't be accessible anymore\r\n\t        // e.g. var x = observe({a:5})\r\n\t        //      var b = observe({})\r\n\t        //      x.subject.a === 5    ;; true\r\n\t        //      b.union(true).set('x', x)\r\n\t        //      b.subject.x.a === 5            ;; true\r\n\t        //      b.subject.x.subject.a === 5    ;; false\r\n\t    this.union = function(collapse) {\r\n\t        if(collapse === undefined) collapse = false\r\n\t        return ObserveeChild(this, [], {union: collapse})\r\n\t    }\r\n\t\r\n\t\r\n\t    /* pause and unpause may cause weird affects in certain cases (e.g. if you remove an element at index 4 and *then* add an element at index 2)\r\n\t    // pause sending events (for when you want to do a lot of things to an object)\r\n\t    this.pause = function() {\r\n\t        this.paused = true\r\n\t    }\r\n\t    this.unpause = function() {\r\n\t        this.paused = undefined\r\n\t        sendEvent(this)\r\n\t    }*/\r\n\t})\r\n\t\r\n\t\r\n\tfunction parsePropertyList(property) {\r\n\t    if(!(property instanceof Array)) {\r\n\t        property = property.toString().split('.')\r\n\t    }\r\n\t\r\n\t    return property\r\n\t}\r\n\t\r\n\tfunction getPropertyPointer(subject, propertyList) {\r\n\t    var current = subject\r\n\t    for(var n=0; n<propertyList.length-1; n++) {\r\n\t        current = current[propertyList[n]]\r\n\t    }\r\n\t\r\n\t    return {obj: current, key:propertyList[n]}\r\n\t}\r\n\t\r\n\tvar getPropertyValue = module.exports.getPropertyValue = function(subject, property) {\r\n\t    var pointer = getPropertyPointer(subject, property)\r\n\t    if(pointer.key !== undefined) {\r\n\t        return pointer.obj[pointer.key]\r\n\t    } else {\r\n\t        return pointer.obj\r\n\t    }\r\n\t}\r\n\t\r\n\t// private\r\n\t\r\n\t// options can have the properties:\r\n\t    // union - if true, any value set, pushed, appended, or spliced onto the observee is unioned\r\n\tvar ObserveeChild = proto(EventEmitter, function() {\r\n\t\r\n\t    this.init = function(parent, propertyList, options) {\r\n\t        if(options === undefined) this.options = {}\r\n\t        else                      this.options = options\r\n\t\r\n\t        if(parent._observeeParent !== undefined)\r\n\t            this._observeeParent = parent._observeeParent\r\n\t        else\r\n\t            this._observeeParent = parent\r\n\t\r\n\t        this.property = propertyList\r\n\t        this.subject = getPropertyValue(parent.subject, propertyList)\r\n\t\r\n\t        var that = this\r\n\t        parent.on('change', function(change) {\r\n\t            var answers = changeQuestions(that.property, change)\r\n\t\r\n\t            if(answers.isWithin ) {\r\n\t                that.emit('change', {type:change.type, property: change.property.slice(that.property.length), index:change.index, count:change.count, removed: change.removed})\r\n\t            } else if(answers.couldRelocate) {\r\n\t                if(change.type === 'removed') {\r\n\t                    var relevantIndex = that.property[change.property.length]\r\n\t                    var removedIndexesAreBeforeIndexOfObserveeChild = change.index + change.removed.length - 1 < relevantIndex\r\n\t\r\n\t                    if(removedIndexesAreBeforeIndexOfObserveeChild) {\r\n\t                        that.property[change.property.length] = relevantIndex - change.removed.length // change the propertyList to match the new index\r\n\t                    }\r\n\t                } else if(change.type === 'added') {\r\n\t                    var relevantIndex = that.property[change.property.length]\r\n\t                    if(change.index < relevantIndex) {\r\n\t                        that.property[change.property.length] = relevantIndex + change.count // change the propertyList to match the new index\r\n\t                    }\r\n\t                }\r\n\t            }\r\n\t        })\r\n\t    }\r\n\t\r\n\t    this.get = function(property) {\r\n\t        return this._observeeParent.get(this.property.concat(parsePropertyList(property)))\r\n\t    }\r\n\t\r\n\t    this.set = function(property, value) {\r\n\t        setInternal(this._observeeParent, this.property.concat(parsePropertyList(property)), value, this.options)\r\n\t    }\r\n\t\r\n\t    this.push = function(/*values...*/) {\r\n\t        pushInternal(this._observeeParent, this.property, arguments, this.options)\r\n\t    }\r\n\t\r\n\t    this.splice = function(index, countToRemove/*[, elementsToAdd....]*/) {\r\n\t        spliceInternal(this._observeeParent, this.property, arguments, this.options)\r\n\t    }\r\n\t\r\n\t    this.append = function(/*[property,] arrayToAppend*/) {\r\n\t        appendInternal(this._observeeParent, this.property, arguments, this.options)\r\n\t    }\r\n\t\r\n\t    this.id = function(id) {\r\n\t        return ObserveeChild(this, this.property, utils.merge({}, this.options, {id: id}))\r\n\t        //return idFunction(this._observeeParent, this.property, id)\r\n\t    }\r\n\t\r\n\t    this.union = function(collapse) {\r\n\t        if(collapse === undefined) collapse = false\r\n\t        return ObserveeChild(this, [], utils.merge({}, this.options, {union: collapse}))\r\n\t    }\r\n\t\r\n\t})\r\n\t\r\n\t     /*\r\n\tfunction idFunction(that, propertyList, id) {\r\n\t    var result = {\r\n\t        set: function(property, value) {\r\n\t            var fullPropertyList = propertyList.concat(parsePropertyList(property))\r\n\t            setInternal(that, fullPropertyList, value, id)\r\n\t        },\r\n\t        push: function() {\r\n\t            pushInternal(that, propertyList, arguments, id)\r\n\t        },\r\n\t        splice: function() {\r\n\t            spliceInternal(that, propertyList, arguments, id)\r\n\t        },\r\n\t        append: function() {\r\n\t            appendInternal(that, propertyList, arguments, id)\r\n\t        },\r\n\t        get: function() {\r\n\t\r\n\t        }\r\n\t    }\r\n\t}\r\n\t*/\r\n\t\r\n\t// that - the Observee object\r\n\tfunction setInternal(that, propertyList, value, options) {\r\n\t    var pointer = getPropertyPointer(that.subject, propertyList)\r\n\t\r\n\t    var internalObservee = value\r\n\t    if(options.union === true) {\r\n\t        value = value.subject\r\n\t    }\r\n\t\r\n\t    pointer.obj[pointer.key] = value\r\n\t\r\n\t    var event = {type: 'set', property: propertyList}\r\n\t    if(options.id !== undefined) event.id = options.id\r\n\t    that.emit('change',event)\r\n\t\r\n\t    if(options.union !== undefined)\r\n\t        unionizeEvents(that, internalObservee, propertyList, options.union)\r\n\t}\r\n\t\r\n\tfunction pushInternal(that, propertyList, args, options) {\r\n\t    var array = getPropertyValue(that.subject, propertyList)\r\n\t    var originalLength = array.length\r\n\t    array.push.apply(array, args)\r\n\t\r\n\t    var internalObservees = unionizeList(array, originalLength, args.length, options.union)\r\n\t\r\n\t    var event = {type: 'added', property: propertyList, index: originalLength, count: 1}\r\n\t    if(options.id !== undefined) event.id = options.id\r\n\t    that.emit('change', event)\r\n\t\r\n\t    unionizeListEvents(that, internalObservees, propertyList, options.union)\r\n\t}\r\n\t\r\n\tfunction spliceInternal(that, propertyList, args, options) {\r\n\t    var index = args[0]\r\n\t    var countToRemove = args[1]\r\n\t\r\n\t    var array = getPropertyValue(that.subject, propertyList)\r\n\t    var result = array.splice.apply(array, args)\r\n\t\r\n\t    if(countToRemove > 0) {\r\n\t        var event = {type: 'removed', property: propertyList, index: index, removed: result}\r\n\t        if(options.id !== undefined) event.id = options.id\r\n\t        that.emit('change', event)\r\n\t    }\r\n\t    if(args.length > 2) {\r\n\t        var event = {type: 'added', property: propertyList, index: index, count: args.length-2}\r\n\t\r\n\t        var internalObservees = unionizeList(array, index, event.count, options.union)\r\n\t\r\n\t        if(options.id !== undefined) event.id = options.id\r\n\t        that.emit('change', event)\r\n\t\r\n\t        unionizeListEvents(that, internalObservees, propertyList, options.union)\r\n\t    }\r\n\t\r\n\t    return result\r\n\t}\r\n\t\r\n\t// note: I'm not using splice to do this as an optimization (because otherwise the property list would have to be parsed twice and the value gotten twice) - maybe this optimization wasn't worth it but its already done\r\n\tfunction appendInternal(that, propertyList, args, options) {\r\n\t    var arrayToAppend = args[0]\r\n\t    if(arrayToAppend.length === 0) return; //nothing to do\r\n\t\r\n\t    var array = getPropertyValue(that.subject, propertyList)\r\n\t    var originalLength = array.length\r\n\t\r\n\t    var spliceArgs = [originalLength, 0]\r\n\t    spliceArgs = spliceArgs.concat(arrayToAppend)\r\n\t    var oldLength = array.length\r\n\t    array.splice.apply(array, spliceArgs)\r\n\t\r\n\t    var internalObservees = unionizeList(array, oldLength, array.length, options.union)\r\n\t\r\n\t    var event = {type: 'added', property: propertyList, index: originalLength, count: arrayToAppend.length}\r\n\t    if(options.id !== undefined) event.id = options.id\r\n\t    that.emit('change', event)\r\n\t\r\n\t    unionizeListEvents(that, internalObservees, propertyList, options.union)\r\n\t}\r\n\t\r\n\t// sets a slice of elements to their subjects and\r\n\t// returns the original observee objects along with their indexes\r\n\tfunction unionizeList(array, start, count, union) {\r\n\t    var internalObservees = [] // list of observees and their property path\r\n\t    if(union !== undefined) {\r\n\t        var afterEnd = start+count\r\n\t        for(var n=start; n<afterEnd; n++) {\r\n\t            internalObservees.push({obj: array[n], index: n})\r\n\t            if(union === true)\r\n\t                array[n] = array[n].subject\r\n\t        }\r\n\t    }\r\n\t\r\n\t    return internalObservees\r\n\t}\r\n\t\r\n\t// runs unionizeEvents for elements in a list\r\n\t// internalObservees should be the result from `unionizeList`\r\n\tfunction unionizeListEvents(that, internalObservees, propertyList, collapse) {\r\n\t    for(var n=0; n<internalObservees.length; n++) {\r\n\t        unionizeEvents(that, internalObservees[n].obj, propertyList.concat(internalObservees[n].index), collapse)\r\n\t    }\r\n\t}\r\n\t\r\n\t\r\n\t// sets up the union change events for an observee with one of its inner properties\r\n\t// parameters:\r\n\t    // that - the container observee\r\n\t    // innerObservee - the contained observee\r\n\t    // propertyList - the propertyList to unionize\r\n\t    // collapse - the union option (true for collapse)\r\n\tfunction unionizeEvents(that, innerObservee, propertyList, collapse) {\r\n\t    var propertyListDepth = propertyList.length\r\n\t\r\n\t    if(innerObservee.on === undefined || innerObservee.emit === undefined || innerObservee.removeListener === undefined || innerObservee.set === undefined) {\r\n\t        throw new Error(\"Attempting to union a value that isn't an observee\")\r\n\t    }\r\n\t\r\n\t    var innerChangeHandler, containerChangeHandler\r\n\t    var ignorableContainerEvents = [], ignorableInnerEvents = []\r\n\t    innerObservee.on('change', innerChangeHandler = function(change) {\r\n\t        if(ignorableInnerEvents.indexOf(change) === -1) {        // don't run this for events generated by the union event handlers\r\n\t            if(collapse) {\r\n\t                var property = propertyList.concat(change.property)\r\n\t            } else {\r\n\t                var property = propertyList.concat(['subject']).concat(change.property)\r\n\t            }\r\n\t\r\n\t            var containerChange = utils.merge({}, change, {property: property})\r\n\t            ignorableContainerEvents.push(containerChange)\r\n\t            that.emit('change', containerChange)\r\n\t        }\r\n\t    })\r\n\t    that.on('change', containerChangeHandler = function(change) {\r\n\t        var changedPropertyDepth = change.property.length\r\n\t\r\n\t        var answers = changeQuestions(propertyList, change)\r\n\t        var changeIsWithinInnerProperty = answers.isWithin\r\n\t        var changeCouldRelocateInnerProperty = answers.couldRelocate\r\n\t\r\n\t        if(changeIsWithinInnerProperty && ignorableContainerEvents.indexOf(change) === -1) {   // don't run this for events generated by the union event handlers\r\n\t            if(collapse) {\r\n\t                var property = change.property.slice(propertyListDepth)\r\n\t            } else {\r\n\t                var property = change.property.slice(propertyListDepth+1) // +1 for the 'subject'\r\n\t            }\r\n\t\r\n\t            var innerObserveeEvent = utils.merge({}, change, {property: property})\r\n\t            ignorableInnerEvents.push(innerObserveeEvent)\r\n\t            innerObservee.emit('change', innerObserveeEvent)\r\n\t        } else if(changeCouldRelocateInnerProperty) {\r\n\t            if(change.type === 'set' /*&& changedPropertyDepth <= propertyListDepth  - this part already done above*/) {\r\n\t                removeUnion()\r\n\t            } else if(change.type === 'removed') {\r\n\t                var relevantIndex = propertyList[change.property.length]\r\n\t                var removedIndexesContainsIndexOfInnerObservee = change.index <= relevantIndex && relevantIndex <= change.index + change.removed.length - 1\r\n\t                var removedIndexesAreBeforeIndexOfInnerObservee = change.index + change.removed.length - 1 < relevantIndex && relevantIndex\r\n\t\r\n\t                if(removedIndexesContainsIndexOfInnerObservee && changedPropertyDepth <= propertyListDepth+1) {\r\n\t                    removeUnion()\r\n\t                } else if(removedIndexesAreBeforeIndexOfInnerObservee) {\r\n\t                    propertyList[change.property.length] = relevantIndex - change.removed.length // change the propertyList to match the new index\r\n\t                }\r\n\t            } else if(change.type === 'added') {\r\n\t                var relevantIndex = propertyList[change.property.length]\r\n\t                if(change.index < relevantIndex) {\r\n\t                    propertyList[change.property.length] = relevantIndex + change.count // change the propertyList to match the new index\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t    })\r\n\t\r\n\t    var removeUnion = function() {\r\n\t        innerObservee.removeListener('change', innerChangeHandler)\r\n\t        that.removeListener('change', containerChangeHandler)\r\n\t    }\r\n\t}\r\n\t\r\n\t\r\n\t// answers certain questions about a change compared to a property list\r\n\t// returns an object like: {\r\n\t    // isWithin: _,           // true if changeIsWithinInnerProperty\r\n\t    // couldRelocate: _       // true if changeCouldRelocateInnerProperty or if innerProperty might be removed\r\n\t// }\r\n\tfunction changeQuestions(propertyList, change) {\r\n\t    var propertyListDepth = propertyList.length\r\n\t\r\n\t    var changeIsWithinInnerProperty = true // assume true until proven otherwise\r\n\t    var changeCouldRelocateInnerProperty = true // assume true until prove otherwise\r\n\t    for(var n=0; n<propertyListDepth; n++) {\r\n\t        if(change.property[n] !== propertyList[n]) {\r\n\t            changeIsWithinInnerProperty = false\r\n\t            if(n<change.property.length) {\r\n\t                changeCouldRelocateInnerProperty = false\r\n\t            }\r\n\t        }\r\n\t    }\r\n\t\r\n\t    if(change.property.length <= propertyListDepth) {\r\n\t        changeIsWithinInnerProperty = false\r\n\t    } else {\r\n\t        changeCouldRelocateInnerProperty = false\r\n\t    }\r\n\t\r\n\t    return {couldRelocate: changeCouldRelocateInnerProperty, isWithin: changeIsWithinInnerProperty}\r\n\t}\n\n/***/ },\n/* 29 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t\"use strict\";\r\n\t/* Copyright (c) 2013 Billy Tetrud - Free to use for any purpose: MIT License*/\r\n\t\r\n\tvar noop = function() {}\r\n\t\r\n\tvar prototypeName='prototype', undefined, protoUndefined='undefined', init='init', ownProperty=({}).hasOwnProperty; // minifiable variables\r\n\tfunction proto() {\r\n\t    var args = arguments // minifiable variables\r\n\t\r\n\t    if(args.length == 1) {\r\n\t        var parent = {init: noop}\r\n\t        var prototypeBuilder = args[0]\r\n\t\r\n\t    } else { // length == 2\r\n\t        var parent = args[0]\r\n\t        var prototypeBuilder = args[1]\r\n\t    }\r\n\t\r\n\t    // special handling for Error objects\r\n\t    var namePointer = {}    // name used only for Error Objects\r\n\t    if([Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError].indexOf(parent) !== -1) {\r\n\t        parent = normalizeErrorObject(parent, namePointer)\r\n\t    }\r\n\t\r\n\t    // set up the parent into the prototype chain if a parent is passed\r\n\t    var parentIsFunction = typeof(parent) === \"function\"\r\n\t    if(parentIsFunction) {\r\n\t        prototypeBuilder[prototypeName] = parent[prototypeName]\r\n\t    } else {\r\n\t        prototypeBuilder[prototypeName] = parent\r\n\t    }\r\n\t\r\n\t    // the prototype that will be used to make instances\r\n\t    var prototype = new prototypeBuilder(parent)\r\n\t    namePointer.name = prototype.name\r\n\t\r\n\t    // if there's no init, assume its inheriting a non-proto class, so default to applying the superclass's constructor.\r\n\t    if(!prototype[init] && parentIsFunction) {\r\n\t        prototype[init] = function() {\r\n\t            parent.apply(this, arguments)\r\n\t        }\r\n\t    }\r\n\t\r\n\t    // constructor for empty object which will be populated via the constructor\r\n\t    var F = function() {}\r\n\t        F[prototypeName] = prototype    // set the prototype for created instances\r\n\t\r\n\t    var constructorName = prototype.name?prototype.name:''\r\n\t    if(prototype[init] === undefined || prototype[init] === noop) {\r\n\t        var ProtoObjectFactory = new Function('F',\r\n\t            \"return function \" + constructorName + \"(){\" +\r\n\t                \"return new F()\" +\r\n\t            \"}\"\r\n\t        )(F)\r\n\t    } else {\r\n\t        // dynamically creating this function cause there's no other way to dynamically name a function\r\n\t        var ProtoObjectFactory = new Function('F','i','u','n', // shitty variables cause minifiers aren't gonna minify my function string here\r\n\t            \"return function \" + constructorName + \"(){ \" +\r\n\t                \"var x=new F(),r=i.apply(x,arguments)\\n\" +    // populate object via the constructor\r\n\t                \"if(r===n)\\n\" +\r\n\t                    \"return x\\n\" +\r\n\t                \"else if(r===u)\\n\" +\r\n\t                    \"return n\\n\" +\r\n\t                \"else\\n\" +\r\n\t                    \"return r\\n\" +\r\n\t            \"}\"\r\n\t        )(F, prototype[init], proto[protoUndefined]) // note that n is undefined\r\n\t    }\r\n\t\r\n\t    prototype.constructor = ProtoObjectFactory;    // set the constructor property on the prototype\r\n\t\r\n\t    // add all the prototype properties onto the static class as well (so you can access that class when you want to reference superclass properties)\r\n\t    for(var n in prototype) {\r\n\t        addProperty(ProtoObjectFactory, prototype, n)\r\n\t    }\r\n\t\r\n\t    // add properties from parent that don't exist in the static class object yet\r\n\t    for(var n in parent) {\r\n\t        if(ownProperty.call(parent, n) && ProtoObjectFactory[n] === undefined) {\r\n\t            addProperty(ProtoObjectFactory, parent, n)\r\n\t        }\r\n\t    }\r\n\t\r\n\t    ProtoObjectFactory.parent = parent;            // special parent property only available on the returned proto class\r\n\t    ProtoObjectFactory[prototypeName] = prototype  // set the prototype on the object factory\r\n\t\r\n\t    return ProtoObjectFactory;\r\n\t}\r\n\t\r\n\tproto[protoUndefined] = {} // a special marker for when you want to return undefined from a constructor\r\n\t\r\n\tmodule.exports = proto\r\n\t\r\n\tfunction normalizeErrorObject(ErrorObject, namePointer) {\r\n\t    function NormalizedError() {\r\n\t        var tmp = new ErrorObject(arguments[0])\r\n\t        tmp.name = namePointer.name\r\n\t\r\n\t        this.message = tmp.message\r\n\t        if(Object.defineProperty) {\r\n\t            /*this.stack = */Object.defineProperty(this, 'stack', { // getter for more optimizy goodness\r\n\t                get: function() {\r\n\t                    return tmp.stack\r\n\t                }\r\n\t            })\r\n\t        } else {\r\n\t            this.stack = tmp.stack\r\n\t        }\r\n\t\r\n\t        return this\r\n\t    }\r\n\t\r\n\t    var IntermediateInheritor = function() {}\r\n\t        IntermediateInheritor.prototype = ErrorObject.prototype\r\n\t    NormalizedError.prototype = new IntermediateInheritor()\r\n\t\r\n\t    return NormalizedError\r\n\t}\r\n\t\r\n\tfunction addProperty(factoryObject, prototype, property) {\r\n\t    try {\r\n\t        var info = Object.getOwnPropertyDescriptor(prototype, property)\r\n\t        if(info.get !== undefined || info.get !== undefined && Object.defineProperty !== undefined) {\r\n\t            Object.defineProperty(factoryObject, property, info)\r\n\t        } else {\r\n\t            factoryObject[property] = prototype[property]\r\n\t        }\r\n\t    } catch(e) {\r\n\t        // do nothing, if a property (like `name`) can't be set, just ignore it\r\n\t    }\r\n\t}\n\n/***/ },\n/* 30 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tvar proto = __webpack_require__(29)\r\n\t\r\n\tvar Block = __webpack_require__(1)\r\n\tvar Style = __webpack_require__(2)\r\n\tvar Cell = __webpack_require__(24);\r\n\t\r\n\t// generates either a Header or a Row, depending on what you pass in\r\n\t// elementType should either be \"tr\" or \"th\r\n\t// name should either be \"Header\" or \"Row\r\n\tmodule.exports = function(elementType, name) {\r\n\t    return proto(Block, function(superclass) {\r\n\t\r\n\t        // static properties\r\n\t\r\n\t        this.name = name\r\n\t\r\n\t        this.defaultStyle = Style({\r\n\t            display: 'table-row'\r\n\t        })\r\n\t\r\n\t\r\n\t        // instance properties\r\n\t\r\n\t        this.init = function(/*[label,] rowInit*/) {\r\n\t            if(arguments[0] instanceof Array) {\r\n\t                var rowInit = arguments[0]\r\n\t            } else {\r\n\t                var label = arguments[0]\r\n\t                var rowInit = arguments[1]\r\n\t            }\r\n\t\r\n\t            this.domNode = document.createElement(elementType) // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\r\n\t            superclass.init.call(this) // superclass constructor\r\n\t            this.label = label\r\n\t\r\n\t            if(rowInit !== undefined) {\r\n\t                for(var n=0; n<rowInit.length; n++) {\r\n\t                    this.cell(rowInit[n])\r\n\t                }\r\n\t            }\r\n\t        }\r\n\t\r\n\t        this.cell = function(/*[label,] contents*/) {\r\n\t            var cell = Cell.apply(undefined, arguments);\r\n\t            this.add(cell);\r\n\t            return cell;\r\n\t        }\r\n\t    })\r\n\t}\n\n/***/ },\n/* 31 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.\n\t//\n\t// Permission is hereby granted, free of charge, to any person obtaining a\n\t// copy of this software and associated documentation files (the\n\t// \"Software\"), to deal in the Software without restriction, including\n\t// without limitation the rights to use, copy, modify, merge, publish,\n\t// distribute, sublicense, and/or sell copies of the Software, and to permit\n\t// persons to whom the Software is furnished to do so, subject to the\n\t// following conditions:\n\t//\n\t// The above copyright notice and this permission notice shall be included\n\t// in all copies or substantial portions of the Software.\n\t//\n\t// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n\t// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n\t// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n\t// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n\t// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n\t// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n\t// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\t\n\t// resolves . and .. elements in a path array with directory names there\n\t// must be no slashes, empty elements, or device names (c:\\) in the array\n\t// (so also no leading and trailing slashes - it does not distinguish\n\t// relative and absolute paths)\n\tfunction normalizeArray(parts, allowAboveRoot) {\n\t  // if the path tries to go above the root, `up` ends up > 0\n\t  var up = 0;\n\t  for (var i = parts.length - 1; i >= 0; i--) {\n\t    var last = parts[i];\n\t    if (last === '.') {\n\t      parts.splice(i, 1);\n\t    } else if (last === '..') {\n\t      parts.splice(i, 1);\n\t      up++;\n\t    } else if (up) {\n\t      parts.splice(i, 1);\n\t      up--;\n\t    }\n\t  }\n\t\n\t  // if the path is allowed to go above the root, restore leading ..s\n\t  if (allowAboveRoot) {\n\t    for (; up--; up) {\n\t      parts.unshift('..');\n\t    }\n\t  }\n\t\n\t  return parts;\n\t}\n\t\n\t// Split a filename into [root, dir, basename, ext], unix version\n\t// 'root' is just a slash, or nothing.\n\tvar splitPathRe =\n\t    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\n\tvar splitPath = function(filename) {\n\t  return splitPathRe.exec(filename).slice(1);\n\t};\n\t\n\t// path.resolve([from ...], to)\n\t// posix version\n\texports.resolve = function() {\n\t  var resolvedPath = '',\n\t      resolvedAbsolute = false;\n\t\n\t  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n\t    var path = (i >= 0) ? arguments[i] : process.cwd();\n\t\n\t    // Skip empty and invalid entries\n\t    if (typeof path !== 'string') {\n\t      throw new TypeError('Arguments to path.resolve must be strings');\n\t    } else if (!path) {\n\t      continue;\n\t    }\n\t\n\t    resolvedPath = path + '/' + resolvedPath;\n\t    resolvedAbsolute = path.charAt(0) === '/';\n\t  }\n\t\n\t  // At this point the path should be resolved to a full absolute path, but\n\t  // handle relative paths to be safe (might happen when process.cwd() fails)\n\t\n\t  // Normalize the path\n\t  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n\t    return !!p;\n\t  }), !resolvedAbsolute).join('/');\n\t\n\t  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n\t};\n\t\n\t// path.normalize(path)\n\t// posix version\n\texports.normalize = function(path) {\n\t  var isAbsolute = exports.isAbsolute(path),\n\t      trailingSlash = substr(path, -1) === '/';\n\t\n\t  // Normalize the path\n\t  path = normalizeArray(filter(path.split('/'), function(p) {\n\t    return !!p;\n\t  }), !isAbsolute).join('/');\n\t\n\t  if (!path && !isAbsolute) {\n\t    path = '.';\n\t  }\n\t  if (path && trailingSlash) {\n\t    path += '/';\n\t  }\n\t\n\t  return (isAbsolute ? '/' : '') + path;\n\t};\n\t\n\t// posix version\n\texports.isAbsolute = function(path) {\n\t  return path.charAt(0) === '/';\n\t};\n\t\n\t// posix version\n\texports.join = function() {\n\t  var paths = Array.prototype.slice.call(arguments, 0);\n\t  return exports.normalize(filter(paths, function(p, index) {\n\t    if (typeof p !== 'string') {\n\t      throw new TypeError('Arguments to path.join must be strings');\n\t    }\n\t    return p;\n\t  }).join('/'));\n\t};\n\t\n\t\n\t// path.relative(from, to)\n\t// posix version\n\texports.relative = function(from, to) {\n\t  from = exports.resolve(from).substr(1);\n\t  to = exports.resolve(to).substr(1);\n\t\n\t  function trim(arr) {\n\t    var start = 0;\n\t    for (; start < arr.length; start++) {\n\t      if (arr[start] !== '') break;\n\t    }\n\t\n\t    var end = arr.length - 1;\n\t    for (; end >= 0; end--) {\n\t      if (arr[end] !== '') break;\n\t    }\n\t\n\t    if (start > end) return [];\n\t    return arr.slice(start, end - start + 1);\n\t  }\n\t\n\t  var fromParts = trim(from.split('/'));\n\t  var toParts = trim(to.split('/'));\n\t\n\t  var length = Math.min(fromParts.length, toParts.length);\n\t  var samePartsLength = length;\n\t  for (var i = 0; i < length; i++) {\n\t    if (fromParts[i] !== toParts[i]) {\n\t      samePartsLength = i;\n\t      break;\n\t    }\n\t  }\n\t\n\t  var outputParts = [];\n\t  for (var i = samePartsLength; i < fromParts.length; i++) {\n\t    outputParts.push('..');\n\t  }\n\t\n\t  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\t\n\t  return outputParts.join('/');\n\t};\n\t\n\texports.sep = '/';\n\texports.delimiter = ':';\n\t\n\texports.dirname = function(path) {\n\t  var result = splitPath(path),\n\t      root = result[0],\n\t      dir = result[1];\n\t\n\t  if (!root && !dir) {\n\t    // No dirname whatsoever\n\t    return '.';\n\t  }\n\t\n\t  if (dir) {\n\t    // It has a dirname, strip trailing slash\n\t    dir = dir.substr(0, dir.length - 1);\n\t  }\n\t\n\t  return root + dir;\n\t};\n\t\n\t\n\texports.basename = function(path, ext) {\n\t  var f = splitPath(path)[2];\n\t  // TODO: make this comparison case-insensitive on windows?\n\t  if (ext && f.substr(-1 * ext.length) === ext) {\n\t    f = f.substr(0, f.length - ext.length);\n\t  }\n\t  return f;\n\t};\n\t\n\t\n\texports.extname = function(path) {\n\t  return splitPath(path)[3];\n\t};\n\t\n\tfunction filter (xs, f) {\n\t    if (xs.filter) return xs.filter(f);\n\t    var res = [];\n\t    for (var i = 0; i < xs.length; i++) {\n\t        if (f(xs[i], i, xs)) res.push(xs[i]);\n\t    }\n\t    return res;\n\t}\n\t\n\t// String.prototype.substr - negative index don't work in IE8\n\tvar substr = 'ab'.substr(-1) === 'b'\n\t    ? function (str, start, len) { return str.substr(start, len) }\n\t    : function (str, start, len) {\n\t        if (start < 0) start = str.length + start;\n\t        return str.substr(start, len);\n\t    }\n\t;\n\t\n\t/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(33)))\n\n/***/ },\n/* 32 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// utilities needed by the configuration (excludes dependencies the configs don't need so the webpack bundle is lean)\r\n\t\r\n\tvar path = __webpack_require__(31)\r\n\t\r\n\t\r\n\t// Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1\r\n\t// any number of objects can be passed into the function and will be merged into the first argument in order\r\n\t// returns obj1 (now mutated)\r\n\tvar merge = exports.merge = function(obj1, obj2/*, moreObjects...*/){\r\n\t    return mergeInternal(arrayify(arguments), false)\r\n\t}\r\n\t\r\n\t// like merge, but traverses the whole object tree\r\n\t// the result is undefined for objects with circular references\r\n\tvar deepMerge = exports.deepMerge = function(obj1, obj2/*, moreObjects...*/) {\r\n\t    return mergeInternal(arrayify(arguments), true)\r\n\t}\r\n\t\r\n\tfunction mergeInternal(objects, deep) {\r\n\t    var obj1 = objects[0]\r\n\t    var obj2 = objects[1]\r\n\t\r\n\t    for(var key in obj2){\r\n\t       if(Object.hasOwnProperty.call(obj2, key)) {\r\n\t            if(deep && obj1[key] instanceof Object && obj2[key] instanceof Object) {\r\n\t                mergeInternal([obj1[key], obj2[key]], true)\r\n\t            } else {\r\n\t                obj1[key] = obj2[key]\r\n\t            }\r\n\t       }\r\n\t    }\r\n\t\r\n\t    if(objects.length > 2) {\r\n\t        var newObjects = [obj1].concat(objects.slice(2))\r\n\t        return mergeInternal(newObjects, deep)\r\n\t    } else {\r\n\t        return obj1\r\n\t    }\r\n\t}\r\n\t\r\n\tfunction arrayify(a) {\r\n\t    return Array.prototype.slice.call(a, 0)\r\n\t}\r\n\n\n/***/ },\n/* 33 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t// shim for using process in browser\n\t\n\tvar process = module.exports = {};\n\t\n\tprocess.nextTick = (function () {\n\t    var canSetImmediate = typeof window !== 'undefined'\n\t    && window.setImmediate;\n\t    var canMutationObserver = typeof window !== 'undefined'\n\t    && window.MutationObserver;\n\t    var canPost = typeof window !== 'undefined'\n\t    && window.postMessage && window.addEventListener\n\t    ;\n\t\n\t    if (canSetImmediate) {\n\t        return function (f) { return window.setImmediate(f) };\n\t    }\n\t\n\t    var queue = [];\n\t\n\t    if (canMutationObserver) {\n\t        var hiddenDiv = document.createElement(\"div\");\n\t        var observer = new MutationObserver(function () {\n\t            var queueList = queue.slice();\n\t            queue.length = 0;\n\t            queueList.forEach(function (fn) {\n\t                fn();\n\t            });\n\t        });\n\t\n\t        observer.observe(hiddenDiv, { attributes: true });\n\t\n\t        return function nextTick(fn) {\n\t            if (!queue.length) {\n\t                hiddenDiv.setAttribute('yes', 'no');\n\t            }\n\t            queue.push(fn);\n\t        };\n\t    }\n\t\n\t    if (canPost) {\n\t        window.addEventListener('message', function (ev) {\n\t            var source = ev.source;\n\t            if ((source === window || source === null) && ev.data === 'process-tick') {\n\t                ev.stopPropagation();\n\t                if (queue.length > 0) {\n\t                    var fn = queue.shift();\n\t                    fn();\n\t                }\n\t            }\n\t        }, true);\n\t\n\t        return function nextTick(fn) {\n\t            queue.push(fn);\n\t            window.postMessage('process-tick', '*');\n\t        };\n\t    }\n\t\n\t    return function nextTick(fn) {\n\t        setTimeout(fn, 0);\n\t    };\n\t})();\n\t\n\tprocess.title = 'browser';\n\tprocess.browser = true;\n\tprocess.env = {};\n\tprocess.argv = [];\n\t\n\tfunction noop() {}\n\t\n\tprocess.on = noop;\n\tprocess.addListener = noop;\n\tprocess.once = noop;\n\tprocess.off = noop;\n\tprocess.removeListener = noop;\n\tprocess.removeAllListeners = noop;\n\tprocess.emit = noop;\n\t\n\tprocess.binding = function (name) {\n\t    throw new Error('process.binding is not supported');\n\t};\n\t\n\t// TODO(shtylman)\n\tprocess.cwd = function () { return '/' };\n\tprocess.chdir = function (dir) {\n\t    throw new Error('process.chdir is not supported');\n\t};\n\n\n/***/ }\n/******/ ])\n});\n\n\n\n/** WEBPACK FOOTER **\n ** blocks.umd.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 25e46c271fcdf3323517\n **/","exports.Block = require('Block')\r\nexports.Style = require('Style')\r\n\r\nexports.Canvas = require('Components/Canvas')\r\nexports.Container = require(\"Components/Container\")\r\nexports.Button = require(\"Components/Button\")\r\nexports.CheckBox = require(\"Components/CheckBox\")\r\nexports.Image = require('Components/Image')\r\nexports.List = require('Components/List')\r\n//exports.MultiSelect = require(\"Components/MultiSelect\") // not ready yet\r\nexports.Radio = require(\"Components/Radio\")\r\nexports.Select = require(\"Components/Select\")\r\nexports.Table = require(\"Components/Table\")\r\nexports.TextArea = require(\"Components/TextArea\")\r\nexports.TextField = require(\"Components/TextField\")\r\nexports.Text = require(\"Components/Text\")\r\n\r\n\r\n\r\nObject.defineProperty(exports, 'dev', {\r\n    get: function() {\r\n        return exports.Block.dev\r\n    }, set: function(v) {\r\n        exports.Block.dev = v\r\n    }\r\n})\r\n\r\nexports.attach = function(/*component,component,.. or components*/) {\r\n    exports.Block.attach.apply(this,arguments)\r\n}\r\nexports.detach = function(/*component,component,.. or components*/) {\r\n    exports.Block.detach.apply(this,arguments)\r\n}\r\n\r\nexports.createBody = function(callback) {\r\n    exports.Block.detach.apply(this,arguments)\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./blocks.browser.js\n ** module id = 0\n ** module chunks = 0\n **/","var EventEmitterB = require('EventEmitterB')\nvar proto = require(\"proto\");\nvar trimArguments = require(\"trimArguments\")\nvar observe = require('observe')\n\nvar utils = require('./utils')\nvar domUtils = require('./domUtils')\nvar blockStyleUtils = require(\"./blockStyleUtils\")\n\nvar Style = require(\"./Style\")\nStyle.isDev = function() {return module.exports.dev}\n\nvar components = {};\n\nvar setOfBrowserEvents = utils.arrayToMap([\n    'abort','afterprint','animationend','animationiteration','animationstart','audioprocess','beforeprint','beforeunload',\n    'beginEvent','blocked','blur','cached','canplay','canplaythrough','change','chargingchange','chargingtimechange',\n    'checking','click','close','compassneedscalibration','complete','compositionend','compositionstart','compositionupdate','contextmenu',\n    'copy','cut','dblclick','decivelight','devicemotion','deviceorientation','deviceproximity','dischargingtimechange','DOMContentLoaded',\n    'downloading','drag','dragend','dragenter','dragleave','dragover','dragstart','drop','durationchange','emptied','ended','endEvent',\n    'error','focus','focusin','focusout','fullscreenchange','fullscreenerror','gamepadconnected','gamepaddisconnected','hashchange',\n    'input','invalid','keydown','keypress','keyup','languagechange','levelchange','load','loadeddata','loadedmetadata','loadend',\n    'loadstart','message','mousedown','mouseenter','mouseleave','mousemove','mouseout','mouseover','mouseup','noupdate','obsolete',\n    'offline','online','open','orientationchange','pagehide','pageshow','paste','pause','pointerlockchange','pointerlockerror','play',\n    'playing','popstate','progress','ratechange','readystatechange','repeatEvent','reset','resize','scroll','seeked','seeking','select',\n    'show','stalled','storage','submit','success','suspend','SVGAbort','SVGError','SVGLoad','SVGResize','SVGScroll','SVGUnload','SVGZoom',\n    'timeout','timeupdate','touchcancel','touchend','touchenter','touchleave','touchmove','touchstart','transitionend','unload',\n    'updateready','upgradeneeded','userproximity','versionchange','visibilitychange','volumechange','waiting','wheel'\n])\n\n// events:\n    // newParent - emits this when a component gets a new parent\n    // parentRemoved - emits this when a component is detached from its parent\nvar Block = module.exports = proto(EventEmitterB,function(superclass) {\n\n    // static properties\n\n    // constructor\n\tthis.init = function() {\n        var that = this\n\n        if(this.name === undefined) {\n            throw new Error(\"The 'name' property is required for Blocks\")\n        }\n\n        var defaultBlockStyle = blockStyleUtils.defaultStyleMap.get(this.constructor)\n        if(defaultBlockStyle === undefined) {\n            defaultBlockStyle = blockStyleUtils.createDefaultBlockStyle(this)\n        }\n\n        superclass.init.call(this)\n\n        this.children = []\n        this.state = observe({})\n        this.parent = undefined;\n\n\t\tif (this.id !== undefined) {\n\t\t\tcomponents[this.id] = this;\n\t\t}\n\n        if(this.domNode === undefined) {\n            this.domNode = domUtils.div()\n        }\n\n        this.build.apply(this, arguments)\n\n        //if(module.exports.dev) {\n            this.attr('blkName', this.name)\n        //}\n\n        var classList = [this.domNode.className]\n        if(defaultBlockStyle !== false) classList.push(defaultBlockStyle.className)\n        classList.push(Style.defaultClassName)\n        this.domNode.className = classList.join(' ') // note that the order of classes doesn't matter\n\n        // set up dom event handlers\n        var ifonHandlers={}\n        that.ifon(function(event) {\n            if(event in setOfBrowserEvents && (that.excludeDomEvents === undefined || !(event in that.excludeDomEvents))) {\n                that.domNode.addEventListener(event, ifonHandlers[event]=function() {\n                    that.emit.apply(that, [event].concat(Array.prototype.slice.call(arguments)))\n                })\n            }\n        })\n        that.ifoff(function(event) {\n            if(event in setOfBrowserEvents && (that.excludeDomEvents === undefined || !(event in that.excludeDomEvents))) {\n                that.domNode.removeEventListener(event,ifonHandlers[event])\n            }\n        })\n\t}\n\n    // sub-constructor - called by the constructor\n    // parameters:\n        // label - (Optional) A label that can be used to style a component differently.\n                   // Intended to be some string describing what the component is being used for.\n                   // Note, tho, that labels are not dynamic - changing the label won't affect styling until a new style is applied to the component)\n        // domNode - (Optional) A domNode to be used as the container domNode instead of the default (a div)\n    this.build = function(/*[label,] domNode*/) {\n        if(arguments.length === 1) {\n            this.domNode = arguments[0]\n        } else if(arguments.length >= 2) {\n            this.label = arguments[0]\n            this.domNode = arguments[1]\n        }\n    }\n\t\n\n\t// instance properties\n\n\t\n\tthis.domNode;\n    this.label;\n    this.excludeDomEvents;\n    this.children;     // a list of child components that are a part of a Block object (these are used so Styles can be propogated down to child components)\n\n\n    Object.defineProperty(this, 'label', {\n        get: function() {\n            return this._label\n        }, set: function(v) {\n            if(this._label === undefined) {\n                this._label = v\n\n                if(module.exports.dev) {\n                    this.attr('label', this._label)\n                }\n            } else {\n                throw new Error(\"A Block's label can only be set once (was already set to: \"+this._label+\")\")\n            }\n        }\n    })\n\n    // adds elements to the components main domNode\n    // arguments can be one of the following:\n        // component, component, component, ...\n        // listOfBlocks\n    this.add = function() {\n        this.addAt.apply(this, [this.domNode.children.length].concat(trimArguments(arguments)))\n\t}\n\n    // adds nodes at a particular index\n    // nodes can be one of the following:\n        // component, component, component, ...\n        // listOfBlocks\n    this.addAt = function(index/*, nodes...*/) {\n        var nodes = normalizeAddAtArguments.apply(this, arguments)\n\n        for (var i=0;i<nodes.length;i++) {\n\t\t\tvar node = nodes[i];\n            this.children.splice(index+i, 0, node)\n\n            if(!isBlock(node)) {\n                throw new Error(\"node is not a Block\")\n            }\n\n            node.parent = undefined\n            node.emit('parentRemoved')\n\n            var beforeChild = this.children[1+i+index]\n            if(beforeChild === undefined) {\n                this.domNode.appendChild(node.domNode)\n            } else {\n                this.domNode.insertBefore(node.domNode, beforeChild.domNode)\n            }\n\n            node.parent = this;\n            node.emit('newParent')\n\n            // apply styles\n            //if(itsaBlock) { // its always a component now\n                var that = this\n                node.getParentStyleMap = function() {return that.computedStyleMap}\n                blockStyleUtils.propogateStyleSet([node], this.computedStyleMap)\n            //}\n\t\t}\n    }\n\n\t// add a list of nodes before a particular node\n    // if beforeChild is undefined, this will append the given nodes\n    // arguments can be one of the following:\n        // component, component, component, ...\n        // listOfBlocks\n    this.addBefore = this.addBeforeNode = function(beforeChild) {\n        var nodes = trimArguments(arguments).slice(1)\n        if(beforeChild === undefined) {\n            this.add.apply(this, nodes)\n        } else {\n            var index = this.children.indexOf(beforeChild)\n            this.addAt.apply(this, [index].concat(nodes))\n        }\n    }\n\n\n    // arguments can be one of the following:\n        // component, component, component, ...\n        // index, index, index, ... - each index is the numerical index to remove\n        // arrayOfComponents\n        // arrayOfIndexes\n    this.remove = function() {\n        var removals = normalizeRemoveArguments.apply(this, arguments)\n        removals = removals.sort(function(a,b) {\n            return b-a // reverse sort (so that removing multiple indexes doesn't mess up)\n        })\n\n        for(var n=0; n<removals.length; n++) {\n            var r = removals[n]\n            var c = this.children[r]\n\n            if(c === undefined) {\n                throw new Error(\"There is no child at index \"+r)\n            }\n\n            c.parent = undefined\n            this.children.splice(r, 1)\n            this.domNode.removeChild(this.domNode.childNodes[r])\n\n            c.emit('parentRemoved')\n        }\n    }\n\n    // sets or gets an attribute on the components domNode\n    // parameter sets:\n    // if one argument is passed, the attribute's value is returned (if there is no attribute, undefined is returned)\n    // if there are two arguments passed, the attribute is set\n        // if 'value' is undefined, the attribute is removed\n    this.attr = function(/*attribute, value OR attributeObject*/) {\n        if(arguments.length === 1) {\n            if(arguments[0] instanceof Object) {\n                var attributes = arguments[0]\n                for(var attribute in attributes) {\n                    domUtils.setAttribute(this.domNode, attribute, arguments[0][attribute])\n                }\n            } else {\n                var attribute = this.domNode.getAttribute(arguments[0])\n                if(attribute === null) {\n                    return undefined // screw null\n                } else {\n                    return attribute\n                }\n            }\n        } else {\n            var attribute = arguments[0]\n            if(arguments[1] !== undefined) {\n                var value = arguments[1]\n                domUtils.setAttribute(this.domNode, arguments[0], value)\n            } else {\n                this.domNode.removeAttribute(attribute)\n            }\n        }\n    }\n\n    Object.defineProperty(this, 'visible', {\n        // returns true if the element is visible\n        get: function() {\n            return this.domNode.style.display !== 'none';\n\n        // sets whether or not the element is visible\n        }, set: function(setToVisible) {\n            if(setToVisible) {\n                if (this._displayStyle !== undefined) {\n                    this.domNode.style.display = this._displayStyle // set back to its previous inline style\n                    this._displayStyle = undefined\n                } else {\n                    this.domNode.style.display = ''\n                }\n            } else {\n                if(this.domNode.style.display !== '' && this.domNode.style.display !== 'none') { // domNode has inline style\n                    this._displayStyle = this.domNode.style.display\n                }\n\n                this.domNode.style.display = 'none'\n            }\n        }\n    })\n\n\n    Object.defineProperty(this, 'focus', {\n        // returns true if the element is in focus\n        get: function() {\n            return document.activeElement === this.domNode\n\n        // sets whether or not the element is in focus (setting it to true gives it focus, setting it to false blurs it)\n        }, set: function(setToInFocus) {\n            if(setToInFocus) {\n                this.domNode.focus()\n            } else {\n                this.domNode.blur()\n            }\n        }\n    })\n\n    Object.defineProperty(this, 'style', {\n        get: function() {\n            return this._style\n\n        // sets the style, replacing one if one already exists\n        }, set: function(styleObject) {\n            if(styleObject === undefined) {\n                var styleMap = this.getParentStyleMap()\n                if(styleMap !== undefined) {\n                    blockStyleUtils.setCurrentStyle(this, blockStyleUtils.getStyleForComponent(styleMap, this))\n                } else {\n                    blockStyleUtils.setCurrentStyle(this, undefined)\n                }\n\n                this.computedStyleMap = styleMap\n\n            } else {\n                blockStyleUtils.setCurrentStyle(this, styleObject)\n                var specificStyle = styleObject.get(this)\n                if(this.getParentStyleMap() !== undefined) {\n                    this.computedStyleMap = blockStyleUtils.styleMapConjunction(this.getParentStyleMap(), specificStyle.componentStyleMap)\n                } else {\n                    this.computedStyleMap = specificStyle.componentStyleMap\n                }\n            }\n\n            this._style = styleObject\n            blockStyleUtils.propogateStyleSet(this.children, this.computedStyleMap) // propogate styles to children\n        }\n    })\n\n    Object.defineProperty(this, 'selectionRange', {\n        // returns the visible character selection range inside the element\n        // returns an array like [offsetStart, offsetEnd]\n        get: function() {\n            return domUtils.getSelectionRange(this.domNode)\n\n        // sets the visible character selection range\n        }, set: function(selection) {\n            domUtils.setSelectionRange(this.domNode, selection[0], selection[1])\n        }\n    })\n\n    this.attach = function() {\n        attach(this)\n    }\n    this.detach = function() {\n        detach(this)\n    }\n\n\n\t// private instance variables/functions\n\n    this.getParentStyleMap = function() {/*default returns undefined*/}  // should be set to a function that returns the computedStyleMap of the component containing this one (so Styles objects can be inherited)\n    this.computedStyleMap;  // a map of style objects computed from the Styles set on a given component and its parent components\n\n\tthis._style;              // the object's explicit Style object (undefined if it inherits a style)\n    this.currentStyle;       // the object's current Style (inherited or explicit)\n    this._displayStyle;      // temporariliy stores an inline display style while the element is hidden (for use when 'show' is called)\n    this._styleSetupStates   // place to put states for setup functions (used for css pseudoclass emulation)\n});\n\n\nmodule.exports.dev = false // set to true to enable dom element naming (so you can see boundaries of components when inspecting the dom)\n\n\n// appends components to the body\nvar attach = module.exports.attach = function(/*component,component,.. or components*/) {\n    if(arguments[0] instanceof Array) {\n        var components = arguments[0]\n    } else {\n        var components = arguments\n    }\n\n    if(document.body === null) throw new Error(\"Your document does not have a body.\")\n\n    for(var n=0; n<components.length; n++) {\n        document.body.appendChild(components[n].domNode)\n    }\n}\n// removes components from the body\nvar detach = module.exports.detach = function(/*component,component,.. or components*/) {\n    if(arguments[0] instanceof Array) {\n        var components = arguments[0]\n    } else {\n        var components = arguments\n    }\n\n    for(var n=0; n<components.length; n++) {\n        document.body.removeChild(components[n].domNode)\n    }\n}\n\n// creates a body tag (only call this if document.body is null)\n\nmodule.exports.createBody = function(callback) {\n    var dom = document.implementation.createDocument('http://www.w3.org/1999/xhtml', 'html', null);\n    var body = dom.createElement(\"body\")\n    dom.documentElement.appendChild(body)\n    setTimeout(function() {  // set timeout is needed because the body tag is only added after javascript goes back to the scheduler\n        callback()\n    },0)\n}\n\n\n\n\n// returns a list of indexes to remove from Block.remove's arguments\n/*private*/ var normalizeRemoveArguments = module.exports.normalizeRemoveArguments = function() {\n    var that = this\n\n    if(arguments[0] instanceof Array) {\n        var removals = arguments[0]\n    } else {\n        var removals = Array.prototype.slice.call(arguments)\n    }\n\n    return removals.map(function(removal, parameterIndex) {\n        if(isBlock(removal)) {\n            var index = that.children.indexOf(removal)\n            if(index === -1) {\n                throw new Error(\"The Block passed at index \"+parameterIndex+\" is not a child of this Block.\")\n            }\n            return index\n        } else {\n            return removal\n        }\n\n    })\n}\n\n// returns a list of nodes to add\n/*private*/ var normalizeAddAtArguments = module.exports.normalizeAddAtArguments = function() {\n    if(arguments.length === 2) {\n        if(arguments[1] instanceof Array) {\n            return arguments[1]\n        } else {\n            return [arguments[1]]\n        }\n    } else { // > 2\n        return trimArguments(arguments).slice(1)\n    }\n}\n\nfunction isBlock(c) {\n    return c.add !== undefined && c.children instanceof Array && c.domNode !== undefined\n}\nfunction isDomNode(node) {\n    return node.nodeName !== undefined\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Block.js\n ** module id = 1\n ** module chunks = 0\n **/","var jssModule = require(\"../external/jss\")\nvar proto = require('proto')\nvar HashMap = require('hashmap') // .HashMap // weirdly, it looks like this is being treated like an AMD module\n\nvar utils = require(\"./utils\")\nvar blockStyleUtils = require(\"./blockStyleUtils\")\n\nvar baseClassName = '_ComponentStyle_' // the base name for generated class names\nvar nextClassNumber = 0\n\nvar defaultJss = jssModule.forDocument(document) // must be created before the jss object (so that the styles there override the styles in the default sheet)\ndefaultJss.defaultSheet = defaultJss._createSheet() // create its sheet first (before the regular jss sheet)\nvar jss = jssModule.forDocument(document)\njss.defaultSheet = jss._createSheet()\n\n// creates a style object\nvar Style = module.exports = proto(function() {\n\n    this.defaultClassName = '_default_'     // the name of the default class (used to prevent style inheritance)\n\n    // styleDefinition is an object where key-value pairs can be any of the following:\n    // <cssPropertyName>: the value should be a valid css value for that style attribute\n    // <ComponentName>: the value can either be a Style object or a nested styleDefinition object\n    // $setup: the value is a function to be run on a component when the style is applied to it\n    // $kill: the value is a function to be run on a component when a style is removed from it\n    // $state: the value should be a state handler function\n    // $<label>: the value should be a nested styleDefinition object that does not contain any label styles.\n    this.init = function(styleDefinition, privateOptions) {\n        if(privateOptions === undefined) privateOptions = {}\n        if(privateOptions.inLabel===undefined) inLabel = false\n\n        this.className = baseClassName+nextClassNumber\n        nextClassNumber++\n\n        this.componentStyleMap = {}\n        this.labelStyleMap = {}\n\n        var labelStyles = {}\n        var pseudoClassStyles = {}\n        var cssProperties = {}\n        for(var key in styleDefinition) {\n            var value = styleDefinition[key]\n\n            if(key === '$setup') {\n                if(!(value instanceof Function)) throw new Error(\"$setup key must be a function ('setup' can't be used as a label)\")\n                this.setup = value\n\n            } else if(key === '$kill') {\n                if(!(value instanceof Function)) throw new Error(\"$kill key must be a function ('kill' can't be used as a label)\")\n                this.kill = value\n\n            } else if(key.indexOf('$$') === 0) { // pseudo-class style\n                var pseudoClass = mapCamelCase(key.substr(2))\n                if(pseudoClass === '') {\n                    throw new Error(\"Empty pseudo-class name not valid (style key '$$')\")\n                }\n\n                utils.merge(pseudoClassStyles, flattenPseudoClassStyles(pseudoClass, value))\n\n            } else if(key.indexOf('$') === 0) {   // label style\n                if(privateOptions.inLabel)\n                    throw new Error(\"Can't create nested label style \"+key+\" because components can only have one label\")\n\n                var label = key.substr(1)\n                if(label === '') {\n                    throw new Error(\"Empty label name not valid (style key '$')\")\n                }\n\n                labelStyles[label] = value\n\n            } else if(isStyleObject(value)) {\n                this.componentStyleMap[key] = value\n\n            } else if(value instanceof Object) {\n                this.componentStyleMap[key] = Style(value)  // turn the object description into a full fledged style object\n            } else {\n                var cssStyle = key\n                var cssStyleName = mapCamelCase(cssStyle)\n                cssProperties[cssStyleName] = cssValue(cssStyleName, value)\n            }\n        }\n\n        // create the css class\n        if(privateOptions.default) {\n            var jssSheet = defaultJss\n        } else {\n            var jssSheet = jss\n        }\n\n        jssSheet.set('.'+this.className, cssProperties)\n\n        //if(module.exports.isDev) {\n            this.styleDefinitions = {}\n            this.styleDefinitions['.'+this.className] = cssProperties\n        //}\n\n        // create label styles\n        if(Object.keys(labelStyles).length > 0) {\n            var baseStyle = utils.merge({}, cssProperties, this.componentStyleMap)\n\n            for(var label in labelStyles) {\n                if(isStyleObject(labelStyles[label])) {\n                    this.labelStyleMap[label] = labelStyles[label]\n                } else {\n                    var mergedStyle = utils.merge({}, baseStyle, labelStyles[label])\n                    this.labelStyleMap[label] = Style(mergedStyle, {inLabel:true})\n                }\n            }\n        }\n\n        // create pseudoclass styles\n        if(Object.keys(pseudoClassStyles).length > 0) {\n\n            var tieredPseudoClasses = createTieredPseudoClasses(this, pseudoClassStyles)\n            pseudoclassCombinations(tieredPseudoClasses) // mutates tieredPseudoClasses\n\n            // turn the emulatable pseudo classes into Style objects\n            // also build up the set of psuedoclasses that will be emulated\n            // also build up a map of pseudoclasses-to-emulate to the emulation functions for those pseudoclasses\n            var pseudoClasesToEmulate = []\n            var preSplitPseudoClasses = [] // a list where each element looks like: [pseudoClassList, styleObject]  (this is primarily for performance - so we don't have to split the key every time we check for state changes)\n            var pseudoClassesToEmulationInfo = {}\n            for(var key in tieredPseudoClasses) {\n                if(isStyleObject(tieredPseudoClasses[key])) {\n                    tieredPseudoClasses[key] = tieredPseudoClasses[key]\n                } else {\n                    var newStyle = Style(utils.merge({}, cssProperties, tieredPseudoClasses[key])) // pseudoClassStyles merged with parent css styles\n\n                    // merge in componentStyleMap and labelStyleMap\n                    for(var k in this.componentStyleMap) {\n                        if(newStyle.componentStyleMap[k] === undefined)\n                            newStyle.componentStyleMap[k] = this.componentStyleMap[k]\n                    }\n                    for(var k in this.labelStyleMap) {\n                        if(newStyle.labelStyleMap[k] === undefined)\n                            newStyle.labelStyleMap[k] = this.labelStyleMap[k]\n                    }\n\n                    tieredPseudoClasses[key] = newStyle\n                }\n\n\n                var pseudoClassList = key.split(\":\")\n                for(var n=0; n<pseudoClassList.length; n++) {\n                    var pseudoClass = pseudoClassList[n]\n                    if(pseudoClasesToEmulate.indexOf(pseudoClass) === -1) {\n                        pseudoClasesToEmulate.push(pseudoClass)\n\n                        var pseudoClassParts = getPseudoClassParts(pseudoClass)\n                        var fns = emulatedPseudoClasses[pseudoClassParts.class]\n                        var info = {fns: fns}\n                        if(fns.processParameter !== undefined) {\n                            info.parameter = fns.processParameter(pseudoClassParts.parameter)\n                        }\n                        pseudoClassesToEmulationInfo[pseudoClass] = info\n                    }\n                }\n\n                preSplitPseudoClasses.push([pseudoClassList, tieredPseudoClasses[key]])\n            }\n\n            // create functions that initialize and keep track of state\n            var initializeState = function(component) {\n                var state = {}\n                for(var n=0; n<pseudoClasesToEmulate.length; n++) {\n                    var pseudoClass = pseudoClasesToEmulate[n]\n                    var pseudoClassEmulationInfo = pseudoClassesToEmulationInfo[pseudoClass]\n                    state[pseudoClass] = pseudoClassEmulationInfo.fns.check(component, pseudoClassEmulationInfo.parameter)\n                }\n\n                return state\n            }\n\n            var that = this\n            var changeStyleIfNecessary = function(currentStyle, component, state) {\n                var longestMatchingLength = 0;\n                var mostSpecificMatchingStyle = that; // if nothing else matches, change back to the base style object\n                for(var n=0; n<preSplitPseudoClasses.length; n++) {\n                    var pseudoClassList = preSplitPseudoClasses[n][0]\n                    for(var j=0; j<pseudoClassList.length; j++) {\n                        if(!state[pseudoClassList[j]]) {\n                            break;\n                        }\n                    }\n\n                    if(j === pseudoClassList.length && j > longestMatchingLength) {\n                        longestMatchingLength = j\n                        mostSpecificMatchingStyle = preSplitPseudoClasses[n][1]\n                    }\n                }\n\n                if(mostSpecificMatchingStyle !== currentStyle) {\n                    component.style = mostSpecificMatchingStyle\n\n                    //blockStyleUtils.setCurrentStyle(component, mostSpecificMatchingStyle)\n                    //blockStyleUtils.propogateStyleSet(component.children, component.computedStyleMap) // propogate styles to children\n                }\n            }\n\n            // setup pseudoclass emulation with $setup and $kill handlers\n\n            var wrapSetupAndKill = function(style) {\n                var originalSetup = style.setup\n                style.setup = function(component) {\n                    var that = this\n\n                    this._styleSetupStates = {} // maps pseudoClass to setupState\n                    var state = initializeState(component)\n                    for(var pseudoClass in pseudoClassesToEmulationInfo) {\n                        ;(function(pseudoClass, emulationInfo){   // close over those variables (so they keep the value they had when the function was setup)\n                            that._styleSetupStates[pseudoClass] = emulationInfo.fns.setup(component, function() { // start\n                                state[pseudoClass] = true\n                                changeStyleIfNecessary(that, component, state)\n                            }, function() { // end\n                                state[pseudoClass] = false\n                                changeStyleIfNecessary(that, component, state)\n                            }, emulationInfo.parameter)\n\n                        })(pseudoClass, pseudoClassesToEmulationInfo[pseudoClass])\n                    }\n\n                    changeStyleIfNecessary(that, component, state)\n\n                    if(originalSetup !== undefined) {\n                        originalSetup.apply(this, arguments)\n                    }\n                }\n\n                var originalKill = style.kill\n                style.kill = function(component) {\n                    for(var pseudoClass in pseudoClassesToEmulationInfo) {\n                        var emulationInfo = pseudoClassesToEmulationInfo[pseudoClass]\n                        emulationInfo.fns.kill(component, this._styleSetupStates[pseudoClass])\n                    }\n\n                    if(originalKill !== undefined) {\n                        originalKill.apply(this, arguments)\n                    }\n                }\n            }\n\n            // wrap all the setup and kill functions\n\n            for(var key in tieredPseudoClasses) {\n                var style = tieredPseudoClasses[key]\n                wrapSetupAndKill(style)\n            }\n\n            wrapSetupAndKill(this)\n        }\n    }\n\n    // instance properties\n\n    this.className          // the css classname for this style\n    this.componentStyleMap; // maps a Component name to a Style object for that component\n    this.labelStyleMap;     // maps a label name to a Style object for that label\n    this.setup;             // run some javascript on any element this class is applied to\n    this.kill;              // a function to run on removal of the style (should reverse setup)\n\n    // gets the style object for a component based on the current style object (takes into account whether the component has a label\n    this.get = function(component) {\n        if(component.label !== undefined) {\n            var labelStyle = this.labelStyleMap[component.label]\n            if(labelStyle !==  undefined) {\n                return labelStyle\n            }\n        }\n        // else\n        return this\n    }\n})\n\n\n// private\n\n\n// returns a two-level map where the top-level keys are emulatable psuedo classes, and non-emulatable pseudo classes are at the second level\n// the classes will also be sorted and deduped\n// Example return value: {\"hover:lastChild\": {color:'red', \"$$visited:disabled\": {fontWeight: 'bold'}}, }\n// parameters:\n    // style - the style object being created\n    // pseudoClassStyles - a flat object where each key is a list of pseudoclasses separated by colons (e.g. \"hover\" or \"hover:focus\") and the value is an object of styles that don't contain pseudoclasses\nfunction createTieredPseudoClasses(style, pseudoClassStyles) {\n    var tieredPseudoClasses = {} // the two-level map\n    for(var key in pseudoClassStyles) {\n        var value = pseudoClassStyles[key]\n\n        // split key into pseudoclass list\n        var pseudoClassList = key.split(\":\")\n        var emulatablePseudoClasses = []\n        var nonEmulatablePseudoClasses = []\n        for(var n in pseudoClassList) {\n            var pseudoClass = pseudoClassList[n]\n            var pseudoClassParts = getPseudoClassParts(pseudoClass)\n            if(pseudoClassParts.class in emulatedPseudoClasses) {\n                emulatablePseudoClasses.push(pseudoClass)\n            } else {\n                nonEmulatablePseudoClasses.push(pseudoClass)\n            }\n        }\n\n        // todo: add a third branch as an optimization: if the Style can be rendered without emulation - do that\n        if(emulatablePseudoClasses.length === 0) { // if none of the pseudoclasses can be emulated using javascript\n            validatePurePseudoClassStyles(key, value)                        // then validate the value and\n            createPseudoClassRules(style, key, '.'+style.className+\":\"+key, value)   // create pseudoClassRules\n\n        } else { // if some of the pseudoclasses can be emulated using javascript\n\n            emulatablePseudoClasses.sort()\n            var emulatablePseudoClassKey = emulatablePseudoClasses.join(':')\n            if(tieredPseudoClasses[emulatablePseudoClassKey] === undefined)\n                tieredPseudoClasses[emulatablePseudoClassKey] = {}\n\n            if(nonEmulatablePseudoClasses.length === 0) {\n                utils.merge(tieredPseudoClasses[emulatablePseudoClassKey], value)\n            } else {\n                nonEmulatablePseudoClasses.sort()\n                var nonEmulatablePsuedoClassKey = nonEmulatablePseudoClasses.join(':')\n\n                var secondTier = {}\n                secondTier['$$'+nonEmulatablePsuedoClassKey] = value\n\n                utils.merge(tieredPseudoClasses[emulatablePseudoClassKey], secondTier)\n            }\n        }\n    }\n\n    return tieredPseudoClasses\n}\n\n\n\n// make combinations of the emulatable pseudoclasses, so that they combine like the non-emulated ones do\n// info about mathematical combination: https://en.wikipedia.org/wiki/Combination\n// mutates tieredPseudoClasses\nfunction pseudoclassCombinations(tieredPseudoClasses) {\n    var tieredPseudoClassesKeys = Object.keys(tieredPseudoClasses).reverse().map(function(v) {    // reverse first so that more specific pseudoclasses go first\n        return {key: v, parts: v.split(':')} // so it doesn't have to split every time\n    })\n\n    for(var n=0; n<tieredPseudoClassesKeys.length; n++) {\n        var keyA = tieredPseudoClassesKeys[n]\n        for(var k=2; k <= tieredPseudoClassesKeys.length; k++) { // k is the number of psuedoclasses to combine\n            for(var j=n+1; j<tieredPseudoClassesKeys.length-(k-2); j++) {\n                var result = combinePseudoclasses(tieredPseudoClasses, [keyA].concat(tieredPseudoClassesKeys.slice(j, k)))\n                if(result.key in tieredPseudoClasses) {\n                    utils.merge(tieredPseudoClasses[result.key], result.value)\n                } else { // new key\n                    tieredPseudoClasses[result.key] = result.value\n                }\n            }\n        }\n    }\n}\n\n\n\n// keys is a list of objects where each object has the members:\n    // key - the original string key\n    // parts - the key split by \":\"\n// returns an object with the following members:\n    // key - the new combined key\n    // value - the new merged value\nvar combinePseudoclasses = function(pseudoclasses, keys) {\n    var resultKeyParts = keys[0].parts\n    var resultValue = utils.merge({}, pseudoclasses[keys[0].key]) // make a copy\n    for(var n=1; n<keys.length; n++) {\n        var key = keys[n]\n        // merge all psuedoclasses that don't already exist into the resultKey\n        for(var j=0; j<key.parts.length; j++) {\n            var part = key.parts[j]\n            if(resultKeyParts.indexOf(part) === -1) {\n                resultKeyParts.push(part)\n            }\n        }\n\n        // merge the value into resultValue\n        utils.merge(resultValue, pseudoclasses[key.key])\n    }\n\n    return {key: resultKeyParts.join(':'), value: resultValue}\n}\n\n// a map of pseudoclass names and how they are emulated with javascript\n// each pseudoclass sets up the following functions:\n    // check - a function that checks if that pseudoclass currently applies to the component when its called\n    // setup - calls a callback when the pseudoClass starts and stops applying\n        // should return an object that will be passed to the kill function (as its 'state' parameter)\n    // kill - cleans up anything set up in the 'setup' function\n    // processParameter - takes the pseudoclass parameter and returns some object representing it that will be used by the setup and check functions\nvar emulatedPseudoClasses = {\n    hover: {\n        check: function(component) {\n            var nodes = document.querySelectorAll( \":hover\" )\n            for(var n=0; n<nodes.length; n++) {\n                if(nodes[n] === component.domNode) {\n                    return true\n                }\n            }\n            return false\n        },\n        setup: function(component, startCallback, endCallback) {\n            component.on(\"mouseover\", function() {\n                startCallback()\n            })\n            component.on(\"mouseout\", endCallback)\n\n            return {start: startCallback, end: endCallback}\n        },\n        kill: function(component, state) {\n            component.off(\"mouseover\", state.start)\n            component.off(\"mouseout\", state.end)\n        }\n    },\n    checked: {\n        check: function(component) {\n            return component.selected\n        },\n        setup: function(component, startCallback, endCallback) {\n            var setupState = {}\n            component.on(\"change\", setupState.listener = function() {\n                if(component.selected) {\n                    startCallback()\n                } else {\n                    endCallback()\n                }\n            })\n\n            return setupState\n        },\n        kill: function(component, state) {\n            component.removeListener(\"change\", state.listener)\n        }\n    },\n    required: {\n        check: function(component) {\n            return component.attr('required') !== undefined\n        },\n        setup: function(component, startCallback, endCallback) {\n            var observer = new MutationObserver(function() {\n                if(component.attr('required') !== undefined) {\n                    startCallback()\n                } else {\n                    endCallback()\n                }\n            })\n\n            observer.observe(component.domNode, {attributes: true})\n\n            return {observer: observer}\n        },\n        kill: function(component, state) {\n            state.observer.disconnect()\n        }\n    },\n    'last-child': {\n        check: function(component) {\n            return nthLastChildCheck(component, '1')\n        },\n        setup: function(component, startCallback, endCallback) {\n            var observer = new MutationObserver(function() {\n                if(nthLastChildCheck(component, '1')) {\n                    startCallback()\n                } else {\n                    endCallback()\n                }\n            })\n\n            var setupObserver = function() {\n                // note that since this uses the component parent rather than domNode.parentNode, this won't work for components added to non-component nodes (and there's no good way to do it, because you would have to poll for parent changes)\n                observer.observe(component.parent.domNode, {childList: true})\n            }\n\n            if(component.parent !== undefined) {\n                setupObserver()\n            }\n\n            component.on('newParent', function() {\n                setupObserver()\n            })\n            component.on('parentRemoved', function() {\n                observer.disconnect()\n            })\n\n            return {observer: observer}\n        },\n        kill: function(component, state) {\n            state.observer.disconnect()\n        }\n    },\n    'nth-child': {\n        // todo: support full an+b parameters for nth-child https://developer.mozilla.org/en-US/docs/Web/CSS/:nth-child\n        check: function(component, parameterCheck) {\n            return nthChildCheck(component, parameterCheck)\n        },\n        setup: function(component, startCallback, endCallback, parameterCheck) {\n\n            var checkAndCallCallbacks = function() {\n                if(nthChildCheck(component, parameterCheck)) {\n                    startCallback()\n                } else {\n                    endCallback()\n                }\n            }\n\n            var observer = new MutationObserver(function() {\n                checkAndCallCallbacks()\n            })\n\n            var setupObserver = function() {\n                // note that since this uses the component parent rather than domNode.parentNode, this won't work for components added to non-component nodes (and there's no good way to do it, because you would have to poll for parent changes)\n                observer.observe(component.parent.domNode, {childList: true})\n            }\n\n            if(component.parent !== undefined) {\n                setupObserver()\n            }\n\n            component.on('newParent', function() {\n                setupObserver()\n                checkAndCallCallbacks()\n            })\n            component.on('parentRemoved', function() {\n                observer.disconnect()\n                checkAndCallCallbacks()\n            })\n\n            return {observer: observer}\n        },\n        kill: function(component, state) {\n            state.observer.disconnect()\n        },\n        processParameter: function(parameter) {\n            return nthChildParameterFn(parameter)\n        }\n    },\n\n    // not's parameter is a statement consisting of pseudoclasses separated either by & or ,\n    // $$not(pseudoclass1&pseudoclass2,psuedoclass3) translates to the css :not(:pseudoclass1:pseudoclass2,:psuedoclass3)\n    /*not: {\n        check: function() {\n\n        },\n    }*/\n}\n\n// name is the name of the new pseudoclass\n// fns is an object with the members:\n    // check(component) - returns true if the pseudoclass applies to the component\n    // setup(component, startCallback, endCallback, parameter) - a function that should call startCallback when the pseudoclass starts applying, and endCallback when it stops applying\n        // parameter - the parameter passed to the pseudoclass (e.g. in :not(:first-child), \":first-child\" is the parameter)\n    // kill - a function that cleans up any event listeners or anything else set up in the 'setup' function\nmodule.exports.addPseudoClass = function(name, fns) {\n    if(emulatedPseudoClasses[name] !== undefined) throw new Error(\"The pseudoclass '\"+name+\"' is already defined.\")\n    // else\n    emulatedPseudoClasses[name] = fns\n}\n\n\nfunction nthChildCheck(component, testFn) {\n    if(component.domNode.parentNode === null)\n        return false\n\n    var children = component.domNode.parentNode.children                    // must be domNode.parentNode, because child nodes may not be Components\n    var index = Array.prototype.indexOf.call(children, component.domNode)\n    return testFn(index)\n}\n\nfunction nthLastChildCheck(component, parameter) {\n    if(component.domNode.parentNode === null)\n        return false\n\n    var children = component.domNode.parentNode.children                    // must be domNode.parentNode, because child nodes may not be Components\n    var index = children.length - parseInt(parameter)\n    return children[index] === component.domNode\n}\n\n// returns a function that takes an index and tell you if that index applies to the nthChildParameter\nvar nthChildParameter = /^(((-?\\d*)(([+-]\\d*)n?)?)|((-?\\d)*n?([+-]\\d*)?))$/\nfunction nthChildParameterFn(parameter) {\n    var parts = parameter.match(nthChildParameter)\n    if(parts === null)\n        throw new Error(\"nth-child parameter '\"+parameter+\"' isn't valid\")\n\n    if(parts[2] !== undefined) {\n        var constant = parts[3]\n        var variable = parts[5]\n    } else {\n        var constant = parts[8]\n        var variable = parts[7]\n    }\n\n    if(constant === undefined) constant = 0\n    else                       constant = parseInt(constant)\n    if(variable === undefined) variable = 0\n    else                       variable = parseInt(variable)\n\n    if(variable === 0) {\n        return function(index) {\n            return index+1 === constant\n        }\n    } else {\n        return function(index) {\n            return ((index+1-constant)/variable) % 1 === 0\n        }\n    }\n\n}\n\n// maps a style value to a css value\n// style values that are numbers are mapped to strings, usually with px postfix\nfunction cssValue(cssStyleName, value) {\n    // If a number was passed in, add 'px' to the (except for certain CSS properties) [also taken from jquery's code]\n    if(typeof(value) === \"number\" && cssNumber[cssStyleName] === undefined) {\n        return value+\"px\"\n    } else {\n        return value.toString()\n    }\n}\n\nfunction createPseudoClassRules(that, pseudoClass, selector, pseudoClassStyle) {\n\n    var pseudoClassCss = {}\n    for(var key in pseudoClassStyle) {\n        var value = pseudoClassStyle[key]\n\n        if(!(value instanceof Object)) {\n            var cssStyle = key\n            var cssStyleName = mapCamelCase(cssStyle)\n            pseudoClassCss[cssStyleName] = cssValue(cssStyleName, value)\n        } else {\n            throw new Error(\"All properties within the pseudoclasses '\"+pseudoClass+\"' must be css styles\")\n        }\n    }\n\n    // create immediate pseudo class style\n    defaultJss.set(selector, pseudoClassCss) // create the css class with the pseudoClass\n\n    //if(module.exports.isDev) {\n        that.styleDefinitions = {}\n        that.styleDefinitions[selector] = pseudoClassCss\n    //}\n}\n\n// throws exceptions for various style configurations that are unsupported by pure pseudo classes (ones that can't be emulated usuing javascript)\nfunction validatePurePseudoClassStyles(pseudoClass, pseudoClassStyles) {\n    for(var key in pseudoClassStyles) {\n        var value = pseudoClassStyles[key]\n\n        if(isStyleObject(value)) {\n            throw new Error(\"Can't set the pseudoclasses '\"+pseudoClass+\"' to a Style object\")\n        } else if(key === '$setup') {\n            throw new Error(\"$setup can't be used within the pseudoclasses '\"+pseudoClass+\"'\")\n        } else if(key === '$kill') {\n            throw new Error(\"$kill can't be used within the pseudoclasses '\"+pseudoClass+\"'\")\n        } else if(key.indexOf('$') === 0) {   // label style\n            throw new Error(\"Block labels can't be used within the pseudoclasses '\"+pseudoClass+\"'\")\n        }\n    }\n}\n\n// e.g. pulls out 'nth-child' and '2+3n' from 'nth-child(2+3n)'\nvar pseudoClassRegex = /^([^(]*)(\\((.*)\\))?$/\nfunction getPseudoClassParts(fullPsuedoClass) {\n    var x = fullPsuedoClass.match(pseudoClassRegex)\n    if(x === null) throw new Error(\"Pseudoclass '\"+fullPsuedoClass+\"' is invalid\")\n    return {class: x[1], parameter: x[3]}\n}\n\n\n// takes in a list of pseudoClassRules and changes any nesting like {hover: {focus: {}}} into something like {hover: {}, \"hover:focus\": {}}\n// also does some validation\nfunction flattenPseudoClassStyles(pseudoClass, pseudoClassStyle) {\n    var nonPseudoClassStyles = {}\n    var subpseudoClasses = {}\n    for(var key in pseudoClassStyle) {\n        var value = pseudoClassStyle[key]\n\n        if(key.indexOf('$$') === 0) { // pseudo-class style\n            var subPseudoClass = key.substr(2)\n            if(subPseudoClass === '') {\n                throw new Error(\"Empty pseudo-class name not valid (style key '$$')\")\n            }\n\n            subpseudoClasses[subPseudoClass] = value\n        } else {\n            nonPseudoClassStyles[key] = value\n        }\n    }\n\n    // create flattened styles (with merged in styles from its parent pseudoclass\n    var flattenedStyles = {}\n    for(var subPseudoClass in subpseudoClasses) {\n        var value = subpseudoClasses[subPseudoClass]\n\n        if(isStyleObject(value)) {\n            flattenedStyles[pseudoClass+\":\"+subPseudoClass] =  value\n        } else {\n            utils.merge(flattenedStyles, flattenPseudoClassStyles(pseudoClass+\":\"+subPseudoClass, utils.merge({}, nonPseudoClassStyles, value)))\n        }\n    }\n\n    // write the top-level pseudoClass\n    flattenedStyles[pseudoClass] = nonPseudoClassStyles\n\n    return flattenedStyles\n}\n\n\n// taken from jquery's code\nvar cssNumber = {\n    \"column-count\": 1,\n    \"fill-opacity\": 1,\n    \"flex-grow\": 1,\n    \"flex-shrink\": 1,\n    \"font-weight\": 1,\n    \"line-height\": 1,\n    \"opacity\": 1,\n    \"order\": 1,\n    \"orphans\": 1,\n    \"widows\": 1,\n    \"z-index\": 1,\n    \"zoom\": 1\n}\n\nfunction isStyleObject(o) {\n    return o.componentStyleMap !== undefined\n}\n\n\nvar asciiA = 'A'.charCodeAt(0), asciiZ = 'Z'.charCodeAt(0), difference = 'a'.charCodeAt(0) - asciiA\nfunction mapCamelCase(cssStyleName) {\n    for(var n=0; n<cssStyleName.length; n++) {\n        var ascii = cssStyleName.charCodeAt(n)\n        if(asciiA <= ascii && ascii <= asciiZ) { // found capital letter\n            cssStyleName = cssStyleName.slice(0, n) + '-'+String.fromCharCode(ascii+difference) + cssStyleName.slice(n+1)\n            n++ // increment a second time for the dash\n        }\n    }\n\n    return cssStyleName\n}\n\n// maps all the styles that are inherited by descendant nodes to their default values\n// source: http://stackoverflow.com/questions/5612302/which-css-styles-are-inherited\nvar defaultStyleValues = {\n    'azimuth': 'center',\n    'border-collapse': 'separate',\n    'border-spacing': '0',\n    'caption-side': 'top',\n    //'color': 'black',         // let this inherit\n    //'cursor': 'auto',         // let this one inherit - its weird otherwise\n    'direction': 'ltr',\n     display: 'inline-block', // changes the default display to inline-block\n    'elevation': '',\n    'empty-cells': 'show',\n    // 'font-family': '',       // let this inherit\n    // 'font-size': 'medium',   // let this inherit\n    //'font-style': 'normal',   // let this inherit\n    //'font-variant': 'normal', // let this inherit\n    //'font-weight': 'normal',  // let this inherit\n    'letter-spacing': 'normal',\n    'line-height': 'normal',\n    'list-style-image': 'none',\n    'list-style-position': 'outside',\n    'list-style-type': 'disc',\n    'orphans': '2',\n    'pitch-range': '',\n    'pitch': '',\n     position: 'relative', // changes the default positioning so that absolute is relative to its parent by default\n    'quotes': '',\n    'richness': '',\n    'speak-header': '',\n    'speak-numeral': '',\n    'speak-punctuation': '',\n    'speak': '',\n    'speak-rate': '',\n    'stress': '',\n    'text-align': 'left',\n    'text-indent': '0',\n    'text-transform': 'none',\n    //'visibility': 'visible',    // let this inherit - otherwise you just hide the container and not the contents\n    'voice-family': '',\n    'volume': '',\n    'white-space': 'normal',\n    'widows': '2',\n    'word-spacing': 'normal'\n}\n\ndefaultJss.set('.'+Style.defaultClassName, defaultStyleValues) // creates default css class in order to prevent inheritance\n\ndefaultJss.set('input', { // chrome and firefox user agent stylesheets mess with this otherwise\n    cursor: 'inherit'\n})\n\n/*private*/ module.exports.isDev; // should be set by Block\n\nvar computedStyles = module.exports.computedStyles = new HashMap() // stores a map from styleMap components, to the combined style map\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Style.js\n ** module id = 2\n ** module chunks = 0\n **/","var Block = require('Block')\nvar proto = require('proto')\nvar Style = require(\"Style\")\n\nmodule.exports = proto(Block, function(superclass) {\n\n    //static properties\n\n    this.name = 'Canvas'\n\n    this.init = function(/*[label,] height, width*/) {\n        if(arguments.length === 2) {\n            var height = arguments[0]\n            var width = arguments[1]\n        } else {\n            var label = arguments[0]\n            var height = arguments[1]\n            var width = arguments[2]\n        }\n\n        this.domNode = document.createElement('canvas') // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n\n        this.label = label\n        this.height = height\n        this.width = width\n    }\n\n    // instance properties\n\n    Object.defineProperty(this, 'width', {\n        get: function() {\n            return this.domNode.width\n        }, set: function(v) {\n            this.domNode.width = v\n        }\n    })\n    Object.defineProperty(this, 'height', {\n        get: function() {\n            return this.domNode.height\n        }, set: function(v) {\n            this.domNode.height = v\n        }\n    })\n\n    this.context = function() {\n        return this.domNode.getContext.apply(this.domNode, arguments)\n    }\n\n    this.toImg = this.toDataURL = function() {\n        return this.domNode.toDataURL()\n    }\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Canvas.js\n ** module id = 3\n ** module chunks = 0\n **/","var Block = require('../Block')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static properties\n\n    this.name = 'Container'\n\n\n\t// instance properties\n\n\tthis.init = function (/*[label,] content*/) {\n        if(arguments.length === 1) {\n            var contentArgs = [arguments[0]]\n        } else if(arguments.length > 1) {\n            if(typeof(arguments[0]) === 'string') {\n                var label = arguments[0]\n                var contentArgs = Array.prototype.slice.call(arguments, 1)\n            } else {\n                var contentArgs = arguments\n            }\n        }\n\n\t\tvar that = this\n        superclass.init.call(this) // superclass constructor\n\n        this.label = label\n\n\t\tif(contentArgs !== undefined)\n            this.add.apply(this,contentArgs)\n\t}\n})\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Container.js\n ** module id = 4\n ** module chunks = 0\n **/","var Block = require('Block')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\n    // static variables\n\n    this.name = 'Button'\n\n\n    // instance properties\n\n\tthis.init = function(/*[label,] text*/) {\n        if(arguments.length >= 2) {\n            var label = arguments[0]\n            var text = arguments[1]\n        } else {\n            var text = arguments[0]\n        }\n\n        this.domNode = document.createElement(\"input\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n\n        this.label = label\n\t\tthis.attr('type','button');\n\t\tthis.text = text\n\t}\n\n    Object.defineProperty(this, 'text', {\n        get: function() {\n            return this.attr('value')\n        },\n        set: function(text) {\n            this.attr('value', text)\n        }\n    })\n\n})\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Button.js\n ** module id = 5\n ** module chunks = 0\n **/","var Block = require('Block')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\t// static variables\n    this.name = 'CheckBox'\n\n\t// instance methods\n\tthis.init = function(label) {\n        var that = this\n\n        this.domNode = document.createElement(\"input\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n\n        this.label = label\n\t\tthis.attr('type','checkbox')\n\t}\n\n    Object.defineProperty(this, 'selected', {\n        // returns whether or not the checkbox is checked\n        get: function() {\n            return this.domNode.checked\n        },\n        // sets the value of the checkbox to the passed value (true for checked)\n        set: function(checked) {\n            var newValue = checked === true\n            var curValue = this.domNode.checked\n            if(curValue === newValue) return;  // do nothing if nothing's changing\n\n            this.domNode.checked = newValue\n            this.emit('change') // the browser has no listenable event that is triggered on change of the 'checked' property\n        }\n    })\n})\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/CheckBox.js\n ** module id = 6\n ** module chunks = 0\n **/","var Block = require('Block')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\n    //static properties\n\n    this.name = 'Image'\n\n    this.init = function(/*[label,] imageSource*/) {\n        if(arguments.length === 1) {\n            var imageSource = arguments[0]\n        } else {\n            var label = arguments[0]\n            var imageSource = arguments[1]\n        }\n\n        this.domNode = document.createElement('img') // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n\n        var that = this\n\n        this.label = label\n        if(imageSource !==  undefined) this.src = imageSource\n    }\n\n    // instance properties\n\n    Object.defineProperty(this, 'src', {\n        get: function() {\n            return this.domNode.src\n        }, set: function(v) {\n            this.domNode.src = v\n        }\n    })\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Image.js\n ** module id = 7\n ** module chunks = 0\n **/","var proto = require('proto')\n\nvar Block = require('Block')\nvar Style = require(\"Style\")\n\nvar Item = require(\"./Item\");\n\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static properties\n\n\tthis.Item = Item\n\n    this.name = 'List'\n\n\t// instance properties\n\n\tthis.init = function(/*[label,] [ordered,] listInit*/) {\n\t\tif(arguments[0] instanceof Array) {\n            var listInit = arguments[0]\n        } else {\n            if(arguments[1] instanceof Array) {\n                var listInit = arguments[1]\n            } else if(arguments[2] instanceof Array) {\n                var listInit = arguments[2]\n            }\n\n            if(typeof(arguments[0]) === 'boolean') {\n                var ordered = arguments[0]\n            } else {\n                if(typeof(arguments[1]) === 'boolean') {\n                    var ordered = arguments[1]\n                } else {\n                    var ordered = false // default\n                }\n\n                if(typeof(arguments[0]) === 'string') {\n                    var label = arguments[0]\n                }\n            }\n        }\n\n        if(ordered) {\n            var type = 'ol'\n        } else {\n            var type = 'ul'\n            this.defaultStyle = Style({\n                listStyleType: 'decimal'\n            })\n        }\n\n\n        this.domNode = document.createElement(type) // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n        this.label = label\n\n        if(listInit !== undefined) {\n            for(var n=0; n<listInit.length; n++) {\n                this.item(listInit[n])\n            }\n        }\n\t}\n\n\tthis.item = function() {\n\t\tvar item = Item.apply(this, arguments)\n        this.add(item)\n        return item\n\t}\n});\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/List.js\n ** module id = 8\n ** module chunks = 0\n **/","var proto = require('proto')\nvar EventEmitter = require('events').EventEmitter\n\nvar Block = require('../Block')\n\nvar randomStart = getRandomInt(0,999999) // a random number used to start off the numbers given to radio button names (using a random number in case there are somehow two different instances of blocks.js on the page)\n\n// A group of radio buttons\nmodule.exports = proto(EventEmitter, function(superclass) {\n\n\t// static properties\n\n    this.name = 'Radio'\n\n\t// instance properties\n\n\n    // required - If true, a radio button must always be selected. Otherwise, radio buttons can be deselected by clicking on them.\n\tthis.init = function(required) {\n        //this.selected\n        this.required = required === true || required === undefined\n        this.buttons = {} // maps values to the buttons that have each value\n        this.randomStart = randomStart++\n\t}\n\n    // returns a new radio button\n    this.button = function(/*[label,] value*/) {\n        if(arguments.length >= 2) {\n            var label = arguments[0]\n            var value = arguments[1]\n        } else {\n            var value = arguments[0]\n        }\n\n        if(this.buttons[value] !== undefined) {\n            throw new Error(\"Can't give a RadioButton the same value as another in the group (value: '\"+value+\"')\")\n        }\n\n        var button = RadioButton(this, label, value, \"_radioblock\"+this.randomStart)\n        this.buttons[value] = button\n\n        if(this.required && this._selected === undefined) {\n            button.selected = true\n        }\n\n        return button\n    }\n\n    // returns the RadioButton in the group that's selected (or undefined if none are selected)\n    Object.defineProperty(this, 'selected', {\n        get: function() {\n            return this._selected\n        },\n        set: function() {\n            throw new Error(\"Can't set selected on a Radio object\")\n        }\n    })\n\n    Object.defineProperty(this, 'val', {\n        // returns the value of the selected radio button in the group (undefined if none are selected)\n        get: function() {\n            var selected = this._selected\n            if(selected === undefined) return undefined\n            // else\n            return selected.attr('value')\n        },\n\n        // sets the value of the checkbox to the passed value (true for checked)\n        // throws an exception if none of the radio buttons have that value\n        // throws an exception if an unset is attempted for a required Radio set\n        set: function(value) {\n            if(value === undefined) {\n                var selected = this._selected\n                if(selected !== undefined) {\n                    selected.selected = false\n                }\n            } else {\n                var button = this.buttons[value]\n                if(button === undefined) throw new Error(\"There is no RadioButton in the group with the value: '\"+value+\"'\")\n\n                button.selected = true\n            }\n        }\n    })\n\n\n    // arguments can be one of the following:\n        // RadioButton, RadioButton, RadioButton, ...\n        // value, value, value, ... - each value is the value of the RadioButton to remove\n        // arrayOfRadioButtons\n        // arrayOfValues\n    this.remove = function() {\n        if(arguments[0] instanceof Array) {\n            var removals = arguments[0]\n        } else {\n            var removals = arguments\n        }\n\n        for(var n=0; n<removals.length; n++) {\n            var r = removals[n]\n\n            if(r instanceof RadioButton) {\n                var button = r\n                var value = r.val\n\n                if(this.buttons[value] !== r) {\n                    throw new Error(\"The button passed at index \"+n+\" is not part of the group.\")\n                }\n            } else {\n                var button = this.buttons[r]\n                var value = r\n\n                if(button === undefined) {\n                    throw new Error(\"There is no RadioButton in the group with the value: '\"+value+\"'\")\n                }\n            }\n\n            var originalSelected = this.selected\n            if(this.selected === button) {\n                this._selected = undefined\n            }\n\n            this.buttons[value].group = undefined // fully remove it from the group\n            delete this.buttons[value]\n        }\n\n        if(this.required && this.selected === undefined) {\n            for(var v in this.buttons) {\n                this.buttons[v].selected = true // just select the first one\n                break; // yes this doesn't loop\n            }\n        } else if(originalSelected !== this.selected) {\n            this.emit('change')\n        }\n    }\n\n})\n\nvar RadioButton = proto(Block, function(superclass) {\n    this.name = 'RadioButton'\n\n    this.init = function(radioGroup, label, value, name) {\n        this.domNode = document.createElement(\"input\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n\n        this.label = label\n        this.group = radioGroup\n\n        this.attr('type', 'radio')\n        this.attr('name', name) // the name is needed so that using tab to move through page elements can tab between different radio groups\n        this.val = value\n\n        var that = this\n\t\tthis.on(\"mousedown\",function(event) {\n            event.preventDefault()           // this needs to be here otherwise the radio button can't be changed\n\n\t\t\tif(that.group.required) {\n                if(that.selected === false) {\n                    that.selected = true\n                }\n            } else {\n                that.selected = !that.selected // toggle\n            }\n\t\t})\n        this.on(\"click\",function(event) {\n            event.preventDefault()         // this needs to be here otherwise the radio button can't be *unset*\n        })\n        this.on(\"keydown\",function(event) {\n            if(event.keyCode === 40 || event.keyCode === 39) { // down or right\n                event.preventDefault()         // this needs to be here otherwise the radio button strangely calls the click handler which causes things to mess up\n                that.selectNext()\n            } else if(event.keyCode === 38 || event.keyCode === 37) { // up or left\n                event.preventDefault()         // this needs to be here otherwise the radio button strangely calls the click handler which causes things to mess up\n                that.selectPrevious()\n            }\n        })\n    }\n\n    Object.defineProperty(this, 'val', {\n        // returns the value attribute of the checkbox\n        get: function() {\n            return this.attr('value')\n        },\n\n        // sets the value attribute of the checkbox\n        set: function(value) {\n            if(this.group.buttons[value] !== undefined) {\n                throw new Error(\"Can't give a RadioButton the same value as another in the group (value: '\"+value+\"')\")\n            }\n\n            var oldValue = this.val\n            this.attr('value', value)\n            if(oldValue !== undefined) delete this.group.buttons[oldValue]\n            this.group.buttons[value] = this\n        }\n    })\n\n\n    Object.defineProperty(this, 'selected', {\n        // returns whether or not the checkbox is checked\n        get: function() {\n            return this.domNode.checked\n        },\n\n        // sets the selected state of the checkbox to the passed value (true for checked)\n        set: function(value) {\n            var booleanValue = value === true\n            if(this.selected === value) return; // ignore if there's no change\n\n            if(booleanValue) {\n                var previouslySelected = this.group.selected\n                setButtonInGroup(this.group, this)\n                if(previouslySelected !== undefined)\n                    previouslySelected.emit('change')\n            } else {\n                if(this.group.required) throw new Error(\"Can't unset this Radio set, a value is required.\")\n                this.domNode.checked = false\n                this.group._selected = undefined\n            }\n            this.emit('change') // the browser has no listenable event that is triggered on change of the 'checked' property\n            this.group.emit('change')\n        }\n    })\n\n    this.selectNext = function() {\n        selectSibling(this,1)\n    }\n    this.selectPrevious = function() {\n        selectSibling(this,-1)\n    }\n\n})\n\n// direction can be +1 or -1\nfunction selectSibling(button, direction) {\n    var buttons = button.group.buttons\n    var values = Object.keys(buttons)\n    var index = values.indexOf(button.attr('value'))\n    if(direction === 1 && index === values.length-1) {\n        var buttonToSelect = buttons[values[0]]\n    } else if(direction === -1 && index === 0) {\n        var buttonToSelect = buttons[values[values.length-1]]\n\n    } else {\n        var buttonToSelect = buttons[values[index+direction]]\n    }\n\n    buttonToSelect.selected = true\n    buttonToSelect.focus()\n}\n\nfunction setButtonInGroup(group, button) {\n    var selected = group._selected\n    if(selected !== undefined) selected.domNode.checked = false\n    button.domNode.checked = true\n    group._selected = button\n}\n\nfunction getRandomInt(min, max) {\n  return Math.floor(Math.random() * (max - min)) + min;\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Radio.js\n ** module id = 9\n ** module chunks = 0\n **/","var Block = require('../Block')\nvar proto = require('proto')\n\nvar Option = require('Components/Option')\n\n// emits a 'change' event when its 'val' changes\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static variables\n\n    this.name = 'Select'\n\n    this.Option = Option\n\n\tthis.init = function(/*[label,] options*/) {\n        if(arguments[0] instanceof Object) {\n            var options = arguments[0]\n        } else {\n            var label = arguments[0]\n            var options = arguments[1]\n        }\n\n        this.domNode = document.createElement(\"select\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n        this.label = label\n\n        this.options = {}\n\n\t\tfor(var value in options) {\n\t\t\tthis.option(value, options[value])\n\t\t}\n\t}\n\n\n\t// instance methods\n\n    Object.defineProperty(this, 'val', {\n        // returns the value that is selected\n        get: function() {\n            for(var value in this.options) {\n                if(this.options[value].selected) {\n                    return value\n                }\n            }\n        },\n\n        set: function(value) {\n            var option = this.options[value]\n            if(option === undefined) throw new Error(\"There is no Option in the Select with the value: '\"+value+\"'\")\n            option.selected = true\n        }\n    })\n\t\n\tthis.option = function(/*[label,] value,text*/) {\n        if(arguments.length === 2) {\n            var value = arguments[0]\n            var text = arguments[1]\n        } else if(arguments.length === 3) {\n            var label = arguments[0]\n            var value = arguments[1]\n            var text = arguments[2]\n        } else {\n            throw new Error(\"Invalid number of arguments\")\n        }\n\n        var newOption = Option(label, value,text)\n        this.add(newOption)\n\n        return newOption\n\n\t}\n\n    // same interface as Block.addAt\n    /*override*/ this.addAt = function(index/*, nodes...*/) {\n        var that = this\n\n        var nodesToAdd = Block.normalizeAddAtArguments.apply(this, arguments)\n\n        // validation first\n        nodesToAdd.forEach(function(option) {\n            if(that.options[option.val] !== undefined) {\n                throw new Error(\"Can't give an Option the same value as another in the Select (value: '\"+option.val+\"')\")\n            }\n        })\n\n        superclass.addAt.call(this, index, nodesToAdd)\n\n        // Select specific state modifications - this must be done after the superclass call in case an error is thrown from it\n        var anyWereSelected = false\n        nodesToAdd.forEach(function(option) {\n            if(option.selected) anyWereSelected = true\n            that.options[option.val] = option\n\n            // set up Select events\n            // todo: remove events when the Option is removed\n\n            option.on(\"mousedown\",function(event) {\n                option.parent.val = option.val      // select this one\n            })\n        })\n\n        if(anyWereSelected) {\n            this.emit('change')\n        }\n    }\n\n    // same interface as Block.remove\n    /*override*/ this.remove = function() {\n        var that = this\n\n        var removalIndexes = Block.normalizeRemoveArguments.apply(this, arguments)\n        var removals = removalIndexes.map(function(index) {\n            return that.children[index]\n        })\n\n        superclass.remove.call(this, removalIndexes)\n\n        // Select specific state modifications - this must be done after the superclass call in case an error is thrown from it\n        var theSelectedWasRemoved = false\n        removals.forEach(function(option) {\n            if(option.selected) theSelectedWasRemoved = true\n            delete that.options[option.val]\n        })\n\n        if(theSelectedWasRemoved) {\n            //this.children[0].selected = true // I think the browser does this automatically??\n            this.emit('change')\n        }\n    }\n\n\n    // private\n\n    this.prepareForValueChange = function(values) {\n        var value = values[0]\n\n        for(var optionValue in this.options) {\n            if(optionValue !== value) {\n                var option = this.options[optionValue]\n                if(option.selected === true) {\n                    option.setSelectedQuiet(false)\n                }\n            }\n        }\n    }\n})\n\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Select.js\n ** module id = 10\n ** module chunks = 0\n **/","var proto = require('proto')\n\nvar Block = require('../Block')\nvar Style = require(\"Style\")\n\nvar Header = require(\"./Header\");\nvar Row = require(\"./Row\");\nvar Cell = require(\"./Cell\");\n\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static properties\n\n    this.name = 'Table'\n\n    this.defaultStyle = Style({\n        borderSpacing: 0\n    })\n\n    this.Row = Row\n\tthis.Header = Header\n    this.Cell = Cell\n\n\n\t// instance properties\n\n\tthis.init = function(/*[label,] tableInit*/) {\n\t\tif(arguments[0] instanceof Array) {\n            var tableInit = arguments[0]\n        } else {\n            var label = arguments[0]\n            var tableInit = arguments[1]\n        }\n\n        this.domNode = document.createElement(\"table\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n        this.label = label\n\n        if(tableInit !== undefined) {\n            for(var n=0; n<tableInit.length; n++) {\n                this.row(tableInit[n])\n            }\n        }\n\t}\n\t\n\tthis.header = function(/*[]label,] listOfBlocksOrText*/) {\n        return headerOrRegularRow(this, Header, arguments)\n\t}\n\n\tthis.row = function() {\n\t\treturn headerOrRegularRow(this, Row, arguments)\n\t}\n});\n\nfunction headerOrRegularRow(that, Prototype, args) {\n    var row = Prototype.apply(undefined, args)\n    that.add(row)\n    return row\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Table.js\n ** module id = 11\n ** module chunks = 0\n **/","var Block = require('../Block')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static variables\n\n    this.name = 'TextArea'\n\n\tthis.init = function(label) {\n        this.domNode = document.createElement(\"textarea\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n\t\tthis.label = label\n\t}\n\n\n\t// instance properties\n\n\n    Object.defineProperty(this, 'val', {\n        // returns the value of the Option\n        get: function() {\n            return this.domNode.value\n        },\n\n        // sets the value of the Option\n        set: function(value) {\n            if(this.val === value) return; // do nothing if there's no change\n\n            this.domNode.value = value\n            this.emit('change')\n        }\n    })\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/TextArea.js\n ** module id = 12\n ** module chunks = 0\n **/","var Block = require('../Block')\nvar proto = require('proto')\n\nvar domUtils = require(\"../domUtils\")\n\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static properties\n\n    this.name = 'TextField'\n\n\tthis.init = function(/*[label,] password*/) {\n        if(arguments.length === 1) {\n            var password = arguments[0]\n        } else if(arguments.length > 1) {\n            var label = arguments[0]\n            var password = arguments[1]\n        }\n\n        this.domNode = document.createElement(\"input\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n        superclass.init.call(this) // superclass constructor\n\n\t\tthis.label = label\n        this.domNode.className = 'field'\n\t\tdomUtils.setAttribute(this.domNode,'type','text');\n        if(password)\n            domUtils.setAttribute(this.domNode, 'type', 'password')\n\t}\n\n\n\t// instance properties\n\n    Object.defineProperty(this, 'val', {\n        // returns the value of the Option\n        get: function() {\n            return this.domNode.value\n        },\n\n        // sets the value of the Option\n        set: function(value) {\n            if(this.val === value) return; // do nothing if there's no change\n\n            this.domNode.value = value\n            this.emit('change')\n        }\n    })\n\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/TextField.js\n ** module id = 13\n ** module chunks = 0\n **/","var Block = require('../Block')\nvar proto = require('proto')\nvar Style = require(\"Style\")\n\nmodule.exports = proto(Block, function(superclass) {\n\n    //static properties\n\n    this.name = 'Text'\n\n    this.defaultStyle = Style({\n        whiteSpace: 'pre'\n    })\n\n    this.init = function(/*[label,] text*/) {\n        if(arguments.length === 1) {\n            var text = arguments[0]\n        } else {\n            var label = arguments[0]\n            var text = arguments[1]\n        }\n\n        if (text === undefined) text = '';\n\n        superclass.init.call(this) // superclass constructor\n\n        var that = this\n\n        this.label = label\n        this.text = text\n\n        this.on(\"input\",function(data) {\n            var eventData = {newText:data.srcElement.textContent,oldText:that.oldText};\n            that.oldText = eventData.newText;\n            //that.emit(\"input\",eventData);\n        });\n\n        this.on(\"blur\",function(data) {\n            var eventData = {newText:data.srcElement.textContent,oldText:that.lastFocus};\n            that.lastFocus = eventData.newText;\n            //that.emit(\"blur\",eventData);\n        });\n    }\n\n    // instance properties\n\n    Object.defineProperty(this, 'text', {\n        get: function() {\n            return this.domNode.textContent\n        }, set: function(v) {\n            this.domNode.innerText = v   // apparently textContent can't be set or something\n        }\n    })\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Text.js\n ** module id = 14\n ** module chunks = 0\n **/","/*\r\n * JSS v0.6 - JavaScript Stylesheets\r\n * https://github.com/Box9/jss\r\n *\r\n * Copyright (c) 2011, David Tang\r\n * MIT Licensed (http://www.opensource.org/licenses/mit-license.php)\r\n */\r\nvar jss = (function() {\r\n    var adjSelAttrRegex = /((?:\\.|#)[^\\.\\s#]+)((?:\\.|#)[^\\.\\s#]+)/g;\r\n    var doubleColonPseudoElRegex = /(::)(before|after|first-line|first-letter|selection)/;\r\n    var singleColonPseudoElRegex = /([^:])(:)(before|after|first-line|first-letter|selection)/;\r\n    var singleColonForPseudoElements; // flag for older browsers\r\n\r\n    function getSelectorsAndRules(sheet) {\r\n        var rules = sheet.cssRules || sheet.rules || [];\r\n        var results = {};\r\n        for (var i = 0; i < rules.length; i++) {\r\n            // Older browsers and FF report pseudo element selectors in an outdated format\r\n            var selectorText = toDoubleColonPseudoElements(rules[i].selectorText);\r\n            if (!results[selectorText]) {\r\n                results[selectorText] = [];\r\n            }\r\n            results[selectorText].push({\r\n                sheet: sheet,\r\n                index: i,\r\n                style: rules[i].style\r\n            });\r\n        }\r\n        return results;\r\n    }\r\n\r\n    function getRules(sheet, selector) {\r\n        var rules = sheet.cssRules || sheet.rules || [];\r\n        var results = [];\r\n        // Browsers report selectors in lowercase\r\n        selector = selector.toLowerCase();\r\n        for (var i = 0; i < rules.length; i++) {\r\n            var selectorText = rules[i].selectorText;\r\n            // Note - certain rules (e.g. @rules) don't have selectorText\r\n            if (selectorText && (selectorText == selector || selectorText == swapAdjSelAttr(selector) || selectorText == swapPseudoElSyntax(selector))) {\r\n                results.push({\r\n                    sheet: sheet,\r\n                    index: i,\r\n                    style: rules[i].style\r\n                });\r\n            }\r\n        }\r\n        return results;\r\n    }\r\n\r\n    function addRule(sheet, selector) {\r\n        var rules = sheet.cssRules || sheet.rules || [];\r\n        var index = rules.length;\r\n        var pseudoElementRule = addPseudoElementRule(sheet, selector, rules, index);\r\n\r\n        if (!pseudoElementRule) {\r\n            addRuleToSheet(sheet, selector, index);\r\n        }\r\n\r\n        return {\r\n            sheet: sheet,\r\n            index: index,\r\n            style: rules[index].style\r\n        };\r\n    };\r\n\r\n    function addRuleToSheet(sheet, selector, index) {\r\n        if (sheet.insertRule) {\r\n            sheet.insertRule(selector + ' { }', index);\r\n        } else {\r\n            sheet.addRule(selector, null, index);\r\n        }\r\n    }\r\n\r\n    // Handles single colon syntax for older browsers and bugzilla.mozilla.org/show_bug.cgi?id=949651\r\n    function addPseudoElementRule(sheet, selector, rules, index) {\r\n        var doubleColonSelector;\r\n        var singleColonSelector;\r\n\r\n        if (doubleColonPseudoElRegex.exec(selector)) {\r\n            doubleColonSelector = selector;\r\n            singleColonSelector = toSingleColonPseudoElements(selector);\r\n        } else if (singleColonPseudoElRegex.exec(selector)) {\r\n            doubleColonSelector = toDoubleColonPseudoElements(selector);\r\n            singleColonSelector = selector;\r\n        } else {\r\n            return false; // Not dealing with a pseudo element\r\n        }\r\n\r\n        if (!singleColonForPseudoElements) {\r\n            // Assume modern browser and then check if successful\r\n            addRuleToSheet(sheet, doubleColonSelector, index);\r\n            if (rules.length <= index) {\r\n                singleColonForPseudoElements = true;\r\n            }\r\n        }\r\n        if (singleColonForPseudoElements) {\r\n            addRuleToSheet(sheet, singleColonSelector, index);\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function toDoubleColonPseudoElements(selector) {\r\n        return selector.replace(singleColonPseudoElRegex, function (match, submatch1, submatch2, submatch3) {\r\n            return submatch1 + '::' + submatch3;\r\n        });\r\n    }\r\n\r\n    function toSingleColonPseudoElements(selector) {\r\n        return selector.replace(doubleColonPseudoElRegex, function(match, submatch1, submatch2) {\r\n            return ':' + submatch2;\r\n        })\r\n    }\r\n\r\n    function removeRule(rule) {\r\n        var sheet = rule.sheet;\r\n        if (sheet.deleteRule) {\r\n            sheet.deleteRule(rule.index);\r\n        } else if (sheet.removeRule) {\r\n            sheet.removeRule(rule.index);\r\n        }\r\n    }\r\n\r\n    function extend(dest, src) {\r\n        for (var key in src) {\r\n            if (!src.hasOwnProperty(key))\r\n                continue;\r\n            dest[key] = src[key];\r\n        }\r\n        return dest;\r\n    }\r\n\r\n    function aggregateStyles(rules) {\r\n        var aggregate = {};\r\n        for (var i = 0; i < rules.length; i++) {\r\n            extend(aggregate, declaredProperties(rules[i].style));\r\n        }\r\n        return aggregate;\r\n    }\r\n\r\n    function declaredProperties(style) {\r\n        var declared = {};\r\n        for (var i = 0; i < style.length; i++) {\r\n            declared[style[i]] = style[toCamelCase(style[i])];\r\n        }\r\n        return declared;\r\n    }\r\n\r\n    // IE9 stores rules with attributes (classes or ID's) adjacent in the opposite order as defined\r\n    // causing them to not be found, so this method swaps [#|.]sel1[#|.]sel2 to become [#|.]sel2[#|.]sel1\r\n    function swapAdjSelAttr(selector) {\r\n        var swap = '';\r\n        var lastIndex = 0;\r\n\r\n        while ((match = adjSelAttrRegex.exec(selector)) != null) {\r\n            if (match[0] === '')\r\n                break;\r\n            swap += selector.substring(lastIndex, match.index);\r\n            swap += selector.substr(match.index + match[1].length, match[2].length);\r\n            swap += selector.substr(match.index, match[1].length);\r\n            lastIndex = match.index + match[0].length;\r\n        }\r\n        swap += selector.substr(lastIndex);\r\n\r\n        return swap;\r\n    };\r\n\r\n    // FF and older browsers store rules with pseudo elements using single-colon syntax\r\n    function swapPseudoElSyntax(selector) {\r\n        if (doubleColonPseudoElRegex.exec(selector)) {\r\n            return toSingleColonPseudoElements(selector);\r\n        }\r\n        return selector;\r\n    }\r\n\r\n    function setStyleProperties(rule, properties) {\r\n        for (var key in properties) {\r\n            var value = properties[key];\r\n            var importantIndex = value.indexOf(' !important');\r\n\r\n            // Modern browsers seem to handle overrides fine, but IE9 doesn't\r\n            rule.style.removeProperty(key);\r\n            if (importantIndex > 0) {\r\n                rule.style.setProperty(key, value.substr(0, importantIndex), 'important');\r\n            } else {\r\n                rule.style.setProperty(key, value);\r\n            }\r\n        }\r\n    }\r\n\r\n    function toCamelCase(str) {\r\n        return str.replace(/-([a-z])/g, function (match, submatch) {\r\n            return submatch.toUpperCase();\r\n        });\r\n    }\r\n\r\n    function transformCamelCasedPropertyNames(oldProps) {\r\n        var newProps = {};\r\n        for (var key in oldProps) {\r\n            newProps[unCamelCase(key)] = oldProps[key];\r\n        }\r\n        return newProps;\r\n    }\r\n\r\n    function unCamelCase(str) {\r\n        return str.replace(/([A-Z])/g, function(match, submatch) {\r\n            return '-' + submatch.toLowerCase();\r\n        });\r\n    }\r\n\r\n    var Jss = function(doc) {\r\n        this.doc = doc;\r\n        this.head = this.doc.head || this.doc.getElementsByTagName('head')[0];\r\n        this.sheets = this.doc.styleSheets || [];\r\n    };\r\n\r\n    Jss.prototype = {\r\n        // Returns JSS rules (selector is optional)\r\n        get: function(selector) {\r\n            if (!this.defaultSheet) {\r\n                return {};\r\n            }\r\n            if (selector) {\r\n                return aggregateStyles(getRules(this.defaultSheet, selector));\r\n            }\r\n            var rules = getSelectorsAndRules(this.defaultSheet);\r\n            for (selector in rules) {\r\n                rules[selector] = aggregateStyles(rules[selector]);\r\n            }\r\n            return rules;\r\n        },\r\n        // Returns all rules (selector is required)\r\n        getAll: function(selector) {\r\n            var properties = {};\r\n            for (var i = 0; i < this.sheets.length; i++) {\r\n                extend(properties, aggregateStyles(getRules(this.sheets[i], selector)));\r\n            }\r\n            return properties;\r\n        },\r\n        // Adds JSS rules for the selector based on the given properties\r\n        set: function(selector, properties) {\r\n            if (!this.defaultSheet) {\r\n                this.defaultSheet = this._createSheet();\r\n            }\r\n            properties = transformCamelCasedPropertyNames(properties);\r\n            var rules = getRules(this.defaultSheet, selector);\r\n            if (!rules.length) {\r\n                rules = [addRule(this.defaultSheet, selector)];\r\n            }\r\n            for (var i = 0; i < rules.length; i++) {\r\n                setStyleProperties(rules[i], properties);\r\n            }\r\n        },\r\n        // Removes JSS rules (selector is optional)\r\n        remove: function(selector) {\r\n            if (!this.defaultSheet)\r\n                return;\r\n            if (!selector) {\r\n                this._removeSheet(this.defaultSheet);\r\n                delete this.defaultSheet;\r\n                return;\r\n            }\r\n            var rules = getRules(this.defaultSheet, selector);\r\n            for (var i = 0; i < rules.length; i++) {\r\n                removeRule(rules[i]);\r\n            }\r\n            return rules.length;\r\n        },\r\n        _createSheet: function() {\r\n            var styleNode = this.doc.createElement('style');\r\n            styleNode.type = 'text/css';\r\n            styleNode.rel = 'stylesheet';\r\n            this.head.appendChild(styleNode);\r\n            return styleNode.sheet;\r\n        },\r\n        _removeSheet: function(sheet) {\r\n            var node = sheet.ownerNode;\r\n            node.parentNode.removeChild(node);\r\n        }\r\n    };\r\n\r\n    var exports = new Jss(document);\r\n    exports.forDocument = function(doc) {\r\n        return new Jss(doc);\r\n    };\r\n    return exports;\r\n})();\r\n\r\ntypeof module !== 'undefined' && module.exports && (module.exports = jss); // CommonJS support\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./external/jss.js\n ** module id = 15\n ** module chunks = 0\n **/","// utilities needed by the configuration (excludes dependencies the configs don't need so the webpack bundle is lean)\r\n\r\nvar path = require('path')\r\n\r\n\r\n// Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1\r\n// any number of objects can be passed into the function and will be merged into the first argument in order\r\n// returns obj1 (now mutated)\r\nvar merge = exports.merge = function(obj1, obj2/*, moreObjects...*/){\r\n    return mergeInternal(arrayify(arguments), false)\r\n}\r\n\r\n// like merge, but traverses the whole object tree\r\n// the result is undefined for objects with circular references\r\nvar deepMerge = exports.deepMerge = function(obj1, obj2/*, moreObjects...*/) {\r\n    return mergeInternal(arrayify(arguments), true)\r\n}\r\n\r\n// returns a new object where properties of b are merged onto a (a's properties may be overwritten)\r\nexports.objectConjunction = function(a, b) {\r\n    var objectCopy = {}\r\n    merge(objectCopy, a)\r\n    merge(objectCopy, b)\r\n    return objectCopy\r\n}\r\n\r\n// turns an array of values into a an object where those values are all keys that point to 'true'\r\nexports.arrayToMap = function(array) {\r\n    var result = {}\r\n    array.forEach(function(v) {\r\n        result[v] = true\r\n    })\r\n    return result\r\n}\r\n\r\nfunction mergeInternal(objects, deep) {\r\n    var obj1 = objects[0]\r\n    var obj2 = objects[1]\r\n\r\n    for(var key in obj2){\r\n       if(Object.hasOwnProperty.call(obj2, key)) {\r\n            if(deep && obj1[key] instanceof Object && obj2[key] instanceof Object) {\r\n                mergeInternal([obj1[key], obj2[key]], true)\r\n            } else {\r\n                obj1[key] = obj2[key]\r\n            }\r\n       }\r\n    }\r\n\r\n    if(objects.length > 2) {\r\n        var newObjects = [obj1].concat(objects.slice(2))\r\n        return mergeInternal(newObjects, deep)\r\n    } else {\r\n        return obj1\r\n    }\r\n}\r\n\r\nfunction arrayify(a) {\r\n    return Array.prototype.slice.call(a, 0)\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/utils.js\n ** module id = 16\n ** module chunks = 0\n **/","// some functionality that is needed by Block.js but is related to styling (some things are also needed by Style.js)\r\n\r\nvar HashMap = require(\"hashmap\")\r\n\r\nvar Style = require(\"./Style\")\r\nvar utils = require('./utils')\r\n\r\nexports.defaultStyleMap = new HashMap() // maps from a proto class to its computed default style\r\n\r\n// propogates a style-set change to a set of components\r\n    // styleMap should be a *copy* of a Style's componentStyleMap property (because it will be modified)\r\nvar propogateStyleSet = exports.propogateStyleSet = function (components, styleMap) {\r\n    for(var n=0; n<components.length; n++) {\r\n        var c = components[n]\r\n\r\n        // object inherits style if its in the styleSet and if it doesn't have an explicitly set style\r\n        if(c._style === undefined) {\r\n            if(styleMap === undefined) {\r\n                setCurrentStyle(c, undefined)\r\n            } else {\r\n                var styleFromMap = getStyleForComponent(styleMap, c)\r\n                if(styleFromMap !== undefined) {\r\n                    setCurrentStyle(c, styleFromMap)\r\n                }\r\n            }\r\n        }\r\n\r\n        // set the computed style set\r\n        var mainStyle; // the style directly given to a component, either its `style` property, or its inherited style\r\n        if(c._style !== undefined) {\r\n            mainStyle = c._style.get(c)\r\n        } else if(styleMap !== undefined) {\r\n            mainStyle = getStyleForComponent(styleMap, c)\r\n            if(mainStyle !== undefined) {\r\n                mainStyle = mainStyle.get(c) // get the specific style (taking into account any label)\r\n            }\r\n        }\r\n\r\n        if(mainStyle !== undefined) {\r\n            if(styleMap !== undefined) {\r\n                c.computedStyleMap = styleMapConjunction(styleMap, mainStyle.componentStyleMap)\r\n            } else {\r\n                c.computedStyleMap = mainStyle.componentStyleMap\r\n            }\r\n        } else {\r\n            c.computedStyleMap = styleMap\r\n        }\r\n\r\n        propogateStyleSet(c.children, c.computedStyleMap)\r\n    }\r\n}\r\n\r\n// gets the right style from the styleMap\r\n// takes the component's inheritance tree into account (relies on the block.constructor.parent property)\r\nvar getStyleForComponent = exports.getStyleForComponent = function (styleMap, block) {\r\n    var constructor = block.constructor\r\n    while(constructor !== undefined) {\r\n        var style = styleMap[constructor.name]\r\n        if(style !== undefined) {\r\n            return style\r\n        } else {\r\n            constructor = constructor.parent\r\n        }\r\n    }\r\n}\r\n\r\n// returns the conjunction of two style maps\r\n// gets it from the computedStyles cache if its already in there\r\nvar styleMapConjunction = exports.styleMapConjunction = function (secondaryStyleMap, primaryStyleMap) {\r\n    var cachedStyleMap = Style.computedStyles.get([secondaryStyleMap, primaryStyleMap])\r\n    if(cachedStyleMap === undefined) {\r\n        cachedStyleMap = utils.objectConjunction(secondaryStyleMap, primaryStyleMap)\r\n        Style.computedStyles.set([secondaryStyleMap, primaryStyleMap], cachedStyleMap)\r\n    }\r\n\r\n    return cachedStyleMap\r\n}\r\n\r\n// takes labels into account\r\nvar setCurrentStyle = exports.setCurrentStyle = function (component, style) {\r\n    if(style === component.currentStyle) return; // do nothing\r\n\r\n    if(style !== undefined)\r\n        var specificStyle = style.get(component)\r\n    else\r\n        var specificStyle = style\r\n\r\n    setStyleClass(component, specificStyle)\r\n    applyStyleKillFunction(component)\r\n    component.currentStyle = specificStyle\r\n    applyStyleSetupFunction(component, specificStyle)\r\n}\r\n\r\n\r\nexports.createDefaultBlockStyle = function (that) {\r\n    if(that.defaultStyle !== undefined) {\r\n        validateDefaultStyle(that.defaultStyle)\r\n    }\r\n\r\n    // get list of default styles\r\n    var defaultStyles = []\r\n    var nextConstructor = that.constructor\r\n    while(nextConstructor !== undefined) {\r\n        if(nextConstructor.defaultStyle !== undefined) {\r\n            defaultStyles.push(nextConstructor.defaultStyle)\r\n        }\r\n        nextConstructor = nextConstructor.parent\r\n    }\r\n\r\n    // generate merged default style\r\n    var defaultStyleSet = {}\r\n    defaultStyles.reverse().forEach(function(style) {\r\n        for(var k in style.styleDefinitions) {\r\n            utils.merge(defaultStyleSet, style.styleDefinitions[k])\r\n            break; // just do first key (shouldn't be more than one key, because only simple stylings are allowed for default styles)\r\n        }\r\n\r\n    })\r\n\r\n    if(Object.keys(defaultStyleSet).length > 0)\r\n        var defaultBlockStyle = Style(defaultStyleSet, {default:true})\r\n    else\r\n        var defaultBlockStyle = false // no special default\r\n\r\n    exports.defaultStyleMap.set(that.constructor, defaultBlockStyle)\r\n    return defaultBlockStyle\r\n}\r\n\r\n\r\n// applies setup appropriately\r\nfunction applyStyleSetupFunction(component, style) {\r\n    if(style !== undefined && style.setup !== undefined) {\r\n        component._styleSetupObject = style.setup(component) // call setup on the component\r\n    } else {\r\n        component._styleSetupObject = undefined\r\n    }\r\n}\r\n// applies kill appropriately\r\nfunction applyStyleKillFunction(component) {\r\n    var currentStyle = component.currentStyle\r\n    if(currentStyle !== undefined && currentStyle.setup !== undefined) {\r\n        if(currentStyle.kill === undefined)\r\n            throw new Error('style has been unset but does not have a \"kill\" function to undo its \"setup\" function')\r\n\r\n        currentStyle.kill(component, component._styleSetupObject)\r\n    }\r\n}\r\n\r\n// sets the style, replacing one if one already exists\r\nfunction setStyleClass(component, style) {\r\n    var currentStyle = component.currentStyle\r\n    if(currentStyle !== undefined) {\r\n        component.domNode.className = component.domNode.className.replace(new RegExp(\" ?\\\\b\"+currentStyle.className+\"\\\\b\"),'') // remove the previous css class\r\n    }\r\n    if(style !== undefined) {\r\n        component.domNode.className = style.className+' '+component.domNode.className.trim() // note that the order of classes doesn't matter\r\n    }\r\n}\r\n\r\nfunction validateDefaultStyle(defaultStyle) {\r\n    if(!(defaultStyle instanceof Style)) {\r\n        throw new Error(\"defaultStyle property must be a Style object\")\r\n    } else if(\r\n        defaultStyle.setup !== undefined || defaultStyle.kill !== undefined ||\r\n        Object.keys(defaultStyle.componentStyleMap).length > 0 || Object.keys(defaultStyle.labelStyleMap).length > 0 /*||\r\n        Object.keys(defaultStyle.pseudoClassStyles).length > 0*/\r\n    ) {\r\n        throw new Error(\"A Block's defaultStyle can only contain basic css stylings, no Block, label, or pseudoclass stylings, nor run/kill javascript\")\r\n    }\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/blockStyleUtils.js\n ** module id = 17\n ** module chunks = 0\n **/","var EventEmitter = require('events').EventEmitter\r\nvar proto = require(\"proto\")\r\nvar utils = require(\"utils\")\r\n\r\nmodule.exports = proto(EventEmitter, function(superclass) {\r\n\r\n    this.init = function() {\r\n        superclass.apply(this, arguments)\r\n\r\n        this.ifonHandlers = {}\r\n        this.ifoffHandlers = {}\r\n        this.ifonAllHandlers = []\r\n        this.ifoffAllHandlers = []\r\n    }\r\n\r\n    // callback will be triggered immediately if there is already a listener attached, or\r\n    // callback will be triggered when the first listener for the event is added\r\n    // (regardless of whether its done through on or once)\r\n    // parameters can be:\r\n        // event, callback - attach an ifon handler for the passed event\r\n        // callback - attach an ifon handler for all events\r\n    this.ifon = function(event, callback) {\r\n        if(event instanceof Function) {     // event not passed, only a callback\r\n            callback = event // fix the argument\r\n            for(var eventName in this._events) {\r\n                if(this.listeners(eventName).length > 0) {\r\n                    callback(eventName)\r\n                }\r\n            }\r\n        } else if(this.listeners(event).length > 0) {\r\n            callback(event)\r\n        }\r\n\r\n        addHandlerToList(this, 'ifonHandlers', event, callback)\r\n    }\r\n\r\n    // removes either:\r\n        // removeIfon() - all ifon handlers (if no arguments are passed), or\r\n        // removeIfon(event) - all ifon handlers for the passed event, or\r\n        // removeIfon(callback) - the passed ifon-all handler (if the first parameter is the callback)\r\n        // removeIfon(event, callback) - the specific passed callback for the passed event\r\n    this.removeIfon = function(event, callback) {\r\n        removeFromHandlerList(this, 'ifonHandlers', event, callback)\r\n    }\r\n\r\n    // callback will be triggered when the last listener for the 'click' event is removed (will not trigger immediately if there is no event listeners on call of ifoff)\r\n    // (regardless of whether this is done through removeListener or as a result of 'once' being fulfilled)\r\n    // parameters can be:\r\n        // event, callback - attach an ifoff handler for the passed event\r\n        // callback - attach an ifoff handler for all events\r\n    this.ifoff = function(event, callback) {\r\n        addHandlerToList(this, 'ifoffHandlers', event, callback)\r\n    }\r\n\r\n    // removes either:\r\n        // removeIfoff() - all ifoff handlers (if no arguments are passed), or\r\n        // removeIfoff(event) - all ifoff handlers for the passed event, or\r\n        // removeIfoff(callback) - the passed ifoff-all handler (if the first parameter is the callback)\r\n        // removeIfoff(event, callback) - the specific passed callback for the passed event\r\n    this.removeIfoff = function(event, callback) {\r\n        removeFromHandlerList(this, 'ifoffHandlers', event, callback)\r\n    }\r\n\r\n    // emitter is the emitter to proxy handler binding to\r\n    // options can have one of the following properties:\r\n        // only - an array of events to proxy\r\n        // except - an array of events to *not* proxy\r\n    this.proxy = function(emitter, options) {\r\n        if(options === undefined) options = {}\r\n        if(options.except !== undefined) {\r\n            var except = utils.arrayToMap(options.except)\r\n            var handleIt = function(event){return !(event in except)}\r\n        } else if(options.only !== undefined) {\r\n            var only = utils.arrayToMap(options.only)\r\n            var handleIt = function(event){return event in only}\r\n        } else {\r\n            var handleIt = function(){return true}\r\n        }\r\n\r\n        var that = this, handler;\r\n        this.ifon(function(event) {\r\n            if(handleIt(event)) {\r\n                emitter.on(event, handler = function() {\r\n                    that.emit.apply(that, [event].concat(Array.prototype.slice.call(arguments)))\r\n                })\r\n            }\r\n        })\r\n        this.ifoff(function(event) {\r\n            if(handleIt(event))\r\n                emitter.off(event, handler)\r\n        })\r\n    }\r\n\r\n    /*override*/ this.on = this.addListener = function(event, callback) {\r\n        var triggerIfOn = this.listeners(event).length === 0\r\n        superclass.prototype.on.apply(this,arguments)\r\n        if(triggerIfOn) triggerIfHandlers(this, 'ifonHandlers', event)\r\n    }\r\n\r\n    /*override*/ this.off = this.removeListener = function(event, callback) {\r\n        var triggerIfOff = this.listeners(event).length === 1\r\n        superclass.prototype.removeListener.apply(this,arguments)\r\n        if(triggerIfOff) triggerIfHandlers(this, 'ifoffHandlers', event)\r\n    }\r\n    /*override*/ this.removeAllListeners = function(event) {\r\n        var triggerIfOffForEvents = []\r\n        if(event !== undefined) {\r\n            if(this.listeners(event).length > 0) {\r\n                triggerIfOffForEvents.push(event)\r\n            }\r\n        } else {\r\n            for(var event in this._events) {\r\n                if(this.listeners(event).length > 0) {\r\n                    triggerIfOffForEvents.push(event)\r\n                }\r\n            }\r\n        }\r\n\r\n        superclass.prototype.removeAllListeners.apply(this,arguments)\r\n\r\n        for(var n=0; n<triggerIfOffForEvents.length; n++) {\r\n            triggerIfHandlers(this, 'ifoffHandlers', triggerIfOffForEvents[n])\r\n        }\r\n    }\r\n\r\n})\r\n\r\n\r\n// triggers the if handlers from the normal list and the \"all\" list\r\nfunction triggerIfHandlers(that, handlerListName, event) {\r\n    triggerIfHandlerList(that[handlerListName][event], event)\r\n    triggerIfHandlerList(that[normalHandlerToAllHandlerProperty(handlerListName)], event)\r\n}\r\n\r\n\r\n// triggers the if handlers from a specific list\r\n// ya these names are confusing, sorry : (\r\nfunction triggerIfHandlerList(handlerList, event) {\r\n    if(handlerList !== undefined) {\r\n        for(var n=0; n<handlerList.length; n++) {\r\n            handlerList[n](event)\r\n        }\r\n    }\r\n}\r\n\r\nfunction addHandlerToList(that, handlerListName, event, callback) {\r\n    if(event instanceof Function) {\r\n        // correct arguments\r\n        callback = event\r\n        event = undefined\r\n    }\r\n\r\n    if(event !== undefined && callback !== undefined) {\r\n        var handlerList = that[handlerListName][event]\r\n        if(handlerList === undefined) {\r\n            handlerList = that[handlerListName][event] = []\r\n        }\r\n\r\n        handlerList.push(callback)\r\n    } else {\r\n        that[normalHandlerToAllHandlerProperty(handlerListName)].push(callback)\r\n    }\r\n}\r\n\r\nfunction removeFromHandlerList(that, handlerListName, event, callback) {\r\n    if(event instanceof Function) {\r\n        // correct arguments\r\n        callback = event\r\n        event = undefined\r\n    }\r\n\r\n    if(event !== undefined && callback !== undefined) {\r\n        removeCallbackFromList(that[handlerListName][event], callback)\r\n    } else if(event !== undefined) {\r\n        delete that[handlerListName][event]\r\n    } else if(callback !== undefined) {\r\n        var allHandlerListName = normalHandlerToAllHandlerProperty(handlerListName)\r\n        removeCallbackFromList(that[allHandlerListName], callback)\r\n    } else {\r\n        var allHandlerListName = normalHandlerToAllHandlerProperty(handlerListName)\r\n        that[handlerListName] = {}\r\n        that[allHandlerListName] = []\r\n    }\r\n}\r\n\r\nfunction normalHandlerToAllHandlerProperty(handlerListName) {\r\n    if(handlerListName === 'ifonHandlers')\r\n        return 'ifonAllHandlers'\r\n    if(handlerListName === 'ifoffHandlers')\r\n        return 'ifoffAllHandlers'\r\n}\r\n\r\nfunction removeCallbackFromList(list, callback) {\r\n    var index = list.indexOf(callback)\r\n    list.splice(index,1)\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/EventEmitterB.js\n ** module id = 18\n ** module chunks = 0\n **/","\r\n// creates a dom element optionally with a class and attributes\r\n var node = module.exports.node = function(type, className, options) {\r\n    var elem = document.createElement(type)\r\n\r\n    if(options !== undefined) {\r\n        if(options.attr !== undefined) {\r\n            for(var attribute in options.attr) {\r\n                createAttribute(elem, attribute, options.attr[attribute])\r\n            }\r\n        }\r\n        if(options.textContent !== undefined) {\r\n            elem.textContent = options.textContent\r\n        }\r\n    }\r\n\r\n    if(className !== undefined)\r\n        elem.className = className\r\n\r\n    return elem\r\n}\r\n\r\n// convenience function for creating a div\r\nmodule.exports.div = function(className, options) {\r\n    return node('div', className, options)\r\n}\r\n\r\n// adds an attribute to a domNode\r\nvar setAttribute = module.exports.setAttribute = function(/*[domNode,] type, value*/) {\r\n    if (arguments.length === 2) {\r\n        var domNode = this.domNode;\r\n        var type = arguments[0];\r\n        var value = arguments[1];\r\n    } else if (arguments.length === 3) {\r\n        var domNode = arguments[0];\r\n        var type = arguments[1];\r\n        var value = arguments[2];\r\n    } else {\r\n        throw new Error(\"This function expects arguments to be: [domNode,] type, value\");\r\n    }\r\n    var attr = document.createAttribute(type)\r\n    attr.value = value\r\n    domNode.setAttributeNode(attr)\r\n}\r\n\r\n\r\n// sets the selection\r\n//\r\n// works for contenteditable elements\r\nexports.setSelectionRange = function(containerEl, start, end) {\r\n\r\n    if(containerEl.nodeName === 'INPUT' || containerEl.nodeName === 'TEXTAREA') {\r\n        containerEl.setSelectionRange(start, end)\r\n    } else {\r\n        var charIndex = 0, range = document.createRange();\r\n        range.setStart(containerEl, 0);\r\n        range.collapse(true);\r\n        var foundStart = false;\r\n\r\n        iterateThroughLeafNodes(containerEl, function(node) {\r\n            var hiddenCharacters = findHiddenCharacters(node, node.length)\r\n            var nextCharIndex = charIndex + node.length - hiddenCharacters;\r\n\r\n            if (!foundStart && start >= charIndex && start <= nextCharIndex) {\r\n                var nodeIndex = start-charIndex\r\n                var hiddenCharactersBeforeStart = findHiddenCharacters(node, nodeIndex)\r\n                range.setStart(node, nodeIndex + hiddenCharactersBeforeStart);\r\n                foundStart = true;\r\n            }\r\n\r\n            if (foundStart && end >= charIndex && end <= nextCharIndex) {\r\n                var nodeIndex = end-charIndex\r\n                var hiddenCharactersBeforeEnd = findHiddenCharacters(node, nodeIndex)\r\n                range.setEnd(node, nodeIndex + hiddenCharactersBeforeEnd);\r\n                return true; // stop the iteration - we're done here\r\n            }\r\n\r\n            charIndex = nextCharIndex\r\n        })\r\n\r\n        var sel = window.getSelection();\r\n        sel.removeAllRanges();\r\n        sel.addRange(range);\r\n    }\r\n}\r\n\r\n// gets the character offsets of a selection within a particular dom node\r\n// returns undefined if there is no selection in the element\r\n// note: yes this code doesn't work in older versions of IE (or possibly any versions) - if you want it to work in IE, please use http://modernizr.com/ or a polyfill for ranges\r\nexports.getSelectionRange = function (element) {\r\n\r\n    var selection = window.getSelection()\r\n    var isInputOrArea = element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA'\r\n\r\n    for(var n=0; n<selection.rangeCount; n++) {\r\n        var range = selection.getRangeAt(0)\r\n        if(isInputOrArea) {\r\n            if(range.startOffset === range.endOffset && range.startContainer.children[range.startOffset] === element /*|| range.startContainer === element || */) { // I don't think the input or textarea itself will ever be the startContainer\r\n                return [element.selectionStart, element.selectionEnd]\r\n            }\r\n        } else {\r\n            var startsInElement = element.contains(range.startContainer)\r\n            if(startsInElement) {\r\n                var elementToIterateThrough = element\r\n                var startFound = true\r\n            } else {\r\n                var elementToIterateThrough = range.commonAncestorContainer\r\n                var startFound = false\r\n                var startContainerFound = false\r\n            }\r\n\r\n            var visibleCharacterOffset = 0, start, end;\r\n            iterateThroughLeafNodes(elementToIterateThrough, function(leaf) {\r\n                if(!startFound) {\r\n                    if(leaf === range.startContainer) {\r\n                        startContainerFound = true\r\n                    }\r\n\r\n                    if(!element.contains(leaf) || !startContainerFound)\r\n                        return; // continue\r\n                    else if(startContainerFound)\r\n                       startFound = true\r\n                } else if(!startsInElement && !element.contains(leaf)) {\r\n                    return true // done!\r\n                }\r\n\r\n                if(leaf === range.startContainer) {\r\n                    start = visibleCharacterOffset + range.startOffset - findHiddenCharacters(leaf, range.startOffset)\r\n                }\r\n                if(leaf === range.endContainer) {\r\n                    end = visibleCharacterOffset + range.endOffset - findHiddenCharacters(leaf, range.endOffset)\r\n                    return true // done!\r\n                }\r\n\r\n                visibleCharacterOffset += leaf.length - findHiddenCharacters(leaf, leaf.length)\r\n            })\r\n\r\n            if(start === undefined && !startFound) {\r\n                return undefined\r\n            } else {\r\n                if(start === undefined) {\r\n                    start = 0 // start is at the beginning\r\n                }\r\n                if(end === undefined) {\r\n                    end = visibleCharacterOffset // end is all the way at the end (the selection may continue in other elements)\r\n                }\r\n\r\n                return [start, end]\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\n\r\n// iterate through the leaf nodes inside element\r\n// callback(node) - a function called for each leaf node\r\n    // returning true from this ends the iteration\r\nfunction iterateThroughLeafNodes(element, callback) {\r\n    var nodeStack = [element], node;\r\n\r\n    while (node = nodeStack.pop()) {\r\n        if (node.nodeType == 3) {\r\n            if(callback(node) === true)\r\n                break;\r\n        } else {\r\n            var i = node.childNodes.length;\r\n            while (i--) {\r\n                nodeStack.push(node.childNodes[i]);\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction findHiddenCharacters(node, beforeCaretIndex) {\r\n    var hiddenCharacters = 0\r\n    var lastCharWasWhiteSpace=true\r\n    for(var n=0; n-hiddenCharacters<beforeCaretIndex &&n<node.length; n++) {\r\n        if([' ','\\n','\\t','\\r'].indexOf(node.textContent[n]) !== -1) {\r\n            if(lastCharWasWhiteSpace)\r\n                hiddenCharacters++\r\n            else\r\n                lastCharWasWhiteSpace = true\r\n        } else {\r\n            lastCharWasWhiteSpace = false\r\n        }\r\n    }\r\n\r\n    return hiddenCharacters\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/domUtils.js\n ** module id = 19\n ** module chunks = 0\n **/","// note: this is  not intended to be used directly - only through Select and MultiSelect\r\n\r\nvar Block = require('Block')\r\nvar Style = require('Style')\r\nvar proto = require('proto')\r\n//var htmlEntities = require('he')\r\n\r\n// emits a 'change' event when its 'selected' value changes\r\nmodule.exports = proto(Block, function(superclass) {\r\n\r\n    // staic members\r\n\r\n    this.name = 'Option'\r\n\r\n    this.defaultStyle = Style({\r\n        display: 'block'\r\n    })\r\n\r\n\r\n    // instance members\r\n\r\n    this.init = function(label, value, text) {\r\n        this.domNode = document.createElement(\"option\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\r\n        superclass.init.call(this) // superclass constructor\r\n\r\n        this.label = label\r\n\r\n        this.text = text\r\n        this.val = value\r\n    }\r\n\r\n    Object.defineProperty(this, 'val', {\r\n        // returns the value of the Option\r\n        get: function() {\r\n            return this.attr('value')\r\n        },\r\n\r\n        // sets the value of the Option\r\n        set: function(value) {\r\n            if(this.parent !== undefined) {\r\n                if(this.parent.options[value] !== undefined) {\r\n                    throw new Error(\"Can't give an Option the same value as another in the Select or MultiSelect (value: '\"+value+\"')\")\r\n                }\r\n\r\n                if(this.val !== null) {\r\n                    delete this.parent.options[this.val]\r\n                }\r\n\r\n                this.parent.options[value] = this\r\n            }\r\n\r\n            this.attr('value', value)\r\n\r\n        }\r\n    })\r\n\r\n\r\n    Object.defineProperty(this, 'selected', {\r\n        // returns whether or not the option is selected\r\n        get: function() {\r\n            return this.domNode.selected\r\n        },\r\n\r\n        // sets the selected state of the option to the passed value (true for selected)\r\n        set: function(value) {\r\n            var booleanValue = value === true\r\n            if(this.selected === booleanValue) return false; // ignore if there's no change\r\n\r\n            if(this.parent !== undefined)\r\n                this.parent.prepareForValueChange([this.val])\r\n\r\n            this.setSelectedQuiet(booleanValue)\r\n\r\n            if(this.parent !== undefined)\r\n                this.parent.emit('change')\r\n        }\r\n    })\r\n\r\n    Object.defineProperty(this, 'text', {\r\n        get: function() {\r\n            return this.domNode.textContent\r\n        },\r\n\r\n        set: function(text) {\r\n            this.domNode.innerText = text // apparently textContent can't be set or something? unclear\r\n        }\r\n    })\r\n\r\n\r\n    // private\r\n\r\n    // does everything for setting the selected state except emit the parent's change event\r\n    this.setSelectedQuiet = function setOptionSelected(booleanValue) {\r\n        if(this.selected === booleanValue) return; // ignore if there's no change\r\n\r\n        this.domNode.selected = booleanValue\r\n        this.emit('change') // the browser has no listenable event that is triggered on change of the 'checked' property\r\n    }\r\n})\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Option.js\n ** module id = 20\n ** module chunks = 0\n **/","var Block = require('Block')\nvar proto = require('proto')\nvar Style = require(\"Style\")\n\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static properties\n\n\tthis.name = 'ListItem'\n\n    this.defaultStyle = Style({\n        display: 'list-item'\n    })\n\n\t// instance properties\n\n\tthis.init = function(/*[label,] contents*/) {\n        if(arguments.length <= 1) {\n            var contents = arguments[0]\n        } else {\n            var label = arguments[0]\n            var contents = arguments[1]\n        }\n\n        this.domNode = document.createElement(\"li\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t\tsuperclass.init.call(this) // superclass constructor\n\t\tthis.label = label\n\n        if(contents instanceof Block) {\n\t\t\tthis.add(contents)\n\t\t} else if(contents !== undefined) {\n            this.domNode.textContent = contents\n        }\n\t}\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Item.js\n ** module id = 21\n ** module chunks = 0\n **/","\n\nvar RowlikeGenerator = require(\"./RowlikeGenerator\");\n\nmodule.exports = RowlikeGenerator('th', \"TableHeader\")\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Header.js\n ** module id = 22\n ** module chunks = 0\n **/","var RowlikeGenerator = require(\"./RowlikeGenerator\");\n\nmodule.exports = RowlikeGenerator('tr', \"TableRow\")\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Row.js\n ** module id = 23\n ** module chunks = 0\n **/","var Block = require('../Block')\nvar proto = require('proto')\n\nmodule.exports = proto(Block, function(superclass) {\n\n\t// static properties\n\n\tthis.name = 'TableCell'\n\t\n\n\t// instance properties\n\n\tthis.init = function(/*[label,] contents*/) {\n        if(arguments.length <= 1) {\n            var contents = arguments[0]\n        } else {\n            var label = arguments[0]\n            var contents = arguments[1]\n        }\n\n        this.domNode = document.createElement(\"td\") // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\n\t\tsuperclass.init.call(this) // superclass constructor\n\t\tthis.label = label\n\n        if(contents instanceof Block) {\n\t\t\tthis.add(contents)\n\t\t} else if(contents !== undefined) {\n            this.domNode.textContent = contents\n        }\n\t}\n\n\tthis.colspan = function(cols) {\n\t\tthis.attr('colspan',cols);\n\t}\n});\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/Cell.js\n ** module id = 24\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      }\n      throw TypeError('Uncaught, unspecified \"error\" event.');\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        len = arguments.length;\n        args = new Array(len - 1);\n        for (i = 1; i < len; i++)\n          args[i - 1] = arguments[i];\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    len = arguments.length;\n    args = new Array(len - 1);\n    for (i = 1; i < len; i++)\n      args[i - 1] = arguments[i];\n\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    var m;\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  var ret;\n  if (!emitter._events || !emitter._events[type])\n    ret = 0;\n  else if (isFunction(emitter._events[type]))\n    ret = 1;\n  else\n    ret = emitter._events[type].length;\n  return ret;\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/build-modules/~/webpack/~/node-libs-browser/~/events/events.js\n ** module id = 25\n ** module chunks = 0\n **/","/**\r\n * HashMap - HashMap Class for JavaScript\r\n * @author Ariel Flesler <aflesler@gmail.com>\r\n * @version 2.0.0\r\n * Homepage: https://github.com/flesler/hashmap\r\n */\r\n\r\n(function (factory) {\r\n\tif (typeof define === 'function' && define.amd) {\r\n\t\t// AMD. Register as an anonymous module.\r\n\t\tdefine([], factory);\r\n\t} else if (typeof exports === 'object') {\r\n\t\t// Node js environment\r\n\t\texports.HashMap = factory();\r\n\t} else {\r\n\t\t// Browser globals (this is window)\r\n\t\tthis.HashMap = factory();\r\n\t}\r\n}(function () {\r\n\t\r\n\tfunction HashMap(other) {\r\n\t\tthis.clear();\r\n\t\tswitch (arguments.length) {\r\n\t\t\tcase 0: break;\r\n\t\t\tcase 1: this.copy(other); break;\r\n\t\t\tdefault: multi(this, arguments); break;\r\n\t\t}\r\n\t}\r\n\r\n\tvar proto = HashMap.prototype = {\r\n\t\tconstructor:HashMap,\r\n\r\n\t\tget:function(key) {\r\n\t\t\tvar data = this._data[this.hash(key)];\r\n\t\t\treturn data && data[1];\r\n\t\t},\r\n\t\t\r\n\t\tset:function(key, value) {\r\n\t\t\t// Store original key as well (for iteration)\r\n\t\t\tthis._data[this.hash(key)] = [key, value];\r\n\t\t},\r\n\r\n\t\tmulti:function() {\r\n\t\t\tmulti(this, arguments);\r\n\t\t},\r\n\r\n\t\tcopy:function(other) {\r\n\t\t\tfor (var key in other._data) {\r\n\t\t\t\tthis._data[key] = other._data[key];\r\n\t\t\t}\r\n\t\t},\r\n\t\t\r\n\t\thas:function(key) {\r\n\t\t\treturn this.hash(key) in this._data;\r\n\t\t},\r\n\t\t\r\n\t\tsearch:function(value) {\r\n\t\t\tfor (var key in this._data) {\r\n\t\t\t\tif (this._data[key][1] === value) {\r\n\t\t\t\t\treturn this._data[key][0];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn null;\r\n\t\t},\r\n\t\t\r\n\t\tremove:function(key) {\r\n\t\t\tdelete this._data[this.hash(key)];\r\n\t\t},\r\n\r\n\t\ttype:function(key) {\r\n\t\t\tvar str = Object.prototype.toString.call(key);\r\n\t\t\tvar type = str.slice(8, -1).toLowerCase();\r\n\t\t\t// Some browsers yield DOMWindow for null and undefined, works fine on Node\r\n\t\t\tif (type === 'domwindow' && !key) {\r\n\t\t\t\treturn key + '';\r\n\t\t\t}\r\n\t\t\treturn type;\r\n\t\t},\r\n\r\n\t\tkeys:function() {\r\n\t\t\tvar keys = [];\r\n\t\t\tthis.forEach(function(value, key) { keys.push(key); });\r\n\t\t\treturn keys;\r\n\t\t},\r\n\r\n\t\tvalues:function() {\r\n\t\t\tvar values = [];\r\n\t\t\tthis.forEach(function(value) { values.push(value); });\r\n\t\t\treturn values;\r\n\t\t},\r\n\r\n\t\tcount:function() {\r\n\t\t\treturn this.keys().length;\r\n\t\t},\r\n\r\n\t\tclear:function() {\r\n\t\t\t// TODO: Would Object.create(null) make any difference\r\n\t\t\tthis._data = {};\r\n\t\t},\r\n\r\n\t\tclone:function() {\r\n\t\t\treturn new HashMap(this);\r\n\t\t},\r\n\r\n\t\thash:function(key) {\r\n\t\t\tswitch (this.type(key)) {\r\n\t\t\t\tcase 'undefined':\r\n\t\t\t\tcase 'null':\r\n\t\t\t\tcase 'boolean':\r\n\t\t\t\tcase 'number':\r\n\t\t\t\tcase 'regexp':\r\n\t\t\t\t\treturn key + '';\r\n\r\n\t\t\t\tcase 'date':\r\n\t\t\t\t\treturn ':' + key.getTime();\r\n\r\n\t\t\t\tcase 'string':\r\n\t\t\t\t\treturn '\"' + key;\r\n\r\n\t\t\t\tcase 'array':\r\n\t\t\t\t\tvar hashes = [];\r\n\t\t\t\t\tfor (var i = 0; i < key.length; i++)\r\n\t\t\t\t\t\thashes[i] = this.hash(key[i]);\r\n\t\t\t\t\treturn '[' + hashes.join('|');\r\n\r\n\t\t\t\tcase 'object':\r\n\t\t\t\tdefault:\r\n\t\t\t\t\t// TODO: Don't use expandos when Object.defineProperty is not available?\r\n\t\t\t\t\tif (!key._hmuid_) {\r\n\t\t\t\t\t\tkey._hmuid_ = ++HashMap.uid;\r\n\t\t\t\t\t\thide(key, '_hmuid_');\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\treturn '{' + key._hmuid_;\r\n\t\t\t}\r\n\t\t},\r\n\r\n\t\tforEach:function(func) {\r\n\t\t\tfor (var key in this._data) {\r\n\t\t\t\tvar data = this._data[key];\r\n\t\t\t\tfunc.call(this, data[1], data[0]);\r\n\t\t\t}\r\n\t\t}\r\n\t};\r\n\r\n\tHashMap.uid = 0;\r\n\r\n\t//- Automatically add chaining to some methods\r\n\r\n\tfor (var method in proto) {\r\n\t\t// Skip constructor, valueOf, toString and any other built-in method\r\n\t\tif (method === 'constructor' || !proto.hasOwnProperty(method)) {\r\n\t\t\tcontinue;\r\n\t\t}\r\n\t\tvar fn = proto[method];\r\n\t\tif (fn.toString().indexOf('return ') === -1) {\r\n\t\t\tproto[method] = chain(fn);\r\n\t\t}\r\n\t}\r\n\r\n\t//- Utils\r\n\r\n\tfunction multi(map, args) {\r\n\t\tfor (var i = 0; i < args.length; i += 2) {\r\n\t\t\tmap.set(args[i], args[i+1])\r\n\t\t}\r\n\t}\r\n\r\n\tfunction chain(fn) {\r\n\t\treturn function() {\r\n\t\t\tfn.apply(this, arguments);\r\n\t\t\treturn this;\r\n\t\t};\r\n\t}\r\n\r\n\tfunction hide(obj, prop) {\r\n\t\t// Make non iterable if supported\r\n\t\tif (Object.defineProperty) {\r\n\t\t\tObject.defineProperty(obj, prop, {enumerable:false});\r\n\t\t}\r\n\t};\r\n\r\n\treturn HashMap;\r\n\r\n}));\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/hashmap/hashmap.js\n ** module id = 26\n ** module chunks = 0\n **/","// resolves varargs variable into more usable form\n// args - should be a function arguments variable\n// returns a javascript Array object of arguments that doesn't count trailing undefined values in the length\nmodule.exports = function(theArguments) {\n    var args = Array.prototype.slice.call(theArguments, 0)\n\n    var count = 0;\n    for(var n=args.length-1; n>=0; n--) {\n        if(args[n] === undefined)\n            count++\n        else\n            break\n    }\n    args.splice(args.length-count, count)\n    return args\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/trimArguments/trimArguments.js\n ** module id = 27\n ** module chunks = 0\n **/","var proto = require(\"proto\")\r\nvar EventEmitter = require(\"events\").EventEmitter\r\nvar utils = require(\"./utils\")\r\n\r\n\r\n// emits the event:\r\n    // change - the event data is an object of one of the following forms:\r\n        // {id:_, type: 'set', property: propertyList}\r\n        // {id:_, type: 'added', property: propertyList, index:_, count: numberOfElementsAdded}\r\n        // {id:_, type: 'removed', property: propertyList, index:_, values: removedValues}\r\nvar Observe = module.exports = proto(EventEmitter, function() {\r\n\r\n    // static members\r\n\r\n    this.init = function(obj) {\r\n        this.subject = obj\r\n\r\n        this.setMaxListeners(1000)\r\n    }\r\n\r\n    // instance members\r\n\r\n    // gets an element or member of the subject and returns another Observee\r\n    // changes to the returned Observee will be emitted by its parent as well\r\n    this.get = function(property) {\r\n        return ObserveeChild(this, parsePropertyList(property))\r\n    }\r\n\r\n    // sets a value on the subject\r\n    // property - either an array of members to select, or a string where properties to select are separated by dots\r\n    // value - the value to set\r\n    this.set = function(property, value) {\r\n        setInternal(this, parsePropertyList(property), value, {})\r\n    }\r\n\r\n    // pushes a value onto a list\r\n    this.push = function(/*value...*/) {\r\n        pushInternal(this, [], arguments, {})\r\n    }\r\n\r\n\r\n    // index is the index to remove/insert at\r\n    // countToRemove is the number to remove\r\n    // elementsToAdd is a list of elements to add\r\n    this.splice = function(/*index, countToRemove[, elementsToAdd]*/) {\r\n        return spliceInternal(this, [], arguments, {})\r\n    }\r\n\r\n    // use this instead of concat for mutation behavior\r\n    this.append = function(arrayToAppend) {\r\n        appendInternal(this, [], arguments, {})\r\n    }\r\n\r\n    this.id = function(id) {\r\n        return ObserveeChild(this, [], {id: id})\r\n        //return idFunction(this, [], id)\r\n    }\r\n\r\n    // For the returned object, any property added via set, push, splice, or append joins an internal observee together with this observee, so that\r\n    //      the internal observee and the containing observee will both send 'change' events appropriately\r\n    // collapse - (default: false) if true, any property added will be set to the subject of the value added (so that value won't be an observee anymore\r\n        // note: only use collapse:true if the observees you're unioning isn't actually an object that inherits from an observee - any instance methods on the observee that come from child classes won't be accessible anymore\r\n        // e.g. var x = observe({a:5})\r\n        //      var b = observe({})\r\n        //      x.subject.a === 5    ;; true\r\n        //      b.union(true).set('x', x)\r\n        //      b.subject.x.a === 5            ;; true\r\n        //      b.subject.x.subject.a === 5    ;; false\r\n    this.union = function(collapse) {\r\n        if(collapse === undefined) collapse = false\r\n        return ObserveeChild(this, [], {union: collapse})\r\n    }\r\n\r\n\r\n    /* pause and unpause may cause weird affects in certain cases (e.g. if you remove an element at index 4 and *then* add an element at index 2)\r\n    // pause sending events (for when you want to do a lot of things to an object)\r\n    this.pause = function() {\r\n        this.paused = true\r\n    }\r\n    this.unpause = function() {\r\n        this.paused = undefined\r\n        sendEvent(this)\r\n    }*/\r\n})\r\n\r\n\r\nfunction parsePropertyList(property) {\r\n    if(!(property instanceof Array)) {\r\n        property = property.toString().split('.')\r\n    }\r\n\r\n    return property\r\n}\r\n\r\nfunction getPropertyPointer(subject, propertyList) {\r\n    var current = subject\r\n    for(var n=0; n<propertyList.length-1; n++) {\r\n        current = current[propertyList[n]]\r\n    }\r\n\r\n    return {obj: current, key:propertyList[n]}\r\n}\r\n\r\nvar getPropertyValue = module.exports.getPropertyValue = function(subject, property) {\r\n    var pointer = getPropertyPointer(subject, property)\r\n    if(pointer.key !== undefined) {\r\n        return pointer.obj[pointer.key]\r\n    } else {\r\n        return pointer.obj\r\n    }\r\n}\r\n\r\n// private\r\n\r\n// options can have the properties:\r\n    // union - if true, any value set, pushed, appended, or spliced onto the observee is unioned\r\nvar ObserveeChild = proto(EventEmitter, function() {\r\n\r\n    this.init = function(parent, propertyList, options) {\r\n        if(options === undefined) this.options = {}\r\n        else                      this.options = options\r\n\r\n        if(parent._observeeParent !== undefined)\r\n            this._observeeParent = parent._observeeParent\r\n        else\r\n            this._observeeParent = parent\r\n\r\n        this.property = propertyList\r\n        this.subject = getPropertyValue(parent.subject, propertyList)\r\n\r\n        var that = this\r\n        parent.on('change', function(change) {\r\n            var answers = changeQuestions(that.property, change)\r\n\r\n            if(answers.isWithin ) {\r\n                that.emit('change', {type:change.type, property: change.property.slice(that.property.length), index:change.index, count:change.count, removed: change.removed})\r\n            } else if(answers.couldRelocate) {\r\n                if(change.type === 'removed') {\r\n                    var relevantIndex = that.property[change.property.length]\r\n                    var removedIndexesAreBeforeIndexOfObserveeChild = change.index + change.removed.length - 1 < relevantIndex\r\n\r\n                    if(removedIndexesAreBeforeIndexOfObserveeChild) {\r\n                        that.property[change.property.length] = relevantIndex - change.removed.length // change the propertyList to match the new index\r\n                    }\r\n                } else if(change.type === 'added') {\r\n                    var relevantIndex = that.property[change.property.length]\r\n                    if(change.index < relevantIndex) {\r\n                        that.property[change.property.length] = relevantIndex + change.count // change the propertyList to match the new index\r\n                    }\r\n                }\r\n            }\r\n        })\r\n    }\r\n\r\n    this.get = function(property) {\r\n        return this._observeeParent.get(this.property.concat(parsePropertyList(property)))\r\n    }\r\n\r\n    this.set = function(property, value) {\r\n        setInternal(this._observeeParent, this.property.concat(parsePropertyList(property)), value, this.options)\r\n    }\r\n\r\n    this.push = function(/*values...*/) {\r\n        pushInternal(this._observeeParent, this.property, arguments, this.options)\r\n    }\r\n\r\n    this.splice = function(index, countToRemove/*[, elementsToAdd....]*/) {\r\n        spliceInternal(this._observeeParent, this.property, arguments, this.options)\r\n    }\r\n\r\n    this.append = function(/*[property,] arrayToAppend*/) {\r\n        appendInternal(this._observeeParent, this.property, arguments, this.options)\r\n    }\r\n\r\n    this.id = function(id) {\r\n        return ObserveeChild(this, this.property, utils.merge({}, this.options, {id: id}))\r\n        //return idFunction(this._observeeParent, this.property, id)\r\n    }\r\n\r\n    this.union = function(collapse) {\r\n        if(collapse === undefined) collapse = false\r\n        return ObserveeChild(this, [], utils.merge({}, this.options, {union: collapse}))\r\n    }\r\n\r\n})\r\n\r\n     /*\r\nfunction idFunction(that, propertyList, id) {\r\n    var result = {\r\n        set: function(property, value) {\r\n            var fullPropertyList = propertyList.concat(parsePropertyList(property))\r\n            setInternal(that, fullPropertyList, value, id)\r\n        },\r\n        push: function() {\r\n            pushInternal(that, propertyList, arguments, id)\r\n        },\r\n        splice: function() {\r\n            spliceInternal(that, propertyList, arguments, id)\r\n        },\r\n        append: function() {\r\n            appendInternal(that, propertyList, arguments, id)\r\n        },\r\n        get: function() {\r\n\r\n        }\r\n    }\r\n}\r\n*/\r\n\r\n// that - the Observee object\r\nfunction setInternal(that, propertyList, value, options) {\r\n    var pointer = getPropertyPointer(that.subject, propertyList)\r\n\r\n    var internalObservee = value\r\n    if(options.union === true) {\r\n        value = value.subject\r\n    }\r\n\r\n    pointer.obj[pointer.key] = value\r\n\r\n    var event = {type: 'set', property: propertyList}\r\n    if(options.id !== undefined) event.id = options.id\r\n    that.emit('change',event)\r\n\r\n    if(options.union !== undefined)\r\n        unionizeEvents(that, internalObservee, propertyList, options.union)\r\n}\r\n\r\nfunction pushInternal(that, propertyList, args, options) {\r\n    var array = getPropertyValue(that.subject, propertyList)\r\n    var originalLength = array.length\r\n    array.push.apply(array, args)\r\n\r\n    var internalObservees = unionizeList(array, originalLength, args.length, options.union)\r\n\r\n    var event = {type: 'added', property: propertyList, index: originalLength, count: 1}\r\n    if(options.id !== undefined) event.id = options.id\r\n    that.emit('change', event)\r\n\r\n    unionizeListEvents(that, internalObservees, propertyList, options.union)\r\n}\r\n\r\nfunction spliceInternal(that, propertyList, args, options) {\r\n    var index = args[0]\r\n    var countToRemove = args[1]\r\n\r\n    var array = getPropertyValue(that.subject, propertyList)\r\n    var result = array.splice.apply(array, args)\r\n\r\n    if(countToRemove > 0) {\r\n        var event = {type: 'removed', property: propertyList, index: index, removed: result}\r\n        if(options.id !== undefined) event.id = options.id\r\n        that.emit('change', event)\r\n    }\r\n    if(args.length > 2) {\r\n        var event = {type: 'added', property: propertyList, index: index, count: args.length-2}\r\n\r\n        var internalObservees = unionizeList(array, index, event.count, options.union)\r\n\r\n        if(options.id !== undefined) event.id = options.id\r\n        that.emit('change', event)\r\n\r\n        unionizeListEvents(that, internalObservees, propertyList, options.union)\r\n    }\r\n\r\n    return result\r\n}\r\n\r\n// note: I'm not using splice to do this as an optimization (because otherwise the property list would have to be parsed twice and the value gotten twice) - maybe this optimization wasn't worth it but its already done\r\nfunction appendInternal(that, propertyList, args, options) {\r\n    var arrayToAppend = args[0]\r\n    if(arrayToAppend.length === 0) return; //nothing to do\r\n\r\n    var array = getPropertyValue(that.subject, propertyList)\r\n    var originalLength = array.length\r\n\r\n    var spliceArgs = [originalLength, 0]\r\n    spliceArgs = spliceArgs.concat(arrayToAppend)\r\n    var oldLength = array.length\r\n    array.splice.apply(array, spliceArgs)\r\n\r\n    var internalObservees = unionizeList(array, oldLength, array.length, options.union)\r\n\r\n    var event = {type: 'added', property: propertyList, index: originalLength, count: arrayToAppend.length}\r\n    if(options.id !== undefined) event.id = options.id\r\n    that.emit('change', event)\r\n\r\n    unionizeListEvents(that, internalObservees, propertyList, options.union)\r\n}\r\n\r\n// sets a slice of elements to their subjects and\r\n// returns the original observee objects along with their indexes\r\nfunction unionizeList(array, start, count, union) {\r\n    var internalObservees = [] // list of observees and their property path\r\n    if(union !== undefined) {\r\n        var afterEnd = start+count\r\n        for(var n=start; n<afterEnd; n++) {\r\n            internalObservees.push({obj: array[n], index: n})\r\n            if(union === true)\r\n                array[n] = array[n].subject\r\n        }\r\n    }\r\n\r\n    return internalObservees\r\n}\r\n\r\n// runs unionizeEvents for elements in a list\r\n// internalObservees should be the result from `unionizeList`\r\nfunction unionizeListEvents(that, internalObservees, propertyList, collapse) {\r\n    for(var n=0; n<internalObservees.length; n++) {\r\n        unionizeEvents(that, internalObservees[n].obj, propertyList.concat(internalObservees[n].index), collapse)\r\n    }\r\n}\r\n\r\n\r\n// sets up the union change events for an observee with one of its inner properties\r\n// parameters:\r\n    // that - the container observee\r\n    // innerObservee - the contained observee\r\n    // propertyList - the propertyList to unionize\r\n    // collapse - the union option (true for collapse)\r\nfunction unionizeEvents(that, innerObservee, propertyList, collapse) {\r\n    var propertyListDepth = propertyList.length\r\n\r\n    if(innerObservee.on === undefined || innerObservee.emit === undefined || innerObservee.removeListener === undefined || innerObservee.set === undefined) {\r\n        throw new Error(\"Attempting to union a value that isn't an observee\")\r\n    }\r\n\r\n    var innerChangeHandler, containerChangeHandler\r\n    var ignorableContainerEvents = [], ignorableInnerEvents = []\r\n    innerObservee.on('change', innerChangeHandler = function(change) {\r\n        if(ignorableInnerEvents.indexOf(change) === -1) {        // don't run this for events generated by the union event handlers\r\n            if(collapse) {\r\n                var property = propertyList.concat(change.property)\r\n            } else {\r\n                var property = propertyList.concat(['subject']).concat(change.property)\r\n            }\r\n\r\n            var containerChange = utils.merge({}, change, {property: property})\r\n            ignorableContainerEvents.push(containerChange)\r\n            that.emit('change', containerChange)\r\n        }\r\n    })\r\n    that.on('change', containerChangeHandler = function(change) {\r\n        var changedPropertyDepth = change.property.length\r\n\r\n        var answers = changeQuestions(propertyList, change)\r\n        var changeIsWithinInnerProperty = answers.isWithin\r\n        var changeCouldRelocateInnerProperty = answers.couldRelocate\r\n\r\n        if(changeIsWithinInnerProperty && ignorableContainerEvents.indexOf(change) === -1) {   // don't run this for events generated by the union event handlers\r\n            if(collapse) {\r\n                var property = change.property.slice(propertyListDepth)\r\n            } else {\r\n                var property = change.property.slice(propertyListDepth+1) // +1 for the 'subject'\r\n            }\r\n\r\n            var innerObserveeEvent = utils.merge({}, change, {property: property})\r\n            ignorableInnerEvents.push(innerObserveeEvent)\r\n            innerObservee.emit('change', innerObserveeEvent)\r\n        } else if(changeCouldRelocateInnerProperty) {\r\n            if(change.type === 'set' /*&& changedPropertyDepth <= propertyListDepth  - this part already done above*/) {\r\n                removeUnion()\r\n            } else if(change.type === 'removed') {\r\n                var relevantIndex = propertyList[change.property.length]\r\n                var removedIndexesContainsIndexOfInnerObservee = change.index <= relevantIndex && relevantIndex <= change.index + change.removed.length - 1\r\n                var removedIndexesAreBeforeIndexOfInnerObservee = change.index + change.removed.length - 1 < relevantIndex && relevantIndex\r\n\r\n                if(removedIndexesContainsIndexOfInnerObservee && changedPropertyDepth <= propertyListDepth+1) {\r\n                    removeUnion()\r\n                } else if(removedIndexesAreBeforeIndexOfInnerObservee) {\r\n                    propertyList[change.property.length] = relevantIndex - change.removed.length // change the propertyList to match the new index\r\n                }\r\n            } else if(change.type === 'added') {\r\n                var relevantIndex = propertyList[change.property.length]\r\n                if(change.index < relevantIndex) {\r\n                    propertyList[change.property.length] = relevantIndex + change.count // change the propertyList to match the new index\r\n                }\r\n            }\r\n        }\r\n    })\r\n\r\n    var removeUnion = function() {\r\n        innerObservee.removeListener('change', innerChangeHandler)\r\n        that.removeListener('change', containerChangeHandler)\r\n    }\r\n}\r\n\r\n\r\n// answers certain questions about a change compared to a property list\r\n// returns an object like: {\r\n    // isWithin: _,           // true if changeIsWithinInnerProperty\r\n    // couldRelocate: _       // true if changeCouldRelocateInnerProperty or if innerProperty might be removed\r\n// }\r\nfunction changeQuestions(propertyList, change) {\r\n    var propertyListDepth = propertyList.length\r\n\r\n    var changeIsWithinInnerProperty = true // assume true until proven otherwise\r\n    var changeCouldRelocateInnerProperty = true // assume true until prove otherwise\r\n    for(var n=0; n<propertyListDepth; n++) {\r\n        if(change.property[n] !== propertyList[n]) {\r\n            changeIsWithinInnerProperty = false\r\n            if(n<change.property.length) {\r\n                changeCouldRelocateInnerProperty = false\r\n            }\r\n        }\r\n    }\r\n\r\n    if(change.property.length <= propertyListDepth) {\r\n        changeIsWithinInnerProperty = false\r\n    } else {\r\n        changeCouldRelocateInnerProperty = false\r\n    }\r\n\r\n    return {couldRelocate: changeCouldRelocateInnerProperty, isWithin: changeIsWithinInnerProperty}\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/observe/observe.js\n ** module id = 28\n ** module chunks = 0\n **/","\"use strict\";\r\n/* Copyright (c) 2013 Billy Tetrud - Free to use for any purpose: MIT License*/\r\n\r\nvar noop = function() {}\r\n\r\nvar prototypeName='prototype', undefined, protoUndefined='undefined', init='init', ownProperty=({}).hasOwnProperty; // minifiable variables\r\nfunction proto() {\r\n    var args = arguments // minifiable variables\r\n\r\n    if(args.length == 1) {\r\n        var parent = {init: noop}\r\n        var prototypeBuilder = args[0]\r\n\r\n    } else { // length == 2\r\n        var parent = args[0]\r\n        var prototypeBuilder = args[1]\r\n    }\r\n\r\n    // special handling for Error objects\r\n    var namePointer = {}    // name used only for Error Objects\r\n    if([Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError].indexOf(parent) !== -1) {\r\n        parent = normalizeErrorObject(parent, namePointer)\r\n    }\r\n\r\n    // set up the parent into the prototype chain if a parent is passed\r\n    var parentIsFunction = typeof(parent) === \"function\"\r\n    if(parentIsFunction) {\r\n        prototypeBuilder[prototypeName] = parent[prototypeName]\r\n    } else {\r\n        prototypeBuilder[prototypeName] = parent\r\n    }\r\n\r\n    // the prototype that will be used to make instances\r\n    var prototype = new prototypeBuilder(parent)\r\n    namePointer.name = prototype.name\r\n\r\n    // if there's no init, assume its inheriting a non-proto class, so default to applying the superclass's constructor.\r\n    if(!prototype[init] && parentIsFunction) {\r\n        prototype[init] = function() {\r\n            parent.apply(this, arguments)\r\n        }\r\n    }\r\n\r\n    // constructor for empty object which will be populated via the constructor\r\n    var F = function() {}\r\n        F[prototypeName] = prototype    // set the prototype for created instances\r\n\r\n    var constructorName = prototype.name?prototype.name:''\r\n    if(prototype[init] === undefined || prototype[init] === noop) {\r\n        var ProtoObjectFactory = new Function('F',\r\n            \"return function \" + constructorName + \"(){\" +\r\n                \"return new F()\" +\r\n            \"}\"\r\n        )(F)\r\n    } else {\r\n        // dynamically creating this function cause there's no other way to dynamically name a function\r\n        var ProtoObjectFactory = new Function('F','i','u','n', // shitty variables cause minifiers aren't gonna minify my function string here\r\n            \"return function \" + constructorName + \"(){ \" +\r\n                \"var x=new F(),r=i.apply(x,arguments)\\n\" +    // populate object via the constructor\r\n                \"if(r===n)\\n\" +\r\n                    \"return x\\n\" +\r\n                \"else if(r===u)\\n\" +\r\n                    \"return n\\n\" +\r\n                \"else\\n\" +\r\n                    \"return r\\n\" +\r\n            \"}\"\r\n        )(F, prototype[init], proto[protoUndefined]) // note that n is undefined\r\n    }\r\n\r\n    prototype.constructor = ProtoObjectFactory;    // set the constructor property on the prototype\r\n\r\n    // add all the prototype properties onto the static class as well (so you can access that class when you want to reference superclass properties)\r\n    for(var n in prototype) {\r\n        addProperty(ProtoObjectFactory, prototype, n)\r\n    }\r\n\r\n    // add properties from parent that don't exist in the static class object yet\r\n    for(var n in parent) {\r\n        if(ownProperty.call(parent, n) && ProtoObjectFactory[n] === undefined) {\r\n            addProperty(ProtoObjectFactory, parent, n)\r\n        }\r\n    }\r\n\r\n    ProtoObjectFactory.parent = parent;            // special parent property only available on the returned proto class\r\n    ProtoObjectFactory[prototypeName] = prototype  // set the prototype on the object factory\r\n\r\n    return ProtoObjectFactory;\r\n}\r\n\r\nproto[protoUndefined] = {} // a special marker for when you want to return undefined from a constructor\r\n\r\nmodule.exports = proto\r\n\r\nfunction normalizeErrorObject(ErrorObject, namePointer) {\r\n    function NormalizedError() {\r\n        var tmp = new ErrorObject(arguments[0])\r\n        tmp.name = namePointer.name\r\n\r\n        this.message = tmp.message\r\n        if(Object.defineProperty) {\r\n            /*this.stack = */Object.defineProperty(this, 'stack', { // getter for more optimizy goodness\r\n                get: function() {\r\n                    return tmp.stack\r\n                }\r\n            })\r\n        } else {\r\n            this.stack = tmp.stack\r\n        }\r\n\r\n        return this\r\n    }\r\n\r\n    var IntermediateInheritor = function() {}\r\n        IntermediateInheritor.prototype = ErrorObject.prototype\r\n    NormalizedError.prototype = new IntermediateInheritor()\r\n\r\n    return NormalizedError\r\n}\r\n\r\nfunction addProperty(factoryObject, prototype, property) {\r\n    try {\r\n        var info = Object.getOwnPropertyDescriptor(prototype, property)\r\n        if(info.get !== undefined || info.get !== undefined && Object.defineProperty !== undefined) {\r\n            Object.defineProperty(factoryObject, property, info)\r\n        } else {\r\n            factoryObject[property] = prototype[property]\r\n        }\r\n    } catch(e) {\r\n        // do nothing, if a property (like `name`) can't be set, just ignore it\r\n    }\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/proto/proto.js\n ** module id = 29\n ** module chunks = 0\n **/","var proto = require('proto')\r\n\r\nvar Block = require('Block')\r\nvar Style = require(\"Style\")\r\nvar Cell = require(\"./Cell\");\r\n\r\n// generates either a Header or a Row, depending on what you pass in\r\n// elementType should either be \"tr\" or \"th\r\n// name should either be \"Header\" or \"Row\r\nmodule.exports = function(elementType, name) {\r\n    return proto(Block, function(superclass) {\r\n\r\n        // static properties\r\n\r\n        this.name = name\r\n\r\n        this.defaultStyle = Style({\r\n            display: 'table-row'\r\n        })\r\n\r\n\r\n        // instance properties\r\n\r\n        this.init = function(/*[label,] rowInit*/) {\r\n            if(arguments[0] instanceof Array) {\r\n                var rowInit = arguments[0]\r\n            } else {\r\n                var label = arguments[0]\r\n                var rowInit = arguments[1]\r\n            }\r\n\r\n            this.domNode = document.createElement(elementType) // do this before calling the superclass constructor so that an extra useless domNode isn't created inside it\r\n            superclass.init.call(this) // superclass constructor\r\n            this.label = label\r\n\r\n            if(rowInit !== undefined) {\r\n                for(var n=0; n<rowInit.length; n++) {\r\n                    this.cell(rowInit[n])\r\n                }\r\n            }\r\n        }\r\n\r\n        this.cell = function(/*[label,] contents*/) {\r\n            var cell = Cell.apply(undefined, arguments);\r\n            this.add(cell);\r\n            return cell;\r\n        }\r\n    })\r\n}\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/Components/RowlikeGenerator.js\n ** module id = 30\n ** module chunks = 0\n **/","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/build-modules/~/webpack/~/node-libs-browser/~/path-browserify/index.js\n ** module id = 31\n ** module chunks = 0\n **/","// utilities needed by the configuration (excludes dependencies the configs don't need so the webpack bundle is lean)\r\n\r\nvar path = require('path')\r\n\r\n\r\n// Overwrites obj1's values with obj2's and adds obj2's if non existent in obj1\r\n// any number of objects can be passed into the function and will be merged into the first argument in order\r\n// returns obj1 (now mutated)\r\nvar merge = exports.merge = function(obj1, obj2/*, moreObjects...*/){\r\n    return mergeInternal(arrayify(arguments), false)\r\n}\r\n\r\n// like merge, but traverses the whole object tree\r\n// the result is undefined for objects with circular references\r\nvar deepMerge = exports.deepMerge = function(obj1, obj2/*, moreObjects...*/) {\r\n    return mergeInternal(arrayify(arguments), true)\r\n}\r\n\r\nfunction mergeInternal(objects, deep) {\r\n    var obj1 = objects[0]\r\n    var obj2 = objects[1]\r\n\r\n    for(var key in obj2){\r\n       if(Object.hasOwnProperty.call(obj2, key)) {\r\n            if(deep && obj1[key] instanceof Object && obj2[key] instanceof Object) {\r\n                mergeInternal([obj1[key], obj2[key]], true)\r\n            } else {\r\n                obj1[key] = obj2[key]\r\n            }\r\n       }\r\n    }\r\n\r\n    if(objects.length > 2) {\r\n        var newObjects = [obj1].concat(objects.slice(2))\r\n        return mergeInternal(newObjects, deep)\r\n    } else {\r\n        return obj1\r\n    }\r\n}\r\n\r\nfunction arrayify(a) {\r\n    return Array.prototype.slice.call(a, 0)\r\n}\r\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/observe/utils.js\n ** module id = 32\n ** module chunks = 0\n **/","// shim for using process in browser\n\nvar process = module.exports = {};\n\nprocess.nextTick = (function () {\n    var canSetImmediate = typeof window !== 'undefined'\n    && window.setImmediate;\n    var canMutationObserver = typeof window !== 'undefined'\n    && window.MutationObserver;\n    var canPost = typeof window !== 'undefined'\n    && window.postMessage && window.addEventListener\n    ;\n\n    if (canSetImmediate) {\n        return function (f) { return window.setImmediate(f) };\n    }\n\n    var queue = [];\n\n    if (canMutationObserver) {\n        var hiddenDiv = document.createElement(\"div\");\n        var observer = new MutationObserver(function () {\n            var queueList = queue.slice();\n            queue.length = 0;\n            queueList.forEach(function (fn) {\n                fn();\n            });\n        });\n\n        observer.observe(hiddenDiv, { attributes: true });\n\n        return function nextTick(fn) {\n            if (!queue.length) {\n                hiddenDiv.setAttribute('yes', 'no');\n            }\n            queue.push(fn);\n        };\n    }\n\n    if (canPost) {\n        window.addEventListener('message', function (ev) {\n            var source = ev.source;\n            if ((source === window || source === null) && ev.data === 'process-tick') {\n                ev.stopPropagation();\n                if (queue.length > 0) {\n                    var fn = queue.shift();\n                    fn();\n                }\n            }\n        }, true);\n\n        return function nextTick(fn) {\n            queue.push(fn);\n            window.postMessage('process-tick', '*');\n        };\n    }\n\n    return function nextTick(fn) {\n        setTimeout(fn, 0);\n    };\n})();\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\n\n\n\n/*****************\n ** WEBPACK FOOTER\n ** ../~/build-modules/~/webpack/~/node-libs-browser/~/process/browser.js\n ** module id = 33\n ** module chunks = 0\n **/"],"sourceRoot":""}